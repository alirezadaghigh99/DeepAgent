output file:
processed_pennylane_iterate_shift_rule_with_multipliers9.json
function:
_iterate_shift_rule_with_multipliers
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976] FAILED'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 9 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586] FAILED

=================================== FAILURES ===================================
__________ TestIterateShiftRuleWithMultipliers.test_first_order[None] __________

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954f75dad0>
period = None

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_first_order(self, period):
        """Test first order iteration of a rule with multipliers."""
        rule = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 1, period)
>       assert np.allclose(iterated_rule, rule)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)], rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
___ TestIterateShiftRuleWithMultipliers.test_first_order[1.0471975511965976] ___

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d142a50>
period = 1.0471975511965976

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_first_order(self, period):
        """Test first order iteration of a rule with multipliers."""
        rule = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 1, period)
>       assert np.allclose(iterated_rule, rule)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)], rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
___ TestIterateShiftRuleWithMultipliers.test_first_order[6.283185307179586] ____

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d142cd0>
period = 6.283185307179586

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_first_order(self, period):
        """Test first order iteration of a rule with multipliers."""
        rule = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 1, period)
>       assert np.allclose(iterated_rule, rule)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [(-0.9, 0.7, -0.2), (0.2, 1.2, 0.4)], rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestIterateShiftRuleWithMultipliers.test_second_order[None] __________

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d143a90>
period = None

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_second_order(self, period):
        """Test second order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 2, period)
        expected = np.array(
            [
                [0.2**2, 1.2**2, 0.4 * 1.2 + 0.4],
                [0.2 * -0.9, 1.2 * 0.7, 0.4 * 0.7 - 0.2],
                [-0.9 * 0.2, 0.7 * 1.2, -0.2 * 1.2 + 0.4],
                [(-0.9) ** 2, 0.7**2, -0.2 * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.04,  1.44,  0.88],
       [-0.18,  0.84,  0.08],
       [-0.18,  0.84,  0.16],
       [ 0.81,  0.49, -0.34]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
__ TestIterateShiftRuleWithMultipliers.test_second_order[1.0471975511965976] ___

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d143d10>
period = 1.0471975511965976

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_second_order(self, period):
        """Test second order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 2, period)
        expected = np.array(
            [
                [0.2**2, 1.2**2, 0.4 * 1.2 + 0.4],
                [0.2 * -0.9, 1.2 * 0.7, 0.4 * 0.7 - 0.2],
                [-0.9 * 0.2, 0.7 * 1.2, -0.2 * 1.2 + 0.4],
                [(-0.9) ** 2, 0.7**2, -0.2 * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.04      ,  1.44      , -0.16719755],
       [-0.18      ,  0.84      ,  0.08      ],
       [-0.18      ,  0.84      ,  0.16      ],
       [ 0.81      ,  0.49      , -0.34      ]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
___ TestIterateShiftRuleWithMultipliers.test_second_order[6.283185307179586] ___

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d143f90>
period = 6.283185307179586

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_second_order(self, period):
        """Test second order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 2, period)
        expected = np.array(
            [
                [0.2**2, 1.2**2, 0.4 * 1.2 + 0.4],
                [0.2 * -0.9, 1.2 * 0.7, 0.4 * 0.7 - 0.2],
                [-0.9 * 0.2, 0.7 * 1.2, -0.2 * 1.2 + 0.4],
                [(-0.9) ** 2, 0.7**2, -0.2 * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.04,  1.44,  0.88],
       [-0.18,  0.84,  0.08],
       [-0.18,  0.84,  0.16],
       [ 0.81,  0.49, -0.34]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
__________ TestIterateShiftRuleWithMultipliers.test_third_order[None] __________

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d150d10>
period = None

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_third_order(self, period):
        """Test third order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 3, period)
        expected = np.array(
            [
                [0.2**3, 1.2**3, (0.4 * 1.2 + 0.4) * 1.2 + 0.4],
                [0.2**2 * -0.9, 1.2**2 * 0.7, (0.4 * 1.2 + 0.4) * 0.7 - 0.2],
                [0.2 * -0.9 * 0.2, 1.2 * 0.7 * 1.2, (0.4 * 0.7 - 0.2) * 1.2 + 0.4],
                [0.2 * (-0.9) ** 2, 1.2 * 0.7**2, (0.4 * 0.7 - 0.2) * 0.7 - 0.2],
                [-0.9 * 0.2**2, 0.7 * 1.2**2, (-0.2 * 1.2 + 0.4) * 1.2 + 0.4],
                [-0.9 * 0.2 * -0.9, 0.7 * 1.2 * 0.7, (-0.2 * 1.2 + 0.4) * 0.7 - 0.2],
                [(-0.9) ** 2 * 0.2, 0.7**2 * 1.2, (-0.2 * 0.7 - 0.2) * 1.2 + 0.4],
                [(-0.9) ** 3, 0.7**3, (-0.2 * 0.7 - 0.2) * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
            expected[4, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.008,  1.728,  1.456],
       [-0.036,  1.008,  0.416],
       [-0.036,  1.008,  0.496],
       [ 0.162,  0....6,  1.008,  0.592],
       [ 0.162,  0.588, -0.088],
       [ 0.162,  0.588, -0.008],
       [-0.729,  0.343, -0.438]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
___ TestIterateShiftRuleWithMultipliers.test_third_order[1.0471975511965976] ___

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d150f90>
period = 1.0471975511965976

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_third_order(self, period):
        """Test third order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 3, period)
        expected = np.array(
            [
                [0.2**3, 1.2**3, (0.4 * 1.2 + 0.4) * 1.2 + 0.4],
                [0.2**2 * -0.9, 1.2**2 * 0.7, (0.4 * 1.2 + 0.4) * 0.7 - 0.2],
                [0.2 * -0.9 * 0.2, 1.2 * 0.7 * 1.2, (0.4 * 0.7 - 0.2) * 1.2 + 0.4],
                [0.2 * (-0.9) ** 2, 1.2 * 0.7**2, (0.4 * 0.7 - 0.2) * 0.7 - 0.2],
                [-0.9 * 0.2**2, 0.7 * 1.2**2, (-0.2 * 1.2 + 0.4) * 1.2 + 0.4],
                [-0.9 * 0.2 * -0.9, 0.7 * 1.2 * 0.7, (-0.2 * 1.2 + 0.4) * 0.7 - 0.2],
                [(-0.9) ** 2 * 0.2, 0.7**2 * 1.2, (-0.2 * 0.7 - 0.2) * 1.2 + 0.4],
                [(-0.9) ** 3, 0.7**3, (-0.2 * 0.7 - 0.2) * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
            expected[4, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.008     ,  1.728     ,  0.40880245],
       [-0.036     ,  1.008     ,  0.416     ],
       [-0.036     ,  ...88     , -0.088     ],
       [ 0.162     ,  0.588     , -0.008     ],
       [-0.729     ,  0.343     , -0.438     ]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
___ TestIterateShiftRuleWithMultipliers.test_third_order[6.283185307179586] ____

self = <test_general_shift_rules.TestIterateShiftRuleWithMultipliers object at 0x79954d151210>
period = 6.283185307179586

    @pytest.mark.parametrize("period", [None, np.pi / 3, 2 * np.pi])
    def test_third_order(self, period):
        """Test third order iteration of a rule with multipliers."""
        rule = [(0.2, 1.2, 0.4), (-0.9, 0.7, -0.2)]
        iterated_rule = _iterate_shift_rule_with_multipliers(rule, 3, period)
        expected = np.array(
            [
                [0.2**3, 1.2**3, (0.4 * 1.2 + 0.4) * 1.2 + 0.4],
                [0.2**2 * -0.9, 1.2**2 * 0.7, (0.4 * 1.2 + 0.4) * 0.7 - 0.2],
                [0.2 * -0.9 * 0.2, 1.2 * 0.7 * 1.2, (0.4 * 0.7 - 0.2) * 1.2 + 0.4],
                [0.2 * (-0.9) ** 2, 1.2 * 0.7**2, (0.4 * 0.7 - 0.2) * 0.7 - 0.2],
                [-0.9 * 0.2**2, 0.7 * 1.2**2, (-0.2 * 1.2 + 0.4) * 1.2 + 0.4],
                [-0.9 * 0.2 * -0.9, 0.7 * 1.2 * 0.7, (-0.2 * 1.2 + 0.4) * 0.7 - 0.2],
                [(-0.9) ** 2 * 0.2, 0.7**2 * 1.2, (-0.2 * 0.7 - 0.2) * 1.2 + 0.4],
                [(-0.9) ** 3, 0.7**3, (-0.2 * 0.7 - 0.2) * 0.7 - 0.2],
            ]
        )
        if period == np.pi / 3:
            expected[0, -1] -= period
            expected[4, -1] -= period
    
>       assert np.allclose(iterated_rule, expected)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([[ 0.008,  1.728,  1.456],
       [-0.036,  1.008,  0.416],
       [-0.036,  1.008,  0.496],
       [ 0.162,  0....6,  1.008,  0.592],
       [ 0.162,  0.588, -0.088],
       [ 0.162,  0.588, -0.008],
       [-0.729,  0.343, -0.438]])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586]
============================== 9 failed in 0.36s ===============================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 9 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586] PASSED

============================== 9 passed in 0.02s ===============================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 9 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_first_order[6.283185307179586] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_second_order[6.283185307179586] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[None] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[1.0471975511965976] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/gradients/core/test_general_shift_rules.py::TestIterateShiftRuleWithMultipliers::test_third_order[6.283185307179586] PASSED

============================== 9 passed in 0.19s ===============================
