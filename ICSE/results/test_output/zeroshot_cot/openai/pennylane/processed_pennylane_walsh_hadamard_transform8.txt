output file:
processed_pennylane_walsh_hadamard_transform8.json
function:
_walsh_hadamard_transform
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1] FAILED'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3] FAILED

=================================== FAILURES ===================================
_____ TestWalshHadamardTransform.test_compare_analytic_results[inp0-exp0] ______

a = None, b = [1, 0, 0, 0], rtol = 1e-05, atol = 1e-08, kwargs = {}
t1 = array(None, dtype=object), t2 = array([1, 0, 0, 0])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [1, 0, 0, 0], rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb1b18f5d0>
inp = array([1, 1, 1, 1]), exp = [1, 0, 0, 0]

    @pytest.mark.parametrize(
        "inp, exp",
        [
            ([1, 1, 1, 1], [1, 0, 0, 0]),
            ([1, 1.5, 0.5, 1], [1, -0.25, 0.25, 0]),
            ([1, 0, -1, 2.5], [0.625, -0.625, -0.125, 1.125]),
        ],
    )
    def test_compare_analytic_results(self, inp, exp):
        """Test against hard-coded results."""
        inp = np.array(inp)
        output = _walsh_hadamard_transform(inp)
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object), b = array([1, 0, 0, 0]), rtol = 1e-05
atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_____ TestWalshHadamardTransform.test_compare_analytic_results[inp1-exp1] ______

a = None, b = [1, -0.25, 0.25, 0], rtol = 1e-05, atol = 1e-08, kwargs = {}
t1 = array(None, dtype=object), t2 = array([ 1.  , -0.25,  0.25,  0.  ])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [1, -0.25, 0.25, 0], rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb1b18f850>
inp = array([1. , 1.5, 0.5, 1. ]), exp = [1, -0.25, 0.25, 0]

    @pytest.mark.parametrize(
        "inp, exp",
        [
            ([1, 1, 1, 1], [1, 0, 0, 0]),
            ([1, 1.5, 0.5, 1], [1, -0.25, 0.25, 0]),
            ([1, 0, -1, 2.5], [0.625, -0.625, -0.125, 1.125]),
        ],
    )
    def test_compare_analytic_results(self, inp, exp):
        """Test against hard-coded results."""
        inp = np.array(inp)
        output = _walsh_hadamard_transform(inp)
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object), b = array([ 1.  , -0.25,  0.25,  0.  ])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_____ TestWalshHadamardTransform.test_compare_analytic_results[inp2-exp2] ______

a = None, b = [0.625, -0.625, -0.125, 1.125], rtol = 1e-05, atol = 1e-08
kwargs = {}, t1 = array(None, dtype=object)
t2 = array([ 0.625, -0.625, -0.125,  1.125])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = [0.625, -0.625, -0.125, 1.125], rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb1b18fad0>
inp = array([ 1. ,  0. , -1. ,  2.5]), exp = [0.625, -0.625, -0.125, 1.125]

    @pytest.mark.parametrize(
        "inp, exp",
        [
            ([1, 1, 1, 1], [1, 0, 0, 0]),
            ([1, 1.5, 0.5, 1], [1, -0.25, 0.25, 0]),
            ([1, 0, -1, 2.5], [0.625, -0.625, -0.125, 1.125]),
        ],
    )
    def test_compare_analytic_results(self, inp, exp):
        """Test against hard-coded results."""
        inp = np.array(inp)
        output = _walsh_hadamard_transform(inp)
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object), b = array([ 0.625, -0.625, -0.125,  1.125])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[True-1] __________

a = None, b = array([ 0.63811769, -0.3565689 ]), rtol = 1e-05, atol = 1e-08
kwargs = {}, t1 = array(None, dtype=object)
t2 = array([ 0.63811769, -0.3565689 ])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = array([ 0.63811769, -0.3565689 ]), rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f08f10>
n = 1, provide_n = True, seed = 3838063485

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object), b = array([ 0.63811769, -0.3565689 ])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[True-2] __________

a = None, b = array([0.48931922, 0.20861827, 0.22234778, 0.06987198])
rtol = 1e-05, atol = 1e-08, kwargs = {}, t1 = array(None, dtype=object)
t2 = array([0.48931922, 0.20861827, 0.22234778, 0.06987198])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = array([0.48931922, 0.20861827, 0.22234778, 0.06987198])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f091d0>
n = 2, provide_n = True, seed = 2431888616

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object)
b = array([0.48931922, 0.20861827, 0.22234778, 0.06987198]), rtol = 1e-05
atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[True-3] __________

a = None
b = array([ 0.50755815, -0.18115797,  0.13008001,  0.09760278, -0.19039236,
        0.02344997, -0.06632666, -0.05773131])
rtol = 1e-05, atol = 1e-08, kwargs = {}, t1 = array(None, dtype=object)
t2 = array([ 0.50755815, -0.18115797,  0.13008001,  0.09760278, -0.19039236,
        0.02344997, -0.06632666, -0.05773131])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([ 0.50755815, -0.18115797,  0.13008001,  0.09760278, -0.19039236,
        0.02344997, -0.06632666, -0.05773131])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f09490>
n = 3, provide_n = True, seed = 3128602072

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object)
b = array([ 0.50755815, -0.18115797,  0.13008001,  0.09760278, -0.19039236,
        0.02344997, -0.06632666, -0.05773131])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[False-1] _________

a = None, b = array([0.83832471, 0.15284467]), rtol = 1e-05, atol = 1e-08
kwargs = {}, t1 = array(None, dtype=object)
t2 = array([0.83832471, 0.15284467])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = array([0.83832471, 0.15284467]), rtol = 1e-05, atol = 1e-08
equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f09750>
n = 1, provide_n = False, seed = 1802076527

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object), b = array([0.83832471, 0.15284467]), rtol = 1e-05
atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[False-2] _________

a = None, b = array([ 0.59358557, -0.21943138,  0.08769825,  0.21094941])
rtol = 1e-05, atol = 1e-08, kwargs = {}, t1 = array(None, dtype=object)
t2 = array([ 0.59358557, -0.21943138,  0.08769825,  0.21094941])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, b = array([ 0.59358557, -0.21943138,  0.08769825,  0.21094941])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f09a10>
n = 2, provide_n = False, seed = 2767269502

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object)
b = array([ 0.59358557, -0.21943138,  0.08769825,  0.21094941]), rtol = 1e-05
atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_________ TestWalshHadamardTransform.test_compare_matrix_mult[False-3] _________

a = None
b = array([ 0.65209446, -0.10145997,  0.03639361, -0.02823722, -0.05813829,
        0.03972309,  0.05573959,  0.01998963])
rtol = 1e-05, atol = 1e-08, kwargs = {}, t1 = array(None, dtype=object)
t2 = array([ 0.65209446, -0.10145997,  0.03639361, -0.02823722, -0.05813829,
        0.03972309,  0.05573959,  0.01998963])

    def allclose(a, b, rtol=1e-05, atol=1e-08, **kwargs):
        """Wrapper around np.allclose, allowing tensors ``a`` and ``b``
        to differ in type"""
        try:
            # Some frameworks may provide their own allclose implementation.
            # Try and use it if available.
>           res = np.allclose(a, b, rtol=rtol, atol=atol, **kwargs)

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None
b = array([ 0.65209446, -0.10145997,  0.03639361, -0.02823722, -0.05813829,
        0.03972309,  0.05573959,  0.01998963])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError

During handling of the above exception, another exception occurred:

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f09d10>
n = 3, provide_n = False, seed = 3784078914

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random(2**n)
        output = _walsh_hadamard_transform(inp, n=n if provide_n else None)
        h = np.array([[0.5, 0.5], [0.5, -0.5]])
        h = reduce(np.kron, [h] * n)
        exp = h @ inp
>       assert qml.math.allclose(output, exp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/math/utils.py:76: in allclose
    res = np.allclose(t1, t2, rtol=rtol, atol=atol, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/autoray/autoray.py:81: in do
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2307: in allclose
    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(None, dtype=object)
b = array([ 0.65209446, -0.10145997,  0.03639361, -0.02823722, -0.05813829,
        0.03972309,  0.05573959,  0.01998963])
rtol = 1e-05, atol = 1e-08, equal_nan = False

    @array_function_dispatch(_isclose_dispatcher)
    def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
        """
        Returns a boolean array where two arrays are element-wise equal within a
        tolerance.
    
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
    
        .. warning:: The default `atol` is not appropriate for comparing numbers
                     with magnitudes much smaller than one (see Notes).
    
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : array_like
            The relative tolerance parameter (see Notes).
        atol : array_like
            The absolute tolerance parameter (see Notes).
        equal_nan : bool
            Whether to compare NaN's as equal.  If True, NaN's in `a` will be
            considered equal to NaN's in `b` in the output array.
    
        Returns
        -------
        y : array_like
            Returns a boolean array of where `a` and `b` are equal within the
            given tolerance. If both `a` and `b` are scalars, returns a single
            boolean value.
    
        See Also
        --------
        allclose
        math.isclose
    
        Notes
        -----
        .. versionadded:: 1.7.0
    
        For finite values, isclose uses the following equation to test whether
        two floating point values are equivalent.::
    
         absolute(a - b) <= (atol + rtol * absolute(b))
    
        Unlike the built-in `math.isclose`, the above equation is not symmetric
        in `a` and `b` -- it assumes `b` is the reference value -- so that
        `isclose(a, b)` might be different from `isclose(b, a)`.
    
        The default value of `atol` is not appropriate when the reference value
        `b` has magnitude smaller than one. For example, it is unlikely that
        ``a = 1e-9`` and ``b = 2e-9`` should be considered "close", yet
        ``isclose(1e-9, 2e-9)`` is ``True`` with default settings. Be sure
        to select `atol` for the use case at hand, especially for defining the
        threshold below which a non-zero value in `a` will be considered "close"
        to a very small or zero value in `b`.
    
        `isclose` is not defined for non-numeric data types.
        :class:`bool` is considered a numeric data-type for this purpose.
    
        Examples
        --------
        >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
        array([ True, False])
        >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
        array([ True, True])
        >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
        array([False,  True])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan])
        array([ True, False])
        >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
        array([ True, True])
        >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
        array([ True, False])
        >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
        array([False, False])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
        array([ True,  True])
        >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
        array([False,  True])
        """
        # Turn all but python scalars into arrays.
        x, y, atol, rtol = (
            a if isinstance(a, (int, float, complex)) else asanyarray(a)
            for a in (a, b, atol, rtol))
    
        # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
        # This will cause casting of x later. Also, make sure to allow subclasses
        # (e.g., for numpy.ma).
        # NOTE: We explicitly allow timedelta, which used to work. This could
        #       possibly be deprecated. See also gh-18286.
        #       timedelta works if `atol` is an integer or also a timedelta.
        #       Although, the default tolerances are unlikely to be useful
        if (dtype := getattr(y, "dtype", None)) is not None and dtype.kind != "m":
            dt = multiarray.result_type(y, 1.)
            y = asanyarray(y, dtype=dt)
        elif isinstance(y, int):
            y = float(y)
    
        with errstate(invalid='ignore'), _no_nep50_warning():
>           result = (less_equal(abs(x-y), atol + rtol * abs(y))
                      & isfinite(y)
                      | (x == y))
E           TypeError: unsupported operand type(s) for -: 'NoneType' and 'float'

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/_core/numeric.py:2417: TypeError
_____ TestWalshHadamardTransform.test_compare_analytic_results_broadcasted _____

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f0a310>

    def test_compare_analytic_results_broadcasted(self):
        """Test against hard-coded results."""
        inp = np.array([[1, 1, 1, 1], [1, 1.5, 0.5, 1], [1, 0, -1, 2.5]])
        exp = [[1, 0, 0, 0], [1, -0.25, 0.25, 0], [0.625, -0.625, -0.125, 1.125]]
>       output = _walsh_hadamard_transform(inp)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:402: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[ 1. ,  1. ,  1. ,  1. ],
       [ 1. ,  1.5,  0.5,  1. ],
       [ 1. ,  0. , -1. ,  2.5]])
n = None

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[True-1] ____

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f0b910>
n = 1, provide_n = True, seed = 2100462323

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.93287813, 0.13962754],
       [0.80448052, 0.92920056],
       [0.23948104, 0.68542779],
       [0.17919804, 0.61745989],
       [0.44913669, 0.2398554 ]])
n = 1

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[True-2] ____

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f0bbd0>
n = 2, provide_n = True, seed = 273615218

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.74525966, 0.39377197, 0.79397901, 0.32854643],
       [0.40046964, 0.45826619, 0.29162439, 0.46641028],
    ...25],
       [0.1143603 , 0.57525868, 0.76017884, 0.42700809],
       [0.44353663, 0.00529997, 0.47032684, 0.74847958]])
n = 2

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[True-3] ____

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f0be90>
n = 3, provide_n = True, seed = 1200370626

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.70196117, 0.16409791, 0.43378728, 0.70672904, 0.63815094,
        0.32227899, 0.87791944, 0.31629901],
     ...047],
       [0.78806771, 0.92466132, 0.20304896, 0.29208374, 0.1221504 ,
        0.5915356 , 0.94403705, 0.830041  ]])
n = 3

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[False-1] ___

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f14190>
n = 1, provide_n = False, seed = 3315233651

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.89031775, 0.76344947],
       [0.78444386, 0.47987019],
       [0.76745283, 0.5340341 ],
       [0.36676864, 0.25001738],
       [0.53074563, 0.44412336]])
n = None

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[False-2] ___

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f14450>
n = 2, provide_n = False, seed = 1629987239

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.15862987, 0.61828138, 0.76404373, 0.66689766],
       [0.69670144, 0.30893637, 0.6329903 , 0.93240977],
    ...71],
       [0.94912081, 0.97853683, 0.16088314, 0.95794808],
       [0.26773715, 0.14927526, 0.80252555, 0.43816412]])
n = None

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
___ TestWalshHadamardTransform.test_compare_matrix_mult_broadcasted[False-3] ___

self = <test_matrix_ops.TestWalshHadamardTransform object at 0x7bcb18f14750>
n = 3, provide_n = False, seed = 637182400

    @pytest.mark.parametrize("n", [1, 2, 3])
    @pytest.mark.parametrize("provide_n", [True, False])
    def test_compare_matrix_mult_broadcasted(self, n, provide_n, seed):
        """Test against matrix multiplication for a few random inputs."""
        rng = np.random.default_rng(seed)
        inp = rng.random((5, 2**n))
>       output = _walsh_hadamard_transform(inp, n=n if provide_n else None)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py:411: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/matrix_ops.py:20: in _walsh_hadamard_transform
    return _walsh_hadamard_transform(D, n)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

D = array([[0.9781762 , 0.38182697, 0.82184611, 0.92540317, 0.6168063 ,
        0.80159327, 0.29487138, 0.11606133],
     ...051],
       [0.9938782 , 0.54062047, 0.43091887, 0.00298519, 0.45790635,
        0.07222516, 0.33494858, 0.72644545]])
n = None

    def _walsh_hadamard_transform(D, n=None):
        length = len(D)
        if length & length - 1 != 0:
>           raise ValueError('Length of D must be a power of two.')
E           ValueError: Length of D must be a power of two.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/ops/qubit/temp.py:17: ValueError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3]
============================== 16 failed in 0.75s ==============================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3] PASSED

============================== 16 passed in 0.03s ==============================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp0-exp0] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp1-exp1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results[inp2-exp2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[True-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult[False-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_analytic_results_broadcasted PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[True-3] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-2] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/ops/qubit/test_matrix_ops.py::TestWalshHadamardTransform::test_compare_matrix_mult_broadcasted[False-3] PASSED

============================== 16 passed in 0.03s ==============================
