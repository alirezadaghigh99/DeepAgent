output file:
processed_korniafilter2d206.json
function:
filter2d
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular] FAILED'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'tvm', 'openxla', 'cudagraphs', 'jit', 'inductor', None, 'onnxrt'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular] FAILED

=================================== FAILURES ===================================
___________ TestFilter2D.test_smoke[cpu-float32-same-True-constant] ____________

self = <test_filters.TestFilter2D object at 0x7fda84542860>
border_type = 'constant', normalized = True, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1444, 0.1214, 0.1517],
         [0.1777, 0.0097, 0.0615],
         [0.0602, 0.1061, 0.1674]]])
border_type = 'constant', normalized = True, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
____________ TestFilter2D.test_smoke[cpu-float32-same-True-reflect] ____________

self = <test_filters.TestFilter2D object at 0x7fda84542770>
border_type = 'reflect', normalized = True, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.0719, 0.1524, 0.1216],
         [0.1242, 0.1371, 0.0111],
         [0.0096, 0.1072, 0.2648]]])
border_type = 'reflect', normalized = True, padding = 'same', behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-same-True-replicate] ___________

self = <test_filters.TestFilter2D object at 0x7fda84542650>
border_type = 'replicate', normalized = True, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1646, 0.1921, 0.1157],
         [0.0016, 0.0062, 0.1623],
         [0.2773, 0.0283, 0.0518]]])
border_type = 'replicate', normalized = True, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-same-True-circular] ____________

self = <test_filters.TestFilter2D object at 0x7fda84542e90>
border_type = 'circular', normalized = True, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1081, 0.1784, 0.0686],
         [0.2382, 0.2075, 0.0617],
         [0.0523, 0.0156, 0.0695]]])
border_type = 'circular', normalized = True, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-same-False-constant] ___________

self = <test_filters.TestFilter2D object at 0x7fda84542f50>
border_type = 'constant', normalized = False, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.7177, 0.8233, 0.1173],
         [0.3050, 0.2895, 0.3555],
         [0.0821, 0.7709, 0.8481]]])
border_type = 'constant', normalized = False, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-same-False-reflect] ____________

self = <test_filters.TestFilter2D object at 0x7fda84543010>
border_type = 'reflect', normalized = False, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.4789, 0.4454, 0.8515],
         [0.9210, 0.6849, 0.0941],
         [0.8951, 0.7814, 0.6416]]])
border_type = 'reflect', normalized = False, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
__________ TestFilter2D.test_smoke[cpu-float32-same-False-replicate] ___________

self = <test_filters.TestFilter2D object at 0x7fda845430d0>
border_type = 'replicate', normalized = False, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.8308, 0.5662, 0.2774],
         [0.0359, 0.2830, 0.7563],
         [0.6263, 0.7165, 0.3430]]])
border_type = 'replicate', normalized = False, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-same-False-circular] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543190>
border_type = 'circular', normalized = False, padding = 'same'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.8357, 0.8098, 0.1847],
         [0.5286, 0.8389, 0.9422],
         [0.2792, 0.4714, 0.1496]]])
border_type = 'circular', normalized = False, padding = 'same'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-valid-True-constant] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543250>
border_type = 'constant', normalized = True, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.3093, 0.1595, 0.0966],
         [0.0539, 0.1666, 0.0445],
         [0.0906, 0.0379, 0.0413]]])
border_type = 'constant', normalized = True, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-valid-True-reflect] ____________

self = <test_filters.TestFilter2D object at 0x7fda84543310>
border_type = 'reflect', normalized = True, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1128, 0.0269, 0.0312],
         [0.0725, 0.1982, 0.1578],
         [0.0677, 0.1962, 0.1367]]])
border_type = 'reflect', normalized = True, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
__________ TestFilter2D.test_smoke[cpu-float32-valid-True-replicate] ___________

self = <test_filters.TestFilter2D object at 0x7fda845433d0>
border_type = 'replicate', normalized = True, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1496, 0.0594, 0.0661],
         [0.1415, 0.0959, 0.0993],
         [0.0508, 0.2176, 0.1198]]])
border_type = 'replicate', normalized = True, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-valid-True-circular] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543490>
border_type = 'circular', normalized = True, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.1388, 0.0241, 0.0615],
         [0.1206, 0.1368, 0.0686],
         [0.1172, 0.1973, 0.1352]]])
border_type = 'circular', normalized = True, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
__________ TestFilter2D.test_smoke[cpu-float32-valid-False-constant] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543550>
border_type = 'constant', normalized = False, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.9062, 0.0508, 0.6114],
         [0.1007, 0.2917, 0.4993],
         [0.3189, 0.2864, 0.9005]]])
border_type = 'constant', normalized = False, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
___________ TestFilter2D.test_smoke[cpu-float32-valid-False-reflect] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543610>
border_type = 'reflect', normalized = False, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.4483, 0.2686, 0.9249],
         [0.6427, 0.1589, 0.3225],
         [0.6838, 0.4395, 0.6513]]])
border_type = 'reflect', normalized = False, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
__________ TestFilter2D.test_smoke[cpu-float32-valid-False-replicate] __________

self = <test_filters.TestFilter2D object at 0x7fda845436d0>
border_type = 'replicate', normalized = False, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.0585, 0.8807, 0.2697],
         [0.0329, 0.2674, 0.3240],
         [0.1289, 0.9757, 0.8473]]])
border_type = 'replicate', normalized = False, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
__________ TestFilter2D.test_smoke[cpu-float32-valid-False-circular] ___________

self = <test_filters.TestFilter2D object at 0x7fda84543790>
border_type = 'circular', normalized = False, padding = 'valid'
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    @pytest.mark.parametrize("padding", ["same", "valid"])
    def test_smoke(self, border_type, normalized, padding, device, dtype):
        kernel = torch.rand(1, 3, 3, device=device, dtype=dtype)
        _, height, width = kernel.shape
        sample = torch.ones(1, 1, 7, 8, device=device, dtype=dtype)
        b, c, h, w = sample.shape
    
>       actual = filter2d(sample, kernel, border_type, normalized, padding)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:26: in filter2d
    return filter2d(input, kernel, border_type, normalized, padding, behaviour)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1.,...1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.],
          [1., 1., 1., 1., 1., 1., 1., 1.]]]])
kernel = tensor([[[0.6867, 0.8444, 0.5014],
         [0.3657, 0.0953, 0.7708],
         [0.6572, 0.6774, 0.2448]]])
border_type = 'circular', normalized = False, padding = 'valid'
behaviour = 'corr'

    def filter2d(input, kernel, border_type='constant', normalized=False, padding='same', behaviour='corr'):
        if input.dim() != 4:
            raise ValueError('Input tensor must have 4 dimensions (B, C, H, W)')
        if kernel.dim() != 3:
            raise ValueError('Kernel must have 3 dimensions (1, kH, kW) or (B, kH, kW)')
        B, C, H, W = input.shape
        _, kH, kW = kernel.shape
        if normalized:
            kernel = kernel / kernel.abs().sum(dim=(1, 2), keepdim=True)
        if padding == 'same':
            pad_h = (kH - 1) // 2
            pad_w = (kW - 1) // 2
        elif padding == 'valid':
            pad_h = 0
            pad_w = 0
        else:
            raise ValueError("Padding must be 'same' or 'valid'")
        if border_type == 'constant':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='constant', value=0)
        elif border_type == 'reflect':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='reflect')
        elif border_type == 'replicate':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='replicate')
        elif border_type == 'circular':
            input_padded = F.pad(input, (pad_w, pad_w, pad_h, pad_h), mode='circular')
        else:
            raise ValueError("Border type must be 'constant', 'reflect', 'replicate', or 'circular'")
        if behaviour == 'conv':
            kernel = kernel.flip(-1, -2)
        output = torch.zeros_like(input)
        for b in range(B):
            for c in range(C):
>               output[b, c] = F.conv2d(input_padded[b:b + 1, c:c + 1], kernel[b:b + 1], padding=0)
E               RuntimeError: expected stride to be a single integer value or a list of 1 values to match the convolution dimensions, but got stride=[1, 1]

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:41: RuntimeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular]
============================== 16 failed in 0.49s ==============================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'onnxrt', 'jit', 'cudagraphs', 'tvm', 'openxla', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular] PASSED

============================== 16 passed in 0.19s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'tvm', 'cudagraphs', 'jit', 'openxla', 'onnxrt', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 16 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-same-False-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter2D::test_smoke[cpu-float32-valid-False-circular] PASSED

============================== 16 passed in 0.17s ==============================
