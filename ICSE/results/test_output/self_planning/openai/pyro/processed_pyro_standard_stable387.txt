output file:
processed_pyro_standard_stable387.json
function:
_standard_stable
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0]', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9] FAILED', '../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5] FAILED'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pyro/pyro/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/pyro/pyro
configfile: setup.cfg
plugins: typeguard-4.4.1, jaxtyping-0.2.19
collecting ... collected 687 items

../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5] FAILED

=================================== FAILURES ===================================
____________________ test_shape[batch_shape1-sample_shape0] ____________________

sample_shape = (), batch_shape = (4,)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False]),), kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________ test_shape[batch_shape1-sample_shape1] ____________________

sample_shape = (7,), batch_shape = (4,)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False]),), kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________ test_shape[batch_shape1-sample_shape2] ____________________

sample_shape = (6, 5), batch_shape = (4,)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False]),), kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________ test_shape[batch_shape2-sample_shape0] ____________________

sample_shape = (), batch_shape = (3, 2)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([[False, False],
        [False, False],
        [False, False]]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________ test_shape[batch_shape2-sample_shape1] ____________________

sample_shape = (7,), batch_shape = (3, 2)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([[False, False],
        [False, False],
        [False, False]]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________ test_shape[batch_shape2-sample_shape2] ____________________

sample_shape = (6, 5), batch_shape = (3, 2)

    @pytest.mark.parametrize("sample_shape", [(), (7,), (6, 5)])
    @pytest.mark.parametrize("batch_shape", [(), (4,), (3, 2)])
    def test_shape(sample_shape, batch_shape):
        stability = torch.empty(batch_shape).uniform_(0, 2).requires_grad_()
        skew = torch.empty(batch_shape).uniform_(-1, 1).requires_grad_()
        scale = torch.randn(batch_shape).exp().requires_grad_()
        loc = torch.randn(batch_shape).requires_grad_()
    
        d = dist.Stable(stability, skew, scale, loc)
        assert d.batch_shape == batch_shape
    
>       x = d.rsample(sample_shape)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([[False, False],
        [False, False],
        [False, False]]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________________ test_sample[0.1--1.0] _____________________________

alpha = 0.1, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f6520>],
      dtype=object)
args = (array(0.1), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.1--0.5] _____________________________

alpha = 0.1, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f7880>],
      dtype=object)
args = (array(0.1), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.0] _____________________________

alpha = 0.1, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f7ec0>],
      dtype=object)
args = (array(0.1), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.5] _____________________________

alpha = 0.1, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f76a0>],
      dtype=object)
args = (array(0.1), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-1.0] _____________________________

alpha = 0.1, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f7ec0>],
      dtype=object)
args = (array(0.1), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--1.0] _____________________________

alpha = 0.4, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041d4b80>],
      dtype=object)
args = (array(0.4), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--0.5] _____________________________

alpha = 0.4, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f74c0>],
      dtype=object)
args = (array(0.4), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.0] _____________________________

alpha = 0.4, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f6520>],
      dtype=object)
args = (array(0.4), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.5] _____________________________

alpha = 0.4, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4037614e0>],
      dtype=object)
args = (array(0.4), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-1.0] _____________________________

alpha = 0.4, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403762020>],
      dtype=object)
args = (array(0.4), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--1.0] _____________________________

alpha = 0.8, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f76a0>],
      dtype=object)
args = (array(0.8), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--0.5] _____________________________

alpha = 0.8, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4041f6520>],
      dtype=object)
args = (array(0.8), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.0] _____________________________

alpha = 0.8, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403761a80>],
      dtype=object)
args = (array(0.8), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.5] _____________________________

alpha = 0.8, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403762200>],
      dtype=object)
args = (array(0.8), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-1.0] _____________________________

alpha = 0.8, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403761080>],
      dtype=object)
args = (array(0.8), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--1.0] ____________________________

alpha = 0.99, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4037620c0>],
      dtype=object)
args = (array(0.99), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--0.5] ____________________________

alpha = 0.99, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403761580>],
      dtype=object)
args = (array(0.99), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.0] _____________________________

alpha = 0.99, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403762980>],
      dtype=object)
args = (array(0.99), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.5] _____________________________

alpha = 0.99, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4037618a0>],
      dtype=object)
args = (array(0.99), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-1.0] _____________________________

alpha = 0.99, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403763e20>],
      dtype=object)
args = (array(0.99), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.0--1.0] _____________________________

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.0--0.5] _____________________________

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.0] _____________________________

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.5] _____________________________

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-1.0] _____________________________

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.01--1.0] ____________________________

alpha = 1.01, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403762520>],
      dtype=object)
args = (array(1.01), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01--0.5] ____________________________

alpha = 1.01, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e4037600e0>],
      dtype=object)
args = (array(1.01), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.0] _____________________________

alpha = 1.01, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e403762980>],
      dtype=object)
args = (array(1.01), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.5] _____________________________

alpha = 1.01, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235cf40>],
      dtype=object)
args = (array(1.01), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-1.0] _____________________________

alpha = 1.01, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235e980>],
      dtype=object)
args = (array(1.01), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--1.0] _____________________________

alpha = 1.3, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235d940>],
      dtype=object)
args = (array(1.3), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--0.5] _____________________________

alpha = 1.3, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f060>],
      dtype=object)
args = (array(1.3), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.0] _____________________________

alpha = 1.3, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235ccc0>],
      dtype=object)
args = (array(1.3), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.5] _____________________________

alpha = 1.3, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f6a0>],
      dtype=object)
args = (array(1.3), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-1.0] _____________________________

alpha = 1.3, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235c5e0>],
      dtype=object)
args = (array(1.3), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--1.0] _____________________________

alpha = 1.7, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235d440>],
      dtype=object)
args = (array(1.7), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--0.5] _____________________________

alpha = 1.7, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235fb00>],
      dtype=object)
args = (array(1.7), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.0] _____________________________

alpha = 1.7, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f100>],
      dtype=object)
args = (array(1.7), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.5] _____________________________

alpha = 1.7, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f560>],
      dtype=object)
args = (array(1.7), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-1.0] _____________________________

alpha = 1.7, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f9c0>],
      dtype=object)
args = (array(1.7), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--1.0] _____________________________

alpha = 2.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235fce0>],
      dtype=object)
args = (array(2.), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--0.5] _____________________________

alpha = 2.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235fba0>],
      dtype=object)
args = (array(2.), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.0] _____________________________

alpha = 2.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f7e0>],
      dtype=object)
args = (array(2.), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.5] _____________________________

alpha = 2.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e40235f9c0>],
      dtype=object)
args = (array(2.), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-1.0] _____________________________

alpha = 2.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x72e430df3e90>
x = array([<function test_sample.<locals>.sampler at 0x72e402d55da0>],
      dtype=object)
args = (array(2.), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
___________________________ test_sample_2[0.1--1.0] ____________________________

alpha = 0.1, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(0.0) > 0.05
E        +  where np.float64(0.0) = KstestResult(statistic=np.float64(0.366), pvalue=np.float64(0.0), statistic_location=np.float64(-0.40038887017701835), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.366), pvalue=np.float64(0.0), statistic_location=np.float64(-0.40038887017701835), statistic_sign=np.int8(1)) = ks_2samp(array([-3.15145151e-02, -4.95554071e-03, -2.15762100e-02, ...,\n       -5.15118098e+00, -8.74745631e+04, -2.02801722e+03]), tensor([-1.5841e-01, -1.5838e-01, -1.5839e-01,  ..., -1.5818e-01,\n        -7.8071e+04, -1.5838e-01]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.1--0.5] ____________________________

alpha = 0.1, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(5.555410244185559e-206) > 0.05
E        +  where np.float64(5.555410244185559e-206) = KstestResult(statistic=np.float64(0.2167), pvalue=np.float64(5.555410244185559e-206), statistic_location=np.float64(-0.30539176209475977), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2167), pvalue=np.float64(5.555410244185559e-206), statistic_location=np.float64(-0.30539176209475977), statistic_sign=np.int8(1)) = ks_2samp(array([-9.14970934e-03, -2.04022809e-03, -7.82603321e-03, ...,\n        9.21775743e+05, -3.12243038e+04, -9.20866368e+02]), tensor([-7.9219e-02, -7.9191e-02, -7.9193e-02,  ..., -7.8984e-02,\n        -7.8071e+04, -7.9193e-02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.1-0.0] ____________________________

alpha = 0.1, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(6.618903608896064e-14) > 0.05
E        +  where np.float64(6.618903608896064e-14) = KstestResult(statistic=np.float64(0.0557), pvalue=np.float64(6.618903608896064e-14), statistic_location=np.float64(-27.329301927662303), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0557), pvalue=np.float64(6.618903608896064e-14), statistic_location=np.float64(-27.329301927662303), statistic_sign=np.int8(1)) = ks_2samp(array([ 5.11785953e-02, -5.80212785e-04, -2.08754904e-03, ...,\n        1.68885624e+08, -8.22789148e+03,  9.56071062e+02]), tensor([-2.6769e-05,  1.3835e-06, -1.1577e-06,  ...,  2.0853e-04,\n        -7.8071e+04, -3.7118e-07]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.1-0.5] ____________________________

alpha = 0.1, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(1.447770563564835e-150) > 0.05
E        +  where np.float64(1.447770563564835e-150) = KstestResult(statistic=np.float64(0.1854), pvalue=np.float64(1.447770563564835e-150), statistic_location=np.float64(0.2991652995546407), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1854), pvalue=np.float64(1.447770563564835e-150), statistic_location=np.float64(0.2991652995546407), statistic_sign=np.int8(-1)) = ks_2samp(array([ 1.79823741e-01,  6.18581675e-05, -8.04847564e-05, ...,\n        5.03937445e+09, -3.88542356e+02,  3.89268738e+03]), tensor([ 7.9165e-02,  7.9194e-02,  7.9191e-02,  ...,  7.9401e-02,\n        -7.8071e+04,  7.9192e-02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.1-1.0] ____________________________

alpha = 0.1, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(0.0) > 0.05
E        +  where np.float64(0.0) = KstestResult(statistic=np.float64(0.3477), pvalue=np.float64(0.0), statistic_location=np.float64(0.33709698537414623), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.3477), pvalue=np.float64(0.0), statistic_location=np.float64(0.33709698537414623), statistic_sign=np.int8(-1)) = ks_2samp(array([4.24037597e-01, 2.76752321e-04, 3.88606886e-04, ...,\n       6.31184682e+10, 1.37396759e+03, 8.25840093e+03]), tensor([ 1.5836e-01,  1.5839e-01,  1.5838e-01,  ...,  1.5859e-01,\n        -7.8070e+04,  1.5838e-01]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.4--1.0] ____________________________

alpha = 0.4, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ -0.36958303,  -0.95129527,  -1.7578711 , ...,  -0.69918619,\n       -23.19323362,  -2.69387547]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.4--0.5] ____________________________

alpha = 0.4, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-1.13388414e-01, -5.02053420e-01, -9.22924691e-01, ...,\n        2.36755016e+02, -1.21662232e+01, -1.16165988e+00]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.4-0.0] ____________________________

alpha = 0.4, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 3.22706852e-01, -1.74426505e-01, -3.45791714e-01, ...,\n        1.28469841e+03, -4.58203177e+00,  8.56311616e-01]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.4-0.5] ____________________________

alpha = 0.4, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 9.60268486e-01,  4.32302263e-02,  4.02527651e-03, ...,\n        3.48651020e+03, -2.56050733e-02,  3.39103670e+00]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.4-1.0] ____________________________

alpha = 0.4, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([1.81894101e+00, 1.63816257e-01, 1.61425176e-01, ...,\n       7.10067631e+03, 1.97971122e+00, 6.47193077e+00]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.8--1.0] ____________________________

alpha = 0.8, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-2.50029797, -4.0107703 , -4.9522371 , ..., -2.65124692,\n       -7.71639653, -3.59607831]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, -1.9374]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.8--0.5] ____________________________

alpha = 0.8, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-1.05374667, -2.23997229, -2.85698394, ..., 18.0370582 ,\n       -4.46762402, -1.66285945]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, -0.3986]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.8-0.0] ____________________________

alpha = 0.8, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.59768584, -0.59650758, -0.93576523, ..., 48.85162985,\n       -1.49184648,  0.40209787]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.1403]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.8-0.5] ____________________________

alpha = 0.8, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 2.40942689,  0.89013834,  0.76016929, ..., 84.34855825,\n        1.12878518,  2.58243471]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.6791]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[0.8-1.0] ____________________________

alpha = 0.8, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([  4.35334197,   2.17113217,   2.13121305, ..., 123.17125921,\n         3.23176515,   4.86552117]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 4.2180]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.99--1.0] ___________________________

alpha = 0.99, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-62.9888824 , -64.7814344 , -65.63989068, ..., -63.07826619,\n       -66.87031923, -63.96484349]), tensor([     nan,      nan,      nan,  ...,      nan,      nan, -62.5237]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.99--0.5] ___________________________

alpha = 0.99, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-31.23233676, -32.7312869 , -33.33050718, ..., -21.44241079,\n       -33.97704428, -31.84053088]), tensor([     nan,      nan,      nan,  ...,      nan,      nan, -30.6953]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.99-0.0] ____________________________

alpha = 0.99, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.70439384, -0.78569262, -1.14706366, ..., 22.18546851,\n       -1.21400539,  0.37261383]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.1331]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.99-0.5] ____________________________

alpha = 0.99, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([32.76951947, 31.0204107 , 30.8555917 , ..., 66.22164918,\n       31.36066202, 32.6598371 ]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.9615]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[0.99-1.0] ____________________________

alpha = 0.99, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 64.93300759,  62.62346178,  62.55608524, ..., 110.48402742,\n        63.61545429,  65.01026226]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, 64.7898]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[0.999999--1.0] _________________________

alpha = 0.999999, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-636619.09970922, -636620.9053101 , -636621.75876601, ...,\n       -636619.18617831, -636622.93271684, -636620.07135295]), tensor([         nan,          nan,          nan,  ...,          nan,\n                 nan, -636618.6938]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[0.999999--0.5] _________________________

alpha = 0.999999, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-318309.28431281, -318310.79869382, -318311.39608723, ...,\n       -318299.794864  , -318312.00537882, -318309.89329279]), tensor([         nan,          nan,          nan,  ...,          nan,\n                 nan, -318308.8076]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[0.999999-0.0] __________________________

alpha = 0.999999, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.70972915, -0.7952902 , -1.15715138, ..., 21.41222973,\n       -1.20368666,  0.37176742]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.0786]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[0.999999-0.5] __________________________

alpha = 0.999999, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([318310.83049343, 318309.06981598, 318308.90333456, ...,\n       318342.95650739, 318309.41530177, 318310.70925523]), tensor([        nan,         nan,         nan,  ...,         nan,\n                nan, 318310.9648]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[0.999999-1.0] __________________________

alpha = 0.999999, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([636621.04803183, 636618.73266516, 636618.66365749, ...,\n       636664.68072027, 636619.72194812, 636621.1084149 ]), tensor([        nan,         nan,         nan,  ...,         nan,\n                nan, 636620.8509]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[1.000001--1.0] _________________________

alpha = 1.000001, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([636620.44485423, 636618.63952851, 636617.78616564, ...,\n       636620.36321965, 636616.61212496, 636619.47359889]), tensor([        nan,         nan,         nan,  ...,         nan,\n                nan, 636620.8511]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[1.000001--0.5] _________________________

alpha = 1.000001, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([318310.48809463, 318308.97375839, 318308.37635614, ...,\n       318319.97752165, 318307.76707415, 318309.87914001]), tensor([        nan,         nan,         nan,  ...,         nan,\n                nan, 318310.9648]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[1.000001-0.0] __________________________

alpha = 1.000001, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.70973022, -0.79529212, -1.15715339, ..., 21.41207885,\n       -1.20368463,  0.37176725]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.0786]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[1.000001-0.5] __________________________

alpha = 1.000001, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-318308.94191255, -318310.70264003, -318310.86906018, ...,\n       -318276.81615903, -318310.35716442, -318309.06316234]), tensor([         nan,          nan,          nan,  ...,          nan,\n                 nan, -318308.8077]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
_________________________ test_sample_2[1.000001-1.0] __________________________

alpha = 1.000001, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-636618.49681771, -636620.81205521, -636620.88083396, ...,\n       -636574.86448012, -636619.82284293, -636618.43642685]), tensor([         nan,          nan,          nan,  ...,          nan,\n                 nan, -636618.6939]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.01--1.0] ___________________________

alpha = 1.01, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([64.33387444, 62.51559891, 61.66736756, ..., 64.2509503 ,\n       60.54801795, 63.36678797]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, 64.6808]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.01--0.5] ___________________________

alpha = 1.01, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([32.43606753, 30.90640207, 30.31089505, ..., 41.63703667,\n       29.73787878, 31.82624939]), tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.8524]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.01-0.0] ____________________________

alpha = 1.01, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.71504171, -0.80485521, -1.16715019, ..., 20.67584422,\n       -1.19367388,  0.37097147]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.0241]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.01-0.5] ____________________________

alpha = 1.01, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-3.08809281e+01, -3.26531652e+01, -3.28212557e+01, ...,\n       -1.25194881e-02, -3.23024367e+01, -3.10134704e+01]), tensor([     nan,      nan,      nan,  ...,      nan,      nan, -30.8043]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.01-1.0] ____________________________

alpha = 1.01, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-62.38165712, -64.70261778, -64.77317472, ..., -20.5624475 ,\n       -63.71590399, -62.33767691]), tensor([     nan,      nan,      nan,  ...,      nan,      nan, -62.6327]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.3--1.0] ____________________________

alpha = 1.3, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 2.77300538,  0.63733495, -0.05079895, ...,  2.78748095,\n       -0.09042718,  1.89326328]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.3--0.5] ____________________________

alpha = 1.3, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.75844891, -0.18231575, -0.70232745, ...,  5.86373065,\n       -0.51963884,  1.10609033]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.3-0.0] ____________________________

alpha = 1.3, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.86113751, -1.06924891, -1.42523312, ...,  8.79158162,\n       -0.99737411,  0.36333326]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.3-0.5] ____________________________

alpha = 1.3, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.04265203, -2.0515895 , -2.26055067, ..., 11.45674658,\n       -1.55243391, -0.34339889]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.3-1.0] ____________________________

alpha = 1.3, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([-0.71860681, -3.1824104 , -3.30511332, ..., 13.94843563,\n       -2.25456708, -1.02021152]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.7--1.0] ____________________________

alpha = 1.7, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.52021865, -0.985973  , -1.44415652, ...,  1.69316727,\n       -0.75004335,  0.69593238]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[1.7--0.5] ____________________________

alpha = 1.7, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.27107822, -1.18750241, -1.5754103 , ...,  2.6014173 ,\n       -0.81182978,  0.53234522]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.7-0.0] ____________________________

alpha = 1.7, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.05316468, -1.41307491, -1.73296067, ...,  3.44493307,\n       -0.88686574,  0.37845239]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.7-0.5] ____________________________

alpha = 1.7, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.85881303, -1.67029988, -1.92912422, ...,  4.16879436,\n       -0.9816211 ,  0.23294617]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[1.7-1.0] ____________________________

alpha = 1.7, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 0.68285115, -1.97096135, -2.18662922, ...,  4.81498771,\n       -1.10829189,  0.09476771]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[2.0--1.0] ____________________________

alpha = 2.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.20746185, -1.68463049, -1.9933968 , ...,  1.53315049,\n       -0.87626082,  0.39939476]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7840]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
___________________________ test_sample_2[2.0--0.5] ____________________________

alpha = 2.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.20746185, -1.68463049, -1.9933968 , ...,  1.53315049,\n       -0.87626082,  0.39939476]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7840]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[2.0-0.0] ____________________________

alpha = 2.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.20746185, -1.68463049, -1.9933968 , ...,  1.53315049,\n       -0.87626082,  0.39939476]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7840]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[2.0-0.5] ____________________________

alpha = 2.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.20746185, -1.68463049, -1.9933968 , ...,  1.53315049,\n       -0.87626082,  0.39939476]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7840]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
____________________________ test_sample_2[2.0-1.0] ____________________________

alpha = 2.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize(
        "alpha",
        [
            0.1,
            0.4,
            0.8,
            0.99,
            0.999999,
            1.000001,  # scipy sampler is buggy very close to 1
            1.01,
            1.3,
            1.7,
            2.0,
        ],
    )
    def test_sample_2(alpha, beta):
        num_samples = 10000
    
        d = dist.Stable(alpha, beta, coords="S")
        # Temporarily increase radius to test hole-patching logic.
        # Scipy doesn't handle values of alpha very close to 1.
        try:
            old = pyro.distributions.stable.RADIUS
            pyro.distributions.stable.RADIUS = 0.02
            actual = d.sample([num_samples])
        finally:
            pyro.distributions.stable.RADIUS = old
        actual = d.sample([num_samples])
    
        expected = levy_stable.rvs(alpha, beta, size=num_samples)
    
>       assert ks_2samp(expected, actual).pvalue > 0.05
E       assert np.float64(nan) > 0.05
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(array([ 1.20746185, -1.68463049, -1.9933968 , ...,  1.53315049,\n       -0.87626082,  0.39939476]), tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7840]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:94: AssertionError
______________________________ test_normal[0.5-0] ______________________________

loc = 0, scale = 0.5

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(0.0004), prec = 0.01
msg = 'nan vs 0.0004278888959946336'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 0.0004278888959946336

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[0.5-1] ______________________________

loc = 1, scale = 0.5

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(1.0004), prec = 0.01
msg = 'nan vs 1.0004278888959948'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 1.0004278888959948

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_____________________________ test_normal[0.5--1] ______________________________

loc = -1, scale = 0.5

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(-0.9996), prec = 0.01
msg = 'nan vs -0.9995721111040053'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs -0.9995721111040053

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_____________________________ test_normal[0.5-2_0] _____________________________

loc = 2, scale = 0.5

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0004), prec = 0.01
msg = 'nan vs 2.0004278888959943'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0004278888959943

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_____________________________ test_normal[0.5-2_1] _____________________________

loc = 2, scale = 0.5

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0004), prec = 0.01
msg = 'nan vs 2.0004278888959943'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0004278888959943

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_______________________________ test_normal[1-0] _______________________________

loc = 0, scale = 1

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(0.0009), prec = 0.01
msg = 'nan vs 0.0008557777919892672'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 0.0008557777919892672

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_______________________________ test_normal[1-1] _______________________________

loc = 1, scale = 1

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(1.0009), prec = 0.01
msg = 'nan vs 1.0008557777919893'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 1.0008557777919893

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[1--1] _______________________________

loc = -1, scale = 1

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(-0.9991), prec = 0.01
msg = 'nan vs -0.9991442222080106'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs -0.9991442222080106

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[1-2_0] ______________________________

loc = 2, scale = 1

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0009), prec = 0.01
msg = 'nan vs 2.0008557777919895'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0008557777919895

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[1-2_1] ______________________________

loc = 2, scale = 1

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0009), prec = 0.01
msg = 'nan vs 2.0008557777919895'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0008557777919895

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_______________________________ test_normal[2-0] _______________________________

loc = 0, scale = 2

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(0.0017), prec = 0.01
msg = 'nan vs 0.0017115555839785344'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 0.0017115555839785344

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_______________________________ test_normal[2-1] _______________________________

loc = 1, scale = 2

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(1.0017), prec = 0.01
msg = 'nan vs 1.0017115555839788'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 1.0017115555839788

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[2--1] _______________________________

loc = -1, scale = 2

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(-0.9983), prec = 0.01
msg = 'nan vs -0.9982884444160213'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs -0.9982884444160213

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[2-2_0] ______________________________

loc = 2, scale = 2

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0017), prec = 0.01
msg = 'nan vs 2.0017115555839786'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0017115555839786

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
______________________________ test_normal[2-2_1] ______________________________

loc = 2, scale = 2

    @pytest.mark.parametrize("loc", [0, 1, -1, 2, 2])
    @pytest.mark.parametrize("scale", [0.5, 1, 2])
    def test_normal(loc, scale):
        num_samples = 100000
        expected = dist.Normal(loc, scale).sample([num_samples])
        actual = dist.Stable(2, 0, scale * 0.5**0.5, loc).sample([num_samples])
>       assert_close(actual.mean(), expected.mean(), atol=0.01)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:218: in assert_close
    assert_tensors_equal(actual, expected, prec, msg)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor(nan), b = tensor(2.0017), prec = 0.01
msg = 'nan vs 2.0017115555839786'

    def assert_tensors_equal(a, b, prec=0.0, msg=""):
        assert a.size() == b.size(), msg
        if isinstance(prec, numbers.Number) and prec == 0:
            assert (a == b).all(), msg
            return
        if a.numel() == 0 and b.numel() == 0:
            return
        b = b.type_as(a)
        b = b.cuda(device=a.get_device()) if a.is_cuda else b.cpu()
        if not a.dtype.is_floating_point:
            assert (a == b).all(), msg
            return
        # check that NaNs are in the same locations
        nan_mask = a != a
>       assert torch.equal(nan_mask, b != b), msg
E       AssertionError: nan vs 2.0017115555839786

/local/data0/moved_data/publishablew/pyro/pyro/tests/common.py:160: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.9--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.3016688942478174e-206) > 0.03
E        +  where np.float64(2.3016688942478174e-206) = KstestResult(statistic=np.float64(0.2169), pvalue=np.float64(2.3016688942478174e-206), statistic_location=np.float64(-1.1432510248653391), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2169), pvalue=np.float64(2.3016688942478174e-206), statistic_location=np.float64(-1.1432510248653391), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3949, -6.3914,  0.0756,  ..., -2.0206, -1.9159, -0.3942]), tensor([ 19.0975,  -1.4212,  -1.9264,  ...,  -1.1140,  -0.6627, 132.7031]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.9--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.8662030577234562e-148) > 0.03
E        +  where np.float64(1.8662030577234562e-148) = KstestResult(statistic=np.float64(0.1841), pvalue=np.float64(1.8662030577234562e-148), statistic_location=np.float64(-1.0456385441784621), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1841), pvalue=np.float64(1.8662030577234562e-148), statistic_location=np.float64(-1.0456385441784621), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3549, -6.3514,  0.1156,  ..., -1.9806, -1.8759, -0.3542]), tensor([ 19.2575,  -1.2612,  -1.7664,  ...,  -0.9540,  -0.5027, 132.8631]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.0667934135073556e-77) > 0.03
E        +  where np.float64(3.0667934135073556e-77) = KstestResult(statistic=np.float64(0.1328), pvalue=np.float64(3.0667934135073556e-77), statistic_location=np.float64(-0.897993068441884), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1328), pvalue=np.float64(3.0667934135073556e-77), statistic_location=np.float64(-0.897993068441884), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3049, -6.3014,  0.1656,  ..., -1.9306, -1.8259, -0.3042]), tensor([ 19.4575,  -1.0612,  -1.5664,  ...,  -0.7540,  -0.3027, 133.0631]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.145397512748782e-21) > 0.03
E        +  where np.float64(6.145397512748782e-21) = KstestResult(statistic=np.float64(0.0687), pvalue=np.float64(6.145397512748782e-21), statistic_location=np.float64(-0.7998504637649275), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0687), pvalue=np.float64(6.145397512748782e-21), statistic_location=np.float64(-0.7998504637649275), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2549, -6.2514,  0.2156,  ..., -1.8806, -1.7759, -0.2542]), tensor([ 1.9658e+01, -8.6118e-01, -1.3664e+00,  ..., -5.5403e-01,\n        -1.0274e-01,  1.3326e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.5--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.8662030577234562e-148) > 0.03
E        +  where np.float64(1.8662030577234562e-148) = KstestResult(statistic=np.float64(0.1841), pvalue=np.float64(1.8662030577234562e-148), statistic_location=np.float64(-0.7256385441784623), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1841), pvalue=np.float64(1.8662030577234562e-148), statistic_location=np.float64(-0.7256385441784623), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0349, -6.0314,  0.4356,  ..., -1.6606, -1.5559, -0.0342]), tensor([ 19.5775,  -0.9412,  -1.4464,  ...,  -0.6340,  -0.1827, 133.1831]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.5--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(4.834653852454181e-91) > 0.03
E        +  where np.float64(4.834653852454181e-91) = KstestResult(statistic=np.float64(0.1442), pvalue=np.float64(4.834653852454181e-91), statistic_location=np.float64(-0.5911443788596754), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1442), pvalue=np.float64(4.834653852454181e-91), statistic_location=np.float64(-0.5911443788596754), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 5.0887e-03, -5.9914e+00,  4.7557e-01,  ..., -1.6206e+00,\n        -1.5159e+00,  5.7757e-03]), tensor([ 1.9738e+01, -7.8118e-01, -1.2864e+00,  ..., -4.7403e-01,\n        -2.2735e-02,  1.3334e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.409750964239297e-30) > 0.03
E        +  where np.float64(8.409750964239297e-30) = KstestResult(statistic=np.float64(0.0822), pvalue=np.float64(8.409750964239297e-30), statistic_location=np.float64(-0.5207828264631508), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0822), pvalue=np.float64(8.409750964239297e-30), statistic_location=np.float64(-0.5207828264631508), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.0551, -5.9414,  0.5256,  ..., -1.5706, -1.4659,  0.0558]), tensor([ 19.9375,  -0.5812,  -1.0864,  ...,  -0.2740,   0.1773, 133.5431]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9--0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.163029979441378e-12) > 0.03
E        +  where np.float64(8.163029979441378e-12) = KstestResult(statistic=np.float64(0.0512), pvalue=np.float64(8.163029979441378e-12), statistic_location=np.float64(-0.30850102852709355), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0512), pvalue=np.float64(8.163029979441378e-12), statistic_location=np.float64(-0.30850102852709355), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.1451, -5.8514,  0.6156,  ..., -1.4806, -1.3759,  0.1458]), tensor([ 2.0298e+01, -2.2118e-01, -7.2635e-01,  ...,  8.5972e-02,\n         5.3726e-01,  1.3390e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9-0.0--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.0667934135073556e-77) > 0.03
E        +  where np.float64(3.0667934135073556e-77) = KstestResult(statistic=np.float64(0.1328), pvalue=np.float64(3.0667934135073556e-77), statistic_location=np.float64(-0.17799306844188412), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1328), pvalue=np.float64(3.0667934135073556e-77), statistic_location=np.float64(-0.17799306844188412), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.4151, -5.5814,  0.8856,  ..., -1.2106, -1.1059,  0.4158]), tensor([ 2.0178e+01, -3.4118e-01, -8.4635e-01,  ..., -3.4028e-02,\n         4.1726e-01,  1.3378e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9-0.0--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.409750964239297e-30) > 0.03
E        +  where np.float64(8.409750964239297e-30) = KstestResult(statistic=np.float64(0.0822), pvalue=np.float64(8.409750964239297e-30), statistic_location=np.float64(-0.12078282646315075), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0822), pvalue=np.float64(8.409750964239297e-30), statistic_location=np.float64(-0.12078282646315075), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.4551, -5.5414,  0.9256,  ..., -1.1706, -1.0659,  0.4558]), tensor([ 2.0338e+01, -1.8118e-01, -6.8635e-01,  ...,  1.2597e-01,\n         5.7726e-01,  1.3394e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.0-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.711508192196644e-19) > 0.03
E        +  where np.float64(6.711508192196644e-19) = KstestResult(statistic=np.float64(0.0652), pvalue=np.float64(6.711508192196644e-19), statistic_location=np.float64(0.12629647472549504), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0652), pvalue=np.float64(6.711508192196644e-19), statistic_location=np.float64(0.12629647472549504), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.5551, -5.4414,  1.0256,  ..., -1.0706, -0.9659,  0.5558]), tensor([ 20.7375,   0.2188,  -0.2864,  ...,   0.5260,   0.9773, 134.3431]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.0-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4126243396730107e-61) > 0.03
E        +  where np.float64(2.4126243396730107e-61) = KstestResult(statistic=np.float64(0.1183), pvalue=np.float64(2.4126243396730107e-61), statistic_location=np.float64(0.26185014121736516), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1183), pvalue=np.float64(2.4126243396730107e-61), statistic_location=np.float64(0.26185014121736516), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.5951, -5.4014,  1.0656,  ..., -1.0306, -0.9259,  0.5958]), tensor([ 2.0898e+01,  3.7882e-01, -1.2635e-01,  ...,  6.8597e-01,\n         1.1373e+00,  1.3450e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9-0.5--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.145397512748782e-21) > 0.03
E        +  where np.float64(6.145397512748782e-21) = KstestResult(statistic=np.float64(0.0687), pvalue=np.float64(6.145397512748782e-21), statistic_location=np.float64(0.3201495362350722), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0687), pvalue=np.float64(6.145397512748782e-21), statistic_location=np.float64(0.3201495362350722), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.8651, -5.1314,  1.3356,  ..., -0.7606, -0.6559,  0.8658]), tensor([ 20.7775,   0.2588,  -0.2464,  ...,   0.5660,   1.0173, 134.3831]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.711508192196644e-19) > 0.03
E        +  where np.float64(6.711508192196644e-19) = KstestResult(statistic=np.float64(0.0652), pvalue=np.float64(6.711508192196644e-19), statistic_location=np.float64(0.526296474725495), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0652), pvalue=np.float64(6.711508192196644e-19), statistic_location=np.float64(0.526296474725495), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.9551, -5.0414,  1.4256,  ..., -0.6706, -0.5659,  0.9558]), tensor([2.1138e+01, 6.1882e-01, 1.1365e-01,  ..., 9.2597e-01, 1.3773e+00,\n        1.3474e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.5-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.115527836912432e-73) > 0.03
E        +  where np.float64(3.115527836912432e-73) = KstestResult(statistic=np.float64(0.1293), pvalue=np.float64(3.115527836912432e-73), statistic_location=np.float64(0.6700837330119719), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1293), pvalue=np.float64(3.115527836912432e-73), statistic_location=np.float64(0.6700837330119719), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0051, -4.9914,  1.4756,  ..., -0.6206, -0.5159,  1.0058]), tensor([ 21.3375,   0.8188,   0.3136,  ...,   1.1260,   1.5773, 134.9431]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.5057845535221732e-122) > 0.03
E        +  where np.float64(1.5057845535221732e-122) = KstestResult(statistic=np.float64(0.1673), pvalue=np.float64(1.5057845535221732e-122), statistic_location=np.float64(0.7860650975669635), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1673), pvalue=np.float64(1.5057845535221732e-122), statistic_location=np.float64(0.7860650975669635), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0451, -4.9514,  1.5156,  ..., -0.5806, -0.4759,  1.0458]), tensor([ 21.4975,   0.9788,   0.4736,  ...,   1.2860,   1.7373, 135.1031]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.1-0.9-0.9--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.163029979441378e-12) > 0.03
E        +  where np.float64(8.163029979441378e-12) = KstestResult(statistic=np.float64(0.0512), pvalue=np.float64(8.163029979441378e-12), statistic_location=np.float64(0.8114989714729064), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0512), pvalue=np.float64(8.163029979441378e-12), statistic_location=np.float64(0.8114989714729064), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.2651, -4.7314,  1.7356,  ..., -0.3606, -0.2559,  1.2658]), tensor([ 21.4175,   0.8988,   0.3936,  ...,   1.2060,   1.6573, 135.0231]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4126243396730107e-61) > 0.03
E        +  where np.float64(2.4126243396730107e-61) = KstestResult(statistic=np.float64(0.1183), pvalue=np.float64(2.4126243396730107e-61), statistic_location=np.float64(0.9818501412173651), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1183), pvalue=np.float64(2.4126243396730107e-61), statistic_location=np.float64(0.9818501412173651), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.3151, -4.6814,  1.7856,  ..., -0.3106, -0.2059,  1.3158]), tensor([ 21.6175,   1.0988,   0.5936,  ...,   1.4060,   1.8573, 135.2231]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.5057845535221732e-122) > 0.03
E        +  where np.float64(1.5057845535221732e-122) = KstestResult(statistic=np.float64(0.1673), pvalue=np.float64(1.5057845535221732e-122), statistic_location=np.float64(1.1060650975669635), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1673), pvalue=np.float64(1.5057845535221732e-122), statistic_location=np.float64(1.1060650975669635), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.3651, -4.6314,  1.8356,  ..., -0.2606, -0.1559,  1.3658]), tensor([ 21.8175,   1.2988,   0.7936,  ...,   1.6060,   2.0573, 135.4231]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.1-0.9-0.9-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.1119944867956573e-172) > 0.03
E        +  where np.float64(1.1119944867956573e-172) = KstestResult(statistic=np.float64(0.1985), pvalue=np.float64(1.1119944867956573e-172), statistic_location=np.float64(1.2106102967253696), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1985), pvalue=np.float64(1.1119944867956573e-172), statistic_location=np.float64(1.2106102967253696), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.4051, -4.5914,  1.8756,  ..., -0.2206, -0.1159,  1.4058]), tensor([ 21.9775,   1.4588,   0.9536,  ...,   1.7660,   2.2173, 135.5831]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.9--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(7.24491108937044e-257) > 0.03
E        +  where np.float64(7.24491108937044e-257) = KstestResult(statistic=np.float64(0.2418), pvalue=np.float64(7.24491108937044e-257), statistic_location=np.float64(-1.1467906078576204), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2418), pvalue=np.float64(7.24491108937044e-257), statistic_location=np.float64(-1.1467906078576204), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.4764, -5.7741,  0.2932,  ..., -1.9794, -2.3345, -0.4265]), tensor([ 21.4847,  -1.5988,  -2.1671,  ...,  -1.2533,  -0.7456, 149.2910]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.9--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.108181721514734e-186) > 0.03
E        +  where np.float64(2.108181721514734e-186) = KstestResult(statistic=np.float64(0.2062), pvalue=np.float64(2.108181721514734e-186), statistic_location=np.float64(-1.053873898691518), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2062), pvalue=np.float64(2.108181721514734e-186), statistic_location=np.float64(-1.053873898691518), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3964, -5.6941,  0.3732,  ..., -1.8994, -2.2545, -0.3465]), tensor([ 21.7247,  -1.3588,  -1.9271,  ...,  -1.0133,  -0.5056, 149.5310]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.7732835079359335e-101) > 0.03
E        +  where np.float64(3.7732835079359335e-101) = KstestResult(statistic=np.float64(0.152), pvalue=np.float64(3.7732835079359335e-101), statistic_location=np.float64(-0.8450374262171348), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.152), pvalue=np.float64(3.7732835079359335e-101), statistic_location=np.float64(-0.8450374262171348), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2964, -5.5941,  0.4732,  ..., -1.7994, -2.1545, -0.2465]), tensor([ 22.0247,  -1.0588,  -1.6271,  ...,  -0.7133,  -0.2056, 149.8310]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.5596299356192165e-28) > 0.03
E        +  where np.float64(2.5596299356192165e-28) = KstestResult(statistic=np.float64(0.0801), pvalue=np.float64(2.5596299356192165e-28), statistic_location=np.float64(-0.6727953255387803), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0801), pvalue=np.float64(2.5596299356192165e-28), statistic_location=np.float64(-0.6727953255387803), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.1964, -5.4941,  0.5732,  ..., -1.6994, -2.0545, -0.1465]), tensor([ 2.2325e+01, -7.5883e-01, -1.3271e+00,  ..., -4.1328e-01,\n         9.4423e-02,  1.5013e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.5--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.108181721514734e-186) > 0.03
E        +  where np.float64(2.108181721514734e-186) = KstestResult(statistic=np.float64(0.2062), pvalue=np.float64(2.108181721514734e-186), statistic_location=np.float64(-0.8138738986915177), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2062), pvalue=np.float64(2.108181721514734e-186), statistic_location=np.float64(-0.8138738986915177), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.1564, -5.4541,  0.6132,  ..., -1.6594, -2.0145, -0.1065]), tensor([ 21.9647,  -1.1188,  -1.6871,  ...,  -0.7733,  -0.2656, 149.7710]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.5--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.2985978514418983e-117) > 0.03
E        +  where np.float64(1.2985978514418983e-117) = KstestResult(statistic=np.float64(0.1639), pvalue=np.float64(1.2985978514418983e-117), statistic_location=np.float64(-0.6646052476482176), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1639), pvalue=np.float64(1.2985978514418983e-117), statistic_location=np.float64(-0.6646052476482176), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0764, -5.3741,  0.6932,  ..., -1.5794, -1.9345, -0.0265]), tensor([ 2.2205e+01, -8.7883e-01, -1.4471e+00,  ..., -5.3328e-01,\n        -2.5577e-02,  1.5001e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.553087110820756e-40) > 0.03
E        +  where np.float64(3.553087110820756e-40) = KstestResult(statistic=np.float64(0.0956), pvalue=np.float64(3.553087110820756e-40), statistic_location=np.float64(-0.44392819180104814), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0956), pvalue=np.float64(3.553087110820756e-40), statistic_location=np.float64(-0.44392819180104814), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.0236, -5.2741,  0.7932,  ..., -1.4794, -1.8345,  0.0735]), tensor([ 22.5047,  -0.5788,  -1.1471,  ...,  -0.2333,   0.2744, 150.3110]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8--0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.1561259758113673e-18) > 0.03
E        +  where np.float64(2.1561259758113673e-18) = KstestResult(statistic=np.float64(0.0643), pvalue=np.float64(2.1561259758113673e-18), statistic_location=np.float64(-0.143036451278411), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0643), pvalue=np.float64(2.1561259758113673e-18), statistic_location=np.float64(-0.143036451278411), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.2036, -5.0941,  0.9732,  ..., -1.2994, -1.6545,  0.2535]), tensor([ 2.3045e+01, -3.8832e-02, -6.0715e-01,  ...,  3.0672e-01,\n         8.1442e-01,  1.5085e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8-0.0--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.7732835079359335e-101) > 0.03
E        +  where np.float64(3.7732835079359335e-101) = KstestResult(statistic=np.float64(0.152), pvalue=np.float64(3.7732835079359335e-101), statistic_location=np.float64(-0.3050374262171349), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.152), pvalue=np.float64(3.7732835079359335e-101), statistic_location=np.float64(-0.3050374262171349), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.2436, -5.0541,  1.0132,  ..., -1.2594, -1.6145,  0.2935]), tensor([ 22.5647,  -0.5188,  -1.0871,  ...,  -0.1733,   0.3344, 150.3710]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8-0.0--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.553087110820756e-40) > 0.03
E        +  where np.float64(3.553087110820756e-40) = KstestResult(statistic=np.float64(0.0956), pvalue=np.float64(3.553087110820756e-40), statistic_location=np.float64(-0.14392819180104824), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0956), pvalue=np.float64(3.553087110820756e-40), statistic_location=np.float64(-0.14392819180104824), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.3236, -4.9741,  1.0932,  ..., -1.1794, -1.5345,  0.3735]), tensor([ 2.2805e+01, -2.7883e-01, -8.4715e-01,  ...,  6.6719e-02,\n         5.7442e-01,  1.5061e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.0-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.1441559634099407e-28) > 0.03
E        +  where np.float64(1.1441559634099407e-28) = KstestResult(statistic=np.float64(0.0806), pvalue=np.float64(1.1441559634099407e-28), statistic_location=np.float64(0.21641788901383252), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0806), pvalue=np.float64(1.1441559634099407e-28), statistic_location=np.float64(0.21641788901383252), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.5236, -4.7741,  1.2932,  ..., -0.9794, -1.3345,  0.5735]), tensor([ 23.4047,   0.3212,  -0.2471,  ...,   0.6667,   1.1744, 151.2110]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.0-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(7.086104486856234e-84) > 0.03
E        +  where np.float64(7.086104486856234e-84) = KstestResult(statistic=np.float64(0.1384), pvalue=np.float64(7.086104486856234e-84), statistic_location=np.float64(0.3945168015923697), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1384), pvalue=np.float64(7.086104486856234e-84), statistic_location=np.float64(0.3945168015923697), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6036, -4.6941,  1.3732,  ..., -0.8994, -1.2545,  0.6535]), tensor([ 2.3645e+01,  5.6117e-01, -7.1455e-03,  ...,  9.0672e-01,\n         1.4144e+00,  1.5145e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8-0.5--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.5596299356192165e-28) > 0.03
E        +  where np.float64(2.5596299356192165e-28) = KstestResult(statistic=np.float64(0.0801), pvalue=np.float64(2.5596299356192165e-28), statistic_location=np.float64(0.1672046744612197), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0801), pvalue=np.float64(2.5596299356192165e-28), statistic_location=np.float64(0.1672046744612197), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.6436, -4.6541,  1.4132,  ..., -0.8594, -1.2145,  0.6935]), tensor([ 2.3165e+01,  8.1168e-02, -4.8715e-01,  ...,  4.2672e-01,\n         9.3442e-01,  1.5097e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.1441559634099407e-28) > 0.03
E        +  where np.float64(1.1441559634099407e-28) = KstestResult(statistic=np.float64(0.0806), pvalue=np.float64(1.1441559634099407e-28), statistic_location=np.float64(0.5164178890138325), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0806), pvalue=np.float64(1.1441559634099407e-28), statistic_location=np.float64(0.5164178890138325), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.8236, -4.4741,  1.5932,  ..., -0.6794, -1.0345,  0.8735]), tensor([2.3705e+01, 6.2117e-01, 5.2854e-02,  ..., 9.6672e-01, 1.4744e+00,\n        1.5151e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.5-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.694562542292794e-99) > 0.03
E        +  where np.float64(6.694562542292794e-99) = KstestResult(statistic=np.float64(0.1503), pvalue=np.float64(6.694562542292794e-99), statistic_location=np.float64(0.7498848493282719), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1503), pvalue=np.float64(6.694562542292794e-99), statistic_location=np.float64(0.7498848493282719), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.9236, -4.3741,  1.6932,  ..., -0.5794, -0.9345,  0.9735]), tensor([ 24.0047,   0.9212,   0.3529,  ...,   1.2667,   1.7744, 151.8110]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4672373181719235e-160) > 0.03
E        +  where np.float64(2.4672373181719235e-160) = KstestResult(statistic=np.float64(0.1913), pvalue=np.float64(2.4672373181719235e-160), statistic_location=np.float64(0.9358651165191753), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1913), pvalue=np.float64(2.4672373181719235e-160), statistic_location=np.float64(0.9358651165191753), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0036, -4.2941,  1.7732,  ..., -0.4994, -0.8545,  1.0535]), tensor([ 24.2447,   1.1612,   0.5929,  ...,   1.5067,   2.0144, 152.0510]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.2-0.8-0.9--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.1561259758113673e-18) > 0.03
E        +  where np.float64(2.1561259758113673e-18) = KstestResult(statistic=np.float64(0.0643), pvalue=np.float64(2.1561259758113673e-18), statistic_location=np.float64(0.6969635487215889), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0643), pvalue=np.float64(2.1561259758113673e-18), statistic_location=np.float64(0.6969635487215889), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0436, -4.2541,  1.8132,  ..., -0.4594, -0.8145,  1.0935]), tensor([ 23.8847,   0.8012,   0.2329,  ...,   1.1467,   1.6544, 151.6910]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(7.086104486856234e-84) > 0.03
E        +  where np.float64(7.086104486856234e-84) = KstestResult(statistic=np.float64(0.1384), pvalue=np.float64(7.086104486856234e-84), statistic_location=np.float64(0.9345168015923697), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1384), pvalue=np.float64(7.086104486856234e-84), statistic_location=np.float64(0.9345168015923697), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.1436, -4.1541,  1.9132,  ..., -0.3594, -0.7145,  1.1935]), tensor([ 24.1847,   1.1012,   0.5329,  ...,   1.4467,   1.9544, 151.9910]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4672373181719235e-160) > 0.03
E        +  where np.float64(2.4672373181719235e-160) = KstestResult(statistic=np.float64(0.1913), pvalue=np.float64(2.4672373181719235e-160), statistic_location=np.float64(1.1758651165191751), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1913), pvalue=np.float64(2.4672373181719235e-160), statistic_location=np.float64(1.1758651165191751), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.2436, -4.0541,  2.0132,  ..., -0.2594, -0.6145,  1.2935]), tensor([ 24.4847,   1.4012,   0.8329,  ...,   1.7467,   2.2544, 152.2910]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.2-0.8-0.9-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.606033096730626e-222) > 0.03
E        +  where np.float64(3.606033096730626e-222) = KstestResult(statistic=np.float64(0.225), pvalue=np.float64(3.606033096730626e-222), statistic_location=np.float64(1.3495913544914917), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.225), pvalue=np.float64(3.606033096730626e-222), statistic_location=np.float64(1.3495913544914917), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.3236, -3.9741,  2.0932,  ..., -0.1794, -0.5345,  1.3735]), tensor([ 24.7247,   1.6412,   1.0729,  ...,   1.9867,   2.4944, 152.5310]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.9--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(4.7975965786460333e-290) > 0.03
E        +  where np.float64(4.7975965786460333e-290) = KstestResult(statistic=np.float64(0.2568), pvalue=np.float64(4.7975965786460333e-290), statistic_location=np.float64(-1.2571319673673602), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2568), pvalue=np.float64(4.7975965786460333e-290), statistic_location=np.float64(-1.2571319673673602), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.6393, -4.5395,  0.7285,  ..., -1.8970, -3.1718, -0.4910]), tensor([ 23.6308,  -1.7585,  -2.3836,  ...,  -1.3785,  -0.8201, 164.2032]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.9--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.420846167781005e-212) > 0.03
E        +  where np.float64(2.420846167781005e-212) = KstestResult(statistic=np.float64(0.22), pvalue=np.float64(2.420846167781005e-212), statistic_location=np.float64(-1.0097853148426703), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.22), pvalue=np.float64(2.420846167781005e-212), statistic_location=np.float64(-1.0097853148426703), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.4793, -4.3795,  0.8885,  ..., -1.7370, -3.0118, -0.3310]), tensor([ 23.9867,  -1.4026,  -2.0277,  ...,  -1.0225,  -0.4641, 164.5591]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4168300383777408e-119) > 0.03
E        +  where np.float64(2.4168300383777408e-119) = KstestResult(statistic=np.float64(0.1651), pvalue=np.float64(2.4168300383777408e-119), statistic_location=np.float64(-0.7157939185194955), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1651), pvalue=np.float64(2.4168300383777408e-119), statistic_location=np.float64(-0.7157939185194955), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2793, -4.1795,  1.0885,  ..., -1.5370, -2.8118, -0.1310]), tensor([ 2.4432e+01, -9.5763e-01, -1.5827e+00,  ..., -5.7756e-01,\n        -1.9142e-02,  1.6500e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(4.240440530283699e-34) > 0.03
E        +  where np.float64(4.240440530283699e-34) = KstestResult(statistic=np.float64(0.088), pvalue=np.float64(4.240440530283699e-34), statistic_location=np.float64(-0.4148500181941011), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.088), pvalue=np.float64(4.240440530283699e-34), statistic_location=np.float64(-0.4148500181941011), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0793, -3.9795,  1.2885,  ..., -1.3370, -2.6118,  0.0690]), tensor([ 2.4877e+01, -5.1268e-01, -1.1378e+00,  ..., -1.3261e-01,\n         4.2581e-01,  1.6545e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.5--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.420846167781005e-212) > 0.03
E        +  where np.float64(2.420846167781005e-212) = KstestResult(statistic=np.float64(0.22), pvalue=np.float64(2.420846167781005e-212), statistic_location=np.float64(-0.9297853148426702), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.22), pvalue=np.float64(2.420846167781005e-212), statistic_location=np.float64(-0.9297853148426702), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3993, -4.2995,  0.9685,  ..., -1.6570, -2.9318, -0.2510]), tensor([ 24.0667,  -1.3226,  -1.9477,  ...,  -0.9425,  -0.3841, 164.6391]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.5--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(9.86353874534622e-137) > 0.03
E        +  where np.float64(9.86353874534622e-137) = KstestResult(statistic=np.float64(0.1767), pvalue=np.float64(9.86353874534622e-137), statistic_location=np.float64(-0.6726717419753281), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1767), pvalue=np.float64(9.86353874534622e-137), statistic_location=np.float64(-0.6726717419753281), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2393, -4.1395,  1.1285,  ..., -1.4970, -2.7718, -0.0910]), tensor([ 2.4423e+01, -9.6662e-01, -1.5917e+00,  ..., -5.8655e-01,\n        -2.8132e-02,  1.6500e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.1457765804065715e-48) > 0.03
E        +  where np.float64(1.1457765804065715e-48) = KstestResult(statistic=np.float64(0.1053), pvalue=np.float64(1.1457765804065715e-48), statistic_location=np.float64(-0.3698677554778274), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1053), pvalue=np.float64(1.1457765804065715e-48), statistic_location=np.float64(-0.3698677554778274), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0393, -3.9395,  1.3285,  ..., -1.2970, -2.5718,  0.1090]), tensor([ 2.4868e+01, -5.2167e-01, -1.1467e+00,  ..., -1.4160e-01,\n         4.1682e-01,  1.6544e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6--0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.624722874142088e-22) > 0.03
E        +  where np.float64(6.624722874142088e-22) = KstestResult(statistic=np.float64(0.0703), pvalue=np.float64(6.624722874142088e-22), statistic_location=np.float64(0.17198551051534094), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0703), pvalue=np.float64(6.624722874142088e-22), statistic_location=np.float64(0.17198551051534094), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.3207, -3.5795,  1.6885,  ..., -0.9370, -2.2118,  0.4690]), tensor([ 25.6685,   0.2792,  -0.3458,  ...,   0.6593,   1.2177, 166.2409]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6-0.0--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.4168300383777408e-119) > 0.03
E        +  where np.float64(2.4168300383777408e-119) = KstestResult(statistic=np.float64(0.1651), pvalue=np.float64(2.4168300383777408e-119), statistic_location=np.float64(-0.5357939185194953), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1651), pvalue=np.float64(2.4168300383777408e-119), statistic_location=np.float64(-0.5357939185194953), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0993, -3.9995,  1.2685,  ..., -1.3570, -2.6318,  0.0490]), tensor([ 2.4612e+01, -7.7763e-01, -1.4027e+00,  ..., -3.9756e-01,\n         1.6086e-01,  1.6518e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6-0.0--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.1457765804065715e-48) > 0.03
E        +  where np.float64(1.1457765804065715e-48) = KstestResult(statistic=np.float64(0.1053), pvalue=np.float64(1.1457765804065715e-48), statistic_location=np.float64(-0.26986775547782743), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1053), pvalue=np.float64(1.1457765804065715e-48), statistic_location=np.float64(-0.26986775547782743), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.0607, -3.8395,  1.4285,  ..., -1.1970, -2.4718,  0.2090]), tensor([ 2.4968e+01, -4.2167e-01, -1.0467e+00,  ..., -4.1600e-02,\n         5.1682e-01,  1.6554e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.0-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.0513878668029795e-35) > 0.03
E        +  where np.float64(2.0513878668029795e-35) = KstestResult(statistic=np.float64(0.0897), pvalue=np.float64(2.0513878668029795e-35), statistic_location=np.float64(0.3545579542581439), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0897), pvalue=np.float64(2.0513878668029795e-35), statistic_location=np.float64(0.3545579542581439), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.4607, -3.4395,  1.8285,  ..., -0.7970, -2.0718,  0.6090]), tensor([ 2.5858e+01,  4.6823e-01, -1.5685e-01,  ...,  8.4830e-01,\n         1.4067e+00,  1.6643e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.0-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.0138484580846585e-97) > 0.03
E        +  where np.float64(1.0138484580846585e-97) = KstestResult(statistic=np.float64(0.1494), pvalue=np.float64(1.0138484580846585e-97), statistic_location=np.float64(0.6254374051853475), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1494), pvalue=np.float64(1.0138484580846585e-97), statistic_location=np.float64(0.6254374051853475), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6207, -3.2795,  1.9885,  ..., -0.6370, -1.9118,  0.7690]), tensor([ 26.2135,   0.8242,   0.1991,  ...,   1.2043,   1.7627, 166.7859]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6-0.5--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(4.240440530283699e-34) > 0.03
E        +  where np.float64(4.240440530283699e-34) = KstestResult(statistic=np.float64(0.088), pvalue=np.float64(4.240440530283699e-34), statistic_location=np.float64(-0.13485001819410114), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.088), pvalue=np.float64(4.240440530283699e-34), statistic_location=np.float64(-0.13485001819410114), statistic_sign=np.int8(-1)) = ks_2samp(tensor([ 0.2007, -3.6995,  1.5685,  ..., -1.0570, -2.3318,  0.3490]), tensor([ 2.5157e+01, -2.3268e-01, -8.5776e-01,  ...,  1.4739e-01,\n         7.0581e-01,  1.6573e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(2.0513878668029795e-35) > 0.03
E        +  where np.float64(2.0513878668029795e-35) = KstestResult(statistic=np.float64(0.0897), pvalue=np.float64(2.0513878668029795e-35), statistic_location=np.float64(0.4545579542581438), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0897), pvalue=np.float64(2.0513878668029795e-35), statistic_location=np.float64(0.4545579542581438), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.5607, -3.3395,  1.9285,  ..., -0.6970, -1.9718,  0.7090]), tensor([ 2.5958e+01,  5.6823e-01, -5.6849e-02,  ...,  9.4830e-01,\n         1.5067e+00,  1.6653e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.5-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(4.8386157177326225e-115) > 0.03
E        +  where np.float64(4.8386157177326225e-115) = KstestResult(statistic=np.float64(0.1621), pvalue=np.float64(4.8386157177326225e-115), statistic_location=np.float64(0.8310778306583677), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1621), pvalue=np.float64(4.8386157177326225e-115), statistic_location=np.float64(0.8310778306583677), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.7607, -3.1395,  2.1285,  ..., -0.4970, -1.7718,  0.9090]), tensor([ 26.4025,   1.0132,   0.3881,  ...,   1.3932,   1.9517, 166.9749]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.887203271604347e-182) > 0.03
E        +  where np.float64(6.887203271604347e-182) = KstestResult(statistic=np.float64(0.2037), pvalue=np.float64(6.887203271604347e-182), statistic_location=np.float64(1.051189389086634), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2037), pvalue=np.float64(6.887203271604347e-182), statistic_location=np.float64(1.051189389086634), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.9207, -2.9795,  2.2885,  ..., -0.3370, -1.6118,  1.0690]), tensor([ 26.7584,   1.3691,   0.7441,  ...,   1.7492,   2.3076, 167.3308]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.4-0.6-0.9--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.624722874142088e-22) > 0.03
E        +  where np.float64(6.624722874142088e-22) = KstestResult(statistic=np.float64(0.0703), pvalue=np.float64(6.624722874142088e-22), statistic_location=np.float64(0.45198551051534086), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0703), pvalue=np.float64(6.624722874142088e-22), statistic_location=np.float64(0.45198551051534086), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6007, -3.2995,  1.9685,  ..., -0.6570, -1.9318,  0.7490]), tensor([ 2.5949e+01,  5.5924e-01, -6.5839e-02,  ...,  9.3931e-01,\n         1.4977e+00,  1.6652e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.0138484580846585e-97) > 0.03
E        +  where np.float64(1.0138484580846585e-97) = KstestResult(statistic=np.float64(0.1494), pvalue=np.float64(1.0138484580846585e-97), statistic_location=np.float64(0.8054374051853475), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1494), pvalue=np.float64(1.0138484580846585e-97), statistic_location=np.float64(0.8054374051853475), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.8007, -3.0995,  2.1685,  ..., -0.4570, -1.7318,  0.9490]), tensor([ 26.3935,   1.0042,   0.3791,  ...,   1.3843,   1.9427, 166.9659]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(6.887203271604347e-182) > 0.03
E        +  where np.float64(6.887203271604347e-182) = KstestResult(statistic=np.float64(0.2037), pvalue=np.float64(6.887203271604347e-182), statistic_location=np.float64(1.1311893890866338), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2037), pvalue=np.float64(6.887203271604347e-182), statistic_location=np.float64(1.1311893890866338), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0007, -2.8995,  2.3685,  ..., -0.2570, -1.5318,  1.1490]), tensor([ 26.8384,   1.4491,   0.8241,  ...,   1.8292,   2.3876, 167.4108]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.4-0.6-0.9-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.614477799807102e-249) > 0.03
E        +  where np.float64(8.614477799807102e-249) = KstestResult(statistic=np.float64(0.238), pvalue=np.float64(8.614477799807102e-249), statistic_location=np.float64(1.3790170977159022), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.238), pvalue=np.float64(8.614477799807102e-249), statistic_location=np.float64(1.3790170977159022), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.1607, -2.7395,  2.5285,  ..., -0.0970, -1.3718,  1.3090]), tensor([ 27.1944,   1.8051,   1.1800,  ...,   2.1852,   2.7436, 167.7668]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.9--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.5089233709674901e-295) > 0.03
E        +  where np.float64(1.5089233709674901e-295) = KstestResult(statistic=np.float64(0.2592), pvalue=np.float64(1.5089233709674901e-295), statistic_location=np.float64(-1.2106609646606523), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2592), pvalue=np.float64(1.5089233709674901e-295), statistic_location=np.float64(-1.2106609646606523), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.7207, -3.9223,  0.9462,  ..., -1.8558, -3.5904, -0.5233]), tensor([ 23.8719,  -1.7765,  -2.4079,  ...,  -1.3925,  -0.8284, 165.8789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.9--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.275067400004083e-218) > 0.03
E        +  where np.float64(3.275067400004083e-218) = KstestResult(statistic=np.float64(0.223), pvalue=np.float64(3.275067400004083e-218), statistic_location=np.float64(-0.9810665657091633), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.223), pvalue=np.float64(3.275067400004083e-218), statistic_location=np.float64(-0.9810665657091633), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.5207, -3.7223,  1.1462,  ..., -1.6558, -3.3904, -0.3233]), tensor([ 24.2719,  -1.3765,  -2.0079,  ...,  -0.9925,  -0.4284, 166.2789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.2405800391330176e-119) > 0.03
E        +  where np.float64(1.2405800391330176e-119) = KstestResult(statistic=np.float64(0.1653), pvalue=np.float64(1.2405800391330176e-119), statistic_location=np.float64(-0.6240696374882452), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1653), pvalue=np.float64(1.2405800391330176e-119), statistic_location=np.float64(-0.6240696374882452), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2707, -3.4723,  1.3962,  ..., -1.4058, -3.1404, -0.0733]), tensor([ 2.4772e+01, -8.7648e-01, -1.5079e+00,  ..., -4.9253e-01,\n         7.1581e-02,  1.6678e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.593970888802968e-35) > 0.03
E        +  where np.float64(8.593970888802968e-35) = KstestResult(statistic=np.float64(0.0889), pvalue=np.float64(8.593970888802968e-35), statistic_location=np.float64(-0.25879042734034785), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0889), pvalue=np.float64(8.593970888802968e-35), statistic_location=np.float64(-0.25879042734034785), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0207, -3.2223,  1.6462,  ..., -1.1558, -2.8904,  0.1767]), tensor([ 2.5272e+01, -3.7648e-01, -1.0079e+00,  ...,  7.4653e-03,\n         5.7158e-01,  1.6728e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.5--0.9] _____________________

stability = 0.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(3.275067400004083e-218) > 0.03
E        +  where np.float64(3.275067400004083e-218) = KstestResult(statistic=np.float64(0.223), pvalue=np.float64(3.275067400004083e-218), statistic_location=np.float64(-0.9810665657091633), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.223), pvalue=np.float64(3.275067400004083e-218), statistic_location=np.float64(-0.9810665657091633), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.5207, -3.7223,  1.1462,  ..., -1.6558, -3.3904, -0.3233]), tensor([ 24.2719,  -1.3765,  -2.0079,  ...,  -0.9925,  -0.4284, 166.2789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.5--0.5] _____________________

stability = 0.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.0738705257687107e-139) > 0.03
E        +  where np.float64(1.0738705257687107e-139) = KstestResult(statistic=np.float64(0.1786), pvalue=np.float64(1.0738705257687107e-139), statistic_location=np.float64(-0.7389304735745944), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1786), pvalue=np.float64(1.0738705257687107e-139), statistic_location=np.float64(-0.7389304735745944), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.3207, -3.5223,  1.3462,  ..., -1.4558, -3.1904, -0.1233]), tensor([ 2.4672e+01, -9.7648e-01, -1.6079e+00,  ..., -5.9253e-01,\n        -2.8419e-02,  1.6668e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.695741664881546e-49) > 0.03
E        +  where np.float64(1.695741664881546e-49) = KstestResult(statistic=np.float64(0.1062), pvalue=np.float64(1.695741664881546e-49), statistic_location=np.float64(-0.32734718643859145), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1062), pvalue=np.float64(1.695741664881546e-49), statistic_location=np.float64(-0.32734718643859145), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0707, -3.2723,  1.5962,  ..., -1.2058, -2.9404,  0.1267]), tensor([ 2.5172e+01, -4.7648e-01, -1.1079e+00,  ..., -9.2535e-02,\n         4.7158e-01,  1.6718e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5--0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.2049450982809622e-22) > 0.03
E        +  where np.float64(1.2049450982809622e-22) = KstestResult(statistic=np.float64(0.0715), pvalue=np.float64(1.2049450982809622e-22), statistic_location=np.float64(0.3139059267267331), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0715), pvalue=np.float64(1.2049450982809622e-22), statistic_location=np.float64(0.3139059267267331), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.3793, -2.8223,  2.0462,  ..., -0.7558, -2.4904,  0.5767]), tensor([ 26.0719,   0.4235,  -0.2079,  ...,   0.8075,   1.3716, 168.0789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5-0.0--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.2405800391330176e-119) > 0.03
E        +  where np.float64(1.2405800391330176e-119) = KstestResult(statistic=np.float64(0.1653), pvalue=np.float64(1.2405800391330176e-119), statistic_location=np.float64(-0.6240696374882452), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1653), pvalue=np.float64(1.2405800391330176e-119), statistic_location=np.float64(-0.6240696374882452), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.2707, -3.4723,  1.3962,  ..., -1.4058, -3.1404, -0.0733]), tensor([ 2.4772e+01, -8.7648e-01, -1.5079e+00,  ..., -4.9253e-01,\n         7.1581e-02,  1.6678e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5-0.0--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.695741664881546e-49) > 0.03
E        +  where np.float64(1.695741664881546e-49) = KstestResult(statistic=np.float64(0.1062), pvalue=np.float64(1.695741664881546e-49), statistic_location=np.float64(-0.32734718643859145), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1062), pvalue=np.float64(1.695741664881546e-49), statistic_location=np.float64(-0.32734718643859145), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0707, -3.2723,  1.5962,  ..., -1.2058, -2.9404,  0.1267]), tensor([ 2.5172e+01, -4.7648e-01, -1.1079e+00,  ..., -9.2535e-02,\n         4.7158e-01,  1.6718e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.0-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.4309870391417165e-35) > 0.03
E        +  where np.float64(1.4309870391417165e-35) = KstestResult(statistic=np.float64(0.0899), pvalue=np.float64(1.4309870391417165e-35), statistic_location=np.float64(0.40790833993433645), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0899), pvalue=np.float64(1.4309870391417165e-35), statistic_location=np.float64(0.40790833993433645), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.4293, -2.7723,  2.0962,  ..., -0.7058, -2.4404,  0.6267]), tensor([ 2.6172e+01,  5.2352e-01, -1.0794e-01,  ...,  9.0747e-01,\n         1.4716e+00,  1.6818e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.0-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.6593530884621873e-98) > 0.03
E        +  where np.float64(1.6593530884621873e-98) = KstestResult(statistic=np.float64(0.15), pvalue=np.float64(1.6593530884621873e-98), statistic_location=np.float64(0.7370718809367137), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.15), pvalue=np.float64(1.6593530884621873e-98), statistic_location=np.float64(0.7370718809367137), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6293, -2.5723,  2.2962,  ..., -0.5058, -2.2404,  0.8267]), tensor([ 26.5719,   0.9235,   0.2921,  ...,   1.3075,   1.8716, 168.5789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5-0.5--0.9] ______________________

stability = 0.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(8.593970888802968e-35) > 0.03
E        +  where np.float64(8.593970888802968e-35) = KstestResult(statistic=np.float64(0.0889), pvalue=np.float64(8.593970888802968e-35), statistic_location=np.float64(-0.25879042734034785), statistic_sign=np.int8(-1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0889), pvalue=np.float64(8.593970888802968e-35), statistic_location=np.float64(-0.25879042734034785), statistic_sign=np.int8(-1)) = ks_2samp(tensor([-0.0207, -3.2223,  1.6462,  ..., -1.1558, -2.8904,  0.1767]), tensor([ 2.5272e+01, -3.7648e-01, -1.0079e+00,  ...,  7.4653e-03,\n         5.7158e-01,  1.6728e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.5-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.4309870391417165e-35) > 0.03
E        +  where np.float64(1.4309870391417165e-35) = KstestResult(statistic=np.float64(0.0899), pvalue=np.float64(1.4309870391417165e-35), statistic_location=np.float64(0.4079083399343365), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0899), pvalue=np.float64(1.4309870391417165e-35), statistic_location=np.float64(0.4079083399343365), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.4293, -2.7723,  2.0962,  ..., -0.7058, -2.4404,  0.6267]), tensor([ 2.6172e+01,  5.2352e-01, -1.0794e-01,  ...,  9.0747e-01,\n         1.4716e+00,  1.6818e+02]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.5-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.3086969579754585e-116) > 0.03
E        +  where np.float64(1.3086969579754585e-116) = KstestResult(statistic=np.float64(0.1632), pvalue=np.float64(1.3086969579754585e-116), statistic_location=np.float64(0.7847434604123515), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.1632), pvalue=np.float64(1.3086969579754585e-116), statistic_location=np.float64(0.7847434604123515), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6793, -2.5223,  2.3462,  ..., -0.4558, -2.1904,  0.8767]), tensor([ 26.6719,   1.0235,   0.3921,  ...,   1.4075,   1.9716, 168.6789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.5-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(7.224443877895371e-184) > 0.03
E        +  where np.float64(7.224443877895371e-184) = KstestResult(statistic=np.float64(0.2048), pvalue=np.float64(7.224443877895371e-184), statistic_location=np.float64(1.1022549686850986), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2048), pvalue=np.float64(7.224443877895371e-184), statistic_location=np.float64(1.1022549686850986), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.8793, -2.3223,  2.5462,  ..., -0.2558, -1.9904,  1.0767]), tensor([ 27.0719,   1.4235,   0.7921,  ...,   1.8075,   2.3716, 169.0789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.5-0.5-0.5-0.9--0.5] ______________________

stability = 0.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.2049450982809622e-22) > 0.03
E        +  where np.float64(1.2049450982809622e-22) = KstestResult(statistic=np.float64(0.0715), pvalue=np.float64(1.2049450982809622e-22), statistic_location=np.float64(0.313905926726733), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.0715), pvalue=np.float64(1.2049450982809622e-22), statistic_location=np.float64(0.313905926726733), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.3793, -2.8223,  2.0462,  ..., -0.7558, -2.4904,  0.5767]), tensor([ 26.0719,   0.4235,  -0.2079,  ...,   0.8075,   1.3716, 168.0789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.9-0.0] ______________________

stability = 0.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.6593530884621873e-98) > 0.03
E        +  where np.float64(1.6593530884621873e-98) = KstestResult(statistic=np.float64(0.15), pvalue=np.float64(1.6593530884621873e-98), statistic_location=np.float64(0.7370718809367136), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.15), pvalue=np.float64(1.6593530884621873e-98), statistic_location=np.float64(0.7370718809367136), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.6293, -2.5723,  2.2962,  ..., -0.5058, -2.2404,  0.8267]), tensor([ 26.5719,   0.9235,   0.2921,  ...,   1.3075,   1.8716, 168.5789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.9-0.5] ______________________

stability = 0.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(7.224443877895371e-184) > 0.03
E        +  where np.float64(7.224443877895371e-184) = KstestResult(statistic=np.float64(0.2048), pvalue=np.float64(7.224443877895371e-184), statistic_location=np.float64(1.1022549686850986), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2048), pvalue=np.float64(7.224443877895371e-184), statistic_location=np.float64(1.1022549686850986), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 0.8793, -2.3223,  2.5462,  ..., -0.2558, -1.9904,  1.0767]), tensor([ 27.0719,   1.4235,   0.7921,  ...,   1.8075,   2.3716, 169.0789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[0.5-0.5-0.5-0.9-0.9] ______________________

stability = 0.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(1.577975220050545e-247) > 0.03
E        +  where np.float64(1.577975220050545e-247) = KstestResult(statistic=np.float64(0.2374), pvalue=np.float64(1.577975220050545e-247), statistic_location=np.float64(1.2967521924160161), statistic_sign=np.int8(1)).pvalue
E        +    where KstestResult(statistic=np.float64(0.2374), pvalue=np.float64(1.577975220050545e-247), statistic_location=np.float64(1.2967521924160161), statistic_sign=np.int8(1)) = ks_2samp(tensor([ 1.0793, -2.1223,  2.7462,  ..., -0.0558, -1.7904,  1.2767]), tensor([ 27.4719,   1.8235,   1.1921,  ...,   2.2075,   2.7716, 169.4789]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.1-0.9--0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.2549]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.1-0.9--0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -53.7086]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.9-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -50.5258]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.9-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -47.3430]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.9-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -44.7967]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.1-0.9--0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.3385]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.1-0.9--0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -30.7922]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.5-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -27.6094]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.5-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -24.4265]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9--0.5-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -21.8803]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.0--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -4.6930]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.0--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -2.1467]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.0-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.0362]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.0-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 4.2190]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.0-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 6.7653]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 23.9526]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 26.4989]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.5-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.6817]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.5-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.8645]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.5-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.4108]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 46.8690]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 49.4153]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.9-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 52.5981]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.9-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 55.7810]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.1-0.9-0.9-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 58.3272]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.2-0.8--0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.3518]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.2-0.8--0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -51.2593]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.9-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -44.8936]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.9-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -38.5280]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.9-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.4354]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.2-0.8--0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -35.9817]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.2-0.8--0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -30.8892]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.5-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -24.5235]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.5-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -18.1578]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8--0.5-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -13.0653]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.0--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -10.5190]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.0--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -5.4265]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.0-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.9392]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.0-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 7.3049]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.0-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 12.3974]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 14.9437]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 20.0362]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.5-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 26.4019]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.5-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.7676]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.5-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 37.8601]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.3139]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 40.4064]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.9-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 46.7721]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.9-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 53.1377]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.2-0.8-0.9-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 58.2303]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.4-0.6--0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.5457]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.4-0.6--0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -46.3606]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.9-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.6293]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.9-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -20.8979]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.9-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -10.7129]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.4-0.6--0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -41.2681]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.4-0.6--0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -31.0830]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.5-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -18.3517]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.5-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -5.6203]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6--0.5-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 4.5648]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.0--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -22.1711]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.0--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -11.9860]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.0-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.7453]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.0-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.4767]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.0-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 23.6618]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -3.0741]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 7.1110]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.5-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 19.8424]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.5-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.5737]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.5-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 42.7588]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 12.2036]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 22.3886]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.9-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.1200]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.9-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 47.8513]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.4-0.6-0.9-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 58.0364]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.5-0.5--0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.6427]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.5-0.5--0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -43.9113]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.9-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -27.9971]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.9-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -12.0829]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.9-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6484]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.5-0.5--0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -43.9113]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[0.99-0.5-0.5--0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -31.1800]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.5-0.0] _____________________

stability = 0.99, skew0 = 0.0, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -15.2658]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.5-0.5] _____________________

stability = 0.99, skew0 = 0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6484]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5--0.5-0.9] _____________________

stability = 0.99, skew0 = 0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.3798]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.0--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -27.9971]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.0--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -15.2658]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.0-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6484]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.0-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 16.5626]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.0-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.2939]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.5--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -12.0829]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.5--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6484]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.5-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 16.5626]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.5-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.4768]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.5-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 45.2081]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.9--0.9] _____________________

stability = 0.99, skew0 = -0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6484]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.9--0.5] _____________________

stability = 0.99, skew0 = -0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.3798]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.9-0.0] ______________________

stability = 0.99, skew0 = 0.0, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.2939]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.9-0.5] ______________________

stability = 0.99, skew0 = 0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 45.2081]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[0.99-0.5-0.5-0.9-0.9] ______________________

stability = 0.99, skew0 = 0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 57.9395]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.1-0.9--0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 58.2165]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.1-0.9--0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 55.6702]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.9-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 52.4873]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.9-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 49.3045]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.9-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 46.7582]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.1-0.9--0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.3000]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.1-0.9--0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.7538]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.5-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.5709]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.5-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 26.3881]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9--0.5-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 23.8418]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.0--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 6.6545]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.0--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 4.1082]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.0-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.9254]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.0-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -2.2575]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.0-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -4.8037]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -21.9910]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -24.5373]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.5-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -27.7201]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.5-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -30.9030]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.5-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.4493]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -44.9075]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -47.4537]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.9-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -50.6366]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.9-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -53.8194]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.1-0.9-0.9-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.3657]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.2-0.8--0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 58.1178]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.2-0.8--0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 53.0252]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.9-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 46.6596]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.9-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 40.2939]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.9-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.2013]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.2-0.8--0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 37.7476]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.2-0.8--0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.6551]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.5-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 26.2894]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.5-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 19.9237]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8--0.5-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 14.8312]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.0--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 12.2849]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.0--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 7.1924]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.0-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.8267]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.0-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -5.5390]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.0-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -10.6315]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -13.1778]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -18.2703]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.5-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -24.6360]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.5-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -31.0017]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.5-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -36.0942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.5479]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -38.6405]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.9-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -45.0062]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.9-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -51.3718]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.2-0.8-0.9-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.4644]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.4-0.6--0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 57.9204]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.4-0.6--0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 47.7353]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.9-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 35.0040]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.9-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 22.2726]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.9-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 12.0875]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.4-0.6--0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 42.6428]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.4-0.6--0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.4577]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.5-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 19.7263]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.5-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 6.9950]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6--0.5-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -3.1901]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.0--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 23.5458]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.0--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.3607]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.0-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.6293]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.0-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -12.1020]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.0-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -22.2871]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 4.4487]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, -5.7364]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.5-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -18.4677]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.5-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -31.1990]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.5-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -41.3841]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -10.8289]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -21.0140]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.9-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -33.7453]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.9-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -46.4767]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.4-0.6-0.9-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.6617]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.5-0.5--0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 57.8217]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.5-0.5--0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 45.0904]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.9-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.1762]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.9-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.2620]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.9-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.5306]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.5-0.5--0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 45.0904]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
____________________ test_additive[1.01-0.5-0.5--0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 32.3590]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.5-0.0] _____________________

stability = 1.01, skew0 = 0.0, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 16.4448]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.5-0.5] _____________________

stability = 1.01, skew0 = 0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.5306]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5--0.5-0.9] _____________________

stability = 1.01, skew0 = 0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -12.2007]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.0--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 29.1762]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.0--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 16.4448]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.0-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.5306]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.0-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -15.3835]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.0-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -28.1149]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.5--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([    nan,     nan,     nan,  ...,     nan,     nan, 13.2620]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.5--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.5306]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.5-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -15.3835]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.5-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -31.2977]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.5-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -44.0291]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.9--0.9] _____________________

stability = 1.01, skew0 = -0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 0.5306]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.9--0.5] _____________________

stability = 1.01, skew0 = -0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -12.2007]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.9-0.0] ______________________

stability = 1.01, skew0 = 0.0, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -28.1149]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.9-0.5] ______________________

stability = 1.01, skew0 = 0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -44.0291]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.01-0.5-0.5-0.9-0.9] ______________________

stability = 1.01, skew0 = 0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([     nan,      nan,      nan,  ...,      nan,      nan, -56.7604]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.9--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.9--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.5--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.5--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9--0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.0--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.0--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.0-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.0-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.0-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.5--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.5--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.9--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.1-0.9-0.9--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.1-0.9-0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.9--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.9--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.5--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.5--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8--0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.0--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.0--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.0-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.0-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.0-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.5--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.5--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.9--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.2-0.8-0.9--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.2-0.8-0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.9--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.9--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.5--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.5--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6--0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.0--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.0--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.0-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.0-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.0-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.5--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.5--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.9--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.4-0.6-0.9--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.4-0.6-0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.9--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.9--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.5--0.9] _____________________

stability = 1.5, skew0 = -0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.5--0.5] _____________________

stability = 1.5, skew0 = -0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5--0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.0--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.0--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.0-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.0-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.0-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.5--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.5--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.5-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.5-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.5-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.9--0.9] ______________________

stability = 1.5, skew0 = -0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.5-0.5-0.5-0.9--0.5] ______________________

stability = 1.5, skew0 = -0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.9-0.0] ______________________

stability = 1.5, skew0 = 0.0, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.9-0.5] ______________________

stability = 1.5, skew0 = 0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.5-0.5-0.5-0.9-0.9] ______________________

stability = 1.5, skew0 = 0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([nan, nan, nan,  ..., nan, nan, nan]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.9--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4970]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.9--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4906]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4827]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4748]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4684]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.5--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4399]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.5--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4336]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4257]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4178]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9--0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.4114]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.0--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.3687]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.0--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.3623]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.0-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.3544]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.0-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.3465]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.0-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.0, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.3402]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.5--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2974]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.5--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2911]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2831]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2752]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.5, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2689]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.9--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2404]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.1-0.9-0.9--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2340]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2261]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2182]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.1-0.9-0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.9, scale0 = 0.1, scale1 = 0.9

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2119]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.9--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2819]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.9--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2692]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2534]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2376]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2249]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.5--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2312]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.5--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2186]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.2027]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1869]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8--0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1742]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.0--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1679]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.0--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1552]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.0-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1394]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.0-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1235]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.0-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.0, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1109]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.5--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.1045]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.5--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0918]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0760]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0602]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.5, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0475]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.9--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0538]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.2-0.8-0.9--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0412]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0253]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 2.0095]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.2-0.8-0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.9, scale0 = 0.2, scale1 = 0.8

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.9968]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.9--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.8518]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.9--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.8265]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7948]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7631]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7378]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.5--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.8138]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.5--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7885]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7568]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7251]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6--0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6998]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.0--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7663]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.0--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7410]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.0-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7093]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.0-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6776]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.0-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.0, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6523]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.5--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.7188]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.5--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6934]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6618]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6301]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.5, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6048]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.9--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6808]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.4-0.6-0.9--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6554]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6238]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5921]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.4-0.6-0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.9, scale0 = 0.4, scale1 = 0.6

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5667]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.9--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6368]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.9--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6051]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5655]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5259]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.5--0.9] _____________________

stability = 1.9, skew0 = -0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.6051]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.5--0.5] _____________________

stability = 1.9, skew0 = -0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5734]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5338]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5--0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = -0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4626]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.0--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5655]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.0--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5338]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.0-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.0-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4546]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.0-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.0, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4230]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.5--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.5259]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.5--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.5-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4546]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.5-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4151]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.5-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.5, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.3834]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.9--0.9] ______________________

stability = 1.9, skew0 = -0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4942]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
_____________________ test_additive[1.9-0.5-0.5-0.9--0.5] ______________________

stability = 1.9, skew0 = -0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4626]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.9-0.0] ______________________

stability = 1.9, skew0 = 0.0, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.4230]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.9-0.5] ______________________

stability = 1.9, skew0 = 0.5, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.3834]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
______________________ test_additive[1.9-0.5-0.5-0.9-0.9] ______________________

stability = 1.9, skew0 = 0.9, skew1 = 0.9, scale0 = 0.5, scale1 = 0.5

    @pytest.mark.parametrize("skew0", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("skew1", [-0.9, -0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize(
        "scale0,scale1", [(0.1, 0.9), (0.2, 0.8), (0.4, 0.6), (0.5, 0.5)]
    )
    @pytest.mark.parametrize("stability", [0.5, 0.99, 1.01, 1.5, 1.9])
    def test_additive(stability, skew0, skew1, scale0, scale1):
        num_samples = 10000
        d0 = dist.Stable(stability, skew0, scale0, coords="S")
        d1 = dist.Stable(stability, skew1, scale1, coords="S")
        expected = d0.sample([num_samples]) + d1.sample([num_samples])
    
        scale = (scale0**stability + scale1**stability) ** (1 / stability)
        skew = (skew0 * scale0**stability + skew1 * scale1**stability) / (
            scale0**stability + scale1**stability
        )
        d = dist.Stable(stability, skew, scale, coords="S")
        actual = d.sample([num_samples])
    
>       assert ks_2samp(expected, actual).pvalue > 0.03
E       assert np.float64(nan) > 0.03
E        +  where np.float64(nan) = KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)).pvalue
E        +    where KstestResult(statistic=np.float64(nan), pvalue=np.float64(nan), statistic_location=np.float64(nan), statistic_sign=np.float64(nan)) = ks_2samp(tensor([   nan,    nan,    nan,  ...,    nan,    nan, 1.3517]), tensor([nan, nan, nan,  ..., nan, nan, nan]))

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:126: AssertionError
__________________________ test_mean[S0-1.7--0.5-0.5] __________________________

stability = 1.7, skew = -0.5, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7--0.5-1.5] __________________________

stability = 1.7, skew = -0.5, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.0-0.5] ___________________________

stability = 1.7, skew = 0.0, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.0-1.5] ___________________________

stability = 1.7, skew = 0.0, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.5-0.5] ___________________________

stability = 1.7, skew = 0.5, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.5-1.5] ___________________________

stability = 1.7, skew = 0.5, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.9-0.5] ___________________________

stability = 1.7, skew = 0.9, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-1.7-0.9-1.5] ___________________________

stability = 1.7, skew = 0.9, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0--0.5-0.5] __________________________

stability = 2.0, skew = -0.5, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0--0.5-1.5] __________________________

stability = 2.0, skew = -0.5, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.0-0.5] ___________________________

stability = 2.0, skew = 0.0, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.0-1.5] ___________________________

stability = 2.0, skew = 0.0, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.5-0.5] ___________________________

stability = 2.0, skew = 0.5, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.5-1.5] ___________________________

stability = 2.0, skew = 0.5, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.9-0.5] ___________________________

stability = 2.0, skew = 0.9, scale = 0.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S0-2.0-0.9-1.5] ___________________________

stability = 2.0, skew = 0.9, scale = 1.5, coords = 'S0'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S-1.7--0.5-0.5] ___________________________

stability = 1.7, skew = -0.5, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S-1.7--0.5-1.5] ___________________________

stability = 1.7, skew = -0.5, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.0-0.5] ___________________________

stability = 1.7, skew = 0.0, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.0-1.5] ___________________________

stability = 1.7, skew = 0.0, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.5-0.5] ___________________________

stability = 1.7, skew = 0.5, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.5-1.5] ___________________________

stability = 1.7, skew = 0.5, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.9-0.5] ___________________________

stability = 1.7, skew = 0.9, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-1.7-0.9-1.5] ___________________________

stability = 1.7, skew = 0.9, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S-2.0--0.5-0.5] ___________________________

stability = 2.0, skew = -0.5, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
__________________________ test_mean[S-2.0--0.5-1.5] ___________________________

stability = 2.0, skew = -0.5, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.0-0.5] ___________________________

stability = 2.0, skew = 0.0, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.0-1.5] ___________________________

stability = 2.0, skew = 0.0, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.5-0.5] ___________________________

stability = 2.0, skew = 0.5, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.5-1.5] ___________________________

stability = 2.0, skew = 0.5, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.9-0.5] ___________________________

stability = 2.0, skew = 0.9, scale = 0.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
___________________________ test_mean[S-2.0-0.9-1.5] ___________________________

stability = 2.0, skew = 0.9, scale = 1.5, coords = 'S'

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("skew", [-0.5, 0.0, 0.5, 0.9])
    @pytest.mark.parametrize("stability", [0.5, 1.0, 1.7, 2.0])
    @pytest.mark.parametrize("coords", ["S0", "S"])
    def test_mean(stability, skew, scale, coords):
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc, coords=coords)
        if stability <= 1:
            assert torch.isnan(d.mean).all()
        else:
>           expected = d.sample((100000,)).mean(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________________ test_variance[2.0-0.5] ____________________________

stability = 2.0, scale = 0.5

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("stability", [1.7, 2.0])
    def test_variance(stability, scale):
        skew = dist.Uniform(-1, 1).sample((10,))
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc)
        if stability < 2:
            assert torch.isinf(d.variance).all()
        else:
>           expected = d.sample((100000,)).var(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
____________________________ test_variance[2.0-1.5] ____________________________

stability = 2.0, scale = 1.5

    @pytest.mark.parametrize("scale", [0.5, 1.5])
    @pytest.mark.parametrize("stability", [1.7, 2.0])
    def test_variance(stability, scale):
        skew = dist.Uniform(-1, 1).sample((10,))
        loc = torch.randn(10)
        d = dist.Stable(stability, skew, scale, loc)
        if stability < 2:
            assert torch.isinf(d.variance).all()
        else:
>           expected = d.sample((100000,)).var(0)

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/distributions/distribution.py:167: in sample
    return self.rsample(sample_shape)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:163: in rsample
    x = _standard_stable(self.stability, self.skew, aux_uniform, aux_exponential, coords=self.coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/stable.py:29: in _standard_stable
    return _standard_stable(alpha, beta, aux_uniform, aux_exponential, coords)
/local/data0/moved_data/publishablew/pyro/pyro/pyro/distributions/temp.py:18: in _standard_stable
    if torch.abs(alpha - 1) < RADIUS:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils._device.DeviceContext object at 0x72e49b052910>
func = <method '__bool__' of 'torch._C.TensorBase' objects>
types = (<class 'torch.Tensor'>,)
args = (tensor([False, False, False, False, False, False, False, False, False, False]),)
kwargs = {}

    def __torch_function__(self, func, types, args=(), kwargs=None):
        kwargs = kwargs or {}
        if func in _device_constructors() and kwargs.get('device') is None:
            kwargs['device'] = self.device
>       return func(*args, **kwargs)
E       RuntimeError: Boolean value of Tensor with more than one value is ambiguous

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/torch/utils/_device.py:106: RuntimeError
=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8
  /local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8: DeprecationWarning: Please import `IntegrationWarning` from the `scipy.integrate` namespace; the `scipy.integrate.quadpack` namespace is deprecated and will be removed in SciPy 2.0.0.
    from scipy.integrate.quadpack import IntegrationWarning

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5]
================== 630 failed, 57 passed, 1 warning in 11.08s ==================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pyro/pyro/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/pyro/pyro
configfile: setup.cfg
plugins: typeguard-4.4.1, jaxtyping-0.2.19
collecting ... collected 687 items

../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5] PASSED

=================================== FAILURES ===================================
____________________________ test_sample[0.1--1.0] _____________________________

alpha = 0.1, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c15d4e00>],
      dtype=object)
args = (array(0.1), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.1--0.5] _____________________________

alpha = 0.1, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c33bbce0>],
      dtype=object)
args = (array(0.1), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.0] _____________________________

alpha = 0.1, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c2904040>],
      dtype=object)
args = (array(0.1), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.5] _____________________________

alpha = 0.1, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b03600>],
      dtype=object)
args = (array(0.1), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-1.0] _____________________________

alpha = 0.1, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c2904040>],
      dtype=object)
args = (array(0.1), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--1.0] _____________________________

alpha = 0.4, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c33bbce0>],
      dtype=object)
args = (array(0.4), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--0.5] _____________________________

alpha = 0.4, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c29040e0>],
      dtype=object)
args = (array(0.4), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.0] _____________________________

alpha = 0.4, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b034c0>],
      dtype=object)
args = (array(0.4), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.5] _____________________________

alpha = 0.4, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c2904040>],
      dtype=object)
args = (array(0.4), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-1.0] _____________________________

alpha = 0.4, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b03880>],
      dtype=object)
args = (array(0.4), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--1.0] _____________________________

alpha = 0.8, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b03420>],
      dtype=object)
args = (array(0.8), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--0.5] _____________________________

alpha = 0.8, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b036a0>],
      dtype=object)
args = (array(0.8), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.0] _____________________________

alpha = 0.8, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b03ec0>],
      dtype=object)
args = (array(0.8), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.5] _____________________________

alpha = 0.8, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9d9e0>],
      dtype=object)
args = (array(0.8), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-1.0] _____________________________

alpha = 0.8, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9dbc0>],
      dtype=object)
args = (array(0.8), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--1.0] ____________________________

alpha = 0.99, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9c5e0>],
      dtype=object)
args = (array(0.99), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--0.5] ____________________________

alpha = 0.99, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9c0b03ec0>],
      dtype=object)
args = (array(0.99), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.0] _____________________________

alpha = 0.99, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9d9e0>],
      dtype=object)
args = (array(0.99), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.5] _____________________________

alpha = 0.99, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9dc60>],
      dtype=object)
args = (array(0.99), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-1.0] _____________________________

alpha = 0.99, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9d8a0>],
      dtype=object)
args = (array(0.99), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.0--1.0] _____________________________

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.0--0.5] _____________________________

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.0] _____________________________

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.5] _____________________________

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-1.0] _____________________________

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.01--1.0] ____________________________

alpha = 1.01, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9fb00>],
      dtype=object)
args = (array(1.01), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01--0.5] ____________________________

alpha = 1.01, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9ef20>],
      dtype=object)
args = (array(1.01), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.0] _____________________________

alpha = 1.01, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9fba0>],
      dtype=object)
args = (array(1.01), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.5] _____________________________

alpha = 1.01, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9ff60>],
      dtype=object)
args = (array(1.01), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-1.0] _____________________________

alpha = 1.01, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd53a0>],
      dtype=object)
args = (array(1.01), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--1.0] _____________________________

alpha = 1.3, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9d940>],
      dtype=object)
args = (array(1.3), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--0.5] _____________________________

alpha = 1.3, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd5da0>],
      dtype=object)
args = (array(1.3), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.0] _____________________________

alpha = 1.3, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd5940>],
      dtype=object)
args = (array(1.3), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.5] _____________________________

alpha = 1.3, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bed9f380>],
      dtype=object)
args = (array(1.3), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-1.0] _____________________________

alpha = 1.3, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd6020>],
      dtype=object)
args = (array(1.3), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--1.0] _____________________________

alpha = 1.7, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd4a40>],
      dtype=object)
args = (array(1.7), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--0.5] _____________________________

alpha = 1.7, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd4e00>],
      dtype=object)
args = (array(1.7), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.0] _____________________________

alpha = 1.7, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd6980>],
      dtype=object)
args = (array(1.7), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.5] _____________________________

alpha = 1.7, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd6200>],
      dtype=object)
args = (array(1.7), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-1.0] _____________________________

alpha = 1.7, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd6fc0>],
      dtype=object)
args = (array(1.7), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--1.0] _____________________________

alpha = 2.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd72e0>],
      dtype=object)
args = (array(2.), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--0.5] _____________________________

alpha = 2.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd68e0>],
      dtype=object)
args = (array(2.), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.0] _____________________________

alpha = 2.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd7b00>],
      dtype=object)
args = (array(2.), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.5] _____________________________

alpha = 2.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd7f60>],
      dtype=object)
args = (array(2.), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-1.0] _____________________________

alpha = 2.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x79da34928b50>
x = array([<function test_sample.<locals>.sampler at 0x79d9bcbd4ea0>],
      dtype=object)
args = (array(2.), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8
  /local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8: DeprecationWarning: Please import `IntegrationWarning` from the `scipy.integrate` namespace; the `scipy.integrate.quadpack` namespace is deprecated and will be removed in SciPy 2.0.0.
    from scipy.integrate.quadpack import IntegrationWarning

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0]
================== 45 failed, 642 passed, 1 warning in 10.37s ==================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pyro/pyro/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/pyro/pyro
configfile: setup.cfg
plugins: typeguard-4.4.1, jaxtyping-0.2.19
collecting ... collected 687 items

../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape0-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape1-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_shape[batch_shape2-sample_shape2] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0] FAILED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.1-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.4-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.8-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.99-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[0.999999-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.000001-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.01-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.3-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[1.7-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample_2[2.0-1.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[0.5-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[1-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2--1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_normal[2-2_1] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.5-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[0.99-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.01-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.5-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.1-0.9-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.2-0.8-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.4-0.6-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5--0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.0-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.5-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9--0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.0] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_additive[1.9-0.5-0.5-0.9-0.9] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-1.7-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S0-2.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-0.5-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-1.7-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0--0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.0-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.5-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_mean[S-2.0-0.9-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[1.7-1.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-0.5] PASSED
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_variance[2.0-1.5] PASSED

=================================== FAILURES ===================================
____________________________ test_sample[0.1--1.0] _____________________________

alpha = 0.1, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29c8e00>],
      dtype=object)
args = (array(0.1), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.1--0.5] _____________________________

alpha = 0.1, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47b3ce0>],
      dtype=object)
args = (array(0.1), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.0] _____________________________

alpha = 0.1, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47f4040>],
      dtype=object)
args = (array(0.1), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-0.5] _____________________________

alpha = 0.1, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29ef600>],
      dtype=object)
args = (array(0.1), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.1-1.0] _____________________________

alpha = 0.1, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47f4040>],
      dtype=object)
args = (array(0.1), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--1.0] _____________________________

alpha = 0.4, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47b3ce0>],
      dtype=object)
args = (array(0.4), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.4--0.5] _____________________________

alpha = 0.4, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47f40e0>],
      dtype=object)
args = (array(0.4), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.0] _____________________________

alpha = 0.4, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29ef4c0>],
      dtype=object)
args = (array(0.4), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-0.5] _____________________________

alpha = 0.4, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb47f4040>],
      dtype=object)
args = (array(0.4), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.4-1.0] _____________________________

alpha = 0.4, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29ef880>],
      dtype=object)
args = (array(0.4), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--1.0] _____________________________

alpha = 0.8, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29ef420>],
      dtype=object)
args = (array(0.8), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.8--0.5] _____________________________

alpha = 0.8, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29ef6a0>],
      dtype=object)
args = (array(0.8), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.0] _____________________________

alpha = 0.8, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29efec0>],
      dtype=object)
args = (array(0.8), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-0.5] _____________________________

alpha = 0.8, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015d9e0>],
      dtype=object)
args = (array(0.8), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[0.8-1.0] _____________________________

alpha = 0.8, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015dbc0>],
      dtype=object)
args = (array(0.8), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--1.0] ____________________________

alpha = 0.99, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015c5e0>],
      dtype=object)
args = (array(0.99), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99--0.5] ____________________________

alpha = 0.99, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb29efec0>],
      dtype=object)
args = (array(0.99), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.0] _____________________________

alpha = 0.99, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015d9e0>],
      dtype=object)
args = (array(0.99), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-0.5] _____________________________

alpha = 0.99, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015dc60>],
      dtype=object)
args = (array(0.99), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[0.99-1.0] _____________________________

alpha = 0.99, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015d8a0>],
      dtype=object)
args = (array(0.99), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.0--1.0] _____________________________

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.0--0.5] _____________________________

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, -0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.0] _____________________________

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-0.5] _____________________________

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 0.5]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
_____________________________ test_sample[1.0-1.0] _____________________________

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
>               consolidated = ar.view(dtype)

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

oldtype = dtype('O'), newtype = dtype([('f0', 'O'), ('f1', 'O')])

    def _view_is_safe(oldtype, newtype):
        """ Checks safety of a view involving object arrays, for example when
        doing::
    
            np.zeros(10, dtype=oldtype).view(newtype)
    
        Parameters
        ----------
        oldtype : data-type
            Data type of original ndarray
        newtype : data-type
            Data type of the view
    
        Raises
        ------
        TypeError
            If the new type is incompatible with the old type.
    
        """
    
        # if the types are equivalent, there is no problem.
        # for example: dtype((np.record, 'i4,i4')) == dtype((np.void, 'i4,i4'))
        if oldtype == newtype:
            return
    
        if newtype.hasobject or oldtype.hasobject:
>           raise TypeError("Cannot change data-type for array of references.")
E           TypeError: Cannot change data-type for array of references.

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/_core/_internal.py:564: TypeError

The above exception was the direct cause of the following exception:

alpha = 1.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1031: in cdf
    uniq_param_pairs = np.unique(data_in[:, 1:], axis=0)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

ar = array([[1.0, 1.0]], dtype=object), return_index = False
return_inverse = False, return_counts = False, axis = 0

    @array_function_dispatch(_unique_dispatcher)
    def unique(ar, return_index=False, return_inverse=False,
               return_counts=False, axis=None, *, equal_nan=True):
        """
        Find the unique elements of an array.
    
        Returns the sorted unique elements of an array. There are three optional
        outputs in addition to the unique elements:
    
        * the indices of the input array that give the unique values
        * the indices of the unique array that reconstruct the input array
        * the number of times each unique value comes up in the input array
    
        Parameters
        ----------
        ar : array_like
            Input array. Unless `axis` is specified, this will be flattened if it
            is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` (along the specified axis,
            if provided, or in the flattened array) that result in the unique array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array (for the specified
            axis, if provided) that can be used to reconstruct `ar`.
        return_counts : bool, optional
            If True, also return the number of times each unique item appears
            in `ar`.
        axis : int or None, optional
            The axis to operate on. If None, `ar` will be flattened. If an integer,
            the subarrays indexed by the given axis will be flattened and treated
            as the elements of a 1-D array with the dimension of the given axis,
            see the notes for more details.  Object arrays or structured arrays
            that contain objects are not supported if the `axis` kwarg is used. The
            default is None.
    
            .. versionadded:: 1.13.0
    
        equal_nan : bool, optional
            If True, collapses multiple NaN values in the return array into one.
    
            .. versionadded:: 1.24
    
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the first occurrences of the unique values in the
            original array. Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the original array from the
            unique array. Only provided if `return_inverse` is True.
        unique_counts : ndarray, optional
            The number of times each of the unique values comes up in the
            original array. Only provided if `return_counts` is True.
    
            .. versionadded:: 1.9.0
    
        See Also
        --------
        repeat : Repeat elements of an array.
    
        Notes
        -----
        When an axis is specified the subarrays indexed by the axis are sorted.
        This is done by making the specified axis the first dimension of the array
        (move the axis to the first dimension to keep the order of the other axes)
        and then flattening the subarrays in C order. The flattened subarrays are
        then viewed as a structured type with each element given a label, with the
        effect that we end up with a 1-D array of structured types that can be
        treated in the same way as any other 1-D array. The result is that the
        flattened subarrays are sorted in lexicographic order starting with the
        first element.
    
        .. versionchanged: 1.21
            If nan values are in the input array, a single nan is put
            to the end of the sorted unique values.
    
            Also for complex arrays all NaN values are considered equivalent
            (no matter whether the NaN is in the real or imaginary part).
            As the representant for the returned array the smallest one in the
            lexicographical order is chosen - see np.sort for how the lexicographical
            order is defined for complex arrays.
    
        .. versionchanged: 2.0
            For multi-dimensional inputs, ``unique_inverse`` is reshaped
            such that the input can be reconstructed using
            ``np.take(unique, unique_inverse, axis=axis)``. The result is
            now not 1-dimensional when ``axis=None``.
    
            Note that in NumPy 2.0.0 a higher dimensional array was returned also
            when ``axis`` was not ``None``.  This was reverted, but
            ``inverse.reshape(-1)`` can be used to ensure compatibility with both
            versions.
    
        Examples
        --------
        >>> import numpy as np
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
    
        Return the unique rows of a 2D array
    
        >>> a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])
        >>> np.unique(a, axis=0)
        array([[1, 0, 0], [2, 3, 4]])
    
        Return the indices of the original array that give the unique values:
    
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'], dtype='<U1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'], dtype='<U1')
    
        Reconstruct the input array from the unique values and inverse:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
        Reconstruct the input values from the unique values and counts:
    
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> values, counts = np.unique(a, return_counts=True)
        >>> values
        array([1, 2, 3, 4, 6])
        >>> counts
        array([1, 3, 1, 1, 1])
        >>> np.repeat(values, counts)
        array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved
    
        """
        ar = np.asanyarray(ar)
        if axis is None:
            ret = _unique1d(ar, return_index, return_inverse, return_counts,
                            equal_nan=equal_nan, inverse_shape=ar.shape, axis=None)
            return _unpack_tuple(ret)
    
        # axis was specified and not None
        try:
            ar = np.moveaxis(ar, axis, 0)
        except np.exceptions.AxisError:
            # this removes the "axis1" or "axis2" prefix from the error message
            raise np.exceptions.AxisError(axis, ar.ndim) from None
        inverse_shape = [1] * ar.ndim
        inverse_shape[axis] = ar.shape[0]
    
        # Must reshape to a contiguous 2D array for this to work...
        orig_shape, orig_dtype = ar.shape, ar.dtype
        ar = ar.reshape(orig_shape[0], np.prod(orig_shape[1:], dtype=np.intp))
        ar = np.ascontiguousarray(ar)
        dtype = [('f{i}'.format(i=i), ar.dtype) for i in range(ar.shape[1])]
    
        # At this point, `ar` has shape `(n, m)`, and `dtype` is a structured
        # data type with `m` fields where each field has the data type of `ar`.
        # In the following, we create the array `consolidated`, which has
        # shape `(n,)` with data type `dtype`.
        try:
            if ar.shape[1] > 0:
                consolidated = ar.view(dtype)
            else:
                # If ar.shape[1] == 0, then dtype will be `np.dtype([])`, which is
                # a data type with itemsize 0, and the call `ar.view(dtype)` will
                # fail.  Instead, we'll use `np.empty` to explicitly create the
                # array with shape `(len(ar),)`.  Because `dtype` in this case has
                # itemsize 0, the total size of the result is still 0 bytes.
                consolidated = np.empty(len(ar), dtype=dtype)
        except TypeError as e:
            # There's no good way to do this for object arrays, etc...
            msg = 'The axis argument to unique is not supported for dtype {dt}'
>           raise TypeError(msg.format(dt=ar.dtype)) from e
E           TypeError: The axis argument to unique is not supported for dtype object

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/numpy/lib/_arraysetops_impl.py:327: TypeError
____________________________ test_sample[1.01--1.0] ____________________________

alpha = 1.01, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015fb00>],
      dtype=object)
args = (array(1.01), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01--0.5] ____________________________

alpha = 1.01, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015ef20>],
      dtype=object)
args = (array(1.01), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.0] _____________________________

alpha = 1.01, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015fba0>],
      dtype=object)
args = (array(1.01), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-0.5] _____________________________

alpha = 1.01, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015ff60>],
      dtype=object)
args = (array(1.01), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.01-1.0] _____________________________

alpha = 1.01, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a53a0>],
      dtype=object)
args = (array(1.01), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--1.0] _____________________________

alpha = 1.3, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015d940>],
      dtype=object)
args = (array(1.3), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.3--0.5] _____________________________

alpha = 1.3, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a5da0>],
      dtype=object)
args = (array(1.3), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.0] _____________________________

alpha = 1.3, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a5940>],
      dtype=object)
args = (array(1.3), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-0.5] _____________________________

alpha = 1.3, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfb015f380>],
      dtype=object)
args = (array(1.3), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.3-1.0] _____________________________

alpha = 1.3, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a6020>],
      dtype=object)
args = (array(1.3), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--1.0] _____________________________

alpha = 1.7, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a4a40>],
      dtype=object)
args = (array(1.7), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[1.7--0.5] _____________________________

alpha = 1.7, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a4e00>],
      dtype=object)
args = (array(1.7), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.0] _____________________________

alpha = 1.7, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a6980>],
      dtype=object)
args = (array(1.7), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-0.5] _____________________________

alpha = 1.7, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a6200>],
      dtype=object)
args = (array(1.7), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[1.7-1.0] _____________________________

alpha = 1.7, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a6fc0>],
      dtype=object)
args = (array(1.7), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--1.0] _____________________________

alpha = 2.0, beta = -1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a72e0>],
      dtype=object)
args = (array(2.), array(-1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
____________________________ test_sample[2.0--0.5] _____________________________

alpha = 2.0, beta = -0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a68e0>],
      dtype=object)
args = (array(2.), array(-0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.0] _____________________________

alpha = 2.0, beta = 0.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a7b00>],
      dtype=object)
args = (array(2.), array(0.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-0.5] _____________________________

alpha = 2.0, beta = 0.5

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a7f60>],
      dtype=object)
args = (array(2.), array(0.5)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
_____________________________ test_sample[2.0-1.0] _____________________________

alpha = 2.0, beta = 1.0

    @pytest.mark.parametrize("beta", [-1.0, -0.5, 0.0, 0.5, 1.0])
    @pytest.mark.parametrize("alpha", [0.1, 0.4, 0.8, 0.99, 1.0, 1.01, 1.3, 1.7, 2.0])
    def test_sample(alpha, beta):
        num_samples = 100
        d = dist.Stable(alpha, beta, coords="S")
    
        def sampler(size):
            # Temporarily increase radius to test hole-patching logic.
            # Scipy doesn't handle values of alpha very close to 1.
            try:
                old = pyro.distributions.stable.RADIUS
                pyro.distributions.stable.RADIUS = 0.02
                return d.sample([size])
            finally:
                pyro.distributions.stable.RADIUS = old
    
        def cdf(x):
            with warnings.catch_warnings(record=True) as w:
                warnings.simplefilter("always", category=IntegrationWarning)
                result = levy_stable.cdf(x, alpha, beta)
            # Scipy has only an experimental .cdf() function for alpha=1, beta!=0.
            # It sometimes passes and sometimes xfails.
            if w and alpha == 1 and beta != 0:
                pytest.xfail(reason="scipy.stats.levy_stable.cdf is unstable")
            return result
    
>       assert kstest(sampler, cdf, N=num_samples).pvalue > 0.1

/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:586: in axis_nan_policy_wrapper
    res = hypotest_fun_out(*samples, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:8389: in kstest
    return ks_1samp(xvals, cdf, args=args, alternative=alternative,
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_axis_nan_policy.py:430: in axis_nan_policy_wrapper
    return hypotest_fun_in(*args, **kwds)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/_lib/_util.py:1020: in wrapper
    return fun(*args, **kwargs)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_stats_py.py:7711: in ks_1samp
    cdfvals = cdf(x, *args)
/local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:52: in cdf
    result = levy_stable.cdf(x, alpha, beta)
/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_levy_stable/__init__.py:1022: in cdf
    return super().cdf(x, *args, **kwds)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <scipy.stats._levy_stable.levy_stable_gen object at 0x73cfdebe3190>
x = array([<function test_sample.<locals>.sampler at 0x73cfad6a4ea0>],
      dtype=object)
args = (array(2.), array(1.)), kwds = {}, loc = array(0), scale = array(1)
_a = -inf, _b = inf, dtyp = dtype('O')

    def cdf(self, x, *args, **kwds):
        """
        Cumulative distribution function of the given RV.
    
        Parameters
        ----------
        x : array_like
            quantiles
        arg1, arg2, arg3,... : array_like
            The shape parameter(s) for the distribution (see docstring of the
            instance object for more information)
        loc : array_like, optional
            location parameter (default=0)
        scale : array_like, optional
            scale parameter (default=1)
    
        Returns
        -------
        cdf : ndarray
            Cumulative distribution function evaluated at `x`
    
        """
        args, loc, scale = self._parse_args(*args, **kwds)
        x, loc, scale = map(asarray, (x, loc, scale))
        args = tuple(map(asarray, args))
        _a, _b = self._get_support(*args)
        dtyp = np.promote_types(x.dtype, np.float64)
>       x = np.asarray((x - loc)/scale, dtype=dtyp)
E       TypeError: unsupported operand type(s) for -: 'function' and 'int'

/local/data0/moved_data/publishablew/pyro/pyro/venv/lib/python3.11/site-packages/scipy/stats/_distn_infrastructure.py:2129: TypeError
=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8
  /local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py:8: DeprecationWarning: Please import `IntegrationWarning` from the `scipy.integrate` namespace; the `scipy.integrate.quadpack` namespace is deprecated and will be removed in SciPy 2.0.0.
    from scipy.integrate.quadpack import IntegrationWarning

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.1-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.4-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.8-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[0.99-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.0-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.01-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.3-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[1.7-1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--1.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0--0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.0]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-0.5]
FAILED ../../../../../../local/data0/moved_data/publishablew/pyro/pyro/tests/distributions/test_stable.py::test_sample[2.0-1.0]
================== 45 failed, 642 passed, 1 warning in 10.43s ==================
