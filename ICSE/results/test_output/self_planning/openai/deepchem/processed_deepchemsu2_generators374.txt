output file:
processed_deepchemsu2_generators374.json
function:
su2_generators
Error Cases:
2025-02-14 01:59:46.319620: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
E0000 00:00:1739516386.330748 1861516 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered
E0000 00:00:1739516386.334159 1861516 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered
2025-02-14 01:59:46.346577: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.
To enable the following instructions: AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1 FAILED', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta FAILED', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0 FAILED', '../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/deepchem/deepchem/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/deepchem/deepchem
configfile: setup.cfg
plugins: flaky-3.8.1
collecting ... collected 14 items

../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_dtype_conversion PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_0 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_2 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0 FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1 FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_shape PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property FAILED

=================================== FAILURES ===================================
________ TestEquivarianceUtils.test_change_basis_real_to_complex_device ________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_change_basis_real_to_complex_device>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_change_basis_real_to_complex_device(self) -> None:
        # Test for device placement (CPU to CUDA)
        j = 1
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        Q = equivariance_utils.change_basis_real_to_complex(j, device=device)
>       self.assertEqual(Q.device, device)
E       AssertionError: device(type='cuda', index=0) != device(type='cuda')

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:111: AssertionError
___________________ TestEquivarianceUtils.test_orthogonality ___________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_orthogonality>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_orthogonality(self):
        j = 2
        alpha = torch.tensor([0.2])
        beta = torch.tensor([0.1])
        gamma = torch.tensor([0.7])
    
>       D_matrix = equivariance_utils.wigner_D(j, alpha, beta, gamma)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:287: in wigner_D
    X = so3_generators(k)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 2

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
__________________ TestEquivarianceUtils.test_so3_commutation __________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_so3_commutation>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_so3_commutation(self):
        j_values = [0, 1, 2, 3, 4,
                    5]  # Test for multiple quantum angular momentum values
        for j in j_values:
            with self.subTest(j=j):
>               X = equivariance_utils.so3_generators(j)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 0

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
_______________ TestEquivarianceUtils.test_so3_generators_shape ________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_so3_generators_shape>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_so3_generators_shape(self):
        j_values = [1, 2, 3, 4, 5]
        for j in j_values:
            with self.subTest(j=j):
>               result = equivariance_utils.so3_generators(j)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 1

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
______________________ TestEquivarianceUtils.test_so3_j0 _______________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_so3_j0>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_so3_j0(self):
        j = 0
>       result = equivariance_utils.so3_generators(j)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 0

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
______________________ TestEquivarianceUtils.test_so3_j1 _______________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_so3_j1>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_so3_j1(self):
        j = 1
>       result = equivariance_utils.so3_generators(j)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 1

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
__________________ TestEquivarianceUtils.test_su2_commutation __________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_su2_commutation>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_su2_commutation(self):
        j_values = [0, 0.5, 1, 1.5, 2,
                    2.5]  # Test for multiple quantum angular momentum values
        for j in j_values:
            with self.subTest(j=j):
>               X = equivariance_utils.su2_generators(j)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:7: in su2_generators
    return su2_generators(k)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 0.5

    def su2_generators(k):
        dim = 2 * k + 1
>       J_x = torch.zeros((dim, dim), dtype=torch.complex128)
E       TypeError: zeros() received an invalid combination of arguments - got (tuple, dtype=torch.dtype), but expected one of:
E        * (tuple of ints size, *, tuple of names names, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)
E        * (tuple of ints size, *, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/temp.py:8: TypeError
________ TestEquivarianceUtils.test_su2_generators_angular_momentum_one ________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_su2_generators_angular_momentum_one>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_su2_generators_angular_momentum_one(self) -> None:
        # Test for the case of momentum j=1 (spin-1).
        j = 1
        generators = equivariance_utils.su2_generators(j)
        # Expected J_x, J_z, J_y matrices for j=1
    
        expected_generators = torch.tensor(
            [[[0.0000 + 0.0000j, 0.7071 + 0.0000j, 0.0000 + 0.0000j],
              [-0.7071 + 0.0000j, 0.0000 + 0.0000j, 0.7071 + 0.0000j],
              [0.0000 + 0.0000j, -0.7071 + 0.0000j, 0.0000 + 0.0000j]],
             [[-0.0000 - 1.0000j, 0.0000 + 0.0000j, 0.0000 + 0.0000j],
              [0.0000 + 0.0000j, 0.0000 + 0.0000j, 0.0000 + 0.0000j],
              [0.0000 + 0.0000j, 0.0000 + 0.0000j, 0.0000 + 1.0000j]],
             [[0.0000 - 0.0000j, 0.0000 + 0.7071j, 0.0000 - 0.0000j],
              [0.0000 + 0.7071j, 0.0000 - 0.0000j, 0.0000 + 0.7071j],
              [0.0000 - 0.0000j, 0.0000 + 0.7071j, 0.0000 - 0.0000j]]])
    
>       self.assertTrue(torch.allclose(generators, expected_generators))
E       RuntimeError: ComplexDouble did not match ComplexFloat

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:50: RuntimeError
____________ TestEquivarianceUtils.test_su2_generators_zero_momenta ____________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_su2_generators_zero_momenta>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_su2_generators_zero_momenta(self) -> None:
        # Test for the case of zero momentum (j=0).
        j = 0
        generators = equivariance_utils.su2_generators(j)
        expected_generators = torch.zeros((3, 1, 1), dtype=torch.complex64)
>       self.assertTrue(torch.allclose(generators, expected_generators))
E       RuntimeError: ComplexDouble did not match ComplexFloat

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:30: RuntimeError
_________________ TestEquivarianceUtils.test_unitary_property __________________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_unitary_property>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_unitary_property(self):
        j = 2
        alpha = torch.tensor([0.2])
        beta = torch.tensor([0.1])
        gamma = torch.tensor([0.7])
    
>       D_matrix = equivariance_utils.wigner_D(j, alpha, beta, gamma)

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:287: in wigner_D
    X = so3_generators(k)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

k = 2

    def so3_generators(k: int) -> torch.Tensor:
        """Construct the generators of the SO(3) Lie algebra for a given quantum angular momentum.
    
        The function generates the generators of the special orthogonal group SO(3), which represents the group
        of rotations in three-dimensional space. Its Lie algebra, which consists of the generators of
        infinitesimal rotations, is often used in physics to describe angular momentum operators.
        The generators of the Lie algebra can be related to the SU(2) group, and this function uses
        a transformation to convert the SU(2) generators to the SO(3) basis.
    
        The primary significance of the SO(3) group lies in its representation of three-dimensional
        rotations. Each matrix in SO(3) corresponds to a unique rotation, capturing the intricate
        ways in which objects can be oriented in 3D space. This concept finds application in
        numerous fields, ranging from physics to engineering.
    
        Parameters
        ----------
         k : int
            The representation index, which determines the order of the representation.
    
        Returns
        -------
        torch.Tensor
            A stack of three SO(3) generators, corresponding to J_x, J_z, and J_y.
    
        Notes
        -----
        The special orthogonal group $SO_n(q)$ is the subgroup of the elements of general orthogonal
        group $GO_n(q)$ with determinant 1. $SO_3$ (often written $SO(3)$) is the rotation group
        for three-dimensional space.
    
        These matrices are orthogonal, which means their rows and columns form mutually perpendicular
        unit vectors. This preservation of angles and lengths makes orthogonal matrices fundamental
        in various mathematical and practical applications.
    
        The "special" part of $SO(3)$ refers to the determinant of these matrices being $+1$. The
        determinant is a scalar value that indicates how much a matrix scales volumes.
        A determinant of $+1$ ensures that the matrix represents a rotation in three-dimensional
        space without involving any reflection or scaling operations that would reverse the orientation of space.
    
        References
        ----------
        .. [1] https://en.wikipedia.org/wiki/Special_orthogonal_group
        .. [2] https://en.wikipedia.org/wiki/3D_rotation_group#Connection_between_SO(3)_and_SU(2)
        .. [3] https://www.pas.rochester.edu/assets/pdf/undergraduate/su-2s_double_covering_of_so-3.pdf
    
        Examples
        --------
        >>> so3_generators(1)
        tensor([[[ 0.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000, -1.0000],
                 [ 0.0000,  1.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000,  0.0000,  1.0000],
                 [ 0.0000,  0.0000,  0.0000],
                 [-1.0000,  0.0000,  0.0000]],
        <BLANKLINE>
                [[ 0.0000, -1.0000,  0.0000],
                 [ 1.0000,  0.0000,  0.0000],
                 [ 0.0000,  0.0000,  0.0000]]])
        """
        X = su2_generators(k)
        Q = change_basis_real_to_complex(k)
>       X = torch.conj(Q.T) @ X @ Q
E       RuntimeError: expected scalar type ComplexFloat but found ComplexDouble

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/equivariance_utils.py:231: RuntimeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property
========================= 10 failed, 4 passed in 4.22s =========================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/deepchem/deepchem/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/deepchem/deepchem
configfile: setup.cfg
plugins: flaky-3.8.1
collecting ... collected 14 items

../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_dtype_conversion PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_0 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_2 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_shape PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property PASSED

=================================== FAILURES ===================================
________ TestEquivarianceUtils.test_change_basis_real_to_complex_device ________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_change_basis_real_to_complex_device>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_change_basis_real_to_complex_device(self) -> None:
        # Test for device placement (CPU to CUDA)
        j = 1
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        Q = equivariance_utils.change_basis_real_to_complex(j, device=device)
>       self.assertEqual(Q.device, device)
E       AssertionError: device(type='cuda', index=0) != device(type='cuda')

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:111: AssertionError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device
========================= 1 failed, 13 passed in 4.17s =========================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/deepchem/deepchem/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/deepchem/deepchem
configfile: setup.cfg
plugins: flaky-3.8.1
collecting ... collected 14 items

../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device FAILED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_dtype_conversion PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_0 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_j_2 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_orthogonality PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_commutation PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_generators_shape PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j0 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_so3_j1 PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_commutation PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_angular_momentum_one PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_shape PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_su2_generators_zero_momenta PASSED
../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_unitary_property PASSED

=================================== FAILURES ===================================
________ TestEquivarianceUtils.test_change_basis_real_to_complex_device ________

self = <deepchem.utils.test.test_equivariance_utils.TestEquivarianceUtils testMethod=test_change_basis_real_to_complex_device>

    @unittest.skipIf(not has_torch, "torch is not available")
    def test_change_basis_real_to_complex_device(self) -> None:
        # Test for device placement (CPU to CUDA)
        j = 1
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        Q = equivariance_utils.change_basis_real_to_complex(j, device=device)
>       self.assertEqual(Q.device, device)
E       AssertionError: device(type='cuda', index=0) != device(type='cuda')

/local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py:111: AssertionError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/deepchem/deepchem/deepchem/utils/test/test_equivariance_utils.py::TestEquivarianceUtils::test_change_basis_real_to_complex_device
========================= 1 failed, 13 passed in 4.12s =========================
