output file:
processed_pennylane_coefficients_no_filter171.json
function:
_coefficients_no_filter
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True] FAILED', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True]', '../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False]'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 24 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False] FAILED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True] FAILED

=================================== FAILURES ===================================
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda08dcf90>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 1, expected_coeffs = tensor([0. , 0.5, 0.5], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0942b90>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 1, expected_coeffs = tensor([0. , 0.5, 0.5], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0942d50>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 2
expected_coeffs = tensor([0. , 0.5, 0. , 0. , 0.5], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0942e90>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 2
expected_coeffs = tensor([0. , 0.5, 0. , 0. , 0.5], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0943050>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,)
expected_coeffs = tensor([ 0.+0.j ,  0.+0.5j, -0.-0.5j], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda09432d0>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,)
expected_coeffs = tensor([ 0.+0.j ,  0.+0.5j, -0.-0.5j], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (1,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0943550>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 3
expected_coeffs = tensor([ 0.+0.j ,  0.+0.5j,  0.+0.j ,  0.+0.j ,  0.+0.j ,  0.+0.j ,
        -0.-0.5j], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (3,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda09437d0>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 3
expected_coeffs = tensor([ 0.+0.j ,  0.+0.5j,  0.+0.j ,  0.+0.j ,  0.+0.j ,  0.+0.j ,
        -0.-0.5j], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (3,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0943a50>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 2
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.25, 0.  ], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0943c90>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 2
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.25, 0.  ], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda0943f10>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 4
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.25, 0.  ], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (4,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095c210>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 4
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.25, 0.  ], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (4,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095c510>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (2,)
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.25, 0.  ], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095c810>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (2,)
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.25, 0.  ], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (2,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095cb10>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = 3
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.  , 0.  , 0.25, 0.  ], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (3,), use_broadcasting = False

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095ce10>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = 3
expected_coeffs = tensor([0.5 , 0.  , 0.25, 0.  , 0.  , 0.25, 0.  ], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (circuit_one_qubit_one_param_rx, 1, np.array([0, 0.5, 0.5])),
            (circuit_one_qubit_one_param_rx, 2, np.array([0, 0.5, 0, 0, 0.5])),
            (circuit_one_qubit_one_param_h_ry, (1,), np.array([0, 0.5j, -0.5j])),
            (
                circuit_one_qubit_one_param_h_ry,
                3,
                np.array([0, 0.5j, 0, 0, 0, 0, -0.5j]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                2,
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_one_qubit_one_param_rx_ry,
                4,
                np.array([0.5, 0, 0.25, 0, 0, 0, 0, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                (2,),
                np.array([0.5, 0, 0.25, 0.25, 0]),
            ),
            (
                circuit_two_qubits_repeated_param,
                3,
                np.array([0.5, 0, 0.25, 0, 0, 0.25, 0]),
            ),
        ],
    )
    def test_coefficients_one_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (3,), use_broadcasting = True

    def _coefficients_no_filter(f, degree, use_broadcasting=True):
        if isinstance(degree, int):
            freq_range = range(-degree, degree + 1)
        elif isinstance(degree, tuple) and len(degree) == 2:
            freq_range = range(degree[0], degree[1] + 1)
        else:
>           raise ValueError('Degree must be an integer or a tuple of two integers.')
E           ValueError: Degree must be an integer or a tuple of two integers.

/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:11: ValueError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095dc10>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = 1
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in _coefficients_no_filter
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in <listcomp>
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:976: in __call__
    return self._impl_call(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:952: in _impl_call
    self.construct(args, kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/logging/decorators.py:61: in wrapper_entry
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:884: in construct
    self._qfunc_output = self.func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

inpt = np.float64(0.0)

    @qml.qnode(dev_2)
    def circuit_two_qubits_two_params(inpt):
        r"""Circuit with a single-qubit, two-param output function :math:`<Z>`.
    
        By-hand calculation of :math:`f(x)` gives :math:`<Z> = cos(x_1) cos(x_2)`
        Fourier coeffs are 0.25 for all :math:`+/-1` combinations, 0 elsewhere
        (Same as the circuit with one qubit and two params)
        """
>       qml.RY(inpt[0], wires=0)
E       IndexError: invalid index to scalar variable.

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:189: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095eb90>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = 1
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:18: in _coefficients_no_filter
    y_fft = np.fft.fft(y) / num_points
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(0.99998118), n = None, axis = -1, norm = None, out = None

    @array_function_dispatch(_fft_dispatcher)
    def fft(a, n=None, axis=-1, norm=None, out=None):
        """
        Compute the one-dimensional discrete Fourier Transform.
    
        This function computes the one-dimensional *n*-point discrete Fourier
        Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        algorithm [CT].
    
        Parameters
        ----------
        a : array_like
            Input array, can be complex.
        n : int, optional
            Length of the transformed axis of the output.
            If `n` is smaller than the length of the input, the input is cropped.
            If it is larger, the input is padded with zeros.  If `n` is not given,
            the length of the input along the axis specified by `axis` is used.
        axis : int, optional
            Axis over which to compute the FFT.  If not given, the last axis is
            used.
        norm : {"backward", "ortho", "forward"}, optional
            .. versionadded:: 1.10.0
    
            Normalization mode (see `numpy.fft`). Default is "backward".
            Indicates which direction of the forward/backward pair of transforms
            is scaled and with what normalization factor.
    
            .. versionadded:: 1.20.0
    
                The "backward", "forward" values were added.
        out : complex ndarray, optional
            If provided, the result will be placed in this array. It should be
            of the appropriate shape and dtype.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        out : complex ndarray
            The truncated or zero-padded input, transformed along the axis
            indicated by `axis`, or the last one if `axis` is not specified.
    
        Raises
        ------
        IndexError
            If `axis` is not a valid axis of `a`.
    
        See Also
        --------
        numpy.fft : for definition of the DFT and conventions used.
        ifft : The inverse of `fft`.
        fft2 : The two-dimensional FFT.
        fftn : The *n*-dimensional FFT.
        rfftn : The *n*-dimensional FFT of real input.
        fftfreq : Frequency bins for given FFT parameters.
    
        Notes
        -----
        FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        Transform (DFT) can be calculated efficiently, by using symmetries in the
        calculated terms.  The symmetry is highest when `n` is a power of 2, and
        the transform is therefore most efficient for these sizes.
    
        The DFT is defined, with the conventions used in this implementation, in
        the documentation for the `numpy.fft` module.
    
        References
        ----------
        .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
                machine calculation of complex Fourier series," *Math. Comput.*
                19: 297-301.
    
        Examples
        --------
        >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
        array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
                2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
               -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
                1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
    
        In this example, real input has an FFT which is Hermitian, i.e., symmetric
        in the real part and anti-symmetric in the imaginary part, as described in
        the `numpy.fft` documentation:
    
        >>> import matplotlib.pyplot as plt
        >>> t = np.arange(256)
        >>> sp = np.fft.fft(np.sin(t))
        >>> freq = np.fft.fftfreq(t.shape[-1])
        >>> plt.plot(freq, sp.real, freq, sp.imag)
        [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
        >>> plt.show()
    
        """
        a = asarray(a)
        if n is None:
>           n = a.shape[axis]
E           IndexError: tuple index out of range

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/fft/_pocketfft.py:209: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095edd0>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (1, 1)
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in _coefficients_no_filter
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in <listcomp>
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:976: in __call__
    return self._impl_call(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:952: in _impl_call
    self.construct(args, kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/logging/decorators.py:61: in wrapper_entry
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:884: in construct
    self._qfunc_output = self.func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

inpt = np.float64(0.0)

    @qml.qnode(dev_2)
    def circuit_two_qubits_two_params(inpt):
        r"""Circuit with a single-qubit, two-param output function :math:`<Z>`.
    
        By-hand calculation of :math:`f(x)` gives :math:`<Z> = cos(x_1) cos(x_2)`
        Fourier coeffs are 0.25 for all :math:`+/-1` combinations, 0 elsewhere
        (Same as the circuit with one qubit and two params)
        """
>       qml.RY(inpt[0], wires=0)
E       IndexError: invalid index to scalar variable.

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:189: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095f050>
circuit = <QNode: device='<default.qubit device (wires=2) at 0x7bfdedf29bd0>', interface='auto', diff_method='best'>
degree = (1, 1)
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:18: in _coefficients_no_filter
    y_fft = np.fft.fft(y) / num_points
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(0.99998118), n = None, axis = -1, norm = None, out = None

    @array_function_dispatch(_fft_dispatcher)
    def fft(a, n=None, axis=-1, norm=None, out=None):
        """
        Compute the one-dimensional discrete Fourier Transform.
    
        This function computes the one-dimensional *n*-point discrete Fourier
        Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        algorithm [CT].
    
        Parameters
        ----------
        a : array_like
            Input array, can be complex.
        n : int, optional
            Length of the transformed axis of the output.
            If `n` is smaller than the length of the input, the input is cropped.
            If it is larger, the input is padded with zeros.  If `n` is not given,
            the length of the input along the axis specified by `axis` is used.
        axis : int, optional
            Axis over which to compute the FFT.  If not given, the last axis is
            used.
        norm : {"backward", "ortho", "forward"}, optional
            .. versionadded:: 1.10.0
    
            Normalization mode (see `numpy.fft`). Default is "backward".
            Indicates which direction of the forward/backward pair of transforms
            is scaled and with what normalization factor.
    
            .. versionadded:: 1.20.0
    
                The "backward", "forward" values were added.
        out : complex ndarray, optional
            If provided, the result will be placed in this array. It should be
            of the appropriate shape and dtype.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        out : complex ndarray
            The truncated or zero-padded input, transformed along the axis
            indicated by `axis`, or the last one if `axis` is not specified.
    
        Raises
        ------
        IndexError
            If `axis` is not a valid axis of `a`.
    
        See Also
        --------
        numpy.fft : for definition of the DFT and conventions used.
        ifft : The inverse of `fft`.
        fft2 : The two-dimensional FFT.
        fftn : The *n*-dimensional FFT.
        rfftn : The *n*-dimensional FFT of real input.
        fftfreq : Frequency bins for given FFT parameters.
    
        Notes
        -----
        FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        Transform (DFT) can be calculated efficiently, by using symmetries in the
        calculated terms.  The symmetry is highest when `n` is a power of 2, and
        the transform is therefore most efficient for these sizes.
    
        The DFT is defined, with the conventions used in this implementation, in
        the documentation for the `numpy.fft` module.
    
        References
        ----------
        .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
                machine calculation of complex Fourier series," *Math. Comput.*
                19: 297-301.
    
        Examples
        --------
        >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
        array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
                2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
               -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
                1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
    
        In this example, real input has an FFT which is Hermitian, i.e., symmetric
        in the real part and anti-symmetric in the imaginary part, as described in
        the `numpy.fft` documentation:
    
        >>> import matplotlib.pyplot as plt
        >>> t = np.arange(256)
        >>> sp = np.fft.fft(np.sin(t))
        >>> freq = np.fft.fftfreq(t.shape[-1])
        >>> plt.plot(freq, sp.real, freq, sp.imag)
        [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
        >>> plt.show()
    
        """
        a = asarray(a)
        if n is None:
>           n = a.shape[axis]
E           IndexError: tuple index out of range

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/fft/_pocketfft.py:209: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095f2d0>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 1
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in _coefficients_no_filter
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in <listcomp>
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:976: in __call__
    return self._impl_call(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:952: in _impl_call
    self.construct(args, kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/logging/decorators.py:61: in wrapper_entry
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:884: in construct
    self._qfunc_output = self.func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

inpt = np.float64(0.0)

    @qml.qnode(dev_1)
    def circuit_one_qubit_two_params(inpt):
        r"""Circuit with a single-qubit, single-param, output function <Z>.
    
        By-hand calculation of :math:`f(x)` gives :math:`<Z> = cos(x_1) cos(x_2)`
        Fourier coeffs are 0.25 for all :math:`+/-1` combinations, 0 elsewhere.
        """
>       qml.RY(inpt[0], wires=0)
E       IndexError: invalid index to scalar variable.

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:156: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095f550>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = 1
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:18: in _coefficients_no_filter
    y_fft = np.fft.fft(y) / num_points
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(0.99998118), n = None, axis = -1, norm = None, out = None

    @array_function_dispatch(_fft_dispatcher)
    def fft(a, n=None, axis=-1, norm=None, out=None):
        """
        Compute the one-dimensional discrete Fourier Transform.
    
        This function computes the one-dimensional *n*-point discrete Fourier
        Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        algorithm [CT].
    
        Parameters
        ----------
        a : array_like
            Input array, can be complex.
        n : int, optional
            Length of the transformed axis of the output.
            If `n` is smaller than the length of the input, the input is cropped.
            If it is larger, the input is padded with zeros.  If `n` is not given,
            the length of the input along the axis specified by `axis` is used.
        axis : int, optional
            Axis over which to compute the FFT.  If not given, the last axis is
            used.
        norm : {"backward", "ortho", "forward"}, optional
            .. versionadded:: 1.10.0
    
            Normalization mode (see `numpy.fft`). Default is "backward".
            Indicates which direction of the forward/backward pair of transforms
            is scaled and with what normalization factor.
    
            .. versionadded:: 1.20.0
    
                The "backward", "forward" values were added.
        out : complex ndarray, optional
            If provided, the result will be placed in this array. It should be
            of the appropriate shape and dtype.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        out : complex ndarray
            The truncated or zero-padded input, transformed along the axis
            indicated by `axis`, or the last one if `axis` is not specified.
    
        Raises
        ------
        IndexError
            If `axis` is not a valid axis of `a`.
    
        See Also
        --------
        numpy.fft : for definition of the DFT and conventions used.
        ifft : The inverse of `fft`.
        fft2 : The two-dimensional FFT.
        fftn : The *n*-dimensional FFT.
        rfftn : The *n*-dimensional FFT of real input.
        fftfreq : Frequency bins for given FFT parameters.
    
        Notes
        -----
        FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        Transform (DFT) can be calculated efficiently, by using symmetries in the
        calculated terms.  The symmetry is highest when `n` is a power of 2, and
        the transform is therefore most efficient for these sizes.
    
        The DFT is defined, with the conventions used in this implementation, in
        the documentation for the `numpy.fft` module.
    
        References
        ----------
        .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
                machine calculation of complex Fourier series," *Math. Comput.*
                19: 297-301.
    
        Examples
        --------
        >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
        array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
                2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
               -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
                1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
    
        In this example, real input has an FFT which is Hermitian, i.e., symmetric
        in the real part and anti-symmetric in the imaginary part, as described in
        the `numpy.fft` documentation:
    
        >>> import matplotlib.pyplot as plt
        >>> t = np.arange(256)
        >>> sp = np.fft.fft(np.sin(t))
        >>> freq = np.fft.fftfreq(t.shape[-1])
        >>> plt.plot(freq, sp.real, freq, sp.imag)
        [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
        >>> plt.show()
    
        """
        a = asarray(a)
        if n is None:
>           n = a.shape[axis]
E           IndexError: tuple index out of range

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/fft/_pocketfft.py:209: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095f810>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2, 1)
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = False

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in _coefficients_no_filter
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:17: in <listcomp>
    y = np.array([f(xi) for xi in x])
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:976: in __call__
    return self._impl_call(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:952: in _impl_call
    self.construct(args, kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/logging/decorators.py:61: in wrapper_entry
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/workflow/qnode.py:884: in construct
    self._qfunc_output = self.func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

inpt = np.float64(0.0)

    @qml.qnode(dev_1)
    def circuit_one_qubit_two_params(inpt):
        r"""Circuit with a single-qubit, single-param, output function <Z>.
    
        By-hand calculation of :math:`f(x)` gives :math:`<Z> = cos(x_1) cos(x_2)`
        Fourier coeffs are 0.25 for all :math:`+/-1` combinations, 0 elsewhere.
        """
>       qml.RY(inpt[0], wires=0)
E       IndexError: invalid index to scalar variable.

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:156: IndexError
_ TestFourierCoefficientCircuits.test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True] _

self = <test_coefficients.TestFourierCoefficientCircuits object at 0x7bfda095fb10>
circuit = <QNode: device='<default.qubit device (wires=1) at 0x7bfda08e40d0>', interface='auto', diff_method='best'>
degree = (2, 1)
expected_coeffs = tensor([[0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25],
        [0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.25]], requires_grad=True)
use_broadcasting = True

    @pytest.mark.parametrize(
        "circuit,degree,expected_coeffs",
        [
            (
                circuit_two_qubits_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_two_qubits_two_params,
                (1, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                1,
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0.25, 0.25]]),
            ),
            (
                circuit_one_qubit_two_params,
                (2, 1),
                np.array([[0, 0, 0], [0, 0.25, 0.25], [0, 0, 0], [0, 0, 0], [0, 0.25, 0.25]]),
            ),
        ],
    )
    def test_coefficients_two_param_circuits(
        self, circuit, degree, expected_coeffs, use_broadcasting
    ):
        """Test that coeffs for a single instance of a single parameter match the by-hand
        results regardless of input degree (max degree is 1)."""
>       coeffs = coefficients(circuit, circuit.n_inputs, degree, use_broadcasting=use_broadcasting)

/local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:158: in coefficients
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/coefficients.py:180: in _coefficients_no_filter
    return _coefficients_no_filter(f, degree, use_broadcasting)
/local/data0/moved_data/publishablew/pennylane/pennylane/pennylane/fourier/temp.py:18: in _coefficients_no_filter
    y_fft = np.fft.fft(y) / num_points
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array(0.99998118), n = None, axis = -1, norm = None, out = None

    @array_function_dispatch(_fft_dispatcher)
    def fft(a, n=None, axis=-1, norm=None, out=None):
        """
        Compute the one-dimensional discrete Fourier Transform.
    
        This function computes the one-dimensional *n*-point discrete Fourier
        Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        algorithm [CT].
    
        Parameters
        ----------
        a : array_like
            Input array, can be complex.
        n : int, optional
            Length of the transformed axis of the output.
            If `n` is smaller than the length of the input, the input is cropped.
            If it is larger, the input is padded with zeros.  If `n` is not given,
            the length of the input along the axis specified by `axis` is used.
        axis : int, optional
            Axis over which to compute the FFT.  If not given, the last axis is
            used.
        norm : {"backward", "ortho", "forward"}, optional
            .. versionadded:: 1.10.0
    
            Normalization mode (see `numpy.fft`). Default is "backward".
            Indicates which direction of the forward/backward pair of transforms
            is scaled and with what normalization factor.
    
            .. versionadded:: 1.20.0
    
                The "backward", "forward" values were added.
        out : complex ndarray, optional
            If provided, the result will be placed in this array. It should be
            of the appropriate shape and dtype.
    
            .. versionadded:: 2.0.0
    
        Returns
        -------
        out : complex ndarray
            The truncated or zero-padded input, transformed along the axis
            indicated by `axis`, or the last one if `axis` is not specified.
    
        Raises
        ------
        IndexError
            If `axis` is not a valid axis of `a`.
    
        See Also
        --------
        numpy.fft : for definition of the DFT and conventions used.
        ifft : The inverse of `fft`.
        fft2 : The two-dimensional FFT.
        fftn : The *n*-dimensional FFT.
        rfftn : The *n*-dimensional FFT of real input.
        fftfreq : Frequency bins for given FFT parameters.
    
        Notes
        -----
        FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        Transform (DFT) can be calculated efficiently, by using symmetries in the
        calculated terms.  The symmetry is highest when `n` is a power of 2, and
        the transform is therefore most efficient for these sizes.
    
        The DFT is defined, with the conventions used in this implementation, in
        the documentation for the `numpy.fft` module.
    
        References
        ----------
        .. [CT] Cooley, James W., and John W. Tukey, 1965, "An algorithm for the
                machine calculation of complex Fourier series," *Math. Comput.*
                19: 297-301.
    
        Examples
        --------
        >>> np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))
        array([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,
                2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,
               -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,
                1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])
    
        In this example, real input has an FFT which is Hermitian, i.e., symmetric
        in the real part and anti-symmetric in the imaginary part, as described in
        the `numpy.fft` documentation:
    
        >>> import matplotlib.pyplot as plt
        >>> t = np.arange(256)
        >>> sp = np.fft.fft(np.sin(t))
        >>> freq = np.fft.fftfreq(t.shape[-1])
        >>> plt.plot(freq, sp.real, freq, sp.imag)
        [<matplotlib.lines.Line2D object at 0x...>, <matplotlib.lines.Line2D object at 0x...>]
        >>> plt.show()
    
        """
        a = asarray(a)
        if n is None:
>           n = a.shape[axis]
E           IndexError: tuple index out of range

/local/data0/moved_data/publishablew/pennylane/pennylane/venv/lib/python3.11/site-packages/numpy/fft/_pocketfft.py:209: IndexError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True]
============================== 24 failed in 0.40s ==============================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 24 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True] PASSED

============================== 24 passed in 0.09s ==============================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/pennylane/pennylane/venv/bin/python
cachedir: .pytest_cache
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /local/data0/moved_data/publishablew/pennylane/pennylane/tests
configfile: pytest.ini
plugins: flaky-3.8.1, xdist-3.6.1, split-0.10.0, rng-1.0.0, mock-3.14.0, forked-1.6.0, cov-6.0.0, benchmark-5.1.0
collecting ... collected 24 items

../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-1-expected_coeffs0-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx-2-expected_coeffs1-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-degree2-expected_coeffs2-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_h_ry-3-expected_coeffs3-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-2-expected_coeffs4-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_one_qubit_one_param_rx_ry-4-expected_coeffs5-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-degree6-expected_coeffs6-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_one_param_circuits[circuit_two_qubits_repeated_param-3-expected_coeffs7-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-1-expected_coeffs0-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_two_qubits_two_params-degree1-expected_coeffs1-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-1-expected_coeffs2-True] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-False] PASSED
../../../../../../local/data0/moved_data/publishablew/pennylane/pennylane/tests/fourier/test_coefficients.py::TestFourierCoefficientCircuits::test_coefficients_two_param_circuits[circuit_one_qubit_two_params-degree3-expected_coeffs3-True] PASSED

============================== 24 passed in 0.12s ==============================
