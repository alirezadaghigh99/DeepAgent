output file:
processed_GPflowmultivariate_normal392.json
function:
multivariate_normal
Error Cases:
2025-02-13 22:44:29.129154: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
E0000 00:00:1739504669.140524 1509736 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered
E0000 00:00:1739504669.144167 1509736 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered
2025-02-13 22:44:29.157017: I tensorflow/core/platform/cpu_feature_guard.cc:210] This TensorFlow binary is optimized to use available CPU instructions in performance-critical operations.
To enable the following instructions: AVX2 FMA, in other operations, rebuild TensorFlow with the appropriate compiler flags.
I0000 00:00:1739504671.786351 1509736 gpu_device.cc:2022] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 9413 MB memory:  -> device: 0, name: NVIDIA GeForce RTX 3060, pci bus id: 0000:06:00.0, compute capability: 8.6
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
I0000 00:00:1739504671.976261 1509736 cuda_solvers.cc:178] Creating GpuSolver handles for stream 0xa204db0

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1]', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1] FAILED', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0]', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1] FAILED', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0]', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1] FAILED', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0]', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0] FAILED', '../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1]'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/GPflow/GPflow/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/GPflow/GPflow
collecting ... collected 8 items

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0] FAILED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1] FAILED

=================================== FAILURES ===================================
__________________ test_multivariate_normal[cov_sqrt0-mu0-x0] __________________

x = array([[-0.7387303 ,  1.36012134, -0.31734415, -0.77178996, -0.64685408,
        -0.25838639,  0.887962  , -1.37048425...1072, -1.12850175, -0.51566441,  2.54564855,
         1.16712739, -0.59262458,  0.05631591,  1.77234886, -0.31167101]])
mu = array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.38383758,
         0.04090519,  0.67528537,  1.32646662...9549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])
cov_sqrt = array([[-0.31255741,  1.74887432,  1.14126846, -0.27077303],
       [-0.18291762,  1.24682481, -1.93034483,  0.1333616...    [-1.76654622, -0.48111773,  0.46647883, -0.70027498],
       [-0.46531756,  1.06877551,  1.13697878,  1.96472281]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:23: in multivariate_normal
    mvn = tfd.MultivariateNormalTriL(loc=mu, scale_tril=L)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_tril.py:228: in __init__
    super(MultivariateNormalTriL, self).__init__(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:195: in __init__
    batch_shape, event_shape = distribution_util.shapes_from_loc_and_scale(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

loc = <tf.Tensor: shape=(4, 10), dtype=float64, numpy=
array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.383837...549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])>
scale = <tensorflow.python.ops.linalg.linear_operator_lower_triangular.LinearOperatorLowerTriangular object at 0x73dd5c542cd0>
name = 'shapes_from_loc_and_scale'

    def shapes_from_loc_and_scale(loc, scale, name='shapes_from_loc_and_scale'):
      """Infer distribution batch and event shapes from a location and scale.
    
      Location and scale family distributions determine their batch/event shape by
      broadcasting the `loc` and `scale` args.  This helper does that broadcast,
      statically if possible.
    
      Batch shape broadcasts as per the normal rules.
      We allow the `loc` event shape to broadcast up to that of `scale`.  We do not
      allow `scale`'s event shape to change.  Therefore, the last dimension of `loc`
      must either be size `1`, or the same as `scale.range_dimension`.
    
      See `MultivariateNormalLinearOperator` for a usage example.
    
      Args:
        loc: `Tensor` (already converted to tensor) or `None`. If `None`, or
          `rank(loc)==0`, both batch and event shape are determined by `scale`.
        scale:  A `LinearOperator` instance.
        name:  A string name to prepend to created ops.
    
      Returns:
        batch_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
        event_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
    
      Raises:
        ValueError:  If the last dimension of `loc` is determined statically to be
          different than the range of `scale`.
      """
      if loc is not None and tensorshape_util.rank(loc.shape) == 0:
        loc = None  # scalar loc is irrelevant to determining batch/event shape.
      with tf.name_scope(name):
        # Get event shape.
        event_size = tf.compat.dimension_value(scale.range_dimension)
        if event_size is None:
          event_size = scale.range_dimension_tensor()
        event_size_ = tf.get_static_value(ps.convert_to_shape_tensor(event_size))
        loc_event_size_ = (None if loc is None
                           else tf.compat.dimension_value(loc.shape[-1]))
    
        if event_size_ is not None and loc_event_size_ is not None:
          # Static check that event shapes match.
          if loc_event_size_ != 1 and loc_event_size_ != event_size_:
>           raise ValueError(
                'Event size of `scale` ({}) could not be broadcast up to that '
E               ValueError: Event size of `scale` (4) could not be broadcast up to that of `loc` (10).

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:130: ValueError
__________________ test_multivariate_normal[cov_sqrt0-mu0-x1] __________________

x = array([[-0.18393875],
       [ 0.35718712],
       [ 1.30453327],
       [-0.86865434]])
mu = array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.38383758,
         0.04090519,  0.67528537,  1.32646662...9549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])
cov_sqrt = array([[-0.31255741,  1.74887432,  1.14126846, -0.27077303],
       [-0.18291762,  1.24682481, -1.93034483,  0.1333616...    [-1.76654622, -0.48111773,  0.46647883, -0.70027498],
       [-0.46531756,  1.06877551,  1.13697878,  1.96472281]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:23: in multivariate_normal
    mvn = tfd.MultivariateNormalTriL(loc=mu, scale_tril=L)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_tril.py:228: in __init__
    super(MultivariateNormalTriL, self).__init__(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:195: in __init__
    batch_shape, event_shape = distribution_util.shapes_from_loc_and_scale(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

loc = <tf.Tensor: shape=(4, 10), dtype=float64, numpy=
array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.383837...549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])>
scale = <tensorflow.python.ops.linalg.linear_operator_lower_triangular.LinearOperatorLowerTriangular object at 0x73dd51f3e7d0>
name = 'shapes_from_loc_and_scale'

    def shapes_from_loc_and_scale(loc, scale, name='shapes_from_loc_and_scale'):
      """Infer distribution batch and event shapes from a location and scale.
    
      Location and scale family distributions determine their batch/event shape by
      broadcasting the `loc` and `scale` args.  This helper does that broadcast,
      statically if possible.
    
      Batch shape broadcasts as per the normal rules.
      We allow the `loc` event shape to broadcast up to that of `scale`.  We do not
      allow `scale`'s event shape to change.  Therefore, the last dimension of `loc`
      must either be size `1`, or the same as `scale.range_dimension`.
    
      See `MultivariateNormalLinearOperator` for a usage example.
    
      Args:
        loc: `Tensor` (already converted to tensor) or `None`. If `None`, or
          `rank(loc)==0`, both batch and event shape are determined by `scale`.
        scale:  A `LinearOperator` instance.
        name:  A string name to prepend to created ops.
    
      Returns:
        batch_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
        event_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
    
      Raises:
        ValueError:  If the last dimension of `loc` is determined statically to be
          different than the range of `scale`.
      """
      if loc is not None and tensorshape_util.rank(loc.shape) == 0:
        loc = None  # scalar loc is irrelevant to determining batch/event shape.
      with tf.name_scope(name):
        # Get event shape.
        event_size = tf.compat.dimension_value(scale.range_dimension)
        if event_size is None:
          event_size = scale.range_dimension_tensor()
        event_size_ = tf.get_static_value(ps.convert_to_shape_tensor(event_size))
        loc_event_size_ = (None if loc is None
                           else tf.compat.dimension_value(loc.shape[-1]))
    
        if event_size_ is not None and loc_event_size_ is not None:
          # Static check that event shapes match.
          if loc_event_size_ != 1 and loc_event_size_ != event_size_:
>           raise ValueError(
                'Event size of `scale` ({}) could not be broadcast up to that '
E               ValueError: Event size of `scale` (4) could not be broadcast up to that of `loc` (10).

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:130: ValueError
__________________ test_multivariate_normal[cov_sqrt0-mu1-x0] __________________

x = array([[-0.7387303 ,  1.36012134, -0.31734415, -0.77178996, -0.64685408,
        -0.25838639,  0.887962  , -1.37048425...1072, -1.12850175, -0.51566441,  2.54564855,
         1.16712739, -0.59262458,  0.05631591,  1.77234886, -0.31167101]])
mu = array([[ 0.13521486],
       [-0.14942097],
       [-1.40888002],
       [-0.47194681]])
cov_sqrt = array([[-0.31255741,  1.74887432,  1.14126846, -0.27077303],
       [-0.18291762,  1.24682481, -1.93034483,  0.1333616...    [-1.76654622, -0.48111773,  0.46647883, -0.70027498],
       [-0.46531756,  1.06877551,  1.13697878,  1.96472281]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:24: in multivariate_normal
    log_prob = mvn.log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1287: in log_prob
    return self._call_log_prob(value, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1269: in _call_log_prob
    return self._log_prob(value, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:1350: in _fn
    return fn(*args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:243: in _log_prob
    return super(MultivariateNormalLinearOperator, self)._log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:364: in _log_prob
    log_prob, _ = self.experimental_local_measure(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:611: in experimental_local_measure
    x = self.bijector.inverse(y, **bijector_kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:614: in _inverse
    return self._call_walk_inverse(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:352: in _call_walk_inverse
    return self._walk_inverse(step_fn, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/chain.py:150: in _walk_inverse
    y = step_fn(bij, y, **kwargs.get(bij.name, {}))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:615: in <lambda>
    lambda b, y, **kwargs: b.inverse(y, **kwargs),
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/scale_matvec_linear_operator.py:54: in _inverse
    return self.scale.solvevec(y, adjoint=self.adjoint)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/ops/linalg/linear_operator.py:1075: in solvevec
    self.shape, self_dim).assert_is_compatible_with(rhs.shape[-1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Dimension(4), other = 10

    def assert_is_compatible_with(self, other):
      """Raises an exception if `other` is not compatible with this Dimension.
    
      Args:
        other: Another Dimension.
    
      Raises:
        ValueError: If `self` and `other` are not compatible (see
          is_compatible_with).
      """
      if not self.is_compatible_with(other):
>       raise ValueError("Dimensions %s and %s are not compatible" %
                         (self, other))
E       ValueError: Dimensions 4 and 10 are not compatible

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/framework/tensor_shape.py:303: ValueError
__________________ test_multivariate_normal[cov_sqrt0-mu1-x1] __________________

x = array([[-0.18393875],
       [ 0.35718712],
       [ 1.30453327],
       [-0.86865434]])
mu = array([[ 0.13521486],
       [-0.14942097],
       [-1.40888002],
       [-0.47194681]])
cov_sqrt = array([[-0.31255741,  1.74887432,  1.14126846, -0.27077303],
       [-0.18291762,  1.24682481, -1.93034483,  0.1333616...    [-1.76654622, -0.48111773,  0.46647883, -0.70027498],
       [-0.46531756,  1.06877551,  1.13697878,  1.96472281]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:24: in multivariate_normal
    log_prob = mvn.log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1287: in log_prob
    return self._call_log_prob(value, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1269: in _call_log_prob
    return self._log_prob(value, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:1350: in _fn
    return fn(*args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:243: in _log_prob
    return super(MultivariateNormalLinearOperator, self)._log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:364: in _log_prob
    log_prob, _ = self.experimental_local_measure(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:611: in experimental_local_measure
    x = self.bijector.inverse(y, **bijector_kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:614: in _inverse
    return self._call_walk_inverse(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:352: in _call_walk_inverse
    return self._walk_inverse(step_fn, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/chain.py:150: in _walk_inverse
    y = step_fn(bij, y, **kwargs.get(bij.name, {}))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:615: in <lambda>
    lambda b, y, **kwargs: b.inverse(y, **kwargs),
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/scale_matvec_linear_operator.py:54: in _inverse
    return self.scale.solvevec(y, adjoint=self.adjoint)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/ops/linalg/linear_operator.py:1075: in solvevec
    self.shape, self_dim).assert_is_compatible_with(rhs.shape[-1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Dimension(4), other = 1

    def assert_is_compatible_with(self, other):
      """Raises an exception if `other` is not compatible with this Dimension.
    
      Args:
        other: Another Dimension.
    
      Raises:
        ValueError: If `self` and `other` are not compatible (see
          is_compatible_with).
      """
      if not self.is_compatible_with(other):
>       raise ValueError("Dimensions %s and %s are not compatible" %
                         (self, other))
E       ValueError: Dimensions 4 and 1 are not compatible

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/framework/tensor_shape.py:303: ValueError
__________________ test_multivariate_normal[cov_sqrt1-mu0-x0] __________________

x = array([[-0.7387303 ,  1.36012134, -0.31734415, -0.77178996, -0.64685408,
        -0.25838639,  0.887962  , -1.37048425...1072, -1.12850175, -0.51566441,  2.54564855,
         1.16712739, -0.59262458,  0.05631591,  1.77234886, -0.31167101]])
mu = array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.38383758,
         0.04090519,  0.67528537,  1.32646662...9549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])
cov_sqrt = array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:23: in multivariate_normal
    mvn = tfd.MultivariateNormalTriL(loc=mu, scale_tril=L)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_tril.py:228: in __init__
    super(MultivariateNormalTriL, self).__init__(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:195: in __init__
    batch_shape, event_shape = distribution_util.shapes_from_loc_and_scale(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

loc = <tf.Tensor: shape=(4, 10), dtype=float64, numpy=
array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.383837...549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])>
scale = <tensorflow.python.ops.linalg.linear_operator_lower_triangular.LinearOperatorLowerTriangular object at 0x73dd5cbbded0>
name = 'shapes_from_loc_and_scale'

    def shapes_from_loc_and_scale(loc, scale, name='shapes_from_loc_and_scale'):
      """Infer distribution batch and event shapes from a location and scale.
    
      Location and scale family distributions determine their batch/event shape by
      broadcasting the `loc` and `scale` args.  This helper does that broadcast,
      statically if possible.
    
      Batch shape broadcasts as per the normal rules.
      We allow the `loc` event shape to broadcast up to that of `scale`.  We do not
      allow `scale`'s event shape to change.  Therefore, the last dimension of `loc`
      must either be size `1`, or the same as `scale.range_dimension`.
    
      See `MultivariateNormalLinearOperator` for a usage example.
    
      Args:
        loc: `Tensor` (already converted to tensor) or `None`. If `None`, or
          `rank(loc)==0`, both batch and event shape are determined by `scale`.
        scale:  A `LinearOperator` instance.
        name:  A string name to prepend to created ops.
    
      Returns:
        batch_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
        event_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
    
      Raises:
        ValueError:  If the last dimension of `loc` is determined statically to be
          different than the range of `scale`.
      """
      if loc is not None and tensorshape_util.rank(loc.shape) == 0:
        loc = None  # scalar loc is irrelevant to determining batch/event shape.
      with tf.name_scope(name):
        # Get event shape.
        event_size = tf.compat.dimension_value(scale.range_dimension)
        if event_size is None:
          event_size = scale.range_dimension_tensor()
        event_size_ = tf.get_static_value(ps.convert_to_shape_tensor(event_size))
        loc_event_size_ = (None if loc is None
                           else tf.compat.dimension_value(loc.shape[-1]))
    
        if event_size_ is not None and loc_event_size_ is not None:
          # Static check that event shapes match.
          if loc_event_size_ != 1 and loc_event_size_ != event_size_:
>           raise ValueError(
                'Event size of `scale` ({}) could not be broadcast up to that '
E               ValueError: Event size of `scale` (4) could not be broadcast up to that of `loc` (10).

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:130: ValueError
__________________ test_multivariate_normal[cov_sqrt1-mu0-x1] __________________

x = array([[-0.18393875],
       [ 0.35718712],
       [ 1.30453327],
       [-0.86865434]])
mu = array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.38383758,
         0.04090519,  0.67528537,  1.32646662...9549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])
cov_sqrt = array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:23: in multivariate_normal
    mvn = tfd.MultivariateNormalTriL(loc=mu, scale_tril=L)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_tril.py:228: in __init__
    super(MultivariateNormalTriL, self).__init__(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/decorator.py:232: in fun
    return caller(func, *(extras + args), **kw)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:342: in wrapped_init
    default_init(self_, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:195: in __init__
    batch_shape, event_shape = distribution_util.shapes_from_loc_and_scale(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

loc = <tf.Tensor: shape=(4, 10), dtype=float64, numpy=
array([[ 0.07841231,  0.18829472,  0.26474981,  0.62782443,  0.383837...549,  0.64773649, -0.40390223, -1.59116531,
         0.16245053, -0.81167826,  0.29087244, -0.3766192 , -0.67640607]])>
scale = <tensorflow.python.ops.linalg.linear_operator_lower_triangular.LinearOperatorLowerTriangular object at 0x73dd5a063790>
name = 'shapes_from_loc_and_scale'

    def shapes_from_loc_and_scale(loc, scale, name='shapes_from_loc_and_scale'):
      """Infer distribution batch and event shapes from a location and scale.
    
      Location and scale family distributions determine their batch/event shape by
      broadcasting the `loc` and `scale` args.  This helper does that broadcast,
      statically if possible.
    
      Batch shape broadcasts as per the normal rules.
      We allow the `loc` event shape to broadcast up to that of `scale`.  We do not
      allow `scale`'s event shape to change.  Therefore, the last dimension of `loc`
      must either be size `1`, or the same as `scale.range_dimension`.
    
      See `MultivariateNormalLinearOperator` for a usage example.
    
      Args:
        loc: `Tensor` (already converted to tensor) or `None`. If `None`, or
          `rank(loc)==0`, both batch and event shape are determined by `scale`.
        scale:  A `LinearOperator` instance.
        name:  A string name to prepend to created ops.
    
      Returns:
        batch_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
        event_shape:  `TensorShape` (if broadcast is done statically), or `Tensor`.
    
      Raises:
        ValueError:  If the last dimension of `loc` is determined statically to be
          different than the range of `scale`.
      """
      if loc is not None and tensorshape_util.rank(loc.shape) == 0:
        loc = None  # scalar loc is irrelevant to determining batch/event shape.
      with tf.name_scope(name):
        # Get event shape.
        event_size = tf.compat.dimension_value(scale.range_dimension)
        if event_size is None:
          event_size = scale.range_dimension_tensor()
        event_size_ = tf.get_static_value(ps.convert_to_shape_tensor(event_size))
        loc_event_size_ = (None if loc is None
                           else tf.compat.dimension_value(loc.shape[-1]))
    
        if event_size_ is not None and loc_event_size_ is not None:
          # Static check that event shapes match.
          if loc_event_size_ != 1 and loc_event_size_ != event_size_:
>           raise ValueError(
                'Event size of `scale` ({}) could not be broadcast up to that '
E               ValueError: Event size of `scale` (4) could not be broadcast up to that of `loc` (10).

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:130: ValueError
__________________ test_multivariate_normal[cov_sqrt1-mu1-x0] __________________

x = array([[-0.7387303 ,  1.36012134, -0.31734415, -0.77178996, -0.64685408,
        -0.25838639,  0.887962  , -1.37048425...1072, -1.12850175, -0.51566441,  2.54564855,
         1.16712739, -0.59262458,  0.05631591,  1.77234886, -0.31167101]])
mu = array([[ 0.13521486],
       [-0.14942097],
       [-1.40888002],
       [-0.47194681]])
cov_sqrt = array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:24: in multivariate_normal
    log_prob = mvn.log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1287: in log_prob
    return self._call_log_prob(value, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1269: in _call_log_prob
    return self._log_prob(value, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:1350: in _fn
    return fn(*args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:243: in _log_prob
    return super(MultivariateNormalLinearOperator, self)._log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:364: in _log_prob
    log_prob, _ = self.experimental_local_measure(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:611: in experimental_local_measure
    x = self.bijector.inverse(y, **bijector_kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:614: in _inverse
    return self._call_walk_inverse(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:352: in _call_walk_inverse
    return self._walk_inverse(step_fn, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/chain.py:150: in _walk_inverse
    y = step_fn(bij, y, **kwargs.get(bij.name, {}))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:615: in <lambda>
    lambda b, y, **kwargs: b.inverse(y, **kwargs),
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/scale_matvec_linear_operator.py:54: in _inverse
    return self.scale.solvevec(y, adjoint=self.adjoint)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/ops/linalg/linear_operator.py:1075: in solvevec
    self.shape, self_dim).assert_is_compatible_with(rhs.shape[-1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Dimension(4), other = 10

    def assert_is_compatible_with(self, other):
      """Raises an exception if `other` is not compatible with this Dimension.
    
      Args:
        other: Another Dimension.
    
      Raises:
        ValueError: If `self` and `other` are not compatible (see
          is_compatible_with).
      """
      if not self.is_compatible_with(other):
>       raise ValueError("Dimensions %s and %s are not compatible" %
                         (self, other))
E       ValueError: Dimensions 4 and 10 are not compatible

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/framework/tensor_shape.py:303: ValueError
__________________ test_multivariate_normal[cov_sqrt1-mu1-x1] __________________

x = array([[-0.18393875],
       [ 0.35718712],
       [ 1.30453327],
       [-0.86865434]])
mu = array([[ 0.13521486],
       [-0.14942097],
       [-1.40888002],
       [-0.47194681]])
cov_sqrt = array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])

    @pytest.mark.parametrize("x", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("mu", [randn(4, 10), randn(4, 1)])
    @pytest.mark.parametrize("cov_sqrt", [randn(4, 4), np.eye(4)])
    def test_multivariate_normal(x: AnyNDArray, mu: AnyNDArray, cov_sqrt: AnyNDArray) -> None:
        cov = np.dot(cov_sqrt, cov_sqrt.T)
        L = np.linalg.cholesky(cov)
    
>       gp_result = logdensities.multivariate_normal(x, mu, L)

/local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/logdensities.py:50: in multivariate_normal
    return multivariate_normal(x, mu, L)
/local/data0/moved_data/publishablew/GPflow/GPflow/gpflow/temp.py:24: in multivariate_normal
    log_prob = mvn.log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1287: in log_prob
    return self._call_log_prob(value, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/distribution.py:1269: in _call_log_prob
    return self._log_prob(value, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/distribution_util.py:1350: in _fn
    return fn(*args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/mvn_linear_operator.py:243: in _log_prob
    return super(MultivariateNormalLinearOperator, self)._log_prob(x)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:364: in _log_prob
    log_prob, _ = self.experimental_local_measure(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/distributions/transformed_distribution.py:611: in experimental_local_measure
    x = self.bijector.inverse(y, **bijector_kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:614: in _inverse
    return self._call_walk_inverse(
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:352: in _call_walk_inverse
    return self._walk_inverse(step_fn, *args, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/chain.py:150: in _walk_inverse
    y = step_fn(bij, y, **kwargs.get(bij.name, {}))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/composition.py:615: in <lambda>
    lambda b, y, **kwargs: b.inverse(y, **kwargs),
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1390: in inverse
    return self._call_inverse(y, name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/bijector.py:1370: in _call_inverse
    return self._cache.inverse(y, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:347: in inverse
    return self._lookup(y, self._inverse_name, self._forward_name, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:493: in _lookup
    self._invoke(input, forward_name, kwargs, attrs))
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/internal/cache_util.py:532: in _invoke
    return getattr(self.bijector, fn_name)(input, **kwargs)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/bijectors/scale_matvec_linear_operator.py:54: in _inverse
    return self.scale.solvevec(y, adjoint=self.adjoint)
/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/ops/linalg/linear_operator.py:1075: in solvevec
    self.shape, self_dim).assert_is_compatible_with(rhs.shape[-1])
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Dimension(4), other = 1

    def assert_is_compatible_with(self, other):
      """Raises an exception if `other` is not compatible with this Dimension.
    
      Args:
        other: Another Dimension.
    
      Raises:
        ValueError: If `self` and `other` are not compatible (see
          is_compatible_with).
      """
      if not self.is_compatible_with(other):
>       raise ValueError("Dimensions %s and %s are not compatible" %
                         (self, other))
E       ValueError: Dimensions 4 and 1 are not compatible

/local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow/python/framework/tensor_shape.py:303: ValueError
=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if (distutils.version.LooseVersion(tf.__version__) <

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    distutils.version.LooseVersion(required_tensorflow_version)):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0]
FAILED ../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1]
======================== 8 failed, 2 warnings in 1.76s =========================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/GPflow/GPflow/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/GPflow/GPflow
collecting ... collected 8 items

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1] PASSED

=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if (distutils.version.LooseVersion(tf.__version__) <

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    distutils.version.LooseVersion(required_tensorflow_version)):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 8 passed, 2 warnings in 0.66s =========================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/GPflow/GPflow/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/GPflow/GPflow
collecting ... collected 8 items

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu0-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt0-mu1-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu0-x1] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x0] PASSED
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/tests/gpflow/test_logdensities.py::test_multivariate_normal[cov_sqrt1-mu1-x1] PASSED

=============================== warnings summary ===============================
../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:57: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if (distutils.version.LooseVersion(tf.__version__) <

../../../../../../local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58
  /local/data0/moved_data/publishablew/GPflow/GPflow/venv/lib/python3.11/site-packages/tensorflow_probability/python/__init__.py:58: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    distutils.version.LooseVersion(required_tensorflow_version)):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 8 passed, 2 warnings in 1.34s =========================
