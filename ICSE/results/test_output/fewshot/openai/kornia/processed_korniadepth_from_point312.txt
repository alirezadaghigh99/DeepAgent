output file:
processed_korniadepth_from_point312.json
function:
depth_from_point
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'jit', 'onnxrt', 'openxla', 'inductor', 'cudagraphs', 'tvm', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED

=================================== FAILURES ===================================
________ TestMotionFromEssentialChooseSolution.test_smoke[cpu-float32] _________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2ed40>
device = device(type='cpu'), dtype = torch.float32

    def test_smoke(self, device, dtype):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        x2 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)
>       assert R.shape == (1, 3, 3)
E       AssertionError: assert torch.Size([1, 1, 3, 3]) == (1, 3, 3)
E         
E         At index 1 diff: 1 != 3
E         Left contains one more item: 3
E         
E         Full diff:
E         + torch.Size([1, 1, 3, 3])
E         - (...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:418: AssertionError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-1-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2f1f0>
batch_size = 1, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.2731,  0.2133,  0.6018],
          [ 0.0397,  0.5322,  0.7526],
          [-0.1804,  0.1247,  0.4870]],
...         [[ 0.3722, -0.3320, -0.6360],
          [ 0.0201, -0.7325, -0.8786],
          [ 0.2838, -0.2681, -0.3953]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2f130>
batch_size = 2, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.1562, -0.2019, -0.6497],
          [ 0.1509,  0.4113, -0.4263],
          [-0.5282, -0.1840, -0.3663]],
...         [[-0.0834,  0.6237, -0.3574],
          [-0.0724,  0.6043, -0.3522],
          [-0.0782,  0.6246, -0.3550]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-8] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2f4f0>
batch_size = 2, num_points = 8, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 4.3724e-01, -8.0836e-02, -3.5084e-01],
          [ 4.0772e-01, -1.6137e-01, -3.3840e-01],
          [ 4.29... -5.0891e-01],
          [ 5.0238e-01, -1.2924e-01, -5.2557e-01],
          [ 4.8775e-01, -3.8430e-02, -4.3889e-01]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-3-2] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2f5b0>
batch_size = 3, num_points = 2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-1.0080e+00, -2.5207e-01,  9.2118e-01],
          [-8.9985e-01, -2.1556e-01,  1.0464e+00]],

         [[ 1....4.2324e-01]],

         [[-7.6065e-01,  3.1405e-01,  5.5381e-01],
          [-6.8748e-01,  5.3657e-01,  4.2324e-01]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (2) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_______ TestMotionFromEssentialChooseSolution.test_masking[cpu-float32] ________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2f880>
device = device(type='cpu'), dtype = torch.float32

    def test_masking(self, device, dtype):
        E_mat = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(2, 10, 2, device=device, dtype=dtype)
        x2 = torch.rand(2, 10, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[:, 1:-1, :], x2[:, 1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-1.7803e-01,  1.0495e+00, -3.0676e-01],
          [-2.1003e-02,  1.0153e+00, -6.4180e-03],
          [ 1.80... -3.4665e-01],
          [-1.1209e+01, -5.7308e+00, -3.7638e+00],
          [-3.1399e-01,  7.8395e-02, -3.5150e-01]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-10] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2fc70>
num_points = 10, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 0.4678, -0.0407, -0.2023],
          [ 0.1896,  0.1085, -0.1886],
          [ 0.3851, -0.0659, -0.0835],
 ...          [-0.1935,  0.3895, -0.1599],
          [-0.0331,  0.2936, -0.1767],
          [-0.1969,  0.2853, -0.0675]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-15] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2fbb0>
num_points = 15, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 0.1116, -5.7412, -0.6166],
          [ 0.6391,  3.0011,  0.5634],
          [ 0.8076,  0.7189,  0.5437],
 ...          [-0.0155,  1.4297,  0.5984],
          [ 0.4935, -0.4176,  0.8669],
          [-0.6196,  3.8016, -0.9656]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (13) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-20] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf2feb0>
num_points = 20, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-9.5877e-02,  3.1625e-01, -2.0988e-01],
          [-1.4066e+00,  5.5943e-01, -2.6567e-01],
          [-6.90... -2.5976e-01],
          [ 1.2110e+00, -1.1462e+00,  4.2873e-01],
          [ 1.7545e+00, -1.2851e-01, -2.9639e-01]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (18) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_______ TestMotionFromEssentialChooseSolution.test_two_view[cpu-float32] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf641c0>
device = device(type='cpu'), dtype = torch.float32

    def test_two_view(self, device, dtype):
        scene = generate_two_view_random_scene(device, dtype)
    
        E_mat = epi.essential_from_Rt(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
    
        R, t = epi.relative_camera_motion(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
        t = torch.nn.functional.normalize(t, dim=1)
    
>       R_hat, t_hat, _ = epi.motion_from_essential_choose_solution(
            E_mat, scene["K1"], scene["K2"], scene["x1"], scene["x2"]
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.2773, -0.0515, -0.3132],
          [-0.2014,  0.0484, -0.2171],
          [-0.1459,  0.0838, -0.2449],
 ...          [-0.7083, -0.0232, -0.9850],
          [-0.4025,  0.0301, -0.4714],
          [-0.5256, -0.0574, -0.6076]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (30) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
__________ TestMotionFromEssentialChooseSolution.test_gradcheck[cpu] ___________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7dea6cf64490>
device = device(type='cpu')

    def test_gradcheck(self, device):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=torch.float64, requires_grad=True)
        K1 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        K2 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        x1 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
        x2 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
    
>       self.gradcheck(
            epi.motion_from_essential_choose_solution,
            (E_mat, K1, K2, x1, x2),
            requires_grad=(True, False, False, False, False),
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...        [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]], dtype=torch.float64)
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]], dtype=torch.float64)
X = tensor([[[[ 0.6663, -0.7029, -0.3233],
          [ 0.1238, -0.0156,  0.0459]],

         [[-0.6663,  0.7029,  0.3233],....4636,  0.5124,  0.2372],
          [-0.0228,  0.1453,  0.1126]]]], dtype=torch.float64,
       grad_fn=<MulBackward0>)

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R (Tensor): The rotation matrix with shape (*, 3, 3).
            t (Tensor): The translation vector with shape (*, 3, 1).
            X (Tensor): The 3D points with shape (*, 3).
    
        Returns:
            Tensor: The depth value per point with shape (*, 1).
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       transformed_points = torch.matmul(R, X.unsqueeze(-1)) + t
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (2) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]
============================== 11 failed in 0.65s ==============================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'jit', 'tvm', 'cudagraphs', 'onnxrt', None, 'openxla'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.22s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'openxla', 'tvm', 'cudagraphs', 'onnxrt', 'jit', 'inductor', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.21s ==============================
