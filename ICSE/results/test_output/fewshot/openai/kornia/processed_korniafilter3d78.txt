output file:
processed_korniafilter3d78.json
function:
filter3d
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32] FAILED'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'onnxrt', 'cudagraphs', 'tvm', 'openxla', 'jit', 'inductor', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 22 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_exception FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_module SKIPPED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False] FAILED

=================================== FAILURES ===================================
______________ TestFilter3D.test_smoke[cpu-float32-True-constant] ______________

self = <test_filters.TestFilter3D object at 0x764558b2e500>
border_type = 'constant', normalized = True, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.6879, 0.5665, 0.1547],
          [0.6196, 0.3879, 0.0828],
          [0.4154, 0.9190, 0.9249]],

        ...3608]],

         [[0.5409, 0.5629, 0.1295],
          [0.3795, 0.2291, 0.0600],
          [0.3322, 0.6313, 0.9597]]]])
border_type = 'constant', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
______________ TestFilter3D.test_smoke[cpu-float32-True-reflect] _______________

self = <test_filters.TestFilter3D object at 0x764558b2e320>
border_type = 'reflect', normalized = True, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.7111, 0.3630, 0.5842],
          [0.0039, 0.2563, 0.0610],
          [0.5759, 0.9183, 0.4744]],

        ...2482]],

         [[0.1161, 0.7312, 0.8274],
          [0.0409, 0.9319, 0.8203],
          [0.1949, 0.0268, 0.1150]]]])
border_type = 'reflect', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_smoke[cpu-float32-True-replicate] ______________

self = <test_filters.TestFilter3D object at 0x764558b2e860>
border_type = 'replicate', normalized = True, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.2838, 0.7525, 0.8621],
          [0.0108, 0.4762, 0.1745],
          [0.3647, 0.8909, 0.0211]],

        ...2848]],

         [[0.3301, 0.0859, 0.5233],
          [0.3790, 0.6438, 0.1293],
          [0.7622, 0.2095, 0.2091]]]])
border_type = 'replicate', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
______________ TestFilter3D.test_smoke[cpu-float32-True-circular] ______________

self = <test_filters.TestFilter3D object at 0x764558b2e920>
border_type = 'circular', normalized = True, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.8225, 0.2970, 0.3851],
          [0.8312, 0.4193, 0.9876],
          [0.4380, 0.1566, 0.8818]],

        ...2277]],

         [[0.8002, 0.4801, 0.8455],
          [0.5593, 0.0590, 0.0388],
          [0.2831, 0.6323, 0.3328]]]])
border_type = 'circular', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_smoke[cpu-float32-False-constant] ______________

self = <test_filters.TestFilter3D object at 0x764558b2e9e0>
border_type = 'constant', normalized = False, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.9715, 0.3668, 0.9031],
          [0.7504, 0.7684, 0.9573],
          [0.7445, 0.3012, 0.5137]],

        ...5738]],

         [[0.6502, 0.5298, 0.5296],
          [0.5070, 0.3929, 0.9605],
          [0.5960, 0.4324, 0.8246]]]])
border_type = 'constant', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
______________ TestFilter3D.test_smoke[cpu-float32-False-reflect] ______________

self = <test_filters.TestFilter3D object at 0x764558b2eaa0>
border_type = 'reflect', normalized = False, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.0068, 0.2922, 0.3432],
          [0.8478, 0.2267, 0.8811],
          [0.5628, 0.1617, 0.2867]],

        ...4424]],

         [[0.4611, 0.3116, 0.9347],
          [0.7548, 0.6280, 0.5001],
          [0.3427, 0.2228, 0.7630]]]])
border_type = 'reflect', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_smoke[cpu-float32-False-replicate] _____________

self = <test_filters.TestFilter3D object at 0x764558b2eb60>
border_type = 'replicate', normalized = False, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.1344, 0.8421, 0.9720],
          [0.1709, 0.1997, 0.7367],
          [0.2342, 0.9756, 0.6430]],

        ...5025]],

         [[0.1091, 0.5382, 0.5794],
          [0.7009, 0.6246, 0.2409],
          [0.3239, 0.2013, 0.1471]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_smoke[cpu-float32-False-circular] ______________

self = <test_filters.TestFilter3D object at 0x764558b2ec20>
border_type = 'circular', normalized = False, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("border_type", ["constant", "reflect", "replicate", "circular"])
    @pytest.mark.parametrize("normalized", [True, False])
    def test_smoke(self, border_type, normalized, device, dtype):
        if torch_version_le(1, 9, 1) and border_type == "reflect":
            pytest.skip(reason="Reflect border is not implemented for 3D on torch < 1.9.1")
    
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(1, 1, 6, 7, 8, device=device, dtype=dtype)
>       actual = filter3d(data, kernel, border_type, normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ... 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]])
kernel = tensor([[[[0.3942, 0.8987, 0.5016],
          [0.8170, 0.7973, 0.9992],
          [0.9650, 0.2631, 0.8095]],

        ...1469]],

         [[0.8230, 0.7758, 0.4025],
          [0.2221, 0.7949, 0.9658],
          [0.2976, 0.1704, 0.3770]]]])
border_type = 'circular', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________ TestFilter3D.test_cardinality[cpu-float32-2] _________________

self = <test_filters.TestFilter3D object at 0x764558b2efb0>, batch_size = 2
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [2, 3, 6, 8])
    def test_cardinality(self, batch_size, device, dtype):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(batch_size, 3, 6, 7, 8, device=device, dtype=dtype)
>       assert filter3d(data, kernel).shape == data.shape

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.8995, 0.8454, 0.5239],
          [0.1304, 0.7129, 0.1211],
          [0.3703, 0.5965, 0.0504]],

        ...5024]],

         [[0.0344, 0.4826, 0.2643],
          [0.4995, 0.4183, 0.0476],
          [0.2446, 0.0417, 0.2761]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________ TestFilter3D.test_cardinality[cpu-float32-3] _________________

self = <test_filters.TestFilter3D object at 0x764558b2eef0>, batch_size = 3
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [2, 3, 6, 8])
    def test_cardinality(self, batch_size, device, dtype):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(batch_size, 3, 6, 7, 8, device=device, dtype=dtype)
>       assert filter3d(data, kernel).shape == data.shape

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.9295, 0.3456, 0.8597],
          [0.5896, 0.4703, 0.7083],
          [0.6322, 0.4809, 0.2388]],

        ...8168]],

         [[0.4300, 0.8491, 0.6775],
          [0.4604, 0.9469, 0.7671],
          [0.0518, 0.5099, 0.2658]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________ TestFilter3D.test_cardinality[cpu-float32-6] _________________

self = <test_filters.TestFilter3D object at 0x764558b2f250>, batch_size = 6
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [2, 3, 6, 8])
    def test_cardinality(self, batch_size, device, dtype):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(batch_size, 3, 6, 7, 8, device=device, dtype=dtype)
>       assert filter3d(data, kernel).shape == data.shape

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.2177, 0.2604, 0.6454],
          [0.3601, 0.1603, 0.9340],
          [0.5529, 0.0304, 0.0262]],

        ...6822]],

         [[0.1536, 0.9069, 0.0039],
          [0.2231, 0.0622, 0.0674],
          [0.1011, 0.3264, 0.3130]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________ TestFilter3D.test_cardinality[cpu-float32-8] _________________

self = <test_filters.TestFilter3D object at 0x764558b2f310>, batch_size = 8
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [2, 3, 6, 8])
    def test_cardinality(self, batch_size, device, dtype):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(batch_size, 3, 6, 7, 8, device=device, dtype=dtype)
>       assert filter3d(data, kernel).shape == data.shape

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:390: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.6318, 0.3106, 0.8263],
          [0.1956, 0.3545, 0.7951],
          [0.9590, 0.9212, 0.5531]],

        ...1155]],

         [[0.8146, 0.4737, 0.6124],
          [0.0085, 0.5536, 0.1462],
          [0.6327, 0.8917, 0.3534]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________________ TestFilter3D.test_exception __________________________

self = <test_filters.TestFilter3D object at 0x764558b2f4c0>

    def test_exception(self):
        k = torch.ones(1, 1, 1, 1)
        data = torch.ones(1, 1, 1, 1, 1)
        with pytest.raises(TypeError) as errinfo:
>           filter3d(1, k)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = 1, kernel = tensor([[[[1.]]]]), border_type = 'replicate'
normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
__________________ TestFilter3D.test_mean_filter[cpu-float32] __________________

self = <test_filters.TestFilter3D object at 0x764558b2f7c0>
device = device(type='cpu'), dtype = torch.float32

    def test_mean_filter(self, device, dtype):
        kernel = torch.ones(1, 3, 3, 3, device=device, dtype=dtype)
        sample = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       actual = filter3d(sample, kernel)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:481: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0.,...0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]]]]])
kernel = tensor([[[[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
____________ TestFilter3D.test_mean_filter_2batch_2ch[cpu-float32] _____________

self = <test_filters.TestFilter3D object at 0x764558b2faf0>
device = device(type='cpu'), dtype = torch.float32

    def test_mean_filter_2batch_2ch(self, device, dtype):
        kernel = torch.ones(1, 3, 3, 3, device=device, dtype=dtype)
        sample = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
        sample = sample.expand(2, 2, -1, -1, -1)
    
        expected = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 5.0, 5.0, 5.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
        expected = expected.expand(2, 2, -1, -1, -1)
    
>       actual = filter3d(sample, kernel)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:552: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0.,...0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]]]]])
kernel = tensor([[[[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
____________ TestFilter3D.test_normalized_mean_filter[cpu-float32] _____________

self = <test_filters.TestFilter3D object at 0x764558b2fe20>
device = device(type='cpu'), dtype = torch.float32

    def test_normalized_mean_filter(self, device, dtype):
        kernel = torch.ones(1, 3, 3, 3, device=device, dtype=dtype)
        sample = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
        sample = sample.expand(2, 2, -1, -1, -1)
    
        nv = 5.0 / 27  # normalization value
        expected = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, nv, nv, nv, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
        expected = expected.expand(2, 2, -1, -1, -1)
    
>       actual = filter3d(sample, kernel, normalized=True)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:624: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0.,...0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]]]]])
kernel = tensor([[[[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]],

         [[1., 1., 1.],
          [1., 1., 1.],
          [1., 1., 1.]]]])
border_type = 'replicate', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_______________ TestFilter3D.test_even_sized_filter[cpu-float32] _______________

self = <test_filters.TestFilter3D object at 0x764558b54190>
device = device(type='cpu'), dtype = torch.float32

    def test_even_sized_filter(self, device, dtype):
        kernel = torch.ones(1, 2, 2, 2, device=device, dtype=dtype)
        sample = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected = torch.tensor(
            [
                [
                    [
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 0.0, 0.0],
                            [0.0, 5.0, 5.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                        [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                        ],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       actual = filter3d(sample, kernel)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:694: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0.,...0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0.]]]]])
kernel = tensor([[[[1., 1.],
          [1., 1.]],

         [[1., 1.],
          [1., 1.]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_________________ TestFilter3D.test_noncontiguous[cpu-float32] _________________

self = <test_filters.TestFilter3D object at 0x764558b544c0>
device = device(type='cpu'), dtype = torch.float32

    def test_noncontiguous(self, device, dtype):
        batch_size = 3
        inp = torch.rand(3, 5, 5, 5, device=device, dtype=dtype).expand(batch_size, -1, -1, -1, -1)
        kernel = torch.ones(1, 2, 2, 2, device=device, dtype=dtype)
    
>       actual = filter3d(inp, kernel)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:702: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[4.5279e-01, 1.5453e-01, 5.9098e-01, 9.1506e-01, 2.9666e-02],
           [1.7272e-01, 1.6042e-01, 7.6435e-0...e-02, 7.0360e-01, 7.8589e-02, 3.0890e-01],
           [5.6084e-01, 4.0559e-01, 3.8376e-01, 6.0207e-01, 7.7211e-01]]]]])
kernel = tensor([[[[1., 1.],
          [1., 1.]],

         [[1., 1.],
          [1., 1.]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_______________________ TestFilter3D.test_gradcheck[cpu] _______________________

self = <test_filters.TestFilter3D object at 0x764558b54790>
device = device(type='cpu')

    def test_gradcheck(self, device):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=torch.float64)
        sample = torch.ones(1, 1, 6, 7, 8, device=device, dtype=torch.float64)
    
        # evaluate function gradient
>       self.gradcheck(filter3d, (sample, kernel), nondet_tol=1e-8)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., ..., 1., 1., 1., 1., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1.]]]]], dtype=torch.float64,
       requires_grad=True)
kernel = tensor([[[[0.0216, 0.3001, 0.7049],
          [0.6199, 0.4839, 0.2568],
          [0.7121, 0.3570, 0.6086]],

        ...9],
          [0.1604, 0.0684, 0.4726],
          [0.9605, 0.5637, 0.0283]]]], dtype=torch.float64, requires_grad=True)
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_dynamo[cpu-float32-inductor-True] ______________

self = <test_filters.TestFilter3D object at 0x764558b54dc0>, normalized = True
device = device(type='cpu'), dtype = torch.float32
torch_optimizer = functools.partial(<function compile at 0x76462df23400>, backend='inductor')

    @pytest.mark.parametrize("normalized", [True, False])
    def test_dynamo(self, normalized, device, dtype, torch_optimizer):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(2, 3, 4, 10, 10, device=device, dtype=dtype)
        op = filter3d
        op_optimized = torch_optimizer(op)
    
>       expected = op(data, kernel, normalized=normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.1945, 0.8456, 0.0858],
          [0.0116, 0.4200, 0.8766],
          [0.3690, 0.1482, 0.7848]],

        ...2469]],

         [[0.9979, 0.4128, 0.6939],
          [0.5358, 0.5115, 0.7235],
          [0.6279, 0.3862, 0.0446]]]])
border_type = 'replicate', normalized = True

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
_____________ TestFilter3D.test_dynamo[cpu-float32-inductor-False] _____________

self = <test_filters.TestFilter3D object at 0x764558b54d30>, normalized = False
device = device(type='cpu'), dtype = torch.float32
torch_optimizer = functools.partial(<function compile at 0x76462df23400>, backend='inductor')

    @pytest.mark.parametrize("normalized", [True, False])
    def test_dynamo(self, normalized, device, dtype, torch_optimizer):
        kernel = torch.rand(1, 3, 3, 3, device=device, dtype=dtype)
        data = torch.ones(2, 3, 4, 10, 10, device=device, dtype=dtype)
        op = filter3d
        op_optimized = torch_optimizer(op)
    
>       expected = op(data, kernel, normalized=normalized)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/filter.py:142: in filter3d
    return filter3d(input, kernel, border_type, normalized)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[[1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1....., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.],
           [1., 1., 1.,  ..., 1., 1., 1.]]]]])
kernel = tensor([[[[0.5123, 0.0194, 0.6244],
          [0.3144, 0.1926, 0.1974],
          [0.8411, 0.5196, 0.1594]],

        ...1351]],

         [[0.3283, 0.7920, 0.1800],
          [0.3103, 0.6939, 0.0082],
          [0.9226, 0.5173, 0.6413]]]])
border_type = 'replicate', normalized = False

    def filter3d(input: torch.Tensor, kernel: torch.Tensor, border_type: str='reflect', normalized: bool=False) -> torch.Tensor:
        """
        Convolves a 3D kernel with a given input tensor.
    
        Args:
            input (torch.Tensor): Input tensor of shape (B, C, D, H, W).
            kernel (torch.Tensor): Kernel tensor to be convolved with the input.
            border_type (str): Padding mode to be applied before convolving. Options: 'reflect', 'replicate', 'constant', 'circular'.
            normalized (bool): If True, normalize the kernel using L1 norm.
    
        Returns:
            torch.Tensor: Convolved tensor of the same shape as the input (B, C, D, H, W).
        """
        if kernel.dim() != 3:
>           raise ValueError('Kernel must be a 3D tensor.')
E           ValueError: Kernel must be a 3D tensor.

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:23: ValueError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_exception
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False]
======================== 21 failed, 1 skipped in 0.73s =========================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'onnxrt', 'cudagraphs', 'inductor', 'tvm', 'openxla', 'jit', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 22 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_exception PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_module SKIPPED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False] PASSED

======================== 21 passed, 1 skipped in 2.15s =========================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'openxla', 'inductor', 'jit', 'onnxrt', 'tvm', None, 'cudagraphs'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 22 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-True-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-constant] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-reflect] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-replicate] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_smoke[cpu-float32-False-circular] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-6] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_cardinality[cpu-float32-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_exception PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_mean_filter_2batch_2ch[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_normalized_mean_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_even_sized_filter[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_noncontiguous[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_gradcheck[cpu] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_module SKIPPED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-True] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_filters.py::TestFilter3D::test_dynamo[cpu-float32-inductor-False] PASSED

======================== 21 passed, 1 skipped in 2.19s =========================
