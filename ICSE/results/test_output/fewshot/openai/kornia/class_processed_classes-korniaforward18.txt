output file:
processed_classes-korniaforward18.json
function:
forward
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu] FAILED [ 66%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True] FAILED [  6%]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06] FAILED [ 33%]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1] FAILED [ 40%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001] FAILED [ 46%]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0] FAILED [ 20%]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False] FAILED [ 13%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu] FAILED [ 60%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0]'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python3
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'cudagraphs', 'openxla', 'tvm', 'onnxrt', 'inductor', 'jit', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 15 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True] FAILED [  6%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False] FAILED [ 13%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0] FAILED [ 20%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-1] FAILED [ 26%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06] FAILED [ 33%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1] FAILED [ 40%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001] FAILED [ 46%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_individual_transforms[cpu] PASSED [ 53%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu] FAILED [ 60%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu] FAILED [ 66%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted[cpu-float32] PASSED [ 73%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted_inv[cpu-float32] PASSED [ 80%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_jit[cpu-float32] FAILED [ 86%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-True] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-False] PASSED [100%]

=================================== FAILURES ===================================
_________________ TestZCA.test_zca_unbiased[cpu-float32-True] __________________

self = <test_zca.TestZCA object at 0x7c38a4721750>, unbiased = True
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("unbiased", [True, False])
    def test_zca_unbiased(self, unbiased, device, dtype):
        data = torch.tensor([[0, 1], [1, 0], [-1, 0], [0, -1]], device=device, dtype=dtype)
    
        if unbiased:
            unbiased_val = 1.5
        else:
            unbiased_val = 2.0
    
        expected = torch.sqrt(unbiased_val * torch.abs(data)) * torch.sign(data)
    
        zca = kornia.enhance.ZCAWhitening(unbiased=unbiased).fit(data)
    
>       actual = zca(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 0.,  1.],
        [ 1.,  0.],
        [-1.,  0.],
        [ 0., -1.]])
b = tensor([[1.2247, 0.0000],
        [0.0000, 1.2247]]), dims = ([0], [0])
out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 4 in dim 0 and second has size 2 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
_________________ TestZCA.test_zca_unbiased[cpu-float32-False] _________________

self = <test_zca.TestZCA object at 0x7c38a47216c0>, unbiased = False
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("unbiased", [True, False])
    def test_zca_unbiased(self, unbiased, device, dtype):
        data = torch.tensor([[0, 1], [1, 0], [-1, 0], [0, -1]], device=device, dtype=dtype)
    
        if unbiased:
            unbiased_val = 1.5
        else:
            unbiased_val = 2.0
    
        expected = torch.sqrt(unbiased_val * torch.abs(data)) * torch.sign(data)
    
        zca = kornia.enhance.ZCAWhitening(unbiased=unbiased).fit(data)
    
>       actual = zca(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 0.,  1.],
        [ 1.,  0.],
        [-1.,  0.],
        [ 0., -1.]])
b = tensor([[1.4142, 0.0000],
        [0.0000, 1.4142]]), dims = ([0], [0])
out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 4 in dim 0 and second has size 2 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
_____________________ TestZCA.test_dim_args[cpu-float32-0] _____________________

self = <test_zca.TestZCA object at 0x7c38a4721c30>, dim = 0
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("dim", [0, 1])
    def test_dim_args(self, dim, device, dtype):
        if "xla" in device.type:
            pytest.skip("buggy with XLA devices.")
    
        if dtype == torch.float16:
            pytest.skip("not work for half-precision")
    
        data = torch.tensor([[0, 1], [1, 0], [-1, 0], [0, -1]], device=device, dtype=dtype)
    
        if dim == 1:
            expected = torch.tensor(
                [
                    [-0.35360718, 0.35360718],
                    [0.35351562, -0.35351562],
                    [-0.35353088, 0.35353088],
                    [0.35353088, -0.35353088],
                ],
                device=device,
                dtype=dtype,
            )
        elif dim == 0:
            expected = torch.tensor(
                [[0.0, 1.2247448], [1.2247448, 0.0], [-1.2247448, 0.0], [0.0, -1.2247448]], device=device, dtype=dtype
            )
    
        zca = kornia.enhance.ZCAWhitening(dim=dim)
>       actual = zca(data, True)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 0.,  1.],
        [ 1.,  0.],
        [-1.,  0.],
        [ 0., -1.]])
b = tensor([[1.2247, 0.0000],
        [0.0000, 1.2247]]), dims = ([0], [0])
out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 4 in dim 0 and second has size 2 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
_____________________ TestZCA.test_dim_args[cpu-float32-1] _____________________

self = <test_zca.TestZCA object at 0x7c38a4721b70>, dim = 1
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("dim", [0, 1])
    def test_dim_args(self, dim, device, dtype):
        if "xla" in device.type:
            pytest.skip("buggy with XLA devices.")
    
        if dtype == torch.float16:
            pytest.skip("not work for half-precision")
    
        data = torch.tensor([[0, 1], [1, 0], [-1, 0], [0, -1]], device=device, dtype=dtype)
    
        if dim == 1:
            expected = torch.tensor(
                [
                    [-0.35360718, 0.35360718],
                    [0.35351562, -0.35351562],
                    [-0.35353088, 0.35353088],
                    [0.35353088, -0.35353088],
                ],
                device=device,
                dtype=dtype,
            )
        elif dim == 0:
            expected = torch.tensor(
                [[0.0, 1.2247448], [1.2247448, 0.0], [-1.2247448, 0.0], [0.0, -1.2247448]], device=device, dtype=dtype
            )
    
        zca = kornia.enhance.ZCAWhitening(dim=dim)
>       actual = zca(data, True)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ZCAWhitening()
x = tensor([[ 0.,  1.],
        [ 1.,  0.],
        [-1.,  0.],
        [ 0., -1.]])
include_fit = True

    def forward(self, x: Tensor, include_fit: bool=False) -> Tensor:
        """
        Apply the ZCA whitening transform to the input data tensor x.
    
        Args:
            x (Tensor): Input data tensor.
            include_fit (bool): Whether to fit the model on the input data.
    
        Returns:
            Tensor: Transformed data.
        """
        if include_fit:
            self.fit(x)
        if not self.fitted:
            raise RuntimeError('The ZCAWhitening instance is not fitted yet. Please fit the model first.')
>       x_centered = x - self.mean_vector
E       RuntimeError: The size of tensor a (2) must match the size of tensor b (4) at non-singleton dimension 1

/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:113: RuntimeError
____________ TestZCA.test_identity[cpu-float32-input_shape0-1e-06] _____________

self = <test_zca.TestZCA object at 0x7c38a47220e0>, input_shape = (15, 2, 2, 2)
eps = 1e-06, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("input_shape,eps", [((15, 2, 2, 2), 1e-6), ((10, 4), 0.1), ((20, 3, 2, 2), 1e-3)])
    def test_identity(self, input_shape, eps, device, dtype):
        """Assert that data can be recovered by the inverse transform."""
        data = torch.randn(*input_shape, device=device, dtype=dtype)
    
        zca = kornia.enhance.ZCAWhitening(compute_inv=True, eps=eps).fit(data)
    
>       data_w = zca(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ZCAWhitening()
x = tensor([[[[-6.3558e-01,  1.4789e-01],
          [-5.5745e-01,  2.0333e-03]],

         [[-1.0554e+00, -2.5684e-01],
  ...
          [-6.0229e-01, -4.5351e-01]],

         [[-9.3104e-01,  4.6113e-01],
          [ 1.6387e+00, -7.7423e-02]]]])
include_fit = False

    def forward(self, x: Tensor, include_fit: bool=False) -> Tensor:
        """
        Apply the ZCA whitening transform to the input data tensor x.
    
        Args:
            x (Tensor): Input data tensor.
            include_fit (bool): Whether to fit the model on the input data.
    
        Returns:
            Tensor: Transformed data.
        """
        if include_fit:
            self.fit(x)
        if not self.fitted:
            raise RuntimeError('The ZCAWhitening instance is not fitted yet. Please fit the model first.')
>       x_centered = x - self.mean_vector
E       RuntimeError: The size of tensor a (2) must match the size of tensor b (8) at non-singleton dimension 3

/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:113: RuntimeError
_____________ TestZCA.test_identity[cpu-float32-input_shape1-0.1] ______________

self = <test_zca.TestZCA object at 0x7c38a4722020>, input_shape = (10, 4)
eps = 0.1, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("input_shape,eps", [((15, 2, 2, 2), 1e-6), ((10, 4), 0.1), ((20, 3, 2, 2), 1e-3)])
    def test_identity(self, input_shape, eps, device, dtype):
        """Assert that data can be recovered by the inverse transform."""
        data = torch.randn(*input_shape, device=device, dtype=dtype)
    
        zca = kornia.enhance.ZCAWhitening(compute_inv=True, eps=eps).fit(data)
    
>       data_w = zca(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 0.0820,  0.0612,  1.2729,  0.2104],
        [-0.0612, -0.0664, -0.1797,  1.3997],
        [-0.1107,  1.5084,...0.1444, -0.3635,  0.7933],
        [-1.8093, -0.9869, -0.0697,  0.4392],
        [ 0.9530,  0.2960, -0.8365,  0.9303]])
b = tensor([[ 1.1124, -0.1796,  0.1927,  0.1199],
        [-0.1796,  1.1538,  0.0592, -0.0776],
        [ 0.1927,  0.0592,  1.3104,  0.2352],
        [ 0.1199, -0.0776,  0.2352,  0.9701]])
dims = ([0], [0]), out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 10 in dim 0 and second has size 4 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
____________ TestZCA.test_identity[cpu-float32-input_shape2-0.001] _____________

self = <test_zca.TestZCA object at 0x7c38a4722380>, input_shape = (20, 3, 2, 2)
eps = 0.001, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("input_shape,eps", [((15, 2, 2, 2), 1e-6), ((10, 4), 0.1), ((20, 3, 2, 2), 1e-3)])
    def test_identity(self, input_shape, eps, device, dtype):
        """Assert that data can be recovered by the inverse transform."""
        data = torch.randn(*input_shape, device=device, dtype=dtype)
    
        zca = kornia.enhance.ZCAWhitening(compute_inv=True, eps=eps).fit(data)
    
>       data_w = zca(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ZCAWhitening()
x = tensor([[[[ 1.7083e-01,  1.1421e+00],
          [ 1.4832e+00, -4.1042e-01]],

         [[-1.9449e-01, -2.6678e-01],
  ...
          [ 1.8627e+00, -1.5449e-01]],

         [[-3.6868e-01,  6.2633e-01],
          [-5.5654e-01,  7.4621e-01]]]])
include_fit = False

    def forward(self, x: Tensor, include_fit: bool=False) -> Tensor:
        """
        Apply the ZCA whitening transform to the input data tensor x.
    
        Args:
            x (Tensor): Input data tensor.
            include_fit (bool): Whether to fit the model on the input data.
    
        Returns:
            Tensor: Transformed data.
        """
        if include_fit:
            self.fit(x)
        if not self.fitted:
            raise RuntimeError('The ZCAWhitening instance is not fitted yet. Please fit the model first.')
>       x_centered = x - self.mean_vector
E       RuntimeError: The size of tensor a (2) must match the size of tensor b (12) at non-singleton dimension 3

/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:113: RuntimeError
_____________________ TestZCA.test_grad_zca_with_fit[cpu] ______________________

self = <test_zca.TestZCA object at 0x7c38a4722890>, device = device(type='cpu')

    def test_grad_zca_with_fit(self, device):
        data = torch.tensor([[2, 0], [0, 1], [-2, 0], [0, -1]], device=device, dtype=torch.float64)
    
        def zca_fit(x):
            zca = kornia.enhance.ZCAWhitening(detach_transforms=False)
            return zca(x, include_fit=True)
    
>       self.gradcheck(zca_fit, (data,))

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:93: in zca_fit
    return zca(x, include_fit=True)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 2.,  0.],
        [ 0.,  1.],
        [-2.,  0.],
        [ 0., -1.]], dtype=torch.float64, grad_fn=<SubBackward0>)
b = tensor([[0.6124, 0.0000],
        [0.0000, 1.2247]], dtype=torch.float64, grad_fn=<MmBackward0>)
dims = ([0], [0]), out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 4 in dim 0 and second has size 2 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
______________________ TestZCA.test_grad_detach_zca[cpu] _______________________

self = <test_zca.TestZCA object at 0x7c38a4722b60>, device = device(type='cpu')

    def test_grad_detach_zca(self, device):
        data = torch.tensor([[1, 0], [0, 1], [-2, 0], [0, -1]], device=device, dtype=torch.float64)
    
        zca = kornia.enhance.ZCAWhitening()
    
        zca.fit(data)
    
>       self.gradcheck(zca, (data,))

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py:114: in forward
    transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = tensor([[ 1.2500,  0.0000],
        [ 0.2500,  1.0000],
        [-1.7500,  0.0000],
        [ 0.2500, -1.0000]], dtype=torch.float64, grad_fn=<SubBackward0>)
b = tensor([[0.7947, 0.0000],
        [0.0000, 1.2247]], dtype=torch.float64)
dims = ([0], [0]), out = None

    def tensordot(  # noqa: F811
        a,
        b,
        dims=2,
        out: Optional[torch.Tensor] = None,
    ):
        r"""Returns a contraction of a and b over multiple dimensions.
    
        :attr:`tensordot` implements a generalized matrix product.
    
        Args:
          a (Tensor): Left tensor to contract
          b (Tensor): Right tensor to contract
          dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to
             contract or explicit lists of dimensions for :attr:`a` and
             :attr:`b` respectively
    
        When called with a non-negative integer argument :attr:`dims` = :math:`d`, and
        the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,
        respectively, :func:`~torch.tensordot` computes
    
        .. math::
            r_{i_0,...,i_{m-d}, i_d,...,i_n}
              = \sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \times b_{k_0,...,k_{d-1}, i_d,...,i_n}.
    
        When called with :attr:`dims` of the list form, the given dimensions will be contracted
        in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes
        in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted
        dimensions.
    
        Examples::
    
            >>> a = torch.arange(60.).reshape(3, 4, 5)
            >>> b = torch.arange(24.).reshape(4, 3, 2)
            >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))
            tensor([[4400., 4730.],
                    [4532., 4874.],
                    [4664., 5018.],
                    [4796., 5162.],
                    [4928., 5306.]])
    
            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)
            >>> a = torch.randn(3, 4, 5, device='cuda')
            >>> b = torch.randn(4, 5, 6, device='cuda')
            >>> c = torch.tensordot(a, b, dims=2).cpu()
            tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],
                    [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],
                    [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])
    
            >>> a = torch.randn(3, 5, 4, 6)
            >>> b = torch.randn(6, 4, 5, 3)
            >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))
            tensor([[  7.7193,  -2.4867, -10.3204],
                    [  1.5513, -14.4737,  -6.5113],
                    [ -0.2850,   4.2573,  -3.5997]])
        """
        if has_torch_function_variadic(a, b):
            return handle_torch_function(tensordot, (a, b), a, b, dims=dims, out=out)
    
        if not isinstance(dims, (tuple, list, torch.Tensor, int, torch.SymInt)):
            raise RuntimeError(
                "tensordot expects dims to be int or "
                + "Tuple[List[int], List[int]] or "
                + "List[List[int]] containing two lists, but got "
                + f"dims={dims}"
            )
    
        dims_a: List[int] = []
        dims_b: List[int] = []
    
        if isinstance(dims, (tuple, list)):
            dims_a, dims_b = dims
    
        if isinstance(dims, torch.Tensor):
            num_elements = dims.numel()
            if num_elements > 1:
                assert dims.size()[0] == 2
                dims_a = torch.jit.annotate(List[int], dims[0].tolist())
                dims_b = torch.jit.annotate(List[int], dims[1].tolist())
            else:
                dims_val = int(dims.item())
                if dims_val < 0:
                    raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
                dims_a = list(range(-dims_val, 0))
                dims_b = list(range(dims_val))
    
        if isinstance(dims, (int, torch.SymInt)):
            if dims < 0:
                raise RuntimeError(f"tensordot expects dims >= 0, but got dims={dims}")
            if dims > min(a.dim(), b.dim()):
                raise RuntimeError(
                    f"tensordot expects dims < ndim_a or ndim_b, but got dims={dims}"
                )
            dims_a = list(range(-dims, 0))
            dims_b = list(range(dims))
    
        if out is None:
>           return _VF.tensordot(a, b, dims_a, dims_b)  # type: ignore[attr-defined]
E           RuntimeError: contracted dimensions need to match, but first has size 4 in dim 0 and second has size 2 in dim 0

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/functional.py:1355: RuntimeError
________________________ TestZCA.test_jit[cpu-float32] _________________________

self = <test_zca.TestZCA object at 0x7c38a4723160>, device = device(type='cpu')
dtype = torch.float32

    def test_jit(self, device, dtype):
        data = torch.rand(10, 3, 1, 2, device=device, dtype=dtype)
        zca = kornia.enhance.ZCAWhitening().fit(data)
        zca_jit = kornia.enhance.ZCAWhitening().fit(data)
        zca_jit = torch.jit.script(zca_jit)
>       self.assert_close(zca_jit(data), zca(data))

/local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = RecursiveScriptModule(original_name=ZCAWhitening)
args = (tensor([[[[3.8668e-01, 7.4568e-02]],

         [[7.1886e-01, 1.6844e-01]],

         [[1.8783e-01, 6.3869e-01]]],


 ...


        [[[7.3122e-01, 4.8560e-01]],

         [[6.6795e-01, 3.8110e-01]],

         [[9.4208e-01, 5.7621e-01]]]]),)
kwargs = {}

    def _call_impl(self, *args, **kwargs):
        forward_call = (self._slow_forward if torch._C._get_tracing_state() else self.forward)
        # If we don't have any hooks, we want to skip the rest of the logic in
        # this function, and just call forward.
        if not (self._backward_hooks or self._backward_pre_hooks or self._forward_hooks or self._forward_pre_hooks
                or _global_backward_pre_hooks or _global_backward_hooks
                or _global_forward_hooks or _global_forward_pre_hooks):
>           return forward_call(*args, **kwargs)
E           RuntimeError: The following operation failed in the TorchScript interpreter.
E           Traceback of TorchScript (most recent call last):
E             File "/local/data0/moved_data/publishablew/kornia/kornia/kornia/enhance/zca.py", line 113, in forward
E                   if not self.fitted:
E                       raise RuntimeError('The ZCAWhitening instance is not fitted yet. Please fit the model first.')
E                   x_centered = x - self.mean_vector
E                                ~~~~~~~~~~~~~~~~~~~~ <--- HERE
E                   transformed_data = torch.tensordot(x_centered, self.transform_matrix, dims=([self.dim], [0]))
E                   return transformed_data
E           RuntimeError: The size of tensor a (2) must match the size of tensor b (6) at non-singleton dimension 3

/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: RuntimeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_jit[cpu-float32]
========================= 10 failed, 5 passed in 1.23s =========================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python3
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'jit', 'inductor', 'tvm', 'openxla', 'onnxrt', None, 'cudagraphs'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 15 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True] PASSED [  6%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False] PASSED [ 13%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0] PASSED [ 20%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-1] PASSED [ 26%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06] PASSED [ 33%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1] PASSED [ 40%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001] PASSED [ 46%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_individual_transforms[cpu] PASSED [ 53%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu] PASSED [ 60%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu] PASSED [ 66%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted[cpu-float32] PASSED [ 73%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted_inv[cpu-float32] PASSED [ 80%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_jit[cpu-float32] PASSED [ 86%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-True] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-False] PASSED [100%]

============================== 15 passed in 0.24s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python3
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'onnxrt', 'jit', 'openxla', 'inductor', 'tvm', 'cudagraphs', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 15 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-True] PASSED [  6%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_unbiased[cpu-float32-False] PASSED [ 13%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-0] PASSED [ 20%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_dim_args[cpu-float32-1] PASSED [ 26%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape0-1e-06] PASSED [ 33%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape1-0.1] PASSED [ 40%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_identity[cpu-float32-input_shape2-0.001] PASSED [ 46%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_individual_transforms[cpu] PASSED [ 53%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_zca_with_fit[cpu] PASSED [ 60%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_grad_detach_zca[cpu] PASSED [ 66%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted[cpu-float32] PASSED [ 73%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_not_fitted_inv[cpu-float32] PASSED [ 80%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_jit[cpu-float32] PASSED [ 86%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-True] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/enhance/test_zca.py::TestZCA::test_zca_whiten_func_unbiased[cpu-float32-False] PASSED [100%]

============================== 15 passed in 0.70s ==============================
