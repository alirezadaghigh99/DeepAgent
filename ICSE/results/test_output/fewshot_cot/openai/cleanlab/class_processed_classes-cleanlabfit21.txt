output file:
processed_classes-cleanlabfit21.json
function:
fit
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data FAILED [ 16%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy] FAILED [ 66%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse] FAILED [ 67%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe] FAILED [ 49%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe] FAILED [ 33%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy] FAILED [ 35%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe] FAILED [ 44%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv FAILED [ 83%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs FAILED [ 13%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy] FAILED [ 40%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe] FAILED [ 38%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy] FAILED [ 30%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf FAILED [  6%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse] FAILED [ 72%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs FAILED [ 15%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse] FAILED [ 47%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse] FAILED [ 32%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm FAILED [ 28%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats FAILED [ 81%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy] FAILED [ 71%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe] FAILED [ 74%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse] FAILED [ 42%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy] FAILED [ 45%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe] FAILED [ 69%]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm FAILED [ 27%]', '../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse] FAILED [ 37%]'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/home/aliredaq/Desktop/ICSE/src/tester/.hypothesis/examples'))
rootdir: /local/data0/moved_data/publishablew/cleanlab/cleanlab
configfile: pyproject.toml
plugins: hypothesis-6.124.1
collecting ... collected 59 items

../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data0] PASSED [  1%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data1] PASSED [  3%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data2] PASSED [  5%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf FAILED [  6%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data0] PASSED [  8%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data1] PASSED [ 10%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data2] PASSED [ 11%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs FAILED [ 13%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs FAILED [ 15%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data FAILED [ 16%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_fit PASSED [ 18%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict_proba PASSED [ 20%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict PASSED [ 22%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_seed PASSED [ 23%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_default_clf PASSED [ 25%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm FAILED [ 27%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm FAILED [ 28%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy] FAILED [ 30%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse] FAILED [ 32%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe] FAILED [ 33%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy] FAILED [ 35%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse] FAILED [ 37%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe] FAILED [ 38%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy] FAILED [ 40%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse] FAILED [ 42%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe] FAILED [ 44%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy] FAILED [ 45%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse] FAILED [ 47%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe] FAILED [ 49%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[numpy] PASSED [ 50%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[sparse] PASSED [ 52%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[dataframe] PASSED [ 54%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[numpy] PASSED [ 55%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[sparse] PASSED [ 57%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[dataframe] PASSED [ 59%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[numpy] PASSED [ 61%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[sparse] PASSED [ 62%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[dataframe] PASSED [ 64%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy] FAILED [ 66%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse] FAILED [ 67%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe] FAILED [ 69%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy] FAILED [ 71%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse] FAILED [ 72%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe] FAILED [ 74%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[1] PASSED [ 76%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[3] PASSED [ 77%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[4] PASSED [ 79%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats FAILED [ 81%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv FAILED [ 83%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-both] PASSED [ 84%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-confident_learning] PASSED [ 86%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-both] PASSED [ 88%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-confident_learning] PASSED [ 89%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-both] PASSED [ 91%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-confident_learning] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_label_issues_uses_thresholds PASSED [ 94%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_missing_classes PASSED [ 96%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_low_memory PASSED [ 98%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_confident_joint_setting_in_find_label_issues_kwargs PASSED [100%]

=================================== FAILURES ===================================
_____________________________ test_cl_default_clf ______________________________

    def test_cl_default_clf():
        cl = CleanLearning()  # default clf is LogisticRegression
        X_train_og = deepcopy(HIGH_DIM_DATA["X_train"])
>       cl.fit(HIGH_DIM_DATA["X_train"], HIGH_DIM_DATA["labels_train"])

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:247: in fit
    self.clf.fit(x_cleaned, labels_cleaned, **self.clf_kwargs)
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/base.py:1473: in wrapper
    return fit_method(estimator, *args, **kwargs)
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/linear_model/_logistic.py:1223: in fit
    X, y = self._validate_data(
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/base.py:650: in _validate_data
    X, y = check_X_y(X, y, **check_params)
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:1301: in check_X_y
    X = check_array(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

array = array([[[0.14509804, 0.92156863, 0.54901961, ..., 0.91764706,
         0.61176471, 0.61568627],
        [0.55686275, 0...1764706, 0.64313725],
        [0.34509804, 0.50588235, 0.59215686, ..., 0.98431373,
         0.18431373, 0.22352941]]])
accept_sparse = 'csr'

    def check_array(
        array,
        accept_sparse=False,
        *,
        accept_large_sparse=True,
        dtype="numeric",
        order=None,
        copy=False,
        force_writeable=False,
        force_all_finite=True,
        ensure_2d=True,
        allow_nd=False,
        ensure_min_samples=1,
        ensure_min_features=1,
        estimator=None,
        input_name="",
    ):
        """Input validation on an array, list, sparse matrix or similar.
    
        By default, the input is checked to be a non-empty 2D array containing
        only finite values. If the dtype of the array is object, attempt
        converting to float, raising on failure.
    
        Parameters
        ----------
        array : object
            Input object to check / convert.
    
        accept_sparse : str, bool or list/tuple of str, default=False
            String[s] representing allowed sparse matrix formats, such as 'csc',
            'csr', etc. If the input is sparse but not in the allowed format,
            it will be converted to the first listed format. True allows the input
            to be any format. False means that a sparse matrix input will
            raise an error.
    
        accept_large_sparse : bool, default=True
            If a CSR, CSC, COO or BSR sparse matrix is supplied and accepted by
            accept_sparse, accept_large_sparse=False will cause it to be accepted
            only if its indices are stored with a 32-bit dtype.
    
            .. versionadded:: 0.20
    
        dtype : 'numeric', type, list of type or None, default='numeric'
            Data type of result. If None, the dtype of the input is preserved.
            If "numeric", dtype is preserved unless array.dtype is object.
            If dtype is a list of types, conversion on the first type is only
            performed if the dtype of the input is not in the list.
    
        order : {'F', 'C'} or None, default=None
            Whether an array will be forced to be fortran or c-style.
            When order is None (default), then if copy=False, nothing is ensured
            about the memory layout of the output array; otherwise (copy=True)
            the memory layout of the returned array is kept as close as possible
            to the original array.
    
        copy : bool, default=False
            Whether a forced copy will be triggered. If copy=False, a copy might
            be triggered by a conversion.
    
        force_writeable : bool, default=False
            Whether to force the output array to be writeable. If True, the returned array
            is guaranteed to be writeable, which may require a copy. Otherwise the
            writeability of the input array is preserved.
    
            .. versionadded:: 1.6
    
        force_all_finite : bool or 'allow-nan', default=True
            Whether to raise an error on np.inf, np.nan, pd.NA in array. The
            possibilities are:
    
            - True: Force all values of array to be finite.
            - False: accepts np.inf, np.nan, pd.NA in array.
            - 'allow-nan': accepts only np.nan and pd.NA values in array. Values
              cannot be infinite.
    
            .. versionadded:: 0.20
               ``force_all_finite`` accepts the string ``'allow-nan'``.
    
            .. versionchanged:: 0.23
               Accepts `pd.NA` and converts it into `np.nan`
    
        ensure_2d : bool, default=True
            Whether to raise a value error if array is not 2D.
    
        allow_nd : bool, default=False
            Whether to allow array.ndim > 2.
    
        ensure_min_samples : int, default=1
            Make sure that the array has a minimum number of samples in its first
            axis (rows for a 2D array). Setting to 0 disables this check.
    
        ensure_min_features : int, default=1
            Make sure that the 2D array has some minimum number of features
            (columns). The default value of 1 rejects empty datasets.
            This check is only enforced when the input data has effectively 2
            dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0
            disables this check.
    
        estimator : str or estimator instance, default=None
            If passed, include the name of the estimator in warning messages.
    
        input_name : str, default=""
            The data name used to construct the error message. In particular
            if `input_name` is "X" and the data has NaN values and
            allow_nan is False, the error message will link to the imputer
            documentation.
    
            .. versionadded:: 1.1.0
    
        Returns
        -------
        array_converted : object
            The converted and validated array.
    
        Examples
        --------
        >>> from sklearn.utils.validation import check_array
        >>> X = [[1, 2, 3], [4, 5, 6]]
        >>> X_checked = check_array(X)
        >>> X_checked
        array([[1, 2, 3], [4, 5, 6]])
        """
        if isinstance(array, np.matrix):
            raise TypeError(
                "np.matrix is not supported. Please convert to a numpy array with "
                "np.asarray. For more information see: "
                "https://numpy.org/doc/stable/reference/generated/numpy.matrix.html"
            )
    
        xp, is_array_api_compliant = get_namespace(array)
    
        # store reference to original array to check if copy is needed when
        # function returns
        array_orig = array
    
        # store whether originally we wanted numeric dtype
        dtype_numeric = isinstance(dtype, str) and dtype == "numeric"
    
        dtype_orig = getattr(array, "dtype", None)
        if not is_array_api_compliant and not hasattr(dtype_orig, "kind"):
            # not a data type (e.g. a column named dtype in a pandas DataFrame)
            dtype_orig = None
    
        # check if the object contains several dtypes (typically a pandas
        # DataFrame), and store them. If not, store None.
        dtypes_orig = None
        pandas_requires_conversion = False
        # track if we have a Series-like object to raise a better error message
        type_if_series = None
        if hasattr(array, "dtypes") and hasattr(array.dtypes, "__array__"):
            # throw warning if columns are sparse. If all columns are sparse, then
            # array.sparse exists and sparsity will be preserved (later).
            with suppress(ImportError):
                from pandas import SparseDtype
    
                def is_sparse(dtype):
                    return isinstance(dtype, SparseDtype)
    
                if not hasattr(array, "sparse") and array.dtypes.apply(is_sparse).any():
                    warnings.warn(
                        "pandas.DataFrame with sparse columns found."
                        "It will be converted to a dense numpy array."
                    )
    
            dtypes_orig = list(array.dtypes)
            pandas_requires_conversion = any(
                _pandas_dtype_needs_early_conversion(i) for i in dtypes_orig
            )
            if all(isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig):
                dtype_orig = np.result_type(*dtypes_orig)
            elif pandas_requires_conversion and any(d == object for d in dtypes_orig):
                # Force object if any of the dtypes is an object
                dtype_orig = object
    
        elif (_is_extension_array_dtype(array) or hasattr(array, "iloc")) and hasattr(
            array, "dtype"
        ):
            # array is a pandas series
            type_if_series = type(array)
            pandas_requires_conversion = _pandas_dtype_needs_early_conversion(array.dtype)
            if isinstance(array.dtype, np.dtype):
                dtype_orig = array.dtype
            else:
                # Set to None to let array.astype work out the best dtype
                dtype_orig = None
    
        if dtype_numeric:
            if (
                dtype_orig is not None
                and hasattr(dtype_orig, "kind")
                and dtype_orig.kind == "O"
            ):
                # if input is object, convert to float.
                dtype = xp.float64
            else:
                dtype = None
    
        if isinstance(dtype, (list, tuple)):
            if dtype_orig is not None and dtype_orig in dtype:
                # no dtype conversion required
                dtype = None
            else:
                # dtype conversion required. Let's select the first element of the
                # list of accepted types.
                dtype = dtype[0]
    
        if pandas_requires_conversion:
            # pandas dataframe requires conversion earlier to handle extension dtypes with
            # nans
            # Use the original dtype for conversion if dtype is None
            new_dtype = dtype_orig if dtype is None else dtype
            array = array.astype(new_dtype)
            # Since we converted here, we do not need to convert again later
            dtype = None
    
        if force_all_finite not in (True, False, "allow-nan"):
            raise ValueError(
                'force_all_finite should be a bool or "allow-nan". Got {!r} instead'.format(
                    force_all_finite
                )
            )
    
        if dtype is not None and _is_numpy_namespace(xp):
            # convert to dtype object to conform to Array API to be use `xp.isdtype` later
            dtype = np.dtype(dtype)
    
        estimator_name = _check_estimator_name(estimator)
        context = " by %s" % estimator_name if estimator is not None else ""
    
        # When all dataframe columns are sparse, convert to a sparse array
        if hasattr(array, "sparse") and array.ndim > 1:
            with suppress(ImportError):
                from pandas import SparseDtype  # noqa: F811
    
                def is_sparse(dtype):
                    return isinstance(dtype, SparseDtype)
    
                if array.dtypes.apply(is_sparse).all():
                    # DataFrame.sparse only supports `to_coo`
                    array = array.sparse.to_coo()
                    if array.dtype == np.dtype("object"):
                        unique_dtypes = set([dt.subtype.name for dt in array_orig.dtypes])
                        if len(unique_dtypes) > 1:
                            raise ValueError(
                                "Pandas DataFrame with mixed sparse extension arrays "
                                "generated a sparse matrix with object dtype which "
                                "can not be converted to a scipy sparse matrix."
                                "Sparse extension arrays should all have the same "
                                "numeric type."
                            )
    
        if sp.issparse(array):
            _ensure_no_complex_data(array)
            array = _ensure_sparse_format(
                array,
                accept_sparse=accept_sparse,
                dtype=dtype,
                copy=copy,
                force_all_finite=force_all_finite,
                accept_large_sparse=accept_large_sparse,
                estimator_name=estimator_name,
                input_name=input_name,
            )
            if ensure_2d and array.ndim < 2:
                raise ValueError(
                    f"Expected 2D input, got input with shape {array.shape}.\n"
                    "Reshape your data either using array.reshape(-1, 1) if "
                    "your data has a single feature or array.reshape(1, -1) "
                    "if it contains a single sample."
                )
        else:
            # If np.array(..) gives ComplexWarning, then we convert the warning
            # to an error. This is needed because specifying a non complex
            # dtype to the function converts complex to real dtype,
            # thereby passing the test made in the lines following the scope
            # of warnings context manager.
            with warnings.catch_warnings():
                try:
                    warnings.simplefilter("error", ComplexWarning)
                    if dtype is not None and xp.isdtype(dtype, "integral"):
                        # Conversion float -> int should not contain NaN or
                        # inf (numpy#14412). We cannot use casting='safe' because
                        # then conversion float -> int would be disallowed.
                        array = _asarray_with_order(array, order=order, xp=xp)
                        if xp.isdtype(array.dtype, ("real floating", "complex floating")):
                            _assert_all_finite(
                                array,
                                allow_nan=False,
                                msg_dtype=dtype,
                                estimator_name=estimator_name,
                                input_name=input_name,
                            )
                        array = xp.astype(array, dtype, copy=False)
                    else:
                        array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)
                except ComplexWarning as complex_warning:
                    raise ValueError(
                        "Complex data not supported\n{}\n".format(array)
                    ) from complex_warning
    
            # It is possible that the np.array(..) gave no warning. This happens
            # when no dtype conversion happened, for example dtype = None. The
            # result is that np.array(..) produces an array of complex dtype
            # and we need to catch and raise exception for such cases.
            _ensure_no_complex_data(array)
    
            if ensure_2d:
                # If input is scalar raise error
                if array.ndim == 0:
                    raise ValueError(
                        "Expected 2D array, got scalar array instead:\narray={}.\n"
                        "Reshape your data either using array.reshape(-1, 1) if "
                        "your data has a single feature or array.reshape(1, -1) "
                        "if it contains a single sample.".format(array)
                    )
                # If input is 1D raise error
                if array.ndim == 1:
                    # If input is a Series-like object (eg. pandas Series or polars Series)
                    if type_if_series is not None:
                        msg = (
                            f"Expected a 2-dimensional container but got {type_if_series} "
                            "instead. Pass a DataFrame containing a single row (i.e. "
                            "single sample) or a single column (i.e. single feature) "
                            "instead."
                        )
                    else:
                        msg = (
                            f"Expected 2D array, got 1D array instead:\narray={array}.\n"
                            "Reshape your data either using array.reshape(-1, 1) if "
                            "your data has a single feature or array.reshape(1, -1) "
                            "if it contains a single sample."
                        )
                    raise ValueError(msg)
    
            if dtype_numeric and hasattr(array.dtype, "kind") and array.dtype.kind in "USV":
                raise ValueError(
                    "dtype='numeric' is not compatible with arrays of bytes/strings."
                    "Convert your data to numeric values explicitly instead."
                )
            if not allow_nd and array.ndim >= 3:
>               raise ValueError(
                    "Found array with dim %d. %s expected <= 2."
                    % (array.ndim, estimator_name)
                )
E               ValueError: Found array with dim 3. LogisticRegression expected <= 2.

/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/utils/validation.py:1058: ValueError
_____________________________ test_invalid_inputs ______________________________

    def test_invalid_inputs():
        data = make_data(sizes=[1, 1, 1])
        try:
            test_cl(data)
        except Exception as e:
            assert "Need more data" in str(e)
        else:
            raise Exception("expected test to raise Exception")
        try:
            cl = CleanLearning(
                clf=LogisticRegression(solver="lbfgs", random_state=SEED),
                find_label_issues_kwargs={"return_indices_ranked_by": "self_confidence"},
            )
>           cl.fit(
                data["X_train"],
                data["labels"],
            )

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CleanLearning(clf=LogisticRegression(random_state=1),
              find_label_issues_kwargs={'return_indices_ranked_by': 'self_confidence'})
X = array([[-0.75073318,  2.79426808],
       [ 5.1023396 ,  9.07909963],
       [-0.19992896,  7.09474511]])
y = array([0, 1, 2]), labels = array([0, 1, 2]), label_issues = None
sample_weight = None, clf_kwargs = {}, clf_final_kwargs = {}

    def fit(self, X, y=None, labels=None, label_issues=None, sample_weight=None, clf_kwargs={}, clf_final_kwargs={}):
        if y is None and labels is None or (y is not None and labels is not None):
            raise ValueError("Either 'labels' or 'y' must be provided, but not both.")
        labels = y if labels is None else labels
        if self.clf is None and X.ndim != 2:
            raise ValueError('Input data X must be two-dimensional.')
        self.clf_kwargs = {**clf_kwargs, **clf_final_kwargs}
        if sample_weight is not None:
            if not hasattr(self.clf, 'fit'):
                raise ValueError('The classifier does not support sample weights.')
        if label_issues is None:
>           label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)
E           TypeError: CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:236: TypeError

During handling of the above exception, another exception occurred:

    def test_invalid_inputs():
        data = make_data(sizes=[1, 1, 1])
        try:
            test_cl(data)
        except Exception as e:
            assert "Need more data" in str(e)
        else:
            raise Exception("expected test to raise Exception")
        try:
            cl = CleanLearning(
                clf=LogisticRegression(solver="lbfgs", random_state=SEED),
                find_label_issues_kwargs={"return_indices_ranked_by": "self_confidence"},
            )
            cl.fit(
                data["X_train"],
                data["labels"],
            )
        except Exception as e:
>           assert "not supported" in str(e) or "Need more data from each class" in str(e)
E           assert ('not supported' in "CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'" or 'Need more data from each class' in "CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'")
E            +  where "CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'" = str(TypeError("CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'"))
E            +  and   "CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'" = str(TypeError("CleanLearning.find_label_issues() got an unexpected keyword argument 'return_indices_ranked_by'"))

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:224: AssertionError
_______________________________ test_aux_inputs ________________________________

    @pytest.mark.filterwarnings("ignore::UserWarning")
    def test_aux_inputs():
        data = DATA
        K = len(np.unique(data["labels"]))
        confident_joint = np.ones(shape=(K, K))
        np.fill_diagonal(confident_joint, 10)
        find_label_issues_kwargs = {
            "confident_joint": confident_joint,
            "min_examples_per_class": 2,
        }
        cl = CleanLearning(
            clf=LogisticRegression(solver="lbfgs", random_state=SEED),
            find_label_issues_kwargs=find_label_issues_kwargs,
            verbose=1,
        )
        label_issues_df = cl.find_label_issues(data["X_train"], data["labels"], clf_kwargs={})
        assert isinstance(label_issues_df, pd.DataFrame)
        FIND_OUTPUT_COLUMNS = ["is_label_issue", "label_quality", "given_label", "predicted_label"]
        assert list(label_issues_df.columns) == FIND_OUTPUT_COLUMNS
        assert label_issues_df.equals(cl.get_label_issues())
        cl.fit(
            data["X_train"],
            data["labels"],
            label_issues=label_issues_df,
            clf_kwargs={},
            clf_final_kwargs={},
        )
        label_issues_df = cl.get_label_issues()
        assert isinstance(label_issues_df, pd.DataFrame)
>       assert list(label_issues_df.columns) == (FIND_OUTPUT_COLUMNS + ["sample_weight"])
E       AssertionError: assert ['is_label_is...dicted_label'] == ['is_label_is...ample_weight']
E         
E         Right contains one more item: 'sample_weight'
E         
E         Full diff:
E           [
E               'is_label_issue',
E               'label_quality',...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:258: AssertionError
----------------------------- Captured stdout call -----------------------------
Computing label noise estimates from provided noise matrix ...
Computing out of sample predicted probabilities via 5-fold cross validation. May take a while ...
Using predicted probabilities to identify label issues ...
Identified 6 examples with label issues.
_____________________________ test_validation_data _____________________________

    def test_validation_data():
        data = DATA
        cl = CleanLearning(clf=LogisticRegressionWithValidationData())
>       cl.fit(
            data["X_train"],
            data["labels"],
            validation_func=val_func,
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'validation_func'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:352: TypeError
_______________________________ test_clf_fit_nm ________________________________

    def test_clf_fit_nm():
        cl = CleanLearning()
        # Example of a bad noise matrix (impossible to learn from)
        nm = np.array([[0, 1], [1, 0]])
        try:
>           cl.fit(X=np.arange(3), labels=np.array([0, 0, 1]), noise_matrix=nm)
E           TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:424: TypeError

During handling of the above exception, another exception occurred:

    def test_clf_fit_nm():
        cl = CleanLearning()
        # Example of a bad noise matrix (impossible to learn from)
        nm = np.array([[0, 1], [1, 0]])
        try:
            cl.fit(X=np.arange(3), labels=np.array([0, 0, 1]), noise_matrix=nm)
        except Exception as e:
>           assert "Trace(noise_matrix)" in str(e)
E           assert 'Trace(noise_matrix)' in "CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'"
E            +  where "CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'" = str(TypeError("CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'"))

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:426: AssertionError
_______________________________ test_clf_fit_inm _______________________________

    def test_clf_fit_inm():
        cl = CleanLearning()
        # Example of a bad noise matrix (impossible to learn from)
        inm = np.array([[0.1, 0.9], [0.9, 0.1]])
        try:
>           cl.fit(X=np.arange(3), labels=np.array([0, 0, 1]), inverse_noise_matrix=inm)
E           TypeError: CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:436: TypeError

During handling of the above exception, another exception occurred:

    def test_clf_fit_inm():
        cl = CleanLearning()
        # Example of a bad noise matrix (impossible to learn from)
        inm = np.array([[0.1, 0.9], [0.9, 0.1]])
        try:
            cl.fit(X=np.arange(3), labels=np.array([0, 0, 1]), inverse_noise_matrix=inm)
        except Exception as e:
>           assert "Trace(inverse_noise_matrix)" in str(e)
E           assert 'Trace(inverse_noise_matrix)' in "CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'"
E            +  where "CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'" = str(TypeError("CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'"))

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:438: AssertionError
___________________________ test_fit_with_nm[numpy] ____________________________

format = 'numpy', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_nm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        nm = data["noise_matrix"]
        # Learn with noisy labels with noise matrix given
>       cl.fit(data["X_train"], data["labels"], noise_matrix=nm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:455: TypeError
___________________________ test_fit_with_nm[sparse] ___________________________

format = 'sparse', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_nm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        nm = data["noise_matrix"]
        # Learn with noisy labels with noise matrix given
>       cl.fit(data["X_train"], data["labels"], noise_matrix=nm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:455: TypeError
_________________________ test_fit_with_nm[dataframe] __________________________

format = 'dataframe', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_nm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        nm = data["noise_matrix"]
        # Learn with noisy labels with noise matrix given
>       cl.fit(data["X_train"], data["labels"], noise_matrix=nm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:455: TypeError
___________________________ test_fit_with_inm[numpy] ___________________________

format = 'numpy', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_inm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=data["noise_matrix"],
            ps=data["ps"],
        )
        # Learn with noisy labels with inverse noise matrix given
>       cl.fit(data["X_train"], data["labels"], inverse_noise_matrix=inm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:488: TypeError
__________________________ test_fit_with_inm[sparse] ___________________________

format = 'sparse', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_inm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=data["noise_matrix"],
            ps=data["ps"],
        )
        # Learn with noisy labels with inverse noise matrix given
>       cl.fit(data["X_train"], data["labels"], inverse_noise_matrix=inm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:488: TypeError
_________________________ test_fit_with_inm[dataframe] _________________________

format = 'dataframe', seed = 1, used_by_another_test = False

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_with_inm(
        format,
        seed=SEED,
        used_by_another_test=False,
    ):
        data = DATA_FORMATS[format]
        cl = CleanLearning(
            seed=seed,
        )
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=data["noise_matrix"],
            ps=data["ps"],
        )
        # Learn with noisy labels with inverse noise matrix given
>       cl.fit(data["X_train"], data["labels"], inverse_noise_matrix=inm)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'inverse_noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:488: TypeError
__________________________ test_clf_fit_nm_inm[numpy] __________________________

format = 'numpy'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_nm_inm(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
        nm = data["noise_matrix"]
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=nm,
            ps=data["ps"],
        )
>       cl.fit(
            X=data["X_train"],
            labels=data["labels"],
            noise_matrix=nm,
            inverse_noise_matrix=inm,
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:515: TypeError
_________________________ test_clf_fit_nm_inm[sparse] __________________________

format = 'sparse'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_nm_inm(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
        nm = data["noise_matrix"]
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=nm,
            ps=data["ps"],
        )
>       cl.fit(
            X=data["X_train"],
            labels=data["labels"],
            noise_matrix=nm,
            inverse_noise_matrix=inm,
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:515: TypeError
________________________ test_clf_fit_nm_inm[dataframe] ________________________

format = 'dataframe'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_nm_inm(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
        nm = data["noise_matrix"]
        inm = compute_inv_noise_matrix(
            py=data["py"],
            noise_matrix=nm,
            ps=data["ps"],
        )
>       cl.fit(
            X=data["X_train"],
            labels=data["labels"],
            noise_matrix=nm,
            inverse_noise_matrix=inm,
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'noise_matrix'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:515: TypeError
_________________________ test_clf_fit_y_alias[numpy] __________________________

format = 'numpy'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_y_alias(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
    
        # Valid signature
        cl.fit(data["X_train"], data["labels"])
    
        # Valid signature for labels/y alias
>       cl.fit(data["X_train"], labels=data["labels"])

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CleanLearning(clf=LogisticRegression(),
              find_label_issues_kwargs={'confident_joint': array([[72,  3,  7]...4],
       [12,  4, 35]]),
                                        'min_examples_per_class': 10},
              seed=1)
X = array([[-0.75073318,  2.79426808],
       [ 3.93518489,  0.88852811],
       [ 0.55994988,  1.09788438],
       [-1.05... 9.04068597],
       [ 0.65105019,  8.27861528],
       [-3.50445673,  7.97608746],
       [ 2.6961701 ,  9.39529131]])
y = None
labels = array([0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,...2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2,
       2, 1, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 1, 2, 1, 2, 2, 2, 2,
       2, 2])
label_issues = None, sample_weight = None, clf_kwargs = {}
clf_final_kwargs = {}

    def fit(self, X, y=None, labels=None, label_issues=None, sample_weight=None, clf_kwargs={}, clf_final_kwargs={}):
        if y is None and labels is None or (y is not None and labels is not None):
            raise ValueError("Either 'labels' or 'y' must be provided, but not both.")
        labels = y if labels is None else labels
        if self.clf is None and X.ndim != 2:
            raise ValueError('Input data X must be two-dimensional.')
        self.clf_kwargs = {**clf_kwargs, **clf_final_kwargs}
        if sample_weight is not None:
            if not hasattr(self.clf, 'fit'):
                raise ValueError('The classifier does not support sample weights.')
        if label_issues is None:
>           label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)
E           TypeError: CleanLearning.find_label_issues() got an unexpected keyword argument 'min_examples_per_class'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:236: TypeError
_________________________ test_clf_fit_y_alias[sparse] _________________________

format = 'sparse'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_y_alias(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
    
        # Valid signature
        cl.fit(data["X_train"], data["labels"])
    
        # Valid signature for labels/y alias
>       cl.fit(data["X_train"], labels=data["labels"])

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CleanLearning(clf=LogisticRegression(),
              find_label_issues_kwargs={'confident_joint': array([[72,  3,  7]...4],
       [12,  4, 35]]),
                                        'min_examples_per_class': 10},
              seed=1)
X = <Compressed Sparse Row sparse matrix of dtype 'float64'
	with 400 stored elements and shape (200, 2)>
y = None
labels = array([0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,...2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2,
       2, 1, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 1, 2, 1, 2, 2, 2, 2,
       2, 2])
label_issues = None, sample_weight = None, clf_kwargs = {}
clf_final_kwargs = {}

    def fit(self, X, y=None, labels=None, label_issues=None, sample_weight=None, clf_kwargs={}, clf_final_kwargs={}):
        if y is None and labels is None or (y is not None and labels is not None):
            raise ValueError("Either 'labels' or 'y' must be provided, but not both.")
        labels = y if labels is None else labels
        if self.clf is None and X.ndim != 2:
            raise ValueError('Input data X must be two-dimensional.')
        self.clf_kwargs = {**clf_kwargs, **clf_final_kwargs}
        if sample_weight is not None:
            if not hasattr(self.clf, 'fit'):
                raise ValueError('The classifier does not support sample weights.')
        if label_issues is None:
>           label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)
E           TypeError: CleanLearning.find_label_issues() got an unexpected keyword argument 'min_examples_per_class'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:236: TypeError
_______________________ test_clf_fit_y_alias[dataframe] ________________________

format = 'dataframe'

    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_clf_fit_y_alias(format):
        data = DATA_FORMATS[format]
        cl = CleanLearning(seed=SEED)
    
        # Valid signature
        cl.fit(data["X_train"], data["labels"])
    
        # Valid signature for labels/y alias
>       cl.fit(data["X_train"], labels=data["labels"])

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = CleanLearning(clf=LogisticRegression(),
              find_label_issues_kwargs={'confident_joint': array([[72,  3,  7]...4],
       [12,  4, 35]]),
                                        'min_examples_per_class': 10},
              seed=1)
X =             0         1
0   -0.750733  2.794268
1    3.935185  0.888528
2    0.559950  1.097884
3   -1.052172  2.78335...196  0.660621  9.040686
197  0.651050  8.278615
198 -3.504457  7.976087
199  2.696170  9.395291

[200 rows x 2 columns]
y = None
labels = array([0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 2, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,...2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 2,
       2, 1, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 1, 2, 1, 2, 2, 2, 2,
       2, 2])
label_issues = None, sample_weight = None, clf_kwargs = {}
clf_final_kwargs = {}

    def fit(self, X, y=None, labels=None, label_issues=None, sample_weight=None, clf_kwargs={}, clf_final_kwargs={}):
        if y is None and labels is None or (y is not None and labels is not None):
            raise ValueError("Either 'labels' or 'y' must be provided, but not both.")
        labels = y if labels is None else labels
        if self.clf is None and X.ndim != 2:
            raise ValueError('Input data X must be two-dimensional.')
        self.clf_kwargs = {**clf_kwargs, **clf_final_kwargs}
        if sample_weight is not None:
            if not hasattr(self.clf, 'fit'):
                raise ValueError('The classifier does not support sample weights.')
        if label_issues is None:
>           label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)
E           TypeError: CleanLearning.find_label_issues() got an unexpected keyword argument 'min_examples_per_class'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:236: TypeError
_______________________ test_no_fit_sample_weight[numpy] _______________________

format = 'numpy'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_no_fit_sample_weight(format):
        data = DATA_FORMATS[format]
    
        class Struct:
            def fit(self, X, y):
                pass
    
            def predict_proba(self):
                pass
    
            def predict(self, X):
                return data["true_labels_test"]
    
        n = np.shape(data["true_labels_test"])[0]
        m = len(np.unique(data["true_labels_test"]))
        pred_probs = np.zeros(shape=(n, m))
        cl = CleanLearning(clf=Struct())
>       cl.fit(
            data["X_train"],
            data["true_labels_train"],
            pred_probs=pred_probs,
            noise_matrix=data["noise_matrix"],
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:631: TypeError
______________________ test_no_fit_sample_weight[sparse] _______________________

format = 'sparse'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_no_fit_sample_weight(format):
        data = DATA_FORMATS[format]
    
        class Struct:
            def fit(self, X, y):
                pass
    
            def predict_proba(self):
                pass
    
            def predict(self, X):
                return data["true_labels_test"]
    
        n = np.shape(data["true_labels_test"])[0]
        m = len(np.unique(data["true_labels_test"]))
        pred_probs = np.zeros(shape=(n, m))
        cl = CleanLearning(clf=Struct())
>       cl.fit(
            data["X_train"],
            data["true_labels_train"],
            pred_probs=pred_probs,
            noise_matrix=data["noise_matrix"],
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:631: TypeError
_____________________ test_no_fit_sample_weight[dataframe] _____________________

format = 'dataframe'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_no_fit_sample_weight(format):
        data = DATA_FORMATS[format]
    
        class Struct:
            def fit(self, X, y):
                pass
    
            def predict_proba(self):
                pass
    
            def predict(self, X):
                return data["true_labels_test"]
    
        n = np.shape(data["true_labels_test"])[0]
        m = len(np.unique(data["true_labels_test"]))
        pred_probs = np.zeros(shape=(n, m))
        cl = CleanLearning(clf=Struct())
>       cl.fit(
            data["X_train"],
            data["true_labels_train"],
            pred_probs=pred_probs,
            noise_matrix=data["noise_matrix"],
        )
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:631: TypeError
__________________________ test_fit_pred_probs[numpy] __________________________

format = 'numpy'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_pred_probs(format):
        data = DATA_FORMATS[format]
    
        cl = CleanLearning()
        pred_probs = estimate_cv_predicted_probabilities(
            X=data["X_train"],
            labels=data["true_labels_train"],
        )
>       cl.fit(X=data["X_train"], labels=data["true_labels_train"], pred_probs=pred_probs)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:650: TypeError
_________________________ test_fit_pred_probs[sparse] __________________________

format = 'sparse'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_pred_probs(format):
        data = DATA_FORMATS[format]
    
        cl = CleanLearning()
        pred_probs = estimate_cv_predicted_probabilities(
            X=data["X_train"],
            labels=data["true_labels_train"],
        )
>       cl.fit(X=data["X_train"], labels=data["true_labels_train"], pred_probs=pred_probs)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:650: TypeError
________________________ test_fit_pred_probs[dataframe] ________________________

format = 'dataframe'

    @pytest.mark.filterwarnings("ignore::UserWarning")
    @pytest.mark.parametrize("format", list(DATA_FORMATS.keys()))
    def test_fit_pred_probs(format):
        data = DATA_FORMATS[format]
    
        cl = CleanLearning()
        pred_probs = estimate_cv_predicted_probabilities(
            X=data["X_train"],
            labels=data["true_labels_train"],
        )
>       cl.fit(X=data["X_train"], labels=data["true_labels_train"], pred_probs=pred_probs)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:650: TypeError
_______________________________ test_1D_formats ________________________________

    @pytest.mark.filterwarnings("ignore::UserWarning")
    def test_1D_formats():
        X, labels = dimN_data(1)
        X_series = pd.Series(X)
        labels_series = pd.Series(labels)
        idx = list(np.random.choice(len(labels), size=len(labels), replace=False))
        X_series.index = idx
        labels_series.index = idx
        cl = CleanLearning(clf=ReshapingLogisticRegression())
        # just make sure we don't crash...
        cl.fit(X_series, labels_series)
        cl.predict(X_series)
        cl.predict_proba(X_series)
        cl.score(X_series, labels)
        # Repeat with rare labels:
        labels_rare = deepcopy(labels)
        class0_inds = np.where(labels_rare == 0)[0]
        class0_inds_remove = class0_inds[1:]
        labels_rare[class0_inds_remove] = 1
        cl = CleanLearning(clf=ReshapingLogisticRegression())
        cl.fit(X_series, labels_rare)
        cl.predict(X_series)
        cl.predict_proba(X_series)
        cl.score(X_series, labels)
        # Repeat with DataFrame labels:
        labels_df = pd.DataFrame({"colname": labels})
        cl = CleanLearning(clf=ReshapingLogisticRegression())
        cl.fit(X, labels_df)
        cl.predict(X)
        pred_probs = cl.predict_proba(X)
        cl.score(X, labels)
        # Repeat with DataFrame labels and pred_probs
        cl = CleanLearning(clf=ReshapingLogisticRegression())
>       cl.fit(X, labels_df, pred_probs=pred_probs)
E       TypeError: CleanLearning.fit() got an unexpected keyword argument 'pred_probs'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:741: TypeError
__________________________ test_sklearn_gridsearchcv ___________________________

    @sre_deprecation_pytestmark  # Allow sre_constants deprecation warning for Python 3.11
    @pytest.mark.filterwarnings("error")  # All other warnings are treated as errors
    @pytest.mark.skipif(
        uses_sklearn_1_5_0,
        reason="Test is skipped because sklearn 1.5.0 is installed, which has a regression for GridSearchCV.",
    )  # TODO: Remove this line once sklearn 1.5.1 is released
    def test_sklearn_gridsearchcv():
        # hyper-parameters for grid search
        param_grid = {
            "find_label_issues_kwargs": [
                {"filter_by": "prune_by_noise_rate"},
                {"filter_by": "prune_by_class"},
                {"filter_by": "both"},
                {"filter_by": "confident_learning"},
                {"filter_by": "predicted_neq_given"},
            ],
            "converge_latent_estimates": [True, False],
        }
    
        clf = LogisticRegression(random_state=0, solver="lbfgs")
    
        cv = GridSearchCV(
            estimator=CleanLearning(clf),
            param_grid=param_grid,
            cv=3,
        )
    
        # cv.fit() raises a warning if some fits fail (including raising
        # exceptions); we don't expect any fits to fail, so ensure that the code
        # doesn't raise any warnings
>       cv.fit(X=DATA["X_train"], y=DATA["labels"])

/local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py:802: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/base.py:1473: in wrapper
    return fit_method(estimator, *args, **kwargs)
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/model_selection/_search.py:1019: in fit
    self._run_search(evaluate_candidates)
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/model_selection/_search.py:1573: in _run_search
    evaluate_candidates(ParameterGrid(self.param_grid))
/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/model_selection/_search.py:996: in evaluate_candidates
    _warn_or_raise_about_fit_failures(out, self.error_score)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

results = [{'fit_error': 'Traceback (most recent call last):\n  File "/local/data0/moved_data/publishablew/cleanlab/cleanlab/ven...word argument \'filter_by\'\n', 'fit_time': 2.9325485229492188e-05, 'n_test_samples': 66, 'score_time': 0.0, ...}, ...]
error_score = nan

    def _warn_or_raise_about_fit_failures(results, error_score):
        fit_errors = [
            result["fit_error"] for result in results if result["fit_error"] is not None
        ]
        if fit_errors:
            num_failed_fits = len(fit_errors)
            num_fits = len(results)
            fit_errors_counter = Counter(fit_errors)
            delimiter = "-" * 80 + "\n"
            fit_errors_summary = "\n".join(
                f"{delimiter}{n} fits failed with the following error:\n{error}"
                for error, n in fit_errors_counter.items()
            )
    
            if num_failed_fits == num_fits:
                all_fits_failed_message = (
                    f"\nAll the {num_fits} fits failed.\n"
                    "It is very likely that your model is misconfigured.\n"
                    "You can try to debug the error by setting error_score='raise'.\n\n"
                    f"Below are more details about the failures:\n{fit_errors_summary}"
                )
>               raise ValueError(all_fits_failed_message)
E               ValueError: 
E               All the 30 fits failed.
E               It is very likely that your model is misconfigured.
E               You can try to debug the error by setting error_score='raise'.
E               
E               Below are more details about the failures:
E               --------------------------------------------------------------------------------
E               30 fits failed with the following error:
E               Traceback (most recent call last):
E                 File "/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/model_selection/_validation.py", line 888, in _fit_and_score
E                   estimator.fit(X_train, y_train, **fit_params)
E                 File "/local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py", line 236, in fit
E                   label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)
E                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: CleanLearning.find_label_issues() got an unexpected keyword argument 'filter_by'

/local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/lib/python3.11/site-packages/sklearn/model_selection/_validation.py:529: ValueError
=============================== warnings summary ===============================
tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:416: UserWarning: `find_label_issues_kwargs` is not used when `low_memory=True`.
    warnings.warn(f'`find_label_issues_kwargs` is not used when `low_memory=True`.')

tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:420: UserWarning: `noise_matrix` is not used when `low_memory=True`.
    warnings.warn(f'`{arg_name}` is not used when `low_memory=True`.')

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe]
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats
FAILED ../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv
================== 26 failed, 33 passed, 2 warnings in 8.58s ===================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/home/aliredaq/Desktop/ICSE/src/tester/.hypothesis/examples'))
rootdir: /local/data0/moved_data/publishablew/cleanlab/cleanlab
configfile: pyproject.toml
plugins: hypothesis-6.124.1
collecting ... collected 59 items

../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data0] PASSED [  1%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data1] PASSED [  3%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data2] PASSED [  5%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf PASSED [  6%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data0] PASSED [  8%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data1] PASSED [ 10%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data2] PASSED [ 11%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs PASSED [ 13%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs PASSED [ 15%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data PASSED [ 16%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_fit PASSED [ 18%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict_proba PASSED [ 20%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict PASSED [ 22%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_seed PASSED [ 23%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_default_clf PASSED [ 25%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm PASSED [ 27%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm PASSED [ 28%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy] PASSED [ 30%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse] PASSED [ 32%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe] PASSED [ 33%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy] PASSED [ 35%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse] PASSED [ 37%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe] PASSED [ 38%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy] PASSED [ 40%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse] PASSED [ 42%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe] PASSED [ 44%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy] PASSED [ 45%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse] PASSED [ 47%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe] PASSED [ 49%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[numpy] PASSED [ 50%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[sparse] PASSED [ 52%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[dataframe] PASSED [ 54%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[numpy] PASSED [ 55%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[sparse] PASSED [ 57%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[dataframe] PASSED [ 59%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[numpy] PASSED [ 61%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[sparse] PASSED [ 62%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[dataframe] PASSED [ 64%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy] PASSED [ 66%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse] PASSED [ 67%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe] PASSED [ 69%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy] PASSED [ 71%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse] PASSED [ 72%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe] PASSED [ 74%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[1] PASSED [ 76%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[3] PASSED [ 77%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[4] PASSED [ 79%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats PASSED [ 81%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv PASSED [ 83%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-both] PASSED [ 84%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-confident_learning] PASSED [ 86%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-both] PASSED [ 88%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-confident_learning] PASSED [ 89%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-both] PASSED [ 91%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-confident_learning] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_label_issues_uses_thresholds PASSED [ 94%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_missing_classes PASSED [ 96%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_low_memory PASSED [ 98%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_confident_joint_setting_in_find_label_issues_kwargs PASSED [100%]

=============================== warnings summary ===============================
tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:810: UserWarning: `find_label_issues_kwargs` is not used when `low_memory=True`.
    warnings.warn(f"`find_label_issues_kwargs` is not used when `low_memory=True`.")

tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:818: UserWarning: `noise_matrix` is not used when `low_memory=True`.
    warnings.warn(f"`{arg_name}` is not used when `low_memory=True`.")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================= 59 passed, 2 warnings in 16.88s ========================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/cleanlab/cleanlab/venv/bin/python3
cachedir: .pytest_cache
hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/home/aliredaq/Desktop/ICSE/src/tester/.hypothesis/examples'))
rootdir: /local/data0/moved_data/publishablew/cleanlab/cleanlab
configfile: pyproject.toml
plugins: hypothesis-6.124.1
collecting ... collected 59 items

../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data0] PASSED [  1%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data1] PASSED [  3%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl[data2] PASSED [  5%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cl_default_clf PASSED [  6%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data0] PASSED [  8%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data1] PASSED [ 10%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_rare_label[data2] PASSED [ 11%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_invalid_inputs PASSED [ 13%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_aux_inputs PASSED [ 15%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_validation_data PASSED [ 16%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_fit PASSED [ 18%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict_proba PASSED [ 20%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_raise_error_no_clf_predict PASSED [ 22%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_seed PASSED [ 23%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_default_clf PASSED [ 25%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm PASSED [ 27%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_inm PASSED [ 28%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[numpy] PASSED [ 30%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[sparse] PASSED [ 32%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_nm[dataframe] PASSED [ 33%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[numpy] PASSED [ 35%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[sparse] PASSED [ 37%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_with_inm[dataframe] PASSED [ 38%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[numpy] PASSED [ 40%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[sparse] PASSED [ 42%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_nm_inm[dataframe] PASSED [ 44%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[numpy] PASSED [ 45%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[sparse] PASSED [ 47%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_clf_fit_y_alias[dataframe] PASSED [ 49%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[numpy] PASSED [ 50%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[sparse] PASSED [ 52%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_pred_and_pred_proba[dataframe] PASSED [ 54%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[numpy] PASSED [ 55%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[sparse] PASSED [ 57%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_score[dataframe] PASSED [ 59%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[numpy] PASSED [ 61%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[sparse] PASSED [ 62%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_score[dataframe] PASSED [ 64%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[numpy] PASSED [ 66%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[sparse] PASSED [ 67%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_no_fit_sample_weight[dataframe] PASSED [ 69%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[numpy] PASSED [ 71%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[sparse] PASSED [ 72%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_fit_pred_probs[dataframe] PASSED [ 74%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[1] PASSED [ 76%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[3] PASSED [ 77%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_dimN[4] PASSED [ 79%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_1D_formats PASSED [ 81%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_sklearn_gridsearchcv PASSED [ 83%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-both] PASSED [ 84%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[0-confident_learning] PASSED [ 86%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-both] PASSED [ 88%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[6-confident_learning] PASSED [ 89%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-both] PASSED [ 91%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_cj_in_find_label_issues_kwargs[2-confident_learning] PASSED [ 93%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_label_issues_uses_thresholds PASSED [ 94%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_missing_classes PASSED [ 96%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_find_issues_low_memory PASSED [ 98%]
../../../../../../local/data0/moved_data/publishablew/cleanlab/cleanlab/tests/test_classification.py::test_confident_joint_setting_in_find_label_issues_kwargs PASSED [100%]

=============================== warnings summary ===============================
tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:810: UserWarning: `find_label_issues_kwargs` is not used when `low_memory=True`.
    warnings.warn(f"`find_label_issues_kwargs` is not used when `low_memory=True`.")

tests/test_classification.py::test_find_issues_low_memory
  /local/data0/moved_data/publishablew/cleanlab/cleanlab/cleanlab/classification.py:818: UserWarning: `noise_matrix` is not used when `low_memory=True`.
    warnings.warn(f"`{arg_name}` is not used when `low_memory=True`.")

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================= 59 passed, 2 warnings in 19.47s ========================
