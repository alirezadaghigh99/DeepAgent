output file:
processed_scikit-learnorthogonal_mp95.json
function:
orthogonal_mp
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy FAILED', 'FAILED', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs', '../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path', 'FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors'}

All Test Cases On Generated code:
============================= test session starts ==============================
platform linux -- Python 3.9.0, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/scikit-learn/scikit-learn/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/scikit-learn/scikit-learn
configfile: setup.cfg
plugins: cov-6.0.0
collecting ... collected 23 items

../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes I: Seeding RNGs with 100915847
FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params0] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params1] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_orthogonal_mp_gram_readonly PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv FAILED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_reaches_least_squares PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float32] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float64] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_numerical_consistency PASSED

=================================== FAILURES ===================================
_____________________________ test_correct_shapes ______________________________

    def test_correct_shapes():
>       assert orthogonal_mp(X, y[:, 0], n_nonzero_coefs=5).shape == (n_features,)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[-1.24141064],
       [ 4.98949457],
       [-1.78641052],
       [-3.24823197],
       [ 7.0327858 ],
       [...793793],
       [ 0.51014723],
       [-1.50448226],
       [-2.2522786 ],
       [ 2.63341917],
       [ 2.03115852]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
_____________________________ test_n_nonzero_coefs _____________________________

    def test_n_nonzero_coefs():
>       assert np.count_nonzero(orthogonal_mp(X, y[:, 0], n_nonzero_coefs=5)) <= 5

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[-1.24141064],
       [ 4.98949457],
       [-1.78641052],
       [-3.24823197],
       [ 7.0327858 ],
       [...793793],
       [ 0.51014723],
       [-1.50448226],
       [-2.2522786 ],
       [ 2.63341917],
       [ 2.03115852]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
___________________________________ test_tol ___________________________________

    def test_tol():
        tol = 0.5
>       gamma = orthogonal_mp(X, y[:, 0], tol=tol)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[-1.24141064],
       [ 4.98949457],
       [-1.78641052],
       [-3.24823197],
       [ 7.0327858 ],
       [...793793],
       [ 0.51014723],
       [-1.50448226],
       [-2.2522786 ],
       [ 2.63341917],
       [ 2.03115852]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
____________________________ test_with_without_gram ____________________________

    def test_with_without_gram():
        assert_array_almost_equal(
>           orthogonal_mp(X, y, n_nonzero_coefs=5),
            orthogonal_mp(X, y, n_nonzero_coefs=5, precompute=True),
        )

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ -1.24141064,  -3.4329415 ,   2.19985707],
       [  4.98949457,   4.26586947,  -2.21550569],
       [ -1.7864...,   0.06811033],
       [  2.63341917,   0.14703522,   1.76173811],
       [  2.03115852,  -3.98034558,  -6.03227139]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
__________________________ test_with_without_gram_tol __________________________

    def test_with_without_gram_tol():
        assert_array_almost_equal(
>           orthogonal_mp(X, y, tol=1.0), orthogonal_mp(X, y, tol=1.0, precompute=True)
        )

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ -1.24141064,  -3.4329415 ,   2.19985707],
       [  4.98949457,   4.26586947,  -2.21550569],
       [ -1.7864...,   0.06811033],
       [  2.63341917,   0.14703522,   1.76173811],
       [  2.03115852,  -3.98034558,  -6.03227139]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
__________________________ test_unreachable_accuracy ___________________________

    def test_unreachable_accuracy():
        assert_array_almost_equal(
>           orthogonal_mp(X, y, tol=0), orthogonal_mp(X, y, n_nonzero_coefs=n_features)
        )

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ -1.24141064,  -3.4329415 ,   2.19985707],
       [  4.98949457,   4.26586947,  -2.21550569],
       [ -1.7864...,   0.06811033],
       [  2.63341917,   0.14703522,   1.76173811],
       [  2.03115852,  -3.98034558,  -6.03227139]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
_________________________ test_perfect_signal_recovery _________________________

    def test_perfect_signal_recovery():
        (idx,) = gamma[:, 0].nonzero()
>       gamma_rec = orthogonal_mp(X, y[:, 0], n_nonzero_coefs=5)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[-1.24141064],
       [ 4.98949457],
       [-1.78641052],
       [-3.24823197],
       [ 7.0327858 ],
       [...793793],
       [ 0.51014723],
       [-1.50448226],
       [-2.2522786 ],
       [ 2.63341917],
       [ 2.03115852]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
________________________________ test_estimator ________________________________

    def test_estimator():
        omp = OrthogonalMatchingPursuit(n_nonzero_coefs=n_nonzero_coefs)
>       omp.fit(X, y[:, 0])

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/base.py:1330: in wrapper
    return fit_method(estimator, *args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:616: in fit
    coef_, self.n_iter_ = orthogonal_mp(X, y, n_nonzero_coefs=self.n_nonzero_coefs_, tol=self.tol, precompute=False, copy_X=True, return_n_iter=True)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:189: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.97381918e+00,  1.08337332e+00,  1.77527814e+00,
         3.49331550e+00,  3.32667920e+00, -1.42898788e+00,
... 1.50475130e+00,
         2.11046541e+00, -1.06024365e+00, -2.53715725e-02,
        -1.23395788e+00,  1.07552171e+00]])
y = array([[-1.16749383],
       [ 5.06341137],
       [-1.71249371],
       [-3.17431517],
       [ 7.1067026 ],
       [...402112],
       [ 0.58406404],
       [-1.43056546],
       [-2.1783618 ],
       [ 2.70733597],
       [ 2.10507532]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
________________________ test_estimator_n_nonzero_coefs ________________________

    def test_estimator_n_nonzero_coefs():
        """Check `n_nonzero_coefs_` correct when `tol` is and isn't set."""
        omp = OrthogonalMatchingPursuit(n_nonzero_coefs=n_nonzero_coefs)
>       omp.fit(X, y[:, 0])

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/base.py:1330: in wrapper
    return fit_method(estimator, *args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:616: in fit
    coef_, self.n_iter_ = orthogonal_mp(X, y, n_nonzero_coefs=self.n_nonzero_coefs_, tol=self.tol, precompute=False, copy_X=True, return_n_iter=True)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:189: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.97381918e+00,  1.08337332e+00,  1.77527814e+00,
         3.49331550e+00,  3.32667920e+00, -1.42898788e+00,
... 1.50475130e+00,
         2.11046541e+00, -1.06024365e+00, -2.53715725e-02,
        -1.23395788e+00,  1.07552171e+00]])
y = array([[-1.16749383],
       [ 5.06341137],
       [-1.71249371],
       [-3.17431517],
       [ 7.1067026 ],
       [...402112],
       [ 0.58406404],
       [-1.43056546],
       [-2.1783618 ],
       [ 2.70733597],
       [ 2.10507532]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
__________________________ test_identical_regressors ___________________________

    def test_identical_regressors():
        newX = X.copy()
        newX[:, 1] = newX[:, 0]
        gamma = np.zeros(n_features)
        gamma[0] = gamma[1] = 1.0
        newy = np.dot(newX, gamma)
        warning_message = (
            "Orthogonal matching pursuit ended prematurely "
            "due to linear dependence in the dictionary. "
            "The requested precision might not have been met."
        )
        with pytest.warns(RuntimeWarning, match=warning_message):
>           orthogonal_mp(newX, newy, n_nonzero_coefs=2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  2.91575919e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ 5.83151839],
       [ 0.51685081],
       [ 2.4101921 ],
       [ 6.42512832],
       [-4.92972677],
       [...654972],
       [-4.77661299],
       [-7.42247503],
       [-1.64962491],
       [ 1.33950393],
       [ 0.79200103]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
___________________________ test_swapped_regressors ____________________________

    def test_swapped_regressors():
        gamma = np.zeros(n_features)
        # X[:, 21] should be selected first, then X[:, 0] selected second,
        # which will take X[:, 21]'s place in case the algorithm does
        # column swapping for optimization (which is the case at the moment)
        gamma[21] = 1.0
        gamma[0] = 0.5
        new_y = np.dot(X, gamma)
        new_Xy = np.dot(X.T, new_y)
>       gamma_hat = orthogonal_mp(X, new_y, n_nonzero_coefs=2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: in orthogonal_mp
    coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:189: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:473: in orthogonal_mp_gram
    out = _gram_omp(Gram, Xy[:, k], n_nonzero_coefs, norms_squared[k] if tol is not None else None, tol, copy_Gram=copy_Gram, copy_Xy=False, return_path=return_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

Gram = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
Xy = array([ 2.61741899,  0.24721629,  2.771203  ,  0.83430636,  2.19061724,
        1.93247556, -0.12295829, -0.45571424, ...151048,  0.71051993, -4.68481521,  3.21861464,
       -2.09942819, -0.66600625, -0.50125695,  0.92036838,  0.50402837])
n_nonzero_coefs = 2, tol_0 = None, tol = None, copy_Gram = True, copy_Xy = False
return_path = False

    def _gram_omp(Gram, Xy, n_nonzero_coefs, tol_0=None, tol=None, copy_Gram=True, copy_Xy=True, return_path=False):
        """Orthogonal Matching Pursuit step on a precomputed Gram matrix.
    
        This function uses the Cholesky decomposition method.
    
        Parameters
        ----------
        Gram : ndarray of shape (n_features, n_features)
            Gram matrix of the input data matrix.
    
        Xy : ndarray of shape (n_features,)
            Input targets.
    
        n_nonzero_coefs : int
            Targeted number of non-zero elements.
    
        tol_0 : float, default=None
            Squared norm of y, required if tol is not None.
    
        tol : float, default=None
            Targeted squared error, if not None overrides n_nonzero_coefs.
    
        copy_Gram : bool, default=True
            Whether the gram matrix must be copied by the algorithm. A false
            value is only helpful if it is already Fortran-ordered, otherwise a
            copy is made anyway.
    
        copy_Xy : bool, default=True
            Whether the covariance vector Xy must be copied by the algorithm.
            If False, it may be overwritten.
    
        return_path : bool, default=False
            Whether to return every value of the nonzero coefficients along the
            forward path. Useful for cross-validation.
    
        Returns
        -------
        gamma : ndarray of shape (n_nonzero_coefs,)
            Non-zero elements of the solution.
    
        idx : ndarray of shape (n_nonzero_coefs,)
            Indices of the positions of the elements in gamma within the solution
            vector.
    
        coefs : ndarray of shape (n_features, n_nonzero_coefs)
            The first k values of column k correspond to the coefficient value
            for the active features at that step. The lower left triangle contains
            garbage. Only returned if ``return_path=True``.
    
        n_active : int
            Number of active features at convergence.
        """
        Gram = Gram.copy('F') if copy_Gram else np.asfortranarray(Gram)
        if copy_Xy or not Xy.flags.writeable:
            Xy = Xy.copy()
        min_float = np.finfo(Gram.dtype).eps
        nrm2, swap = linalg.get_blas_funcs(('nrm2', 'swap'), (Gram,))
        potrs, = get_lapack_funcs(('potrs',), (Gram,))
        indices = np.arange(len(Gram))
        alpha = Xy
        tol_curr = tol_0
        delta = 0
        gamma = np.empty(0)
        n_active = 0
        max_features = len(Gram) if tol is not None else n_nonzero_coefs
        L = np.empty((max_features, max_features), dtype=Gram.dtype)
        L[0, 0] = 1.0
        if return_path:
            coefs = np.empty_like(L)
        while True:
            lam = np.argmax(np.abs(alpha))
            if lam < n_active or alpha[lam] ** 2 < min_float:
                warnings.warn(premature, RuntimeWarning, stacklevel=3)
                break
            if n_active > 0:
                L[n_active, :n_active] = Gram[lam, :n_active]
                linalg.solve_triangular(L[:n_active, :n_active], L[n_active, :n_active], trans=0, lower=1, overwrite_b=True, check_finite=False)
                v = nrm2(L[n_active, :n_active]) ** 2
                Lkk = Gram[lam, lam] - v
                if Lkk <= min_float:
                    warnings.warn(premature, RuntimeWarning, stacklevel=3)
                    break
                L[n_active, n_active] = sqrt(Lkk)
            else:
>               L[0, 0] = sqrt(Gram[lam, lam])
E               ValueError: math domain error

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:194: ValueError
________________________________ test_no_atoms _________________________________

    def test_no_atoms():
        y_empty = np.zeros_like(y)
        Xy_empty = np.dot(X.T, y_empty)
>       gamma_empty = ignore_warnings(orthogonal_mp)(X, y_empty, n_nonzero_coefs=1)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_testing.py:147: in wrapper
    return fn(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0...[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
________________________________ test_omp_path _________________________________

    def test_omp_path():
>       path = orthogonal_mp(X, y, n_nonzero_coefs=5, return_path=True)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ -1.24141064,  -3.4329415 ,   2.19985707],
       [  4.98949457,   4.26586947,  -2.21550569],
       [ -1.7864...,   0.06811033],
       [  2.63341917,   0.14703522,   1.76173811],
       [  2.03115852,  -3.98034558,  -6.03227139]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
_____________________ test_omp_return_path_prop_with_gram ______________________

    def test_omp_return_path_prop_with_gram():
>       path = orthogonal_mp(X, y, n_nonzero_coefs=5, return_path=True, precompute=True)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:216: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 2.91575919e+00,  1.14685480e+00,  1.81414114e+00,
         3.47278472e+00,  3.69900930e+00, -1.89437288e+00,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[ -1.24141064,  -3.4329415 ,   2.19985707],
       [  4.98949457,   4.26586947,  -2.21550569],
       [ -1.7864...,   0.06811033],
       [  2.63341917,   0.14703522,   1.76173811],
       [  2.03115852,  -3.98034558,  -6.03227139]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
_________________________________ test_omp_cv __________________________________

    def test_omp_cv():
        y_ = y[:, 0]
        gamma_ = gamma[:, 0]
        ompcv = OrthogonalMatchingPursuitCV(fit_intercept=False, max_iter=10)
>       ompcv.fit(X, y_)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/base.py:1330: in wrapper
    return fit_method(estimator, *args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:834: in fit
    cv_paths = Parallel(n_jobs=self.n_jobs, verbose=self.verbose)((delayed(_omp_path_residues)(X[train], y[train], X[test], y[test], self.copy, self.fit_intercept, max_iter) for train, test in cv.split(X, **routed_params.splitter.split)))
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/parallel.py:77: in __call__
    return super().__call__(iterable_with_config)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/venv/lib/python3.9/site-packages/joblib/parallel.py:1918: in __call__
    return output if self.return_generator else list(output)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/venv/lib/python3.9/site-packages/joblib/parallel.py:1847: in _get_sequential_output
    res = func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/parallel.py:139: in __call__
    return self.function(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:673: in _omp_path_residues
    coefs = orthogonal_mp(X_train, y_train, n_nonzero_coefs=max_iter, tol=None, precompute=False, copy_X=False, return_path=True)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/utils/_param_validation.py:189: in wrapper
    return func(*args, **kwargs)
/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/_omp.py:221: in orthogonal_mp
    return orthogonal_mp(X, y)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

X = array([[ 1.12659099e+00, -2.30258061e+00, -1.27811594e+00,
        -7.05953464e-01,  3.46203824e-02, -6.86188115e-01,
... 1.72094156e+00,
         1.94846422e+00, -1.38523242e+00, -5.71684614e-01,
        -1.77895431e+00,  1.51144931e+00]])
y = array([[-1.1270017 ],
       [-0.06179803],
       [ 0.73819109],
       [-6.28699152],
       [-1.71520559],
       [...793793],
       [ 0.51014723],
       [-1.50448226],
       [-2.2522786 ],
       [ 2.63341917],
       [ 2.03115852]])
n_nonzero_coefs = None, tol = None, precompute = 'auto', copy_X = True
return_path = False, return_n_iter = False

    def orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):
        """
        Orthogonal Matching Pursuit (OMP) algorithm.
    
        Parameters:
        - X: array-like of shape (n_samples, n_features)
        - y: ndarray of shape (n_samples,) or (n_samples, n_targets)
        - n_nonzero_coefs: int, optional
            Desired number of non-zero entries in the solution.
        - tol: float, optional
            Maximum norm of the residual.
        - precompute: 'auto', bool or array-like, default='auto'
            Whether to precompute Gram matrix.
        - copy_X: bool, default=True
            Whether to copy X.
        - return_path: bool, default=False
            Whether to return the entire path of solutions.
        - return_n_iter: bool, default=False
            Whether to return the number of iterations.
    
        Returns:
        - coef: ndarray of shape (n_features,) or (n_features, n_targets)
        - n_iters: int, optional
            Number of active features across every target.
        """
        X = check_array(X, copy=copy_X)
        y = check_array(y, ensure_2d=False)
        if y.ndim == 1:
            y = y[:, np.newaxis]
        n_targets = y.shape[1]
        n_samples, n_features = X.shape
        coef = np.zeros((n_features, n_targets), dtype=X.dtype)
        n_iters = []
        if precompute is True or (precompute == 'auto' and n_samples > n_features):
            Gram = safe_sparse_dot(X.T, X)
            Xy = safe_sparse_dot(X.T, y)
        else:
            Gram = None
            Xy = None
        for k in range(n_targets):
            if Gram is not None:
                coef[:, k], n_iter = orthogonal_mp_gram(Gram, Xy[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
            else:
>               coef[:, k], n_iter = orthogonal_mp_gram(X, y[:, k], n_nonzero_coefs=n_nonzero_coefs, tol=tol, return_path=return_path)
E               ValueError: too many values to unpack (expected 2)

/local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/temp.py:63: ValueError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram
FAILED ../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv
=================== 15 failed, 8 passed, 1 warning in 0.68s ====================


Final Test Result:
============================= test session starts ==============================
platform linux -- Python 3.9.0, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/scikit-learn/scikit-learn/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/scikit-learn/scikit-learn
configfile: setup.cfg
plugins: cov-6.0.0
collecting ... collected 23 items

../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes I: Seeding RNGs with 693119596
PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params0] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params1] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_orthogonal_mp_gram_readonly PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_reaches_least_squares PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float32] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float64] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_numerical_consistency PASSED

======================== 23 passed, 6 warnings in 0.24s ========================


Initial Result:
============================= test session starts ==============================
platform linux -- Python 3.9.0, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/scikit-learn/scikit-learn/venv/bin/python
cachedir: .pytest_cache
rootdir: /local/data0/moved_data/publishablew/scikit-learn/scikit-learn
configfile: setup.cfg
plugins: cov-6.0.0
collecting ... collected 23 items

../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes I: Seeding RNGs with 1247141345
PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_correct_shapes_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_n_nonzero_coefs PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_tol PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_with_without_gram_tol PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_unreachable_accuracy PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params0] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_bad_input[keyword_params0-positional_params1] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_perfect_signal_recovery PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_orthogonal_mp_gram_readonly PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_estimator_n_nonzero_coefs PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_identical_regressors PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_swapped_regressors PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_no_atoms PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_path PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_return_path_prop_with_gram PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_cv PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_reaches_least_squares PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float32] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_dtype_match[float64] PASSED
../../../../../../local/data0/moved_data/publishablew/scikit-learn/scikit-learn/sklearn/linear_model/tests/test_omp.py::test_omp_gram_numerical_consistency PASSED

======================== 23 passed, 6 warnings in 0.23s ========================
