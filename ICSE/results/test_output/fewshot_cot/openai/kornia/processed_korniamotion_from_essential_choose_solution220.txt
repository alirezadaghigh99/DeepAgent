output file:
processed_korniamotion_from_essential_choose_solution220.json
function:
motion_from_essential_choose_solution
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'onnxrt', 'jit', 'cudagraphs', 'tvm', 'openxla', 'inductor', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED

=================================== FAILURES ===================================
________ TestMotionFromEssentialChooseSolution.test_smoke[cpu-float32] _________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3abc0>
device = device(type='cpu'), dtype = torch.float32

    def test_smoke(self, device, dtype):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        x2 = torch.rand(1, 1, 2, device=device, dtype=dtype)
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:417: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5056, 0.3604, 0.6065],
         [0.7718, 0.8826, 0.7250],
         [0.1586, 0.4069, 0.3783]]])
K1 = tensor([[[0.5234, 0.1614, 0.5105],
         [0.2057, 0.8617, 0.6540],
         [0.2978, 0.7523, 0.3999]]])
K2 = tensor([[[0.2177, 0.8328, 0.6232],
         [0.0510, 0.2805, 0.5110],
         [0.5006, 0.5911, 0.0827]]])
x1 = tensor([[[0.4285, 0.0014]]]), x2 = tensor([[[0.9581, 0.7788]]])
mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-1-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3b070>
batch_size = 1, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.7975, 0.7326, 0.7770],
         [0.1940, 0.2736, 0.1378],
         [0.6458, 0.3833, 0.8047]]])
K1 = tensor([[[0.8511, 0.8472, 0.3772],
         [0.2124, 0.2252, 0.6569],
         [0.7560, 0.0249, 0.5936]]])
K2 = tensor([[[0.4947, 0.5184, 0.3366],
         [0.4070, 0.1587, 0.3902],
         [0.6606, 0.2857, 0.8722]]])
x1 = tensor([[[0.9665, 0.3823],
         [0.7128, 0.7856],
         [0.9439, 0.9548]]])
x2 = tensor([[[0.0051, 0.9223]]]), mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3afb0>
batch_size = 2, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5604, 0.3532, 0.4741],
         [0.6441, 0.4183, 0.7847],
         [0.1175, 0.7806, 0.2447]],

        [[0.6466, 0.3318, 0.1100],
         [0.7453, 0.4163, 0.0677],
         [0.1078, 0.9269, 0.0220]]])
K1 = tensor([[[0.5083, 0.8577, 0.9438],
         [0.3909, 0.5769, 0.6947],
         [0.0859, 0.0127, 0.3097]],

        [[0.3340, 0.7749, 0.2572],
         [0.6981, 0.4752, 0.7035],
         [0.5783, 0.6275, 0.4176]]])
K2 = tensor([[[0.5328, 0.2937, 0.0233],
         [0.6265, 0.8329, 0.9385],
         [0.3277, 0.8036, 0.7375]]])
x1 = tensor([[[0.7493, 0.0707],
         [0.3746, 0.2098],
         [0.1747, 0.7343]],

        [[0.7007, 0.4158],
         [0.7540, 0.9479],
         [0.5987, 0.1857]]])
x2 = tensor([[[0.6925, 0.3338]],

        [[0.5772, 0.9475]]]), mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-8] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3b370>
batch_size = 2, num_points = 8, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5353, 0.7224, 0.3320],
         [0.3979, 0.0217, 0.4015],
         [0.1993, 0.8344, 0.8837]],

        [[0.6804, 0.2573, 0.3970],
         [0.7384, 0.7815, 0.1652],
         [0.5110, 0.9222, 0.8256]]])
K1 = tensor([[[0.2437, 0.3813, 0.2624],
         [0.9097, 0.0901, 0.9548],
         [0.7095, 0.7621, 0.5093]],

        [[0.1950, 0.2562, 0.9309],
         [0.8809, 0.5406, 0.8578],
         [0.7887, 0.4149, 0.4705]]])
K2 = tensor([[[0.5093, 0.8799, 0.7724],
         [0.6327, 0.5716, 0.2144],
         [0.5327, 0.7739, 0.7931]]])
x1 = tensor([[[0.3316, 0.7301],
         [0.0021, 0.1128],
         [0.7470, 0.8573],
         [0.4191, 0.2948],
         [... 0.3457],
         [0.4062, 0.7406],
         [0.8419, 0.7471],
         [0.4276, 0.5555],
         [0.2637, 0.9515]]])
x2 = tensor([[[0.4199, 0.6091]],

        [[0.2513, 0.4801]]]), mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-3-2] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3b430>
batch_size = 3, num_points = 2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5238, 0.0537, 0.1032],
         [0.1324, 0.2234, 0.3769],
         [0.6130, 0.9105, 0.1870]],

        [[0..., 0.0626]],

        [[0.1026, 0.3715, 0.6757],
         [0.8099, 0.2543, 0.1981],
         [0.1602, 0.5735, 0.0347]]])
K1 = tensor([[[0.2567, 0.9766, 0.7598],
         [0.1162, 0.0184, 0.8290],
         [0.7139, 0.2165, 0.8555]],

        [[0..., 0.7354]],

        [[0.3377, 0.2532, 0.9745],
         [0.0378, 0.4632, 0.9132],
         [0.2923, 0.3341, 0.4402]]])
K2 = tensor([[[0.5046, 0.3053, 0.9979],
         [0.6650, 0.4249, 0.6742],
         [0.8235, 0.0874, 0.9770]]])
x1 = tensor([[[0.2929, 0.6331],
         [0.4115, 0.2201]],

        [[0.3384, 0.9441],
         [0.8373, 0.7829]],

        [[0.4507, 0.7121],
         [0.4126, 0.4699]]])
x2 = tensor([[[0.4977, 0.4894]],

        [[0.3479, 0.0579]],

        [[0.3134, 0.8493]]])
mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_______ TestMotionFromEssentialChooseSolution.test_masking[cpu-float32] ________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3b700>
device = device(type='cpu'), dtype = torch.float32

    def test_masking(self, device, dtype):
        E_mat = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(2, 10, 2, device=device, dtype=dtype)
        x2 = torch.rand(2, 10, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[:, 1:-1, :], x2[:, 1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5241, 0.2578, 0.8822],
         [0.1233, 0.2431, 0.8478],
         [0.6353, 0.3442, 0.3330]],

        [[0.6841, 0.0694, 0.1598],
         [0.5633, 0.9962, 0.9782],
         [0.1614, 0.9495, 0.7206]]])
K1 = tensor([[[0.7061, 0.5492, 0.5410],
         [0.7505, 0.3489, 0.3532],
         [0.9266, 0.2618, 0.1102]],

        [[0.5125, 0.0189, 0.1875],
         [0.9228, 0.9694, 0.5604],
         [0.5825, 0.3388, 0.0619]]])
K2 = tensor([[[0.2928, 0.2879, 0.9858],
         [0.9954, 0.5450, 0.4855],
         [0.6900, 0.5873, 0.7853]],

        [[0.6115, 0.2581, 0.9337],
         [0.3416, 0.0298, 0.0394],
         [0.1286, 0.5190, 0.2502]]])
x1 = tensor([[[0.5782, 0.3328],
         [0.5216, 0.0629],
         [0.0075, 0.6535],
         [0.4314, 0.9815],
         [... 0.9658],
         [0.8231, 0.4528],
         [0.9868, 0.3379],
         [0.3807, 0.4430],
         [0.4696, 0.6054]]])
x2 = tensor([[[0.6126, 0.7266],
         [0.2939, 0.7514],
         [0.1244, 0.7561],
         [0.7726, 0.2793],
         [... 0.4332],
         [0.9503, 0.7099],
         [0.6660, 0.2219],
         [0.9831, 0.1910],
         [0.3150, 0.8094]]])
mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-10] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3baf0>
num_points = 10, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
        R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])
        assert R.shape == (3, 3)
>       assert t.shape == (3, 1)
E       assert torch.Size([3]) == (3, 1)
E         
E         Right contains one more item: 1
E         
E         Full diff:
E         + torch.Size([3])
E         - (
E         -     3,
E         -     1,
E         - )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:463: AssertionError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-15] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3ba30>
num_points = 15, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
        R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])
        assert R.shape == (3, 3)
>       assert t.shape == (3, 1)
E       assert torch.Size([3]) == (3, 1)
E         
E         Right contains one more item: 1
E         
E         Full diff:
E         + torch.Size([3])
E         - (
E         -     3,
E         -     1,
E         - )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:463: AssertionError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-20] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b3bd30>
num_points = 20, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
        R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])
        assert R.shape == (3, 3)
>       assert t.shape == (3, 1)
E       assert torch.Size([3]) == (3, 1)
E         
E         Right contains one more item: 1
E         
E         Full diff:
E         + torch.Size([3])
E         - (
E         -     3,
E         -     1,
E         - )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:463: AssertionError
_______ TestMotionFromEssentialChooseSolution.test_two_view[cpu-float32] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b74070>
device = device(type='cpu'), dtype = torch.float32

    def test_two_view(self, device, dtype):
        scene = generate_two_view_random_scene(device, dtype)
    
        E_mat = epi.essential_from_Rt(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
    
        R, t = epi.relative_camera_motion(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
        t = torch.nn.functional.normalize(t, dim=1)
    
>       R_hat, t_hat, _ = epi.motion_from_essential_choose_solution(
            E_mat, scene["K1"], scene["K2"], scene["x1"], scene["x2"]
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[-0.3003, -0.1975,  1.0355],
         [ 0.9112, -0.0465,  0.4941],
         [-0.6860, -0.0644,  0.1873]]])
K1 = tensor([[[58.3366,  0.0000, 16.3743],
         [ 0.0000, 27.2250, 97.1153],
         [ 0.0000,  0.0000,  1.0000]]])
K2 = tensor([[[58.3366,  0.0000, 16.3743],
         [ 0.0000, 27.2250, 97.1153],
         [ 0.0000,  0.0000,  1.0000]]])
x1 = tensor([[[-11.6913,  85.9306],
         [ 16.8641,  95.7545],
         [ -6.8846, 112.3517],
         [ 19.1973,  90.5...   [ 35.0849,  80.8930],
         [  9.0117,  94.1931],
         [ 11.1466,  97.5521],
         [  3.1127, 108.0491]]])
x2 = tensor([[[-7.2416e+00,  8.5014e+01],
         [ 1.3176e+01,  9.0226e+01],
         [-7.3391e+00,  9.7080e+01],
       ...e+01],
         [ 6.0750e+00,  9.0912e+01],
         [ 3.9833e+00,  9.5612e+01],
         [-1.1458e+00,  9.6129e+01]]])
mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
__________ TestMotionFromEssentialChooseSolution.test_gradcheck[cpu] ___________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x782271b74310>
device = device(type='cpu')

    def test_gradcheck(self, device):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=torch.float64, requires_grad=True)
        K1 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        K2 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        x1 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
        x2 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
    
>       self.gradcheck(
            epi.motion_from_essential_choose_solution,
            (E_mat, K1, K2, x1, x2),
            requires_grad=(True, False, False, False, False),
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:260: in motion_from_essential_choose_solution
    return motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2, mask)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

E_mat = tensor([[[0.5161, 0.0639, 0.2744],
         [0.1231, 0.3486, 0.6386],
         [0.9102, 0.6774, 0.1241]]], dtype=torch.float64, requires_grad=True)
K1 = tensor([[[0.0222, 0.6982, 0.8273],
         [0.9086, 0.9261, 0.8882],
         [0.9958, 0.1038, 0.9025]]], dtype=torch.float64)
K2 = tensor([[[0.3553, 0.3539, 0.5409],
         [0.2806, 0.8676, 0.6292],
         [0.5844, 0.0741, 0.0171]]], dtype=torch.float64)
x1 = tensor([[[0.9682, 0.7053],
         [0.1068, 0.8082]]], dtype=torch.float64)
x2 = tensor([[[0.1786, 0.9117],
         [0.5042, 0.3570]]], dtype=torch.float64)
mask = None

    def motion_from_essential_choose_solution(E_mat: torch.Tensor, K1: torch.Tensor, K2: torch.Tensor, x1: torch.Tensor, x2: torch.Tensor, mask: Optional[torch.Tensor]=None) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Recover the relative camera rotation and translation from an estimated essential matrix.
    
        Args:
            E_mat (Tensor): Essential matrix of shape (3, 3).
            K1 (Tensor): Camera matrix for the first image of shape (3, 3).
            K2 (Tensor): Camera matrix for the second image of shape (3, 3).
            x1 (Tensor): Points in the first image of shape (N, 2).
            x2 (Tensor): Corresponding points in the second image of shape (N, 2).
            mask (Tensor, optional): Boolean mask to exclude points from choosing the best solution.
    
        Returns:
            Tuple[Tensor, Tensor, Tensor]: Rotation matrix (3, 3), translation vector (3,), and 3D points (N, 3).
        """
        if E_mat.shape != (3, 3):
>           raise ValueError('E_mat must be of shape (3, 3)')
E           ValueError: E_mat must be of shape (3, 3)

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:30: ValueError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]
============================== 11 failed in 0.61s ==============================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'cudagraphs', 'onnxrt', 'tvm', 'openxla', 'jit', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.21s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'onnxrt', 'openxla', 'tvm', 'cudagraphs', 'jit', 'inductor', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.21s ==============================
