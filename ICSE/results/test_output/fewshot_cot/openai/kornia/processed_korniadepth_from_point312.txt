output file:
processed_korniadepth_from_point312.json
function:
depth_from_point
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'openxla', 'inductor', 'tvm', 'onnxrt', 'cudagraphs', 'jit', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] FAILED

=================================== FAILURES ===================================
________ TestMotionFromEssentialChooseSolution.test_smoke[cpu-float32] _________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b42b60>
device = device(type='cpu'), dtype = torch.float32

    def test_smoke(self, device, dtype):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        x2 = torch.rand(1, 1, 2, device=device, dtype=dtype)
        R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)
>       assert R.shape == (1, 3, 3)
E       AssertionError: assert torch.Size([1, 1, 3, 3]) == (1, 3, 3)
E         
E         At index 1 diff: 1 != 3
E         Left contains one more item: 3
E         
E         Full diff:
E         + torch.Size([1, 1, 3, 3])
E         - (...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:418: AssertionError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-1-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b43010>
batch_size = 1, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.0413,  0.5237, -0.5004],
          [-0.0161,  0.5214, -0.5136],
          [-0.0299,  0.5157, -0.5143]],
...         [[ 0.0728, -1.8723,  1.9678],
          [ 0.0451, -1.9836,  1.9708],
          [ 0.0958, -2.0343,  2.0583]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-3] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b42f50>
batch_size = 2, num_points = 3, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 5.3553e-01,  2.2429e-01, -4.9519e-01],
          [ 4.8011e-01, -9.3536e-03, -6.4523e-01],
          [ 5.85...  9.2049e-01],
          [ 8.1050e+01, -2.5267e+01, -6.8177e+00],
          [-7.7117e-01, -1.3128e+00,  6.2927e-01]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (3) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-2-8] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b43310>
batch_size = 2, num_points = 8, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 6.5415e-01,  4.1429e-01, -4.2824e-01],
          [ 3.6906e-02,  8.4921e-01, -3.3292e-01],
          [ 1.08...  6.8594e-02],
          [-1.6315e-01,  7.8981e-02, -8.8032e-02],
          [-1.9033e-01,  6.0198e-02, -8.8786e-02]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
______ TestMotionFromEssentialChooseSolution.test_shape[cpu-float32-3-2] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b433d0>
batch_size = 3, num_points = 2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size, num_points", [(1, 3), (2, 3), (2, 8), (3, 2)])
    def test_shape(self, batch_size, num_points, device, dtype):
        B, N = batch_size, num_points
        E_mat = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(B, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(1, 3, 3, device=device, dtype=dtype)  # check for broadcasting
        x1 = torch.rand(B, N, 2, device=device, dtype=dtype)
        x2 = torch.rand(B, 1, 2, device=device, dtype=dtype)  # check for broadcasting
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1, x2)

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.1740,  0.1087,  0.1727],
          [-0.3432,  0.1706,  0.3136]],

         [[ 0.1740, -0.1087, -0.1727],...        [ 0.3443,  0.6025, -0.6857]],

         [[-0.3080, -0.6735,  0.7018],
          [-0.3443, -0.6025,  0.6857]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (2) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_______ TestMotionFromEssentialChooseSolution.test_masking[cpu-float32] ________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b436a0>
device = device(type='cpu'), dtype = torch.float32

    def test_masking(self, device, dtype):
        E_mat = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K1 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        K2 = torch.rand(2, 3, 3, device=device, dtype=dtype)
        x1 = torch.rand(2, 10, 2, device=device, dtype=dtype)
        x2 = torch.rand(2, 10, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[:, 1:-1, :], x2[:, 1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
  ...
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-7.0766e-01,  4.9654e-01, -3.1367e-01],
          [-4.6641e-01,  4.1559e-01, -3.0252e-01],
          [-6.61...  1.2593e-01],
          [-5.7695e-01,  5.0339e-03,  2.1285e-01],
          [-9.9430e-01,  1.4109e-01,  7.1764e-02]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-10] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b43a90>
num_points = 10, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[ 0.4574,  0.2614, -0.2471],
          [ 0.5836,  0.4372, -0.1154],
          [ 0.7895, -0.1648, -0.2779],
 ...          [-0.7383,  0.2944,  0.0401],
          [-1.0691,  0.2704,  0.2611],
          [-1.1064,  0.2013,  0.1757]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (8) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-15] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b439d0>
num_points = 15, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-0.3924,  0.7602, -0.3213],
          [-0.4104,  0.7206, -0.4256],
          [-0.7333,  0.3107,  0.0229],
 ...          [ 0.3872, -0.6628,  0.4131],
          [ 0.0702, -0.7242,  0.3247],
          [-0.3197, -0.2443,  0.4658]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (13) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_____ TestMotionFromEssentialChooseSolution.test_unbatched[cpu-float32-20] _____

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b43cd0>
num_points = 20, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("num_points", [10, 15, 20])
    def test_unbatched(self, num_points, device, dtype):
        N = num_points
        E_mat = torch.rand(3, 3, device=device, dtype=dtype)
        K1 = torch.rand(3, 3, device=device, dtype=dtype)
        K2 = torch.rand(3, 3, device=device, dtype=dtype)
        x1 = torch.rand(N, 2, device=device, dtype=dtype)
        x2 = torch.rand(N, 2, device=device, dtype=dtype)
    
>       R, t, X = epi.motion_from_essential_choose_solution(E_mat, K1, K2, x1[1:-1, :], x2[1:-1, :])

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-3.5047e-01,  3.2260e-01,  2.5108e-01],
          [ 4.5051e-02, -6.6794e-01,  2.7184e-02],
          [-1.82... -3.0427e-02],
          [ 2.5457e-02, -3.9093e-01, -1.3206e-01],
          [-2.5552e-02, -3.9448e-01,  9.7564e-02]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (18) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
_______ TestMotionFromEssentialChooseSolution.test_two_view[cpu-float32] _______

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b43fa0>
device = device(type='cpu'), dtype = torch.float32

    def test_two_view(self, device, dtype):
        scene = generate_two_view_random_scene(device, dtype)
    
        E_mat = epi.essential_from_Rt(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
    
        R, t = epi.relative_camera_motion(scene["R1"], scene["t1"], scene["R2"], scene["t2"])
        t = torch.nn.functional.normalize(t, dim=1)
    
>       R_hat, t_hat, _ = epi.motion_from_essential_choose_solution(
            E_mat, scene["K1"], scene["K2"], scene["x1"], scene["x2"]
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:482: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...     [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]])
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]])
X = tensor([[[[-9.8403e-02, -4.6656e-01, -1.3979e+00],
          [ 1.4894e-01, -6.2602e-01, -5.8565e-01],
          [-1.75... -8.9209e-01],
          [-1.3158e-01, -1.0147e-01, -5.3109e-01],
          [-1.4673e-01, -8.8105e-01, -1.0922e+00]]]])

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (30) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
__________ TestMotionFromEssentialChooseSolution.test_gradcheck[cpu] ___________

self = <test_essential.TestMotionFromEssentialChooseSolution object at 0x7ff532b782b0>
device = device(type='cpu')

    def test_gradcheck(self, device):
        E_mat = torch.rand(1, 3, 3, device=device, dtype=torch.float64, requires_grad=True)
        K1 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        K2 = torch.rand(1, 3, 3, device=device, dtype=torch.float64)
        x1 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
        x2 = torch.rand(1, 2, 2, device=device, dtype=torch.float64)
    
>       self.gradcheck(
            epi.motion_from_essential_choose_solution,
            (E_mat, K1, K2, x1, x2),
            requires_grad=(True, False, False, False, False),
        )

/local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/essential.py:522: in motion_from_essential_choose_solution
    d1 = depth_from_point(R1, t1, X)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/projection.py:126: in depth_from_point
    return depth_from_point(R, t, X)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

R = tensor([[[[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0...        [0., 0., 1.]],

         [[1., 0., 0.],
          [0., 1., 0.],
          [0., 0., 1.]]]], dtype=torch.float64)
t = tensor([[[[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]],

         [[0.],
          [0.],
          [0.]]]], dtype=torch.float64)
X = tensor([[[[ 0.5765, -0.6906, -0.4298],
          [ 0.5856, -0.4025, -0.4505]],

         [[-0.5765,  0.6906,  0.4298],....5528,  0.6930,  0.3980],
          [-0.5320,  0.5075,  0.4794]]]], dtype=torch.float64,
       grad_fn=<MulBackward0>)

    def depth_from_point(R: torch.Tensor, t: torch.Tensor, X: torch.Tensor) -> torch.Tensor:
        """
        Return the depth of a point transformed by a rigid transform.
    
        Args:
            R: The rotation matrix with shape :math:`(*, 3, 3)`.
            t: The translation vector with shape :math:`(*, 3, 1)`.
            X: The 3D points with shape :math:`(*, 3)`.
    
        Returns:
            The depth value per point with shape :math:`(*, 1)`.
        """
        if R.shape[-2:] != (3, 3):
            raise ValueError('Rotation matrix R must have shape (*, 3, 3)')
        if t.shape[-2:] != (3, 1):
            raise ValueError('Translation vector t must have shape (*, 3, 1)')
        if X.shape[-1] != 3:
            raise ValueError('3D points X must have shape (*, 3)')
>       rotated_points = torch.matmul(R, X.unsqueeze(-1))
E       RuntimeError: The size of tensor a (4) must match the size of tensor b (2) at non-singleton dimension 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/geometry/epipolar/temp.py:29: RuntimeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu]
============================== 11 failed in 0.63s ==============================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'openxla', 'inductor', 'jit', 'tvm', 'cudagraphs', 'onnxrt', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.20s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'tvm', 'openxla', None, 'inductor', 'onnxrt', 'cudagraphs', 'jit'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 11 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_smoke[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-1-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-3] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-2-8] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_shape[cpu-float32-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_masking[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-10] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-15] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_unbatched[cpu-float32-20] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_two_view[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution::test_gradcheck[cpu] PASSED

============================== 11 passed in 0.28s ==============================
