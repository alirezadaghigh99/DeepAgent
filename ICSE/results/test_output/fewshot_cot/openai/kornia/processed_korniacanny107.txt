output file:
processed_korniacanny107.json
function:
canny
Error Cases:

Pass or Failed: 0

Related Failed Test Cases:
{'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32] FAILED', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1]', 'FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1]', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2] FAILED', '../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2] FAILED'}

All Test Cases On Generated code:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'inductor', 'openxla', 'onnxrt', 'tvm', 'cudagraphs', 'jit', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 47 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_exception[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1] FAILED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1] FAILED

=================================== FAILURES ===================================
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1] __________

self = <test_canny.TestCanny object at 0x79effc146650>, batch_size = 1
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = False, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2] __________

self = <test_canny.TestCanny object at 0x79effc145cc0>, batch_size = 2
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = False, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
____ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc146200>, batch_size = 1
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = False
low_threshold = 0.1, high_threshold = 0.2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc1462f0>, batch_size = 2
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = False
low_threshold = 0.1, high_threshold = 0.2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1] __________

self = <test_canny.TestCanny object at 0x79effc1463e0>, batch_size = 1
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = False, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2] __________

self = <test_canny.TestCanny object at 0x79effc1464d0>, batch_size = 2
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = False, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
____ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc1465c0>, batch_size = 1
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = False
low_threshold = 0.1, high_threshold = 0.2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____ TestCanny.test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc1475e0>, batch_size = 2
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = False
low_threshold = 0.1, high_threshold = 0.2, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1] ___________

self = <test_canny.TestCanny object at 0x79effc1476d0>, batch_size = 1
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2] ___________

self = <test_canny.TestCanny object at 0x79effc1477c0>, batch_size = 2
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
_____ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc1478b0>, batch_size = 1
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_____ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc1479a0>, batch_size = 2
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1] ___________

self = <test_canny.TestCanny object at 0x79effc147a90>, batch_size = 1
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2] ___________

self = <test_canny.TestCanny object at 0x79effc147b80>, batch_size = 2
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
_____ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc147c70>, batch_size = 1
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_____ TestCanny.test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc147d60>, batch_size = 2
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.1
high_threshold = 0.2, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1] __________

self = <test_canny.TestCanny object at 0x79effc147e50>, batch_size = 1
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = False, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2] __________

self = <test_canny.TestCanny object at 0x79effc147f40>, batch_size = 2
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = False, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
____ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc174070>, batch_size = 1
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = False
low_threshold = 0.3, high_threshold = 0.5, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc174160>, batch_size = 2
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = False
low_threshold = 0.3, high_threshold = 0.5, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1] __________

self = <test_canny.TestCanny object at 0x79effc174250>, batch_size = 1
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = False, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2] __________

self = <test_canny.TestCanny object at 0x79effc174340>, batch_size = 2
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = False, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
____ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc174430>, batch_size = 1
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = False
low_threshold = 0.3, high_threshold = 0.5, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____ TestCanny.test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc174520>, batch_size = 2
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = False
low_threshold = 0.3, high_threshold = 0.5, device = device(type='cpu')
dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1] ___________

self = <test_canny.TestCanny object at 0x79effc174610>, batch_size = 1
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2] ___________

self = <test_canny.TestCanny object at 0x79effc174700>, batch_size = 2
kernel_size = 3, sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (1.5, 1.0)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
_____ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc1747f0>, batch_size = 1
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_____ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc1748e0>, batch_size = 2
kernel_size = (5, 7), sigma = (1.5, 1.0), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (1.5, 1.0), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1] ___________

self = <test_canny.TestCanny object at 0x79effc1749d0>, batch_size = 1
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
__________ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2] ___________

self = <test_canny.TestCanny object at 0x79effc174ac0>, batch_size = 2
kernel_size = 3, sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = 3, sigma = (2.5, 0.5)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
        blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
        sobel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        sobel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)
        grad_x = F.conv2d(blurred, sobel_x, padding=1)
        grad_y = F.conv2d(blurred, sobel_y, padding=1)
        grad_magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + eps)
        grad_angle = torch.atan2(grad_y, grad_x)
        nms = torch.zeros_like(grad_magnitude)
        angle = grad_angle * (180.0 / torch.pi) % 180.0
        for i in range(1, H - 1):
            for j in range(1, W - 1):
                q = 255
                r = 255
                if 0 <= angle[0, 0, i, j] < 22.5 or 157.5 <= angle[0, 0, i, j] <= 180:
>                   q = grad_magnitude[0, 0, i, j + 1]
E                   IndexError: index 2 is out of bounds for dimension 3 with size 2

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:54: IndexError
_____ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1] _____

self = <test_canny.TestCanny object at 0x79effc174bb0>, batch_size = 1
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_____ TestCanny.test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2] _____

self = <test_canny.TestCanny object at 0x79effc174ca0>, batch_size = 2
kernel_size = (5, 7), sigma = (2.5, 0.5), hysteresis = True, low_threshold = 0.3
high_threshold = 0.5, device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.parametrize("kernel_size", [3, (5, 7)])
    @pytest.mark.parametrize("sigma", [(1.5, 1.0), (2.5, 0.5)])
    @pytest.mark.parametrize("hysteresis", [False, True])
    @pytest.mark.parametrize("low_threshold,high_threshold", [(0.1, 0.2), (0.3, 0.5)])
    def test_smoke(self, batch_size, kernel_size, sigma, hysteresis, low_threshold, high_threshold, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny(low_threshold, high_threshold, kernel_size, sigma, hysteresis)
>       actual = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.3, high_threshold = 0.5, kernel_size = (5, 7)
sigma = (2.5, 0.5), hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________________ TestCanny.test_cardinality[cpu-float32-1] ___________________

self = <test_canny.TestCanny object at 0x79effc175060>, batch_size = 1
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    def test_cardinality(self, batch_size, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny()
>       magnitude, edges = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________________ TestCanny.test_cardinality[cpu-float32-2] ___________________

self = <test_canny.TestCanny object at 0x79effc174fa0>, batch_size = 2
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    def test_cardinality(self, batch_size, device, dtype):
        inp = torch.zeros(batch_size, 3, 4, 4, device=device, dtype=dtype)
    
        op = Canny()
>       magnitude, edges = op(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]],


        [[[0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.],
          [0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____________________ TestCanny.test_exception[cpu-float32] _____________________

self = <test_canny.TestCanny object at 0x79effc175450>
device = device(type='cpu'), dtype = torch.float32

    def test_exception(self, device, dtype):
        with pytest.raises(Exception) as errinfo:
            Canny(0.3, 0.2)
        assert "low_threshold should be smaller than the high_threshold" in str(errinfo)
    
        with pytest.raises(Exception) as errinfo:
            Canny(-2, 0.3)
        assert "Invalid low threshold." in str(errinfo)
    
        with pytest.raises(Exception) as errinfo:
            Canny(0.1, 3)
        assert "Invalid high threshold." in str(errinfo)
    
        with pytest.raises(Exception) as errinfo:
            canny(1)
>       assert "Not a Tensor type" in str(errinfo)
E       assert 'Not a Tensor type' in '<ExceptionInfo AttributeError("\'int\' object has no attribute \'shape\'") tblen=3>'
E        +  where '<ExceptionInfo AttributeError("\'int\' object has no attribute \'shape\'") tblen=3>' = str(<ExceptionInfo AttributeError("'int' object has no attribute 'shape'") tblen=3>)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:50: AssertionError
_________________ TestCanny.test_noncontiguous[cpu-float32-1] __________________

self = <test_canny.TestCanny object at 0x79effc175840>, batch_size = 1
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    def test_noncontiguous(self, batch_size, device, dtype):
        inp = torch.rand(batch_size, 3, 5, 5, device=device, dtype=dtype).expand(batch_size, -1, -1, -1)
    
>       magnitude, edges = canny(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.5501, 0.4778, 0.7225, 0.4900, 0.4997],
          [0.2649, 0.3035, 0.3125, 0.6213, 0.7211],
          [0.1...38, 0.8854],
          [0.3889, 0.2866, 0.3864, 0.6921, 0.4904],
          [0.6152, 0.5806, 0.4574, 0.5948, 0.4639]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_________________ TestCanny.test_noncontiguous[cpu-float32-2] __________________

self = <test_canny.TestCanny object at 0x79effc175780>, batch_size = 2
device = device(type='cpu'), dtype = torch.float32

    @pytest.mark.parametrize("batch_size", [1, 2])
    def test_noncontiguous(self, batch_size, device, dtype):
        inp = torch.rand(batch_size, 3, 5, 5, device=device, dtype=dtype).expand(batch_size, -1, -1, -1)
    
>       magnitude, edges = canny(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.2158, 0.3221, 0.5831, 0.0792, 0.3070],
          [0.3958, 0.8499, 0.7860, 0.4725, 0.2098],
          [0.7...26, 0.8487],
          [0.9153, 0.3715, 0.4874, 0.2608, 0.1583],
          [0.7794, 0.4061, 0.6625, 0.2897, 0.2493]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
____________________ TestCanny.test_magnitude[cpu-float32] _____________________

self = <test_canny.TestCanny object at 0x79effc174d90>
device = device(type='cpu'), dtype = torch.float32

    def test_magnitude(self, device, dtype):
        inp = torch.tensor(
            [
                [
                    [
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                        [0.0, 0.0, 1.0, 0.0, 0.0],
                        [0.0, 1.0, 1.0, 1.0, 0.0],
                        [0.0, 0.0, 1.0, 0.0, 0.0],
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_magnitude = torch.tensor(
            [
                [
                    [
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                        [0.0, 1.2458, 0.9672, 1.2458, 0.0],
                        [0.0, 0.9672, 0.0, 0.9672, 0.0],
                        [0.0, 1.2458, 0.9672, 1.2458, 0.0],
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_edges = torch.tensor(
            [
                [
                    [
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                        [0.0, 1.0, 1.0, 1.0, 0.0],
                        [0.0, 1.0, 0.0, 1.0, 0.0],
                        [0.0, 1.0, 1.0, 1.0, 0.0],
                        [0.0, 0.0, 0.0, 0.0, 0.0],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       magnitude, edges = canny(inp)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0., 0., 0., 0., 0.],
          [0., 0., 1., 0., 0.],
          [0., 1., 1., 1., 0.],
          [0., 0., 1., 0., 0.],
          [0., 0., 0., 0., 0.]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________________ TestCanny.test_magnitude_hyst[cpu-float32] __________________

self = <test_canny.TestCanny object at 0x79effc175db0>
device = device(type='cpu'), dtype = torch.float32

    def test_magnitude_hyst(self, device, dtype):
        inp = torch.tensor(
            [
                [
                    [
                        [0.5, 0.4, 0.5, 0.45, 0.1],
                        [0.3, 0.2, 0.3, 0.0, 0.3],
                        [0.5, 1.0, 1.0, 0.6, 0.75],
                        [0.2, 0.4, 0.6, 0.0, 0.5],
                        [0.1, 0.35, 0.35, 0.26, 0.1],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_magnitude = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.4858, 0.5594, 0.6878, 0.6977, 0.5602],
                        [0.1129, 0.0000, 0.0000, 0.4531, 0.0000],
                        [0.6115, 0.5859, 0.6110, 0.6766, 0.5160],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_edges = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [1.0000, 1.0000, 1.0000, 1.0000, 1.0000],
                        [1.0000, 0.0000, 0.0000, 1.0000, 0.0000],
                        [1.0000, 1.0000, 1.0000, 1.0000, 1.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       magnitude, edges = canny(inp, hysteresis=True)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.5000, 0.4000, 0.5000, 0.4500, 0.1000],
          [0.3000, 0.2000, 0.3000, 0.0000, 0.3000],
          [0.5...00, 0.7500],
          [0.2000, 0.4000, 0.6000, 0.0000, 0.5000],
          [0.1000, 0.3500, 0.3500, 0.2600, 0.1000]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_______________ TestCanny.test_magnitude_hyst_false[cpu-float32] _______________

self = <test_canny.TestCanny object at 0x79effc1760e0>
device = device(type='cpu'), dtype = torch.float32

    def test_magnitude_hyst_false(self, device, dtype):
        inp = torch.tensor(
            [
                [
                    [
                        [0.5, 0.4, 0.5, 0.45, 0.1],
                        [0.3, 0.2, 0.3, 0.0, 0.3],
                        [0.5, 1.0, 1.0, 0.6, 0.75],
                        [0.2, 0.4, 0.6, 0.0, 0.5],
                        [0.1, 0.35, 0.35, 0.26, 0.1],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_magnitude = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.4858, 0.5594, 0.6878, 0.6977, 0.5602],
                        [0.1129, 0.0000, 0.0000, 0.4531, 0.0000],
                        [0.6115, 0.5859, 0.6110, 0.6766, 0.5160],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_edges = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [1.0000, 1.0000, 1.0000, 1.0000, 1.0000],
                        [0.5000, 0.0000, 0.0000, 1.0000, 0.0000],
                        [1.0000, 1.0000, 1.0000, 1.0000, 1.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       magnitude, edges = canny(inp, hysteresis=False)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.5000, 0.4000, 0.5000, 0.4500, 0.1000],
          [0.3000, 0.2000, 0.3000, 0.0000, 0.3000],
          [0.5...00, 0.7500],
          [0.2000, 0.4000, 0.6000, 0.0000, 0.5000],
          [0.1000, 0.3500, 0.3500, 0.2600, 0.1000]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = False, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
_______________ TestCanny.test_magnitude_threshold[cpu-float32] ________________

self = <test_canny.TestCanny object at 0x79effc176410>
device = device(type='cpu'), dtype = torch.float32

    def test_magnitude_threshold(self, device, dtype):
        inp = torch.tensor(
            [
                [
                    [
                        [0.5, 0.4, 0.5, 0.45, 0.1],
                        [0.3, 0.2, 0.3, 0.0, 0.3],
                        [0.5, 1.0, 1.0, 0.6, 0.75],
                        [0.2, 0.4, 0.6, 0.0, 0.5],
                        [0.1, 0.35, 0.35, 0.26, 0.1],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_magnitude = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.4858, 0.5594, 0.6878, 0.6977, 0.5602],
                        [0.1129, 0.0000, 0.0000, 0.4531, 0.0000],
                        [0.6115, 0.5859, 0.6110, 0.6766, 0.5160],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
        expected_edges = torch.tensor(
            [
                [
                    [
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],
                    ]
                ]
            ],
            device=device,
            dtype=dtype,
        )
    
>       magnitude, edges = canny(inp, low_threshold=0.3, high_threshold=0.9)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.5000, 0.4000, 0.5000, 0.4500, 0.1000],
          [0.3000, 0.2000, 0.3000, 0.0000, 0.3000],
          [0.5...00, 0.7500],
          [0.2000, 0.4000, 0.6000, 0.0000, 0.5000],
          [0.1000, 0.3500, 0.3500, 0.2600, 0.1000]]]])
low_threshold = 0.3, high_threshold = 0.9, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
________________________ TestCanny.test_gradcheck[cpu] _________________________

self = <test_canny.TestCanny object at 0x79effc1766e0>
device = device(type='cpu')

    def test_gradcheck(self, device):
        if "cuda" in str(device):
            pytest.skip("RuntimeError: Backward is not reentrant, i.e., running backward,")
        batch_size, channels, height, width = 1, 1, 3, 4
        img = torch.rand(batch_size, channels, height, width, device=device, dtype=torch.float64)
>       self.gradcheck(canny, img)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/testing/base.py:143: in gradcheck
    return gradcheck(func, inputs, raise_exception=raise_exception, fast_mode=fast_mode, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2052: in gradcheck
    return _gradcheck_helper(**args)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/autograd/gradcheck.py:2074: in _gradcheck_helper
    func_out = func(*tupled_inputs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.1504, 0.2912, 0.7566, 0.7929],
          [0.6063, 0.2767, 0.9657, 0.4508],
          [0.3982, 0.1409, 0.0578, 0.5878]]]], dtype=torch.float64,
       requires_grad=True)
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
______________________ TestCanny.test_module[cpu-float32] ______________________

self = <test_canny.TestCanny object at 0x79effc1769e0>
device = device(type='cpu'), dtype = torch.float32

    def test_module(self, device, dtype):
        img = torch.rand(2, 3, 4, 5, device=device, dtype=dtype)
        op = canny
        op_module = Canny()
>       expected_magnitude, expected_edges = op(img)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.5755, 0.4446, 0.3297, 0.6750, 0.4420],
          [0.3729, 0.2360, 0.3975, 0.2023, 0.5247],
          [0.0...98, 0.2352],
          [0.3382, 0.3128, 0.1624, 0.2671, 0.5226],
          [0.1644, 0.2709, 0.5787, 0.4857, 0.2566]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 5), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_dynamo[cpu-float32-inductor-1-kernel_size1] __________

self = <test_canny.TestCanny object at 0x79effc176e00>, batch_size = 1
kernel_size = (5, 7), device = device(type='cpu'), dtype = torch.float32
torch_optimizer = functools.partial(<function compile at 0x79f0c752f1c0>, backend='inductor')

    @pytest.mark.parametrize("kernel_size", [5, (5, 7)])
    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.skipif(torch_version() in {"2.0.0", "2.0.1"}, reason="Not working on 2.0")
    def test_dynamo(self, batch_size, kernel_size, device, dtype, torch_optimizer):
        if (
            torch_version() in {"2.1.1", "2.1.2", "2.2.2", "2.3.1"}
            and dtype == torch.float64
            and (isinstance(kernel_size, int) or kernel_size[0] == kernel_size[1])
        ):
            pytest.skip("Canny compiled failing into fp64 for kernel sizes where kx and ky are equals")
        data = torch.ones(batch_size, 3, 10, 10, device=device, dtype=dtype)
        op = Canny(kernel_size=kernel_size)
        op_optimized = torch_optimizer(op)
    
>       expected_magnitude, expected_edges = op(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
           0.9999, 0.9999],
          [0.99...999, 0.9999],
          [0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
           0.9999, 0.9999]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
__________ TestCanny.test_dynamo[cpu-float32-inductor-2-kernel_size1] __________

self = <test_canny.TestCanny object at 0x79effc177220>, batch_size = 2
kernel_size = (5, 7), device = device(type='cpu'), dtype = torch.float32
torch_optimizer = functools.partial(<function compile at 0x79f0c752f1c0>, backend='inductor')

    @pytest.mark.parametrize("kernel_size", [5, (5, 7)])
    @pytest.mark.parametrize("batch_size", [1, 2])
    @pytest.mark.skipif(torch_version() in {"2.0.0", "2.0.1"}, reason="Not working on 2.0")
    def test_dynamo(self, batch_size, kernel_size, device, dtype, torch_optimizer):
        if (
            torch_version() in {"2.1.1", "2.1.2", "2.2.2", "2.3.1"}
            and dtype == torch.float64
            and (isinstance(kernel_size, int) or kernel_size[0] == kernel_size[1])
        ):
            pytest.skip("Canny compiled failing into fp64 for kernel sizes where kx and ky are equals")
        data = torch.ones(batch_size, 3, 10, 10, device=device, dtype=dtype)
        op = Canny(kernel_size=kernel_size)
        op_optimized = torch_optimizer(op)
    
>       expected_magnitude, expected_edges = op(data)

/local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:274: in __call__
    _output_image = decorated_forward(*inputs, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/core/module.py:63: in wrapper
    tensor_outputs = func(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1736: in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/venv/lib/python3.10/site-packages/torch/nn/modules/module.py:1747: in _call_impl
    return forward_call(*args, **kwargs)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:136: in forward
    return canny(input, self.low_threshold, self.high_threshold, self.kernel_size, self.sigma, self.hysteresis, self.eps)
/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/canny.py:15: in canny
    return canny(input, low_threshold, high_threshold, kernel_size, sigma, hysteresis, eps)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
           0.9999, 0.9999],
          [0.99...999, 0.9999],
          [0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999, 0.9999,
           0.9999, 0.9999]]]])
low_threshold = 0.1, high_threshold = 0.2, kernel_size = (5, 7), sigma = (1, 1)
hysteresis = True, eps = 1e-06

    def canny(input: torch.Tensor, low_threshold: float, high_threshold: float, kernel_size: int=5, sigma: float=1.0, hysteresis: bool=True, eps: float=1e-06) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Implements the Canny edge detection algorithm.
    
        Args:
            input (Tensor): Input image tensor with shape (B, C, H, W).
            low_threshold (float): Lower threshold for the hysteresis procedure.
            high_threshold (float): Upper threshold for the hysteresis procedure.
            kernel_size (int): Size of the kernel for the Gaussian blur.
            sigma (float): Standard deviation of the kernel for the Gaussian blur.
            hysteresis (bool): Whether to apply hysteresis edge tracking.
            eps (float): Regularization number to avoid NaN during backpropagation.
    
        Returns:
            Tuple[Tensor, Tensor]: Canny edge magnitudes map and filtered edges.
        """
        B, C, H, W = input.shape
        if C != 1 and C != 3:
            raise ValueError('Input tensor must have 1 or 3 channels.')
        if C == 3:
            input = 0.2989 * input[:, 0, :, :] + 0.587 * input[:, 1, :, :] + 0.114 * input[:, 2, :, :]
            input = input.unsqueeze(1)
        gaussian_kernel = torch.tensor([[1, 4, 6, 4, 1], [4, 16, 24, 16, 4], [6, 24, 36, 24, 6], [4, 16, 24, 16, 4], [1, 4, 6, 4, 1]], dtype=torch.float32) / 256.0
        gaussian_kernel = gaussian_kernel.unsqueeze(0).unsqueeze(0)
>       blurred = F.conv2d(input, gaussian_kernel, padding=kernel_size // 2)
E       TypeError: unsupported operand type(s) for //: 'tuple' and 'int'

/local/data0/moved_data/publishablew/kornia/kornia/kornia/filters/temp.py:40: TypeError
=========================== short test summary info ============================
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_exception[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1]
FAILED ../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1]
========================= 45 failed, 2 passed in 2.67s =========================


Final Test Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', 'tvm', 'jit', 'cudagraphs', 'openxla', 'onnxrt', 'inductor', None}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 47 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_exception[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1] PASSED

============================== 47 passed in 4.97s ==============================


Initial Result:
Setting up torch compile...
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-8.3.3, pluggy-1.5.0 -- /local/data0/moved_data/publishablew/kornia/kornia/venv/bin/python
cachedir: .pytest_cache

cpu info:
	- Model name: AMD Ryzen 7 PRO 5845 8-Core Processor
	- Architecture: x86_64
	- CPU(s): 16
	- Thread(s) per core: 2
	- CPU max MHz: 4661.7178
	- CPU min MHz: 2200.0000
gpu info: {'GPU 0': 'NVIDIA GeForce RTX 3060'}
main deps:
    - kornia-0.7.4
    - torch-2.5.1+cu124
        - commit: a8d6afb511a69687bbb2b7e88a3cf67917e1697e
        - cuda: 12.4
        - nvidia-driver: 555.42.02
x deps:
    - accelerate-1.1.1
dev deps:
    - kornia_rs-0.1.7
    - onnx-1.17.0
gcc info: (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0
available optimizers: {'', None, 'tvm', 'inductor', 'jit', 'openxla', 'onnxrt', 'cudagraphs'}
model weights cached: []

rootdir: /local/data0/moved_data/publishablew/kornia/kornia
configfile: pyproject.toml
plugins: timeout-2.3.1, jaxtyping-0.2.38
collecting ... collected 47 items

../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-False-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.1-0.2-True-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-False-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma0-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-3-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_smoke[cpu-float32-0.3-0.5-True-sigma1-kernel_size1-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_cardinality[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_exception[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_noncontiguous[cpu-float32-2] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_hyst_false[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_magnitude_threshold[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_gradcheck[cpu] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_module[cpu-float32] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-1-kernel_size1] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-5] PASSED
../../../../../../local/data0/moved_data/publishablew/kornia/kornia/tests/filters/test_canny.py::TestCanny::test_dynamo[cpu-float32-inductor-2-kernel_size1] PASSED

============================== 47 passed in 5.13s ==============================
