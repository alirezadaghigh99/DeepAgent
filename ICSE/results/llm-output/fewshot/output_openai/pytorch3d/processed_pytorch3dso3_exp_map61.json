{
    "result": "Certainly! Below is a Python function `so3_exp_map` that converts a batch of logarithmic representations of rotation matrices to a batch of 3x3 rotation matrices using the Rodrigues formula. The function handles singularities and checks for input shape validity.\n\n```python\nimport torch\n\ndef so3_exp_map(log_rot: torch.Tensor, eps: float = 0.0001) -> torch.Tensor:\n    \"\"\"\n    Converts a batch of logarithmic representations of rotation matrices to a batch of 3x3 rotation matrices\n    using the Rodrigues formula.\n\n    Args:\n        log_rot (torch.Tensor): A batch of vectors of shape (minibatch, 3) representing logarithmic rotations.\n        eps (float, optional): A small value to handle singularity around log(R) = 0. Defaults to 0.0001.\n\n    Returns:\n        torch.Tensor: A batch of rotation matrices of shape (minibatch, 3, 3).\n\n    Raises:\n        ValueError: If the input log_rot is not of shape (minibatch, 3).\n    \"\"\"\n    if log_rot.ndim != 2 or log_rot.shape[1] != 3:\n        raise ValueError(\"Input log_rot must be of shape (minibatch, 3)\")\n\n    # Compute the angle (theta) from the logarithmic representation\n    theta = torch.norm(log_rot, dim=1, keepdim=True)\n\n    # Handle the singularity by clamping theta\n    theta_clamped = torch.clamp(theta, min=eps)\n\n    # Compute the unit rotation axis\n    k = log_rot / theta_clamped\n\n    # Compute the skew-symmetric cross-product matrix of k\n    K = torch.zeros((log_rot.shape[0], 3, 3), device=log_rot.device)\n    K[:, 0, 1] = -k[:, 2]\n    K[:, 0, 2] = k[:, 1]\n    K[:, 1, 0] = k[:, 2]\n    K[:, 1, 2] = -k[:, 0]\n    K[:, 2, 0] = -k[:, 1]\n    K[:, 2, 1] = k[:, 0]\n\n    # Compute the rotation matrices using Rodrigues' formula\n    I = torch.eye(3, device=log_rot.device).unsqueeze(0)\n    R = I + torch.sin(theta_clamped).unsqueeze(-1) * K + (1 - torch.cos(theta_clamped).unsqueeze(-1)) * torch.bmm(K, K)\n\n    return R\n```\n\n### Explanation:\n- **Input Validation**: The function first checks if the input `log_rot` is of the correct shape `(minibatch, 3)`. If not, it raises a `ValueError`.\n- **Theta Calculation**: It calculates the angle `theta` as the norm of each vector in the batch.\n- **Singularity Handling**: To handle the singularity at `theta = 0`, `theta` is clamped to a minimum value of `eps`.\n- **Rodrigues' Formula**: The function uses Rodrigues' rotation formula to compute the rotation matrices. It constructs the skew-symmetric matrix `K` and computes the rotation matrix `R` using the formula:\n  \\[\n  R = I + \\sin(\\theta)K + (1 - \\cos(\\theta))K^2\n  \\]\n- **Output**: The function returns a batch of 3x3 rotation matrices.",
    "prompt": "Create a Python function called so3_exp_map that takes in a torch.Tensor log_rot representing a batch of logarithmic representations of rotation matrices and an optional float eps set to 0.0001. The function converts the logarithmic representations to a batch of 3x3 rotation matrices using the Rodrigues formula. The input log_rot should be a batch of vectors of shape (minibatch, 3) and the output should be a batch of rotation matrices of shape (minibatch, 3, 3). The function handles a singularity around log(R) = 0 by clamping it with the eps argument. If the input log_rot is of incorrect shape, a ValueError is raised. The function returns the batch of rotation matrices after conversion. Reference to Rodrigues' rotation formula is provided for further information.",
    "function_name": "so3_exp_map",
    "ground_truth": "pytorch3d/transforms/so3.py",
    "test": "tests/test_so3.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}