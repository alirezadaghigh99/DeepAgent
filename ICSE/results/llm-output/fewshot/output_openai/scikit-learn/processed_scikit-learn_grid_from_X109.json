{
    "result": "Here's a Python function called `_grid_from_X` that generates a grid of points based on the percentiles of a given dataset `X`. This function follows the specifications you provided:\n\n```python\nimport numpy as np\nfrom itertools import product\n\ndef _grid_from_X(X, percentiles=(0.05, 0.95), is_categorical=None, grid_resolution=100):\n    \"\"\"\n    Generate a grid of points based on the percentiles of a given dataset X.\n\n    Args:\n        X (array-like): Input data of shape (n_samples, n_features).\n        percentiles (tuple of float): Percentiles to use for grid generation.\n        is_categorical (list of bool): List indicating if each feature is categorical.\n        grid_resolution (int): Number of points to generate between percentiles.\n\n    Returns:\n        grid (ndarray): Grid of points with shape (n_points, n_features).\n        values (list of ndarray): List of 1D arrays representing the values used to create the grid.\n    \"\"\"\n    X = np.asarray(X)\n    n_features = X.shape[1]\n    \n    if is_categorical is None:\n        is_categorical = [False] * n_features\n\n    values = []\n    for i in range(n_features):\n        if is_categorical[i]:\n            # Use unique values for categorical features\n            unique_values = np.unique(X[:, i])\n            values.append(unique_values)\n        else:\n            # Calculate percentiles for continuous features\n            lower, upper = np.percentile(X[:, i], [percentiles[0] * 100, percentiles[1] * 100])\n            if grid_resolution > len(np.unique(X[:, i])):\n                # Use unique values if grid_resolution is greater than the number of unique values\n                unique_values = np.unique(X[:, i])\n                values.append(unique_values)\n            else:\n                # Generate equally spaced points between percentiles\n                values.append(np.linspace(lower, upper, grid_resolution))\n\n    # Create a cartesian product of the values\n    grid = np.array(list(product(*values)))\n\n    return grid, values\n```\n\n### Explanation:\n- **Input Parameters:**\n  - `X`: The input dataset, expected to be a 2D array-like structure.\n  - `percentiles`: A tuple specifying the lower and upper percentiles for grid generation.\n  - `is_categorical`: A list indicating whether each feature is categorical.\n  - `grid_resolution`: The number of points to generate between the specified percentiles for continuous features.\n\n- **Function Logic:**\n  - Convert `X` to a NumPy array for easier manipulation.\n  - Determine the number of features in `X`.\n  - Initialize `is_categorical` to a list of `False` if not provided.\n  - For each feature, determine if it is categorical or continuous:\n    - For categorical features, use unique values.\n    - For continuous features, calculate the specified percentiles and generate equally spaced points between them, unless the number of unique values is less than `grid_resolution`.\n  - Use `itertools.product` to create a cartesian product of the values for each feature, resulting in the grid.\n\n- **Output:**\n  - `grid`: A 2D array where each row represents a point in the grid.\n  - `values`: A list of 1D arrays, each containing the values used to create the grid for a specific feature.",
    "prompt": "Generate a Python function called `_grid_from_X` that generates a grid of points based on the percentiles of a given dataset `X`. The function takes four parameters: `X` (array-like data), `percentiles` (tuple of float values), `is_categorical` (list of boolean values), and `grid_resolution` (integer). \n\nThe function calculates a grid by creating a cartesian product between the columns of `values`, where each column consists of `grid_resolution` equally-spaced points between the percentiles of the corresponding column in `X`. If `grid_resolution` is greater than the number of unique values in a column of `X` or if the feature is categorical (based on `is_categorical`), then the unique values will be used instead.\n\nThe function returns two outputs: `grid`, which is an ndarray containing a value for each feature at each point in the grid, and `values`, which is a list of 1d ndarrays representing the values used to create the grid. The size of each array in `values` is either `grid_resolution` or the number of unique values in the corresponding column of `X`, whichever is smaller.",
    "function_name": "_grid_from_X",
    "ground_truth": "sklearn/inspection/_partial_dependence.py",
    "test": "sklearn/inspection/tests/test_partial_dependence.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Table"
}