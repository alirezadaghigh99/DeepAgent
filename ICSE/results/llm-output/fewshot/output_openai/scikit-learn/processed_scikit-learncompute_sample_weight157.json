{
    "result": "Certainly! Below is a Python function `compute_sample_weight` that estimates sample weights for unbalanced datasets. It handles different formats for `class_weight`, including a dictionary, a list of dictionaries, the string \"balanced\", or `None`. It also considers the `y` parameter for class labels and an optional `indices` parameter for subsampling.\n\n```python\nimport numpy as np\nfrom sklearn.utils.class_weight import compute_class_weight\n\ndef compute_sample_weight(class_weight, y, indices=None):\n    \"\"\"\n    Estimate sample weights by class for unbalanced datasets.\n\n    Args:\n        class_weight (dict, list of dicts, \"balanced\", or None): Weights associated with classes.\n        y (array-like, sparse matrix): Original class labels per sample.\n        indices (array-like of shape (n_subsample,), optional): Indices to be used in a subsample.\n\n    Returns:\n        sample_weight_vect (np.ndarray): Array of shape (n_samples,) containing the sample weights.\n    \"\"\"\n    y = np.asarray(y)\n    \n    if indices is not None:\n        y = y[indices]\n\n    unique_classes = np.unique(y)\n    \n    if class_weight == \"balanced\":\n        class_weight_vect = compute_class_weight(class_weight='balanced', classes=unique_classes, y=y)\n        class_weight_dict = dict(zip(unique_classes, class_weight_vect))\n    elif isinstance(class_weight, dict):\n        class_weight_dict = class_weight\n    elif isinstance(class_weight, list):\n        class_weight_dict = {cls: weight for d in class_weight for cls, weight in d.items()}\n    elif class_weight is None:\n        class_weight_dict = {cls: 1.0 for cls in unique_classes}\n    else:\n        raise ValueError(\"Invalid value for class_weight. Must be 'balanced', a dict, a list of dicts, or None.\")\n\n    sample_weight_vect = np.array([class_weight_dict.get(cls, 1.0) for cls in y])\n\n    return sample_weight_vect\n\n# Example usage:\n# y = np.array([0, 1, 0, 1, 1, 2])\n# class_weight = {0: 1.0, 1: 0.5, 2: 2.0}\n# indices = [0, 1, 2, 3]\n# sample_weights = compute_sample_weight(class_weight, y, indices)\n# print(sample_weights)\n```\n\n### Key Features:\n- **Class Weight Handling**: Supports different formats for `class_weight`, including automatic balancing.\n- **Subsampling**: Allows for subsampling using the `indices` parameter.\n- **Error Handling**: Raises a `ValueError` for invalid `class_weight` inputs.\n- **Example Usage**: Includes a commented example to demonstrate how to use the function.\n\nThis function is designed to be flexible and handle various scenarios for computing sample weights in unbalanced datasets.",
    "prompt": "Create a Python function called compute_sample_weight that estimates sample weights by class for unbalanced datasets. The function takes in three parameters: class_weight (dict, list of dicts, \"balanced\", or None), y (array-like, sparse matrix), and indices (array-like of shape (n_subsample,), default=None). \n\nThe class_weight parameter represents weights associated with classes, with options for different formats and the \"balanced\" mode for automatic adjustment based on class frequencies. The y parameter is an array of original class labels per sample, and the indices parameter is an array of indices to be used in a subsample.\n\nThe function returns a numpy array called sample_weight_vect of shape (n_samples,) containing the sample weights as applied to the original y. The function includes examples of usage and error handling for different scenarios.",
    "function_name": "compute_sample_weight",
    "ground_truth": "sklearn/utils/class_weight.py",
    "test": "sklearn/utils/tests/test_class_weight.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}