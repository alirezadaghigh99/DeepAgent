{
    "result": "To generate a Python function for computing a confusion matrix, you can use the following implementation. This function will calculate the confusion matrix based on the provided true labels, predicted labels, and optional parameters for labels, sample weights, and normalization.\n\n```python\nimport numpy as np\nfrom sklearn.utils.multiclass import unique_labels\n\ndef confusion_matrix(y_true, y_pred, labels=None, sample_weight=None, normalize=None):\n    \"\"\"\n    Compute confusion matrix to evaluate the accuracy of a classification.\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples,)\n        Ground truth (correct) target values.\n\n    y_pred : array-like of shape (n_samples,)\n        Estimated targets as returned by a classifier.\n\n    labels : array-like of shape (n_classes), default=None\n        List of labels to index the matrix. This may be used to reorder\n        or select a subset of labels.\n        If ``None`` is given, those that appear at least once\n        in ``y_true`` or ``y_pred`` are used in sorted order.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights.\n\n    normalize : {'true', 'pred', 'all'}, default=None\n        Normalizes confusion matrix over the true (rows), predicted (columns)\n        conditions or all the population. If None, confusion matrix will not be\n        normalized.\n\n    Returns\n    -------\n    C : ndarray of shape (n_classes, n_classes)\n        Confusion matrix whose i-th row and j-th\n        column entry indicates the number of\n        samples with true label being i-th class\n        and predicted label being j-th class.\n    \"\"\"\n    if labels is None:\n        labels = unique_labels(y_true, y_pred)\n    else:\n        labels = np.asarray(labels)\n\n    n_labels = labels.size\n    label_to_index = {label: i for i, label in enumerate(labels)}\n    y_true_indices = np.array([label_to_index.get(label, -1) for label in y_true])\n    y_pred_indices = np.array([label_to_index.get(label, -1) for label in y_pred])\n\n    # Initialize the confusion matrix\n    cm = np.zeros((n_labels, n_labels), dtype=np.int64)\n\n    # Populate the confusion matrix\n    for true_idx, pred_idx in zip(y_true_indices, y_pred_indices):\n        if true_idx >= 0 and pred_idx >= 0:\n            cm[true_idx, pred_idx] += 1\n\n    # Apply sample weights if provided\n    if sample_weight is not None:\n        sample_weight = np.asarray(sample_weight)\n        for i, (true_idx, pred_idx) in enumerate(zip(y_true_indices, y_pred_indices)):\n            if true_idx >= 0 and pred_idx >= 0:\n                cm[true_idx, pred_idx] += sample_weight[i] - 1\n\n    # Normalize the confusion matrix if required\n    if normalize == 'true':\n        cm = cm.astype(np.float64) / cm.sum(axis=1, keepdims=True)\n    elif normalize == 'pred':\n        cm = cm.astype(np.float64) / cm.sum(axis=0, keepdims=True)\n    elif normalize == 'all':\n        cm = cm.astype(np.float64) / cm.sum()\n\n    return cm\n```\n\nThis function uses `numpy` for array operations and `sklearn.utils.multiclass.unique_labels` to determine the unique labels present in the true and predicted arrays. The function supports optional normalization of the confusion matrix by true labels, predicted labels, or the entire matrix.",
    "prompt": "Generate a Python function called confusion_matrix that Compute confusion matrix to evaluate the accuracy of a classification.\n\n    By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`\n    is equal to the number of observations known to be in group :math:`i` and\n    predicted to be in group :math:`j`.\n\n    Thus in binary classification, the count of true negatives is\n    :math:`C_{0,0}`, false negatives is :math:`C_{1,0}`, true positives is\n    :math:`C_{1,1}` and false positives is :math:`C_{0,1}`.\n\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples,)\n        Ground truth (correct) target values.\n\n    y_pred : array-like of shape (n_samples,)\n        Estimated targets as returned by a classifier.\n\n    labels : array-like of shape (n_classes), default=None\n        List of labels to index the matrix. This may be used to reorder\n        or select a subset of labels.\n        If ``None`` is given, those that appear at least once\n        in ``y_true`` or ``y_pred`` are used in sorted order.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights.\n\n        .. versionadded:: 0.18\n\n    normalize : {'true', 'pred', 'all'}, default=None\n        Normalizes confusion matrix over the true (rows), predicted (columns)\n        conditions or all the population. If None, confusion matrix will not be\n        normalized.\n\n    Returns\n    -------\n    C : ndarray of shape (n_classes, n_classes)\n        Confusion matrix whose i-th row and j-th\n        column entry indicates the number of\n        samples with true label being i-th class\n        and predicted label being j-th class.",
    "function_name": "confusion_matrix",
    "ground_truth": "sklearn/metrics/_classification.py",
    "test": "sklearn/metrics/tests/test_classification.py::test_zero_division_nan_no_warning",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": ""
}