{
    "result": "Here's a Python function called `_smacof_single` that implements the SMACOF (Scaling by MAjorizing a COmplicated Function) algorithm for multidimensional scaling (MDS). This function computes the MDS embedding of a set of dissimilarities, either using a metric or non-metric approach.\n\n```python\nimport numpy as np\nfrom sklearn.utils import check_random_state\n\ndef _smacof_single(dissimilarities, metric=True, n_components=2, init=None,\n                   max_iter=300, verbose=0, eps=1e-3, random_state=None,\n                   normalized_stress=False):\n    \"\"\"\n    Computes multidimensional scaling using the SMACOF algorithm.\n\n    Parameters\n    ----------\n    dissimilarities : ndarray of shape (n_samples, n_samples)\n        Pairwise dissimilarities between the points. Must be symmetric.\n\n    metric : bool, default=True\n        Compute metric or nonmetric SMACOF algorithm.\n        When False (i.e. non-metric MDS), dissimilarities with 0 are considered as\n        missing values.\n\n    n_components : int, default=2\n        Number of dimensions in which to immerse the dissimilarities.\n\n    init : ndarray of shape (n_samples, n_components), default=None\n        Starting configuration of the embedding to initialize the algorithm.\n\n    max_iter : int, default=300\n        Maximum number of iterations of the SMACOF algorithm for a single run.\n\n    verbose : int, default=0\n        Level of verbosity.\n\n    eps : float, default=1e-3\n        Relative tolerance with respect to stress at which to declare convergence.\n\n    random_state : int, RandomState instance or None, default=None\n        Determines the random number generator used to initialize the centers.\n\n    normalized_stress : bool, default=False\n        Whether to use and return normed stress value (Stress-1) instead of raw stress.\n\n    Returns\n    -------\n    X : ndarray of shape (n_samples, n_components)\n        Coordinates of the points in a n_components-space.\n\n    stress : float\n        The final value of the stress.\n\n    n_iter : int\n        The number of iterations corresponding to the best stress.\n    \"\"\"\n    n_samples = dissimilarities.shape[0]\n    random_state = check_random_state(random_state)\n\n    if init is None:\n        X = random_state.rand(n_samples, n_components)\n    else:\n        X = init\n\n    old_stress = None\n    for it in range(max_iter):\n        # Compute distance matrix\n        distances = np.sqrt(((X[:, np.newaxis, :] - X[np.newaxis, :, :]) ** 2).sum(axis=2))\n\n        # Compute stress\n        if metric:\n            disparities = dissimilarities\n        else:\n            disparities = np.copy(dissimilarities)\n            disparities[disparities == 0] = np.nan\n            disparities = np.nan_to_num(disparities)\n\n        stress = ((disparities - distances) ** 2).sum()\n\n        if normalized_stress:\n            stress /= (disparities ** 2).sum()\n\n        if verbose:\n            print(f\"Iteration {it + 1}, stress: {stress}\")\n\n        if old_stress is not None and abs(old_stress - stress) < eps:\n            break\n\n        old_stress = stress\n\n        # Update X\n        B = -disparities / distances\n        B[np.diag_indices_from(B)] = 0\n        B[np.isnan(B)] = 0\n        B[np.diag_indices_from(B)] = -B.sum(axis=1)\n\n        X = np.dot(B, X) / n_samples\n\n    return X, stress, it + 1\n```\n\nThis function initializes the embedding either randomly or with a provided initial configuration. It iteratively updates the configuration to minimize the stress, which is a measure of the difference between the dissimilarities and the distances in the embedded space. The function supports both metric and non-metric MDS, and it can return either raw or normalized stress.",
    "prompt": "Generate a Python function called _smacof_single that Computes multidimensional scaling using SMACOF algorithm.\n\n    Parameters\n    ----------\n    dissimilarities : ndarray of shape (n_samples, n_samples)\n        Pairwise dissimilarities between the points. Must be symmetric.\n\n    metric : bool, default=True\n        Compute metric or nonmetric SMACOF algorithm.\n        When ``False`` (i.e. non-metric MDS), dissimilarities with 0 are considered as\n        missing values.\n\n    n_components : int, default=2\n        Number of dimensions in which to immerse the dissimilarities. If an\n        ``init`` array is provided, this option is overridden and the shape of\n        ``init`` is used to determine the dimensionality of the embedding\n        space.\n\n    init : ndarray of shape (n_samples, n_components), default=None\n        Starting configuration of the embedding to initialize the algorithm. By\n        default, the algorithm is initialized with a randomly chosen array.\n\n    max_iter : int, default=300\n        Maximum number of iterations of the SMACOF algorithm for a single run.\n\n    verbose : int, default=0\n        Level of verbosity.\n\n    eps : float, default=1e-3\n        Relative tolerance with respect to stress at which to declare\n        convergence. The value of `eps` should be tuned separately depending\n        on whether or not `normalized_stress` is being used.\n\n    random_state : int, RandomState instance or None, default=None\n        Determines the random number generator used to initialize the centers.\n        Pass an int for reproducible results across multiple function calls.\n        See :term:`Glossary <random_state>`.\n\n    normalized_stress : bool, default=False\n        Whether use and return normed stress value (Stress-1) instead of raw\n        stress calculated by default. Only supported in non-metric MDS. The\n        caller must ensure that if `normalized_stress=True` then `metric=False`\n\n        .. versionadded:: 1.2\n\n    Returns\n    -------\n    X : ndarray of shape (n_samples, n_components)\n        Coordinates of the points in a ``n_components``-space.\n\n    stress : float\n        The final value of the stress (sum of squared distance of the\n        disparities and the distances for all constrained points).\n        If `normalized_stress=True`, and `metric=False` returns Stress-1.\n        A value of 0 indicates \"perfect\" fit, 0.025 excellent, 0.05 good,\n        0.1 fair, and 0.2 poor [1]_.\n\n    n_iter : int\n        The number of iterations corresponding to the best stress.",
    "function_name": "_smacof_single",
    "ground_truth": "sklearn/manifold/_mds.py",
    "test": "sklearn/manifold/tests/test_mds.py::test_normed_stress",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Table"
}