{
    "result": "To create a function that computes chi-squared statistics between each non-negative feature and class, you can use the `LabelBinarizer` from `sklearn.preprocessing` to handle the target vector `y`. The function will calculate the observed and expected frequencies for each feature and class combination, and then compute the chi-squared statistics and p-values. Here's how you can implement this:\n\n```python\nimport numpy as np\nfrom scipy.stats import chi2 as chi2_dist\nfrom sklearn.preprocessing import LabelBinarizer\nfrom scipy.sparse import issparse\n\ndef chi2(X, y):\n    \"\"\"\n    Compute chi-squared statistics between each non-negative feature and class.\n\n    Parameters:\n    X : array-like or sparse matrix, shape (n_samples, n_features)\n        Sample vectors.\n    y : array-like, shape (n_samples,)\n        Target vector (class labels).\n\n    Returns:\n    chi2 : ndarray, shape (n_features,)\n        Chi-squared statistics for each feature.\n    p_values : ndarray, shape (n_features,)\n        P-values for each feature.\n    \"\"\"\n    # Binarize the class labels\n    lb = LabelBinarizer()\n    Y = lb.fit_transform(y)\n    \n    if Y.shape[1] == 1:\n        Y = np.hstack([1 - Y, Y])\n    \n    # If X is sparse, convert it to a dense array for computation\n    if issparse(X):\n        X = X.toarray()\n    \n    # Calculate observed and expected frequencies\n    observed = np.dot(Y.T, X)\n    feature_count = X.sum(axis=0)\n    class_prob = Y.mean(axis=0)\n    expected = np.dot(class_prob[:, np.newaxis], feature_count[np.newaxis, :])\n    \n    # Compute chi-squared statistics\n    chi2_stat = (observed - expected) ** 2 / expected\n    chi2_stat = chi2_stat.sum(axis=0)\n    \n    # Compute p-values\n    p_values = chi2_dist.sf(chi2_stat, df=Y.shape[1] - 1)\n    \n    return chi2_stat, p_values\n```\n\n### Explanation:\n- **LabelBinarizer**: This is used to convert the class labels `y` into a binary matrix representation, which is necessary for calculating the observed frequencies.\n- **Observed Frequencies**: Calculated as the dot product of the transposed binary matrix `Y` and the feature matrix `X`.\n- **Expected Frequencies**: Calculated using the class probabilities and the total count of each feature.\n- **Chi-squared Statistics**: Computed using the formula \\((\\text{observed} - \\text{expected})^2 / \\text{expected}\\).\n- **P-values**: Calculated using the chi-squared distribution's survival function (`sf`), which gives the probability of observing a chi-squared statistic as extreme as, or more extreme than, the observed value under the null hypothesis.\n\nThis function assumes that the input data is non-negative, as required by the chi-squared test.",
    "prompt": "Generate a Python function called chi2 that computes chi-squared statistics between each non-negative feature and class. The function takes two parameters: X, an array-like or sparse matrix of shape (n_samples, n_features) representing sample vectors, and y, an array-like of shape (n_samples,) representing target vector (class labels). The function returns two arrays: chi2, an ndarray of shape (n_features,) containing Chi2 statistics for each feature, and p_values, an ndarray of shape (n_features,) containing p-values for each feature. The complexity of the algorithm is O(n_classes * n_features). The function uses the LabelBinarizer to handle sparse representation for Y and performs calculations to determine observed and expected values before calling the _chisquare function.",
    "function_name": "chi2",
    "ground_truth": "sklearn/feature_selection/_univariate_selection.py",
    "test": "sklearn/feature_selection/tests/test_chi2.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}