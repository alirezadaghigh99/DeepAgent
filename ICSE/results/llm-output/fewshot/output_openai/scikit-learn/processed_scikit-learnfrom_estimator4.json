{
    "result": "To create a function called `from_estimator` that plots a calibration curve using a binary classifier and data, you can use the `calibration_curve` function from `sklearn.calibration` and `matplotlib` for plotting. Below is an implementation of the `from_estimator` function:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.base import is_classifier\nfrom sklearn.utils import check_consistent_length\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.calibration import CalibrationDisplay\n\ndef from_estimator(\n    estimator,\n    X,\n    y,\n    *,\n    n_bins=10,\n    strategy='uniform',\n    pos_label=None,\n    name=None,\n    ref_line=True,\n    ax=None,\n    **kwargs\n):\n    \"\"\"\n    Plot a calibration curve using a binary classifier and data.\n\n    Parameters:\n        estimator: Fitted classifier.\n        X: Input values.\n        y: Binary target values.\n        n_bins: Number of bins for discretization.\n        strategy: Bin width strategy ('uniform' or 'quantile').\n        pos_label: Positive class label.\n        name: Label for the curve.\n        ref_line: Whether to plot a reference line.\n        ax: Matplotlib axes.\n        **kwargs: Additional keyword arguments for plotting.\n\n    Returns:\n        display: CalibrationDisplay object that stores computed values.\n    \"\"\"\n    if not is_classifier(estimator):\n        raise ValueError(\"The estimator should be a fitted classifier.\")\n\n    check_is_fitted(estimator)\n    check_consistent_length(X, y)\n\n    if pos_label is None:\n        pos_label = estimator.classes_[1]\n\n    y_prob = estimator.predict_proba(X)[:, estimator.classes_ == pos_label].ravel()\n\n    prob_true, prob_pred = calibration_curve(y, y_prob, n_bins=n_bins, strategy=strategy)\n\n    if ax is None:\n        ax = plt.gca()\n\n    line = ax.plot(prob_pred, prob_true, marker='o', label=name, **kwargs)\n\n    if ref_line:\n        ax.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly calibrated')\n\n    ax.set_xlabel('Mean predicted probability')\n    ax.set_ylabel('Fraction of positives')\n    ax.set_title('Calibration plot (reliability curve)')\n    if name is not None:\n        ax.legend()\n\n    display = CalibrationDisplay(prob_true=prob_true, prob_pred=prob_pred, estimator_name=name, line_=line)\n    return display\n```\n\n### Explanation:\n- **Parameters**:\n  - `estimator`: The fitted binary classifier.\n  - `X`: Input features.\n  - `y`: Binary target values.\n  - `n_bins`: Number of bins to use for the calibration curve.\n  - `strategy`: Strategy for binning ('uniform' or 'quantile').\n  - `pos_label`: The label of the positive class.\n  - `name`: Optional label for the curve.\n  - `ref_line`: If `True`, a reference line (y=x) is plotted.\n  - `ax`: Matplotlib axes object for plotting.\n  - `**kwargs`: Additional keyword arguments for the plot.\n\n- **Returns**:\n  - A `CalibrationDisplay` object that contains the computed values and the plot line.\n\nThis function checks if the estimator is a classifier and is fitted, computes the predicted probabilities, and then uses `calibration_curve` to compute the calibration curve. It plots the curve and optionally a reference line, and returns a `CalibrationDisplay` object.",
    "prompt": "Generate a Python function called from_estimator that plots a calibration curve using a binary classifier and data. The function takes in parameters such as estimator (fitted classifier), X (input values), y (binary target values), n_bins (number of bins for discretization), strategy (bin width strategy), pos_label (positive class label), name (label for curve), ref_line (whether to plot a reference line), ax (matplotlib axes), and additional keyword arguments. The function returns a CalibrationDisplay object that stores computed values.",
    "function_name": "from_estimator",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}