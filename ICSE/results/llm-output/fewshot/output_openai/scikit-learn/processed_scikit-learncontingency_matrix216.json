{
    "result": "Here's a Python function called `contingency_matrix` that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function includes optional parameters `eps`, `sparse`, and `dtype`, as specified:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom sklearn.utils import check_array\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,)\n        Ground truth class labels.\n    - labels_pred: array-like of shape (n_samples,)\n        Cluster labels.\n    - eps: float, optional\n        If not None, a small value added to each cell of the contingency matrix to avoid zero entries.\n    - sparse: bool, optional\n        If True, return a sparse CSR matrix.\n    - dtype: numeric type, optional\n        Desired data type of the output matrix. If eps is not None, the dtype will be float.\n\n    Returns:\n    - C: ndarray or sparse matrix of shape (n_classes_true, n_classes_pred)\n        Contingency matrix where C[i, j] is the number of samples in true class i and predicted class j.\n\n    Example:\n    >>> labels_true = [0, 0, 1, 1, 2, 2]\n    >>> labels_pred = [0, 0, 1, 1, 0, 2]\n    >>> contingency_matrix(labels_true, labels_pred)\n    array([[2, 0, 0],\n           [0, 2, 0],\n           [1, 0, 1]])\n    \"\"\"\n    labels_true = check_array(labels_true, ensure_2d=False, dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, dtype=None)\n\n    classes_true, class_idx_true = np.unique(labels_true, return_inverse=True)\n    classes_pred, class_idx_pred = np.unique(labels_pred, return_inverse=True)\n\n    n_classes_true = classes_true.shape[0]\n    n_classes_pred = classes_pred.shape[0]\n\n    if dtype is None:\n        dtype = np.float64 if eps is not None else np.int64\n\n    C = np.zeros((n_classes_true, n_classes_pred), dtype=dtype)\n\n    for i in range(len(labels_true)):\n        C[class_idx_true[i], class_idx_pred[i]] += 1\n\n    if eps is not None:\n        C = C.astype(np.float64)\n        C += eps\n\n    if sparse:\n        C = csr_matrix(C)\n\n    return C\n```\n\n### Explanation:\n- **Parameters**:\n  - `labels_true` and `labels_pred` are the input arrays representing the true class labels and predicted cluster labels, respectively.\n  - `eps` is an optional parameter that, if provided, adds a small value to each cell of the contingency matrix to avoid zero entries.\n  - `sparse` determines whether the output should be a sparse matrix.\n  - `dtype` specifies the desired data type of the output matrix.\n\n- **Functionality**:\n  - The function first checks and processes the input arrays.\n  - It then determines the unique classes in both `labels_true` and `labels_pred`.\n  - A contingency matrix `C` is initialized with zeros.\n  - The function iterates over the input labels to populate the contingency matrix.\n  - If `eps` is provided, it adds this small value to each element of the matrix.\n  - If `sparse` is `True`, the matrix is converted to a sparse CSR format.\n\n- **Example Usage**:\n  - The example in the docstring demonstrates how to use the function with sample input arrays and shows the resulting contingency matrix.",
    "prompt": "Generate a Python function called contingency_matrix that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function takes in two array-like inputs: labels_true (ground truth class labels) and labels_pred (cluster labels). Additionally, it has optional parameters eps (float), sparse (bool), and dtype (numeric type). \n\nThe function returns a contingency matrix of shape [n_classes_true, n_classes_pred], where each element C[i, j] represents the number of samples in true class i and predicted class j. If eps is not None, the dtype of the output array will be float; otherwise, it will be an integer unless specified with the dtype argument. If sparse is True, a sparse CSR matrix will be returned. \n\nAn example usage of the function is provided in the docstring, where labels_true and labels_pred are given as input, and the resulting contingency matrix is shown.",
    "function_name": "contingency_matrix",
    "ground_truth": "sklearn/metrics/cluster/_supervised.py",
    "test": "sklearn/metrics/cluster/tests/test_supervised.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}