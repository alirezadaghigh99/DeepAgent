{
    "result": "Certainly! Below is a Python function `train_test_split` that splits arrays or matrices into random train and test subsets. It includes input validation, shuffling, and stratification options.\n\n```python\nimport numpy as np\nfrom sklearn.utils import check_random_state\nfrom sklearn.utils.validation import _num_samples\nfrom sklearn.utils import indexable\nfrom sklearn.utils import safe_indexing\nfrom sklearn.utils.multiclass import type_of_target\n\ndef train_test_split(*arrays, test_size=None, train_size=None, random_state=None, shuffle=True, stratify=None):\n    \"\"\"\n    Split arrays or matrices into random train and test subsets.\n\n    Parameters:\n    - *arrays: sequence of indexables with same length / shape[0]\n    - test_size: float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split.\n        If int, represents the absolute number of test samples.\n        If None, the value is set to the complement of the train size.\n    - train_size: float or int, default=None\n        If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split.\n        If int, represents the absolute number of train samples.\n        If None, the value is automatically set to the complement of the test size.\n    - random_state: int or RandomState instance, default=None\n        Controls the shuffling applied to the data before applying the split.\n    - shuffle: bool, default=True\n        Whether or not to shuffle the data before splitting.\n    - stratify: array-like, default=None\n        If not None, data is split in a stratified fashion, using this as the class labels.\n\n    Returns:\n    - splitting: list, length=2 * len(arrays)\n        List containing train-test split of inputs.\n    \"\"\"\n    n_arrays = len(arrays)\n    if n_arrays == 0:\n        raise ValueError(\"At least one array required as input\")\n\n    arrays = indexable(*arrays)\n    n_samples = _num_samples(arrays[0])\n\n    if stratify is not None:\n        if not shuffle:\n            raise ValueError(\"Stratified train/test split is not implemented for shuffle=False\")\n        stratify = np.asarray(stratify)\n        if stratify.shape[0] != n_samples:\n            raise ValueError(\"Stratify array has different number of samples than input arrays\")\n\n    if test_size is None and train_size is None:\n        test_size = 0.25\n\n    if test_size is not None and train_size is not None:\n        if isinstance(test_size, float) and isinstance(train_size, float):\n            if test_size + train_size > 1.0:\n                raise ValueError(\"The sum of test_size and train_size should be <= 1.0\")\n        elif isinstance(test_size, int) and isinstance(train_size, int):\n            if test_size + train_size > n_samples:\n                raise ValueError(\"The sum of test_size and train_size should be <= number of samples\")\n\n    if test_size is None:\n        test_size = 1.0 - train_size\n    if train_size is None:\n        train_size = 1.0 - test_size\n\n    if isinstance(test_size, float):\n        n_test = int(np.ceil(test_size * n_samples))\n    else:\n        n_test = test_size\n\n    if isinstance(train_size, float):\n        n_train = int(np.floor(train_size * n_samples))\n    else:\n        n_train = train_size\n\n    if n_train + n_test > n_samples:\n        raise ValueError(\"The sum of train_size and test_size should be <= number of samples\")\n\n    if shuffle:\n        rng = check_random_state(random_state)\n        if stratify is not None:\n            type_of_target_y = type_of_target(stratify)\n            if type_of_target_y not in ('binary', 'multiclass'):\n                raise ValueError(\"Stratify is only supported for binary or multiclass targets\")\n            unique_y, y_indices = np.unique(stratify, return_inverse=True)\n            n_classes = unique_y.shape[0]\n            class_counts = np.bincount(y_indices)\n            class_indices = np.split(np.argsort(y_indices, kind='mergesort'), np.cumsum(class_counts)[:-1])\n            train_indices = []\n            test_indices = []\n            for class_index in class_indices:\n                n_class_samples = class_index.shape[0]\n                n_class_test = int(np.ceil(n_test * n_class_samples / n_samples))\n                n_class_train = n_class_samples - n_class_test\n                rng.shuffle(class_index)\n                train_indices.extend(class_index[:n_class_train])\n                test_indices.extend(class_index[n_class_train:])\n            train_indices = np.array(train_indices)\n            test_indices = np.array(test_indices)\n        else:\n            indices = np.arange(n_samples)\n            rng.shuffle(indices)\n            train_indices = indices[:n_train]\n            test_indices = indices[n_train:n_train + n_test]\n    else:\n        train_indices = np.arange(n_train)\n        test_indices = np.arange(n_train, n_train + n_test)\n\n    return list(safe_indexing(a, train_indices) for a in arrays) + list(safe_indexing(a, test_indices) for a in arrays)\n```\n\n### Key Features:\n- **Input Validation**: Ensures that the input arrays are indexable and have the same number of samples.\n- **Shuffle**: Option to shuffle the data before splitting.\n- **Stratification**: Ensures that the train and test sets have the same proportion of classes as the original dataset.\n- **Random State**: Allows for reproducibility by setting a random seed.\n\nThis function is similar to the `train_test_split` function from `scikit-learn`, but it is implemented from scratch to demonstrate the process.",
    "prompt": "Generate a Python function called train_test_split that splits arrays or matrices into random train and test subsets. The function takes in multiple arrays, test_size, train_size, random_state, shuffle, and stratify as parameters. It returns a list containing the train-test split of inputs. The function also includes input validation, shuffling, and stratification options.",
    "function_name": "train_test_split",
    "ground_truth": "sklearn/model_selection/_split.py",
    "test": "sklearn/model_selection/tests/test_split.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": ""
}