{
    "result": "To implement the Orthogonal Matching Pursuit (OMP) algorithm with the specified parameters, we can follow these steps. The OMP algorithm iteratively selects the feature that is most correlated with the current residual, updates the residual, and repeats until the desired number of non-zero coefficients is reached or the residual norm is below a specified tolerance. Here's how you can implement this:\n\n```python\nimport numpy as np\nfrom numpy.linalg import norm\n\ndef orthogonal_mp_gram(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):\n    \"\"\"\n    Orthogonal Matching Pursuit (OMP) algorithm for sparse linear regression.\n\n    Parameters:\n    - X: 2D array-like of shape (n_samples, n_features) with unit norm columns.\n    - y: 1D or 2D array-like of shape (n_samples,) or (n_samples, n_targets).\n    - n_nonzero_coefs: Desired number of non-zero coefficients in the solution.\n    - tol: Maximum squared norm of the residual.\n    - precompute: Whether to precompute the Gram matrix.\n    - copy_X: Whether to copy the input matrix X.\n    - return_path: Whether to return the entire coefficient path.\n    - return_n_iter: Whether to return the number of iterations.\n\n    Returns:\n    - coef: Coefficients of the OMP solution.\n    - (Optional) n_iter: Number of iterations taken for convergence.\n    \"\"\"\n    X = np.array(X, copy=copy_X)\n    y = np.array(y, copy=False)\n    \n    n_samples, n_features = X.shape\n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    n_targets = y.shape[1]\n\n    if n_nonzero_coefs is None:\n        n_nonzero_coefs = max(1, int(0.1 * n_features))\n    \n    if n_nonzero_coefs > n_features:\n        raise ValueError(\"Number of non-zero coefficients cannot exceed the number of features.\")\n    \n    if precompute == 'auto':\n        precompute = n_targets == 1 or n_samples > n_features\n\n    if precompute:\n        G = np.dot(X.T, X)\n    \n    coef = np.zeros((n_features, n_targets))\n    residual = y.copy()\n    index_set = []\n    path = []\n\n    for n_iter in range(n_nonzero_coefs):\n        if precompute:\n            correlations = np.dot(X.T, residual)\n        else:\n            correlations = np.dot(X.T, residual)\n        \n        if n_targets == 1:\n            correlations = correlations.ravel()\n        \n        best_index = np.argmax(np.abs(correlations), axis=0)\n        index_set.append(best_index)\n        \n        if precompute:\n            A = G[np.ix_(index_set, index_set)]\n        else:\n            A = np.dot(X[:, index_set].T, X[:, index_set])\n        \n        b = np.dot(X[:, index_set].T, y)\n        coef_active = np.linalg.solve(A, b)\n        \n        residual = y - np.dot(X[:, index_set], coef_active)\n        \n        if return_path:\n            coef_path = np.zeros_like(coef)\n            coef_path[index_set] = coef_active\n            path.append(coef_path)\n        \n        if tol is not None and norm(residual) ** 2 <= tol:\n            break\n    \n    coef[index_set] = coef_active\n    \n    if return_path:\n        path = np.array(path)\n    \n    if return_n_iter:\n        return (coef, path, n_iter + 1) if return_path else (coef, n_iter + 1)\n    else:\n        return (coef, path) if return_path else coef\n```\n\n### Key Points:\n- **Precomputation**: The Gram matrix \\( G = X^T X \\) is precomputed if `precompute` is enabled, which speeds up the computation of correlations.\n- **Residual Update**: The residual is updated in each iteration by subtracting the contribution of the selected features.\n- **Stopping Criteria**: The algorithm stops when the desired number of non-zero coefficients is reached or the residual norm is below the specified tolerance.\n- **Edge Cases**: The function raises a `ValueError` if the number of non-zero coefficients exceeds the number of features.\n- **Return Options**: The function can return the entire coefficient path and the number of iterations if requested.",
    "prompt": "Create a Python function `orthogonal_mp_gram` that implements the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems. The function should accept the following parameters:\n- `X`: A 2D array-like of shape `(n_samples, n_features)` representing the input data. Columns should be assumed to have unit norm.\n- `y`: A 1D or 2D array-like of shape `(n_samples,)` or `(n_samples, n_targets)` representing the target values.\n- `n_nonzero_coefs`: An integer specifying the desired number of non-zero coefficients in the solution. If `None`, this defaults to 10% of the number of features.\n- `tol`: A float specifying the maximum squared norm of the residual. If provided, this overrides `n_nonzero_coefs`.\n- `precompute`: A boolean or the string `'auto'` indicating whether to precompute the Gram matrix for faster computation when `n_targets` or `n_samples` is large.\n- `copy_X`: A boolean indicating whether to copy the input matrix `X` (default is `True`).\n- `return_path`: A boolean indicating whether to return the entire coefficient path for each iteration.\n- `return_n_iter`: A boolean indicating whether to return the number of iterations taken for convergence.\n\nThe function should return the coefficients of the OMP solution as a 1D or 2D NumPy array, depending on the input, with an option to return the number of iterations if `return_n_iter` is `True`. Handle edge cases such as when the number of non-zero coefficients exceeds the number of features by raising a `ValueError`. The function should use efficient computation techniques, including the option to precompute the Gram matrix if `precompute` is enabled.",
    "function_name": "orthogonal_mp_gram",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Classification",
    "data": "Table"
}