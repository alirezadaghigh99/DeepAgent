{
    "result": "Certainly! Below is a Python function `make_low_rank_matrix` that generates a mostly low-rank matrix with bell-shaped singular values. The function takes parameters such as `n_samples`, `n_features`, `effective_rank`, `tail_strength`, and `random_state`. It returns a matrix `X` of shape `(n_samples, n_features)`.\n\n```python\nimport numpy as np\nfrom sklearn.utils import check_random_state\n\ndef make_low_rank_matrix(n_samples=100, n_features=100, effective_rank=10, tail_strength=0.5, random_state=None):\n    \"\"\"\n    Generate a mostly low-rank matrix with bell-shaped singular values.\n\n    Parameters:\n    - n_samples (int): Number of samples (rows).\n    - n_features (int): Number of features (columns).\n    - effective_rank (int): The approximate number of singular values that are significantly non-zero.\n    - tail_strength (float): The relative importance of the fat noisy tail of the singular values profile.\n    - random_state (int, RandomState instance, or None): Determines random number generation for dataset creation.\n\n    Returns:\n    - X (ndarray): The generated low-rank matrix of shape (n_samples, n_features).\n    \"\"\"\n    random_state = check_random_state(random_state)\n\n    # Generate the singular values with a bell-shaped profile\n    singular_values = np.exp(-1.0 * np.arange(n_features) / effective_rank)\n    singular_values = singular_values / np.linalg.norm(singular_values)\n\n    # Add noise to the singular values\n    noise = tail_strength * random_state.normal(size=n_features)\n    singular_values += noise\n    singular_values = np.sort(singular_values)[::-1]  # Sort in descending order\n\n    # Generate random orthogonal matrices U and V\n    U, _ = np.linalg.qr(random_state.normal(size=(n_samples, n_samples)))\n    V, _ = np.linalg.qr(random_state.normal(size=(n_features, n_features)))\n\n    # Construct the low-rank matrix\n    X = np.dot(U[:, :n_features] * singular_values, V)\n\n    return X\n\n# Example usage:\nif __name__ == \"__main__\":\n    X = make_low_rank_matrix(n_samples=100, n_features=50, effective_rank=10, tail_strength=0.1, random_state=42)\n    print(\"Generated matrix shape:\", X.shape)\n```\n\n### Explanation:\n- **Singular Values**: The function generates singular values with a bell-shaped profile, which are then perturbed by adding noise controlled by `tail_strength`.\n- **Orthogonal Matrices**: Random orthogonal matrices `U` and `V` are generated using QR decomposition of random matrices.\n- **Matrix Construction**: The low-rank matrix `X` is constructed by multiplying `U`, the diagonal matrix of singular values, and `V`.\n- **Random State**: The `random_state` parameter ensures reproducibility of the random number generation.\n\n### Example Usage:\nThe example at the end of the function demonstrates how to use `make_low_rank_matrix` with specific input values, generating a matrix of shape `(100, 50)`.",
    "prompt": "Generate a Python function called make_low_rank_matrix that generates a mostly low rank matrix with bell-shaped singular values. The function takes in parameters such as n_samples, n_features, effective_rank, tail_strength, and random_state. It returns a matrix X of shape (n_samples, n_features) that represents the generated low rank matrix. The function utilizes random number generation for dataset creation and constructs the singular profile by combining signal and noise components based on the specified parameters. The function also includes examples of how to use it with sample input values.",
    "function_name": "make_low_rank_matrix",
    "ground_truth": "sklearn/datasets/_samples_generator.py",
    "test": "sklearn/datasets/tests/test_samples_generator.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Table"
}