{
    "result": "To generate a Python function called `right_jacobian` that computes the right Jacobian of SO(3), you can follow the structure and style of the examples provided. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef vector_to_skew_symmetric_matrix(vec: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Converts a vector of shape (3,) to a skew-symmetric matrix of shape (3, 3).\n\n    Args:\n        vec (Tensor): A tensor of shape (3,).\n\n    Returns:\n        Tensor: A skew-symmetric matrix of shape (3, 3).\n    \"\"\"\n    return torch.tensor([\n        [0, -vec[2], vec[1]],\n        [vec[2], 0, -vec[0]],\n        [-vec[1], vec[0], 0]\n    ], dtype=vec.dtype, device=vec.device)\n\ndef right_jacobian(vec: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Computes the right Jacobian of SO(3) for a given vector.\n\n    Args:\n        vec (Tensor): A tensor of shape (B, 3) representing the input vectors.\n\n    Returns:\n        Tensor: A tensor of shape (B, 3, 3) representing the right Jacobian matrices.\n    \"\"\"\n    B = vec.shape[0]\n    norm_vec = torch.norm(vec, dim=1, keepdim=True)\n    norm_vec = norm_vec.clamp(min=1e-8)  # Avoid division by zero\n\n    eye = torch.eye(3, dtype=vec.dtype, device=vec.device).unsqueeze(0).repeat(B, 1, 1)\n    skew_symmetric = torch.stack([vector_to_skew_symmetric_matrix(v) for v in vec])\n\n    term1 = (1 - torch.cos(norm_vec)) / (norm_vec ** 2)\n    term2 = (norm_vec - torch.sin(norm_vec)) / (norm_vec ** 3)\n\n    jacobian = eye - term1.unsqueeze(-1) * skew_symmetric + term2.unsqueeze(-1) * torch.bmm(skew_symmetric, skew_symmetric)\n\n    return jacobian\n```\n\n### Explanation:\n\n1. **`vector_to_skew_symmetric_matrix` Function**: This helper function converts a 3D vector into a skew-symmetric matrix, which is a common operation in 3D rotations.\n\n2. **`right_jacobian` Function**:\n   - **Input**: A batch of vectors `vec` of shape (B, 3).\n   - **Output**: A batch of right Jacobian matrices of shape (B, 3, 3).\n   - **Steps**:\n     - Compute the norm of each vector to handle the scaling in the Jacobian calculation.\n     - Use the identity matrix and the skew-symmetric matrix to compute the terms of the Jacobian.\n     - Use the Taylor series expansion for small angles to avoid numerical instability.\n     - Combine these terms to form the right Jacobian matrix.\n\nThis function is designed to handle a batch of vectors, making it suitable for use in deep learning applications where operations are often performed on batches of data.",
    "prompt": "Generate a Python function called right_jacobian that computes the right Jacobian of So3. The input is a tensor called vec of shape (B, 3) and the output is a tensor of shape (3, 3) representing the right Jacobian matrix. The function uses vector_to_skew_symmetric_matrix, torch.norm, torch.eye, and matrix multiplication to calculate the right Jacobian matrix.",
    "function_name": "right_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}