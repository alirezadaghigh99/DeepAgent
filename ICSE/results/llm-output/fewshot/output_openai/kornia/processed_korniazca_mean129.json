{
    "result": "To generate a Python function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor, we need to follow these steps:\n\n1. **Import Necessary Libraries**: We'll use PyTorch for tensor operations.\n2. **Validate Input**: Ensure the input tensor is of the correct type and dimensions.\n3. **Compute Mean and Center Data**: Calculate the mean along the specified dimension and center the data.\n4. **Compute Covariance Matrix**: Depending on the `unbiased` flag, compute the covariance matrix.\n5. **Perform Eigen Decomposition**: Use eigen decomposition to compute the ZCA whitening matrix.\n6. **Compute ZCA and Inverse ZCA Matrices**: Calculate the ZCA matrix and optionally the inverse ZCA matrix.\n7. **Return Results**: Return the ZCA matrix, mean vector, and optionally the inverse ZCA matrix.\n\nHere's the implementation:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef zca_mean(\n    inp: Tensor,\n    dim: int = 0,\n    unbiased: bool = True,\n    eps: float = 1e-5,\n    return_inverse: bool = False\n) -> Tuple[Tensor, Tensor, Optional[Tensor]]:\n    \"\"\"\n    Computes the ZCA whitening matrix and mean vector for the input tensor.\n\n    Args:\n        inp (Tensor): Input tensor of shape (..., N, ...).\n        dim (int): Dimension along which the samples are located.\n        unbiased (bool): Whether to use the unbiased estimate of the covariance matrix.\n        eps (float): Small value for numerical stability.\n        return_inverse (bool): Whether to return the inverse ZCA transform.\n\n    Returns:\n        Tuple[Tensor, Tensor, Optional[Tensor]]: ZCA matrix, mean vector, and optionally the inverse ZCA matrix.\n    \"\"\"\n    if not isinstance(inp, Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    \n    if dim < 0 or dim >= inp.ndim:\n        raise ValueError(f\"Dimension 'dim' must be in the range [0, {inp.ndim}).\")\n\n    # Move the specified dimension to the front\n    inp = inp.transpose(0, dim)\n    N = inp.size(0)\n\n    # Compute the mean and center the data\n    mean = inp.mean(dim=0, keepdim=True)\n    centered_inp = inp - mean\n\n    # Compute the covariance matrix\n    if unbiased:\n        cov = centered_inp.t().matmul(centered_inp) / (N - 1)\n    else:\n        cov = centered_inp.t().matmul(centered_inp) / N\n\n    # Eigen decomposition\n    eigvals, eigvecs = torch.linalg.eigh(cov)\n\n    # Compute the ZCA matrix\n    zca_matrix = eigvecs @ torch.diag(1.0 / torch.sqrt(eigvals + eps)) @ eigvecs.t()\n\n    # Optionally compute the inverse ZCA matrix\n    inverse_zca_matrix = None\n    if return_inverse:\n        inverse_zca_matrix = eigvecs @ torch.diag(torch.sqrt(eigvals + eps)) @ eigvecs.t()\n\n    return zca_matrix, mean.squeeze(dim=0), inverse_zca_matrix\n\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input is a tensor and if the specified dimension is valid.\n- **Mean and Centering**: The mean is computed along the specified dimension, and the data is centered by subtracting the mean.\n- **Covariance Matrix**: The covariance matrix is computed using either the unbiased or biased estimator.\n- **Eigen Decomposition**: The eigenvalues and eigenvectors of the covariance matrix are computed.\n- **ZCA Matrix**: The ZCA whitening matrix is calculated using the eigenvectors and eigenvalues.\n- **Inverse ZCA Matrix**: If requested, the inverse ZCA matrix is also computed.\n- **Return**: The function returns the ZCA matrix, mean vector, and optionally the inverse ZCA matrix.",
    "prompt": "Generate a Python function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor. The function should take as input a tensor `inp`, the dimension `dim` along which the samples are located, a boolean `unbiased` to decide whether to use the unbiased estimate of the covariance matrix, a small value `eps` for numerical stability, and a boolean `return_inverse` to decide whether to return the inverse ZCA transform. The function should return a tuple containing the ZCA matrix, the mean vector, and optionally the inverse ZCA matrix. The tensor shapes should be validated, and appropriate exceptions should be raised if inputs are of incorrect types or dimensions. Include the necessary imports and tensor operations to perform the ZCA whitening process.",
    "function_name": "zca_mean",
    "ground_truth": "kornia/enhance/zca.py",
    "test": "tests/enhance/test_zca.py::TestZCA",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}