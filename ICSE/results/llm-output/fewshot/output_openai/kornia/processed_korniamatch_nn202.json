{
    "result": "Here's a Python function `match_nn` that implements the specified functionality:\n\n```python\nimport torch\n\ndef _no_match(b1):\n    # Placeholder function to return when there are no matches\n    return torch.full((b1, 1), float('inf')), torch.full((b1, 2), -1, dtype=torch.long)\n\ndef match_nn(desc1: torch.Tensor, desc2: torch.Tensor, dm: torch.Tensor = None):\n    \"\"\"\n    Finds the nearest neighbors in `desc2` for each vector in `desc1`.\n\n    Args:\n        desc1 (torch.Tensor): A tensor containing a batch of descriptors with shape `(B1, D)`.\n        desc2 (torch.Tensor): A tensor containing another batch of descriptors with shape `(B2, D)`.\n        dm (torch.Tensor, optional): An optional precomputed distance matrix tensor of shape `(B1, B2)`.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: \n            - A tensor of matching descriptor distances with shape `(B1, 1)`.\n            - A tensor of long indices of matching descriptors in `desc1` and `desc2` with shape `(B1, 2)`.\n    \"\"\"\n    b1, d1 = desc1.shape\n    b2, d2 = desc2.shape\n\n    # Check if descriptors have the correct shapes\n    if d1 != d2:\n        raise ValueError(\"Descriptors must have the same dimensionality.\")\n\n    # If either desc1 or desc2 is empty, return a placeholder output\n    if b1 == 0 or b2 == 0:\n        return _no_match(b1)\n\n    # Calculate the distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n\n    # Find the minimum distances and their corresponding indices in desc2 for each vector in desc1\n    min_distances, min_indices = torch.min(dm, dim=1)\n\n    # Construct a tensor containing the indices of matching descriptors in desc1 and desc2\n    match_indices = torch.stack((torch.arange(b1), min_indices), dim=1)\n\n    return min_distances.unsqueeze(1), match_indices\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if the descriptors have the same dimensionality. If not, it raises a `ValueError`.\n\n2. **Empty Descriptors Handling**: If either `desc1` or `desc2` is empty, the function returns a placeholder output using `_no_match`.\n\n3. **Distance Matrix Calculation**: If the distance matrix `dm` is not provided, it calculates the distance matrix using `torch.cdist`.\n\n4. **Nearest Neighbor Search**: The function finds the minimum distances and their corresponding indices in `desc2` for each vector in `desc1`.\n\n5. **Output Construction**: It constructs a tensor containing the indices of matching descriptors in `desc1` and `desc2` and returns the distances and indices.\n\nThis function assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs beyond the dimensionality check.",
    "prompt": "Create a Python function `match_nn` that:\n\n- Takes three parameters:\n  - `desc1`: A tensor containing a batch of descriptors with shape `(B1, D)`.\n  - `desc2`: A tensor containing another batch of descriptors with shape `(B2, D)`.\n  - `dm`: An optional precomputed distance matrix tensor of shape `(B1, B2)`. If not provided, the function computes the distance matrix using `torch.cdist`.\n\n- The function finds the nearest neighbors in `desc2` for each vector in `desc1`:\n  - Checks if the input descriptors have the correct shapes.\n  - If either `desc1` or `desc2` is empty, it returns a placeholder output using `_no_match`.\n  - If `dm` is not provided, it calculates the distance matrix between `desc1` and `desc2`.\n  - Finds the minimum distances and their corresponding indices in `desc2` for each vector in `desc1`.\n  - Constructs a tensor containing the indices of matching descriptors in `desc1` and `desc2`.\n\n- Returns:\n  - A tensor of matching descriptor distances with shape `(B1, 1)`.\n  - A tensor of long indices of matching descriptors in `desc1` and `desc2` with shape `(B1, 2)`.\n\nErrors:\n- The function assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs.",
    "function_name": "match_nn",
    "ground_truth": "kornia/feature/matching.py#L60",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}