{
    "result": "To create the `get_projective_transform` function, we need to calculate the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function will involve creating rotation matrices for each axis, applying scaling, and then combining these transformations into a single projection matrix. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef get_projective_transform(center: torch.Tensor, angles: torch.Tensor, scales: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculate the projection matrix for a 3D rotation given the center, rotation angles, and scales.\n\n    Args:\n        center (Tensor): A tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\n        angles (Tensor): A tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\n        scales (Tensor): A tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\n\n    Returns:\n        Tensor: A tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.\n    \"\"\"\n    assert center.shape[1] == 3, \"Center must have shape (B, 3)\"\n    assert angles.shape[1] == 3, \"Angles must have shape (B, 3)\"\n    assert center.shape == angles.shape, \"Center and angles must have the same shape\"\n    assert center.device == angles.device and center.dtype == angles.dtype, \"Center and angles must share the same device and dtype\"\n\n    B = center.shape[0]\n    angles_rad = torch.deg2rad(angles)\n\n    # Rotation matrices for each axis\n    cos = torch.cos(angles_rad)\n    sin = torch.sin(angles_rad)\n\n    Rx = torch.stack([\n        torch.stack([torch.ones(B), torch.zeros(B), torch.zeros(B)], dim=-1),\n        torch.stack([torch.zeros(B), cos[:, 0], -sin[:, 0]], dim=-1),\n        torch.stack([torch.zeros(B), sin[:, 0], cos[:, 0]], dim=-1)\n    ], dim=1)\n\n    Ry = torch.stack([\n        torch.stack([cos[:, 1], torch.zeros(B), sin[:, 1]], dim=-1),\n        torch.stack([torch.zeros(B), torch.ones(B), torch.zeros(B)], dim=-1),\n        torch.stack([-sin[:, 1], torch.zeros(B), cos[:, 1]], dim=-1)\n    ], dim=1)\n\n    Rz = torch.stack([\n        torch.stack([cos[:, 2], -sin[:, 2], torch.zeros(B)], dim=-1),\n        torch.stack([sin[:, 2], cos[:, 2], torch.zeros(B)], dim=-1),\n        torch.stack([torch.zeros(B), torch.zeros(B), torch.ones(B)], dim=-1)\n    ], dim=1)\n\n    # Combined rotation matrix\n    R = torch.bmm(Rz, torch.bmm(Ry, Rx))\n\n    # Scale matrix\n    S = torch.diag_embed(scales)\n\n    # Combined rotation and scale\n    RS = torch.bmm(R, S)\n\n    # Translation to center\n    T = center.unsqueeze(-1) - torch.bmm(RS, center.unsqueeze(-1))\n\n    # Projection matrix\n    projection_matrix = torch.cat([RS, T], dim=-1)\n\n    return projection_matrix\n```\n\n### Explanation:\n- **Input Validation**: The function checks that `center` and `angles` have the correct shape and are on the same device and dtype.\n- **Rotation Matrices**: Separate rotation matrices are created for each axis (x, y, z) using the provided angles.\n- **Scaling**: A diagonal scale matrix is created using the provided scale factors.\n- **Combination**: The rotation and scale matrices are combined, and a translation is applied to ensure the rotation is around the specified center.\n- **Output**: The function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.",
    "prompt": "Create a Python function get_projective_transform that calculates the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function takes the following parameters:\n\ncenter: A tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\nangles: A tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\nscales: A tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\nThe function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.Raise an AssertionError if center or angles do not have the expected shape.\nRaise an AssertionError if center and angles do not share the same device and dtype.",
    "function_name": "get_projective_transform",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp3d.py::TestGetRotationMatrix3d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}