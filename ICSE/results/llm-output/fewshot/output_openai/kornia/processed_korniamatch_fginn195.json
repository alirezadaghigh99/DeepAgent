{
    "result": "To implement the `match_fginn` function, we need to perform nearest neighbor matching between two sets of descriptors (`desc1` and `desc2`). The function should also consider spatial constraints using `lafs1` and `lafs2`, apply a distance threshold `th`, and optionally perform a mutual nearest neighbor check. Here's a possible implementation:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:\n    \"\"\"\n    Finds nearest neighbors in desc2 for each vector in desc1.\n\n    Args:\n        desc1 (Tensor): Descriptors from the first set, shape (N1, D).\n        desc2 (Tensor): Descriptors from the second set, shape (N2, D).\n        lafs1 (Tensor): Local affine frames for desc1, shape (N1, 2, 3).\n        lafs2 (Tensor): Local affine frames for desc2, shape (N2, 2, 3).\n        th (float): Distance threshold for descriptor matching.\n        spatial_th (float): Spatial threshold for matching.\n        mutual (bool): If True, perform mutual nearest neighbor check.\n        dm (Optional[Tensor]): Precomputed distance matrix, shape (N1, N2).\n\n    Returns:\n        Tuple[Tensor, Tensor]: Descriptor distances and matching indices.\n    \"\"\"\n    if dm is None:\n        # Compute the distance matrix between desc1 and desc2\n        dm = torch.cdist(desc1, desc2, p=2)\n\n    # Find the nearest neighbors in desc2 for each descriptor in desc1\n    min_dist, min_idx = torch.min(dm, dim=1)\n\n    # Apply the distance threshold\n    valid_matches = min_dist < th\n\n    # Apply spatial constraints\n    if spatial_th is not None:\n        # Compute the spatial distance between corresponding lafs\n        spatial_dist = torch.norm(lafs1[:, :2, 2].unsqueeze(1) - lafs2[:, :2, 2], dim=2)\n        valid_matches &= (spatial_dist < spatial_th)\n\n    # Filter matches based on the valid matches\n    min_dist = min_dist[valid_matches]\n    min_idx = min_idx[valid_matches]\n\n    if mutual:\n        # Perform mutual nearest neighbor check\n        reverse_dm = torch.cdist(desc2, desc1, p=2)\n        reverse_min_dist, reverse_min_idx = torch.min(reverse_dm, dim=1)\n        mutual_matches = reverse_min_idx[min_idx] == torch.arange(len(min_idx), device=desc1.device)\n        min_dist = min_dist[mutual_matches]\n        min_idx = min_idx[mutual_matches]\n\n    return min_dist, min_idx\n```\n\n### Explanation:\n- **Distance Matrix Calculation**: If a precomputed distance matrix `dm` is not provided, it is calculated using `torch.cdist`, which computes pairwise distances between descriptors.\n- **Nearest Neighbor Search**: For each descriptor in `desc1`, the nearest neighbor in `desc2` is found using `torch.min`.\n- **Thresholding**: Matches are filtered based on the descriptor distance threshold `th`.\n- **Spatial Constraints**: Additional filtering is done based on spatial distances between local affine frames (`lafs1` and `lafs2`).\n- **Mutual Nearest Neighbor Check**: If `mutual` is `True`, a reverse nearest neighbor check is performed to ensure that matches are mutual.\n\nThis function assumes that `desc1` and `desc2` are 2D tensors where each row is a descriptor vector, and `lafs1` and `lafs2` are 3D tensors representing local affine frames. Adjustments may be needed based on the specific format and requirements of your data.",
    "prompt": "Generate a Python function called match_fginn that finds nearest neighbors in desc2 for each vector in desc1. The inputs are Tensors desc1, desc2, lafs1, lafs2, th, spatial_th, mutual, and dm. The function returns a tuple of Tensors containing the descriptor distance of matching descriptors and the long tensor indexes of matching descriptors in desc1 and desc2. The function also performs a mutual nearest neighbor check if specified.\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:",
    "function_name": "match_fginn",
    "ground_truth": "kornia/feature/matching.py",
    "test": "tests/feature/test_matching.py::TestMatchFGINN",
    "class": "",
    "stage": "Inference",
    "task": "Detection",
    "data": "Image"
}