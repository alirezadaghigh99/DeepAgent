{
    "result": "To implement the `rgb_to_yuv420` function, we need to follow these steps:\n\n1. **Input Validation**: Ensure the input tensor has the correct shape and that the height and width are even numbers.\n2. **Padding**: If the height or width is not even, pad the image to make them even.\n3. **RGB to YUV Conversion**: Convert the RGB image to YUV format.\n4. **Subsampling**: Subsample the U and V channels to achieve the YUV 420 format.\n5. **Return the Result**: Return the Y plane and the subsampled UV planes.\n\nHere's the implementation:\n\n```python\nimport torch\nfrom typing import Tuple\n\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Convert an RGB image to YUV 420 format.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, 3, H, W).\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: \n            - Y plane with shape (*, 1, H, W)\n            - UV planes with shape (*, 2, H/2, W/2)\n    \"\"\"\n    if image.dim() < 3 or image.size(-3) != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    *batch_dims, C, H, W = image.shape\n\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width of the image must be even numbers\")\n\n    # RGB to YUV conversion matrix\n    rgb_to_yuv_matrix = torch.tensor([\n        [0.299, 0.587, 0.114],\n        [-0.14713, -0.28886, 0.436],\n        [0.615, -0.51499, -0.10001]\n    ], dtype=image.dtype, device=image.device)\n\n    # Reshape image to (N, H, W, C) for matrix multiplication\n    image = image.permute(*range(len(batch_dims)), -2, -1, -3)\n\n    # Convert RGB to YUV\n    yuv = torch.tensordot(image, rgb_to_yuv_matrix, dims=([-1], [1]))\n\n    # Split YUV into Y, U, V\n    Y, U, V = yuv.unbind(dim=-1)\n\n    # Reshape Y to (*, 1, H, W)\n    Y = Y.permute(*range(len(batch_dims)), -1, -3, -2).unsqueeze(-3)\n\n    # Subsample U and V\n    U_sub = U[..., ::2, ::2]\n    V_sub = V[..., ::2, ::2]\n\n    # Stack U and V to form UV with shape (*, 2, H/2, W/2)\n    UV = torch.stack((U_sub, V_sub), dim=-3)\n\n    return Y, UV\n\n# Example usage\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```\n\n### Explanation:\n\n- **Input Validation**: We check if the input tensor has at least 3 dimensions and the third-to-last dimension is 3 (for RGB channels). We also ensure that the height and width are even.\n- **RGB to YUV Conversion**: We use a matrix multiplication to convert RGB values to YUV. The conversion matrix is based on standard YUV conversion formulas.\n- **Subsampling**: We subsample the U and V channels by taking every second pixel in both dimensions, which is typical for YUV 420 format.\n- **Output**: The function returns the Y plane and the subsampled UV planes as specified.",
    "prompt": "Generate a Python function called rgb_to_yuv420 that takes in a torch.Tensor representing an RGB image and returns a tuple of two torch.Tensors. The input image is assumed to be in the range of (0, 1) and needs to be padded to be evenly divisible by 2 horizontally and vertically. The function will output the YUV 420 (subsampled) version of the input image with chroma siting at (0.5, 0.5).\n\nThe function should have the following signature:\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nThe function converts the RGB image to YUV 420 format and returns:\n- A Tensor containing the Y plane with shape (*, 1, H, W)\n- A Tensor containing the UV planes with shape (*, 2, H/2, W/2)\n\nEnsure that the input image has a shape of (*, 3, H, W) where H and W are even numbers. If the input does not meet these requirements, appropriate errors will be raised.\n\nExample usage:\n```python\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```",
    "function_name": "rgb_to_yuv420",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestRgbToYuv420",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}