{
    "result": "To generate a Python function that computes the left Jacobian of SO(3) for a given input tensor, you can follow the mathematical formulation of the left Jacobian for SO(3). The left Jacobian is used in robotics and computer vision, particularly in the context of Lie groups and Lie algebras. Here's a Python function that implements this:\n\n```python\nimport torch\n\ndef left_jacobian(vec: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Compute the left Jacobian of SO(3) for a batch of input vectors.\n\n    Args:\n        vec (torch.Tensor): A tensor of shape (B, 3) where B is the batch size.\n\n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 3) representing the left Jacobian matrices.\n    \"\"\"\n    B = vec.shape[0]\n    theta = torch.norm(vec, dim=1, keepdim=True)  # Shape: (B, 1)\n    theta_sq = theta ** 2\n\n    # Avoid division by zero by using a small epsilon\n    epsilon = 1e-8\n    theta = torch.where(theta < epsilon, torch.tensor(epsilon, device=vec.device), theta)\n\n    # Compute the skew-symmetric matrix of vec\n    def skew_symmetric(v):\n        zero = torch.zeros_like(v[:, 0])\n        return torch.stack([\n            zero, -v[:, 2], v[:, 1],\n            v[:, 2], zero, -v[:, 0],\n            -v[:, 1], v[:, 0], zero\n        ], dim=1).reshape(B, 3, 3)\n\n    skew_vec = skew_symmetric(vec)\n\n    # Compute the left Jacobian\n    sin_theta = torch.sin(theta)\n    cos_theta = torch.cos(theta)\n\n    J = (sin_theta / theta).unsqueeze(-1) * torch.eye(3, device=vec.device).unsqueeze(0) + \\\n        ((1 - cos_theta) / theta_sq).unsqueeze(-1) * skew_vec + \\\n        ((theta - sin_theta) / (theta_sq * theta)).unsqueeze(-1) * torch.bmm(skew_vec, skew_vec)\n\n    return J\n```\n\n### Explanation:\n\n1. **Input and Output**: The function takes a tensor `vec` of shape `(B, 3)` as input, where `B` is the batch size. It returns a tensor of shape `(B, 3, 3)` representing the left Jacobian matrices for each vector in the batch.\n\n2. **Theta Calculation**: The norm of each vector in the batch is calculated to determine `theta`, which is used in the computation of the Jacobian.\n\n3. **Skew-Symmetric Matrix**: The function `skew_symmetric` computes the skew-symmetric matrix for each vector in the batch.\n\n4. **Left Jacobian Calculation**: The left Jacobian is computed using the formula involving trigonometric functions and the skew-symmetric matrix. The formula is derived from the properties of the SO(3) group.\n\n5. **Numerical Stability**: A small epsilon is used to avoid division by zero when `theta` is very small.\n\nThis function is useful in applications involving rotations, such as robotics and computer vision, where the SO(3) group is commonly used to represent 3D rotations.",
    "prompt": "Generate a Python function called left_jacobian that computes the left Jacobian of So3. The input is a tensor called vec of shape (B, 3) where B is the batch size. The output is a tensor of shape (B, 3, 3) representing the left Jacobian matrix. The function uses the input tensor to calculate the left Jacobian matrix using specific mathematical operations",
    "function_name": "left_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3::test_left_jacobian",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}