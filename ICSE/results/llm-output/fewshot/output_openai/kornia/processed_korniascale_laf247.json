{
    "result": "To create the `scale_laf` function, we need to focus on modifying the region part of the Local Affine Frame (LAF) while keeping the center, shape, and orientation unchanged. The LAF is represented by a tensor of shape `(B, N, 2, 3)`, where `B` is the batch size, `N` is the number of LAFs, and the last two dimensions represent the affine transformation matrix and translation vector.\n\nHere's how you can implement the `scale_laf` function:\n\n```python\nimport torch\n\ndef scale_laf(laf: torch.Tensor, scale_coef: Union[float, torch.Tensor]) -> torch.Tensor:\n    \"\"\"\n    Scales the region part of a Local Affine Frame (LAF) by a scale coefficient.\n\n    Args:\n        laf (torch.Tensor): Tensor of shape (B, N, 2, 3) representing the LAFs.\n        scale_coef (Union[float, torch.Tensor]): Scaling coefficient. Can be a float or a tensor.\n\n    Returns:\n        torch.Tensor: Scaled LAF of the same shape as the input.\n\n    Raises:\n        TypeError: If scale_coef is neither a float nor a tensor.\n    \"\"\"\n    if not isinstance(scale_coef, (float, torch.Tensor)):\n        raise TypeError(\"scale_coef must be either a float or a torch.Tensor\")\n\n    # Ensure scale_coef is a tensor for consistent operations\n    if isinstance(scale_coef, float):\n        scale_coef = torch.tensor(scale_coef, dtype=laf.dtype, device=laf.device)\n\n    # Extract the affine transformation matrix part of the LAF\n    affine_matrix = laf[..., :2, :2]\n\n    # Scale the affine transformation matrix\n    scaled_affine_matrix = affine_matrix * scale_coef.unsqueeze(-1).unsqueeze(-1)\n\n    # Construct the scaled LAF by replacing the affine matrix part\n    scaled_laf = laf.clone()\n    scaled_laf[..., :2, :2] = scaled_affine_matrix\n\n    return scaled_laf\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if `scale_coef` is either a float or a tensor. If not, it raises a `TypeError`.\n\n2. **Scale Coefficient Handling**: If `scale_coef` is a float, it is converted to a tensor to ensure consistent operations with the LAF tensor.\n\n3. **Affine Matrix Extraction**: The affine transformation matrix part of the LAF is extracted. This is the part that needs to be scaled.\n\n4. **Scaling**: The affine matrix is scaled by the `scale_coef`. If `scale_coef` is a tensor, it is unsqueezed to match the dimensions for broadcasting.\n\n5. **Reconstruction**: The scaled affine matrix is placed back into the LAF tensor, and the modified LAF is returned.\n\nThis function allows you to scale the region part of the LAF while keeping the center, shape, and orientation unchanged.",
    "prompt": "Create a function `scale_laf` that multiplies the region part of a Local Affine Frame (LAF) by a `scale_coef`, keeping the center, shape, and orientation unchanged but altering the region area. The function accepts a tensor `laf` of shape `(B, N, 2, 3)` and a `scale_coef`, which can be either a float or a tensor. It returns the scaled LAF of the same shape. A `TypeError` is raised if `scale_coef` is neither a float nor a tensor.",
    "function_name": "scale_laf",
    "ground_truth": "kornia/feature/laf.py#L133",
    "test": "tests/feature/test_laf.py::TestScaleLAF",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}