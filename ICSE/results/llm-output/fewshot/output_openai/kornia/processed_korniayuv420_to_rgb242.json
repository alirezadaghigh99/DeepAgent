{
    "result": "To create a function `yuv420_to_rgb` that converts a YUV420 image to RGB, we need to follow these steps:\n\n1. **Validate Input**: Ensure that `imagey` and `imageuv` are torch Tensors with the correct shapes.\n2. **Upsample the UV Planes**: Since the UV planes are subsampled by a factor of 2, we need to upsample them to match the Y plane's resolution.\n3. **Convert YUV to RGB**: Use a helper function `yuv_to_rgb` to convert the upsampled YUV444 image to RGB.\n\nHere's how you can implement this:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef yuv_to_rgb(yuv):\n    \"\"\"\n    Convert a YUV444 image to RGB.\n    Assumes YUV values are in the range (0, 1) for Y and (-0.5, 0.5) for U and V.\n    \"\"\"\n    y, u, v = yuv[:, 0, :, :], yuv[:, 1, :, :], yuv[:, 2, :, :]\n    \n    # Conversion matrix from YUV to RGB\n    r = y + 1.402 * v\n    g = y - 0.344136 * u - 0.714136 * v\n    b = y + 1.772 * u\n    \n    rgb = torch.stack((r, g, b), dim=1)\n    return rgb\n\ndef yuv420_to_rgb(imagey, imageuv):\n    \"\"\"\n    Convert a YUV420 image to RGB.\n    \n    Args:\n        imagey (Tensor): Y (luma) image plane with shape (*, 1, H, W).\n        imageuv (Tensor): UV (chroma) image planes with shape (*, 2, H/2, W/2).\n    \n    Returns:\n        Tensor: RGB image with shape (*, 3, H, W).\n    \"\"\"\n    # Validate input\n    if not isinstance(imagey, torch.Tensor) or not isinstance(imageuv, torch.Tensor):\n        raise TypeError(\"imagey and imageuv must be torch Tensors.\")\n    \n    if imagey.shape[1] != 1:\n        raise ValueError(\"imagey must have shape (*, 1, H, W).\")\n    \n    if imageuv.shape[1] != 2:\n        raise ValueError(\"imageuv must have shape (*, 2, H/2, W/2).\")\n    \n    # Get dimensions\n    _, _, H, W = imagey.shape\n    \n    # Upsample UV planes to match Y plane dimensions\n    imageuv_upsampled = F.interpolate(imageuv, size=(H, W), mode='bilinear', align_corners=False)\n    \n    # Concatenate Y and upsampled UV to form YUV444\n    yuv444 = torch.cat((imagey, imageuv_upsampled), dim=1)\n    \n    # Convert YUV444 to RGB\n    rgb = yuv_to_rgb(yuv444)\n    \n    return rgb\n```\n\n### Explanation:\n\n- **Input Validation**: The function checks if the inputs are torch Tensors and have the expected shapes.\n- **Upsampling**: The `F.interpolate` function is used to upsample the UV planes to match the Y plane's resolution. The `bilinear` mode is suitable for this task as it provides smooth interpolation.\n- **YUV to RGB Conversion**: The `yuv_to_rgb` function performs the conversion using the standard YUV to RGB conversion formula.\n- **Output**: The function returns the RGB image with the same spatial dimensions as the input Y plane.",
    "prompt": "Create a Python function called yuv420_to_rgb that converts a YUV420 image to RGB. The function takes two torch Tensors as input: imagey for the Y (luma) image plane with shape (*, 1, H, W) and imageuv for the UV (chroma) image planes with shape (*, 2, H/2, W/2). The output is the RGB version of the image with shape (*, 3, H, W). The function assumes that the image data is in the range of (0, 1) for luma and (-0.5, 0.5) for chroma, and that the input needs to be padded to be evenly divisible by 2 horizontally and vertically. The chroma siting is assumed to be (0.5, 0.5).\n\nEnsure that the input imagey and imageuv are torch Tensors, have the correct shapes, and meet the specified requirements. The function first upsamples the input images and then converts the YUV444 tensor to RGB using a separate function called yuv_to_rgb.",
    "function_name": "yuv420_to_rgb",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestYuv420ToRgb",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}