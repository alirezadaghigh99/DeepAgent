{
    "result": "To implement the `axis_angle_to_rotation_matrix` function, we need to convert a 3D vector representing an axis-angle rotation into a 3x3 rotation matrix. This involves using the Rodrigues' rotation formula. Here's how you can implement this function in Python using PyTorch:\n\n```python\nimport torch\n\ndef axis_angle_to_rotation_matrix(axis_angle: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Convert 3D vector of axis-angle rotation to 3x3 rotation matrix.\n\n    Args:\n        axis_angle: Tensor of 3D vector of axis-angle rotations in radians with shape (N, 3).\n\n    Returns:\n        Tensor of rotation matrices of shape (N, 3, 3).\n    \"\"\"\n    # Ensure the input is a tensor\n    if not isinstance(axis_angle, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor\")\n\n    # Get the number of rotations\n    N = axis_angle.shape[0]\n\n    # Initialize the output tensor for rotation matrices\n    rotation_matrices = torch.zeros((N, 3, 3), dtype=axis_angle.dtype, device=axis_angle.device)\n\n    # Compute the angle (magnitude of the axis-angle vector)\n    angles = torch.norm(axis_angle, dim=1, keepdim=True)\n\n    # Avoid division by zero by setting zero angles to one (will be handled later)\n    angles = torch.where(angles == 0, torch.ones_like(angles), angles)\n\n    # Normalize the axis vectors\n    axis = axis_angle / angles\n\n    # Compute the components of the Rodrigues' rotation formula\n    cos_theta = torch.cos(angles)\n    sin_theta = torch.sin(angles)\n    one_minus_cos_theta = 1 - cos_theta\n\n    # Extract the components of the axis\n    x, y, z = axis[:, 0], axis[:, 1], axis[:, 2]\n\n    # Compute the rotation matrices\n    rotation_matrices[:, 0, 0] = cos_theta + x * x * one_minus_cos_theta\n    rotation_matrices[:, 0, 1] = x * y * one_minus_cos_theta - z * sin_theta\n    rotation_matrices[:, 0, 2] = x * z * one_minus_cos_theta + y * sin_theta\n\n    rotation_matrices[:, 1, 0] = y * x * one_minus_cos_theta + z * sin_theta\n    rotation_matrices[:, 1, 1] = cos_theta + y * y * one_minus_cos_theta\n    rotation_matrices[:, 1, 2] = y * z * one_minus_cos_theta - x * sin_theta\n\n    rotation_matrices[:, 2, 0] = z * x * one_minus_cos_theta - y * sin_theta\n    rotation_matrices[:, 2, 1] = z * y * one_minus_cos_theta + x * sin_theta\n    rotation_matrices[:, 2, 2] = cos_theta + z * z * one_minus_cos_theta\n\n    # Handle the case where the angle is zero (identity rotation)\n    rotation_matrices[angles.squeeze() == 0] = torch.eye(3, dtype=axis_angle.dtype, device=axis_angle.device)\n\n    return rotation_matrices\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input is a PyTorch tensor.\n- **Angle Calculation**: The angle of rotation is the magnitude of the axis-angle vector.\n- **Normalization**: The axis is normalized to ensure it is a unit vector.\n- **Rodrigues' Formula**: The rotation matrix is computed using the Rodrigues' rotation formula.\n- **Zero Angle Handling**: If the angle is zero, the rotation matrix is set to the identity matrix.",
    "prompt": "Write a python function axis_angle_to_rotation_matrix thatConvert 3d vector of axis-angle rotation to 3x3 rotation matrix.\n\n    Args:\n        axis_angle: tensor of 3d vector of axis-angle rotations in radians with shape :math:`(N, 3)`.\n\n    Returns:\n        tensor of rotation matrices of shape :math:`(N, 3, 3)`.\n\n    Example:\n        >>> input = tensor([[0., 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[1., 0., 0.],\n                 [0., 1., 0.],\n                 [0., 0., 1.]]])\n\n        >>> input = tensor([[1.5708, 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[ 1.0000e+00,  0.0000e+00,  0.0000e+00],\n                 [ 0.0000e+00, -3.6200e-06, -1.0000e+00],\n                 [ 0.0000e+00,  1.0000e+00, -3.6200e-06]]]]",
    "function_name": "axis_angle_to_rotation_matrix",
    "ground_truth": "kornia/geometry/conversions.py#L267",
    "test": "tests/geometry/test_conversions.py::TestAngleAxisToRotationMatrix",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}