{
    "result": "Here's a Python function called `quaternion_exp_to_log` that applies the log map to a quaternion. This function takes a tensor `quaternion` in the format (w, x, y, z) and a float `eps` for clamping. It outputs a tensor of shape (*, 3) representing the quaternion log map. The function includes checks for input validity and performs the necessary calculations to compute the quaternion log.\n\n```python\nimport torch\n\ndef quaternion_exp_to_log(quaternion: torch.Tensor, eps: float) -> torch.Tensor:\n    \"\"\"\n    Applies the log map to a quaternion.\n\n    Args:\n        quaternion (torch.Tensor): Tensor of shape (*, 4) representing quaternions in (w, x, y, z) format.\n        eps (float): A small value for clamping to avoid division by zero.\n\n    Returns:\n        torch.Tensor: Tensor of shape (*, 3) representing the quaternion log map.\n    \"\"\"\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    \n    if quaternion.shape[-1] != 4:\n        raise ValueError(\"Input tensor must have shape (*, 4).\")\n\n    # Unpack the quaternion into scalar and vector parts\n    w, x, y, z = quaternion.unbind(-1)\n    vector_part = quaternion[..., 1:]\n\n    # Compute the norm of the vector part\n    vector_norm = torch.norm(vector_part, dim=-1, keepdim=True)\n\n    # Compute the quaternion norm\n    quaternion_norm = torch.norm(quaternion, dim=-1, keepdim=True)\n\n    # Apply the log map\n    vector_norm_clamped = torch.clamp(vector_norm, min=eps)\n    theta = torch.acos(torch.clamp(w / quaternion_norm, min=-1.0, max=1.0))\n    log_map = (theta / vector_norm_clamped) * vector_part\n\n    # Handle the case where the vector part is zero\n    log_map = torch.where(vector_norm < eps, torch.zeros_like(log_map), log_map)\n\n    return log_map\n\n# Example usage\nquaternion = torch.tensor((1., 0., 0., 0.))\nresult = quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\nprint(result)  # Output: tensor([0., 0., 0.])\n```\n\nThis function checks if the input is a tensor and has the correct shape. It then unpacks the quaternion into its scalar and vector components, computes the necessary norms, and applies the log map. The `eps` parameter is used to avoid division by zero, and the function handles the case where the vector part is zero by returning a zero tensor.",
    "prompt": "Generate a Python function called quaternion_exp_to_log that applies the log map to a quaternion. The input is a tensor called quaternion in (w, x, y, z) format and a float called eps for clamping. The output is a tensor of shape (*, 3) representing the quaternion log map. The function checks if the input is a Tensor and has a shape of (*, 4). It then unpacks the quaternion into a vector and scalar, computes the quaternion norm, and applies the log map to calculate the quaternion log. An example usage is provided with a sample quaternion input. >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_exp_to_log",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/epipolar/test_essential.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}