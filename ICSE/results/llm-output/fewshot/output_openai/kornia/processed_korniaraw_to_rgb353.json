{
    "result": "Here's a Python function `raw_to_rgb` that converts a raw Bayer image to an RGB image using the specified requirements:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef raw_to_rgb(image: torch.Tensor, cfa: str) -> torch.Tensor:\n    \"\"\"\n    Convert a raw Bayer image to an RGB image using bilinear interpolation.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, 1, H, W).\n        cfa (str): Color Filter Array configuration ('BG', 'GB', 'RG', 'GR').\n\n    Returns:\n        torch.Tensor: RGB image tensor with shape (*, 3, H, W).\n\n    Raises:\n        TypeError: If the input is not a torch.Tensor.\n        ValueError: If the input shape is not (*, 1, H, W) or if H and W are not evenly divisible by 2.\n    \"\"\"\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(f\"Input type is not a torch.Tensor. Got {type(image)}.\")\n    \n    if image.ndim < 3 or image.shape[-3] != 1:\n        raise ValueError(f\"Input size must have a shape of (*, 1, H, W). Got {image.shape}.\")\n    \n    _, _, H, W = image.shape\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(f\"Input H&W must be evenly divisible by 2. Got {image.shape}.\")\n\n    # Define the CFA patterns\n    cfa_patterns = {\n        'BG': (0, 1, 1, 2),\n        'GB': (1, 0, 2, 1),\n        'RG': (2, 1, 1, 0),\n        'GR': (1, 2, 0, 1)\n    }\n\n    if cfa not in cfa_patterns:\n        raise ValueError(f\"Invalid CFA configuration. Expected one of {list(cfa_patterns.keys())}. Got {cfa}.\")\n\n    # Extract the CFA pattern\n    r_idx, g1_idx, g2_idx, b_idx = cfa_patterns[cfa]\n\n    # Initialize the RGB image\n    rgb_image = torch.zeros(*image.shape[:-3], 3, H, W, dtype=image.dtype, device=image.device)\n\n    # Assign the raw values to the appropriate channels\n    rgb_image[..., 0, ::2, ::2] = image[..., 0, ::2, ::2]  # Red\n    rgb_image[..., 1, ::2, 1::2] = image[..., 0, ::2, 1::2]  # Green 1\n    rgb_image[..., 1, 1::2, ::2] = image[..., 0, 1::2, ::2]  # Green 2\n    rgb_image[..., 2, 1::2, 1::2] = image[..., 0, 1::2, 1::2]  # Blue\n\n    # Interpolate missing values using bilinear interpolation\n    for c in range(3):\n        mask = (rgb_image[..., c, :, :] == 0)\n        rgb_image[..., c, :, :] = F.interpolate(rgb_image[..., c, :, :].unsqueeze(1), scale_factor=2, mode='bilinear', align_corners=False).squeeze(1)\n        rgb_image[..., c, :, :][mask] = 0\n\n    return rgb_image\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input is a `torch.Tensor` and if its shape is correct. It also checks if the height and width are divisible by 2.\n- **CFA Patterns**: The function supports four CFA configurations: 'BG', 'GB', 'RG', 'GR'. Each configuration determines the arrangement of the color channels in the Bayer pattern.\n- **RGB Initialization**: An empty RGB tensor is initialized, and the raw values are assigned to the appropriate channels based on the CFA pattern.\n- **Interpolation**: Bilinear interpolation is used to fill in the missing values for each color channel. The `F.interpolate` function is used for this purpose.\n- **Output**: The function returns the RGB image tensor.",
    "prompt": "Generate a Python function called raw_to_rgb that converts a raw Bayer image to an RGB version of the image. The function takes in a torch.Tensor called image and a CFA configuration called cfa. It returns the RGB version of the image with shape (*,3,H,W). The function assumes a CFA with 2 green, 1 red, and 1 blue, using bilinear interpolation for R/G and a fixed convolution for the green pixels. The input image data is expected to be in the range of (0, 1) and the Height/Width to be evenly divisible by 2. The function handles different CFA configurations (BG, GB, RG, GR) and performs necessary padding and interpolation to convert the raw image to RGB. If the input is not type of tensor, raise type error Input type is not a torch.Tensor. Got {type(image)}. if dimension is not correct, raise value error (f\"Input size must have a shape of (*, 1, H, W). Got {image.shape}.\"). else if shape is not correct, raise value error Input H&W must be evenly disible by 2. Got {image.shape}",
    "function_name": "raw_to_rgb",
    "ground_truth": "kornia/color/raw.py",
    "test": "tests/color/test_raw.py::TestRawToRgb",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}