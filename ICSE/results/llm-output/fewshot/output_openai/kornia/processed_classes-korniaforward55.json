{
    "result": "To implement the `forward` method for the `Rotate` class, we need to rotate the input tensor around its center. We'll use PyTorch's `torch.nn.functional.grid_sample` and `torch.nn.functional.affine_grid` to perform the rotation. Here's how you can implement it:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Rotate(nn.Module):\n    def __init__(self, angle: float, center: Optional[Tuple[float, float]] = None, \n                 interpolation: str = 'bilinear', padding_mode: str = 'zeros', \n                 align_corners: bool = False):\n        super(Rotate, self).__init__()\n        self.angle = angle\n        self.center = center\n        self.interpolation = interpolation\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Get the dimensions of the input tensor\n        n, c, h, w = input.size()\n\n        # Calculate the center of rotation\n        if self.center is None:\n            center_x, center_y = w / 2, h / 2\n        else:\n            center_x, center_y = self.center\n\n        # Convert angle from degrees to radians\n        angle_rad = -self.angle * (3.141592653589793 / 180.0)\n\n        # Create the rotation matrix\n        cos_a = torch.cos(torch.tensor(angle_rad))\n        sin_a = torch.sin(torch.tensor(angle_rad))\n        rotation_matrix = torch.tensor([\n            [cos_a, -sin_a, (1 - cos_a) * center_x + sin_a * center_y],\n            [sin_a, cos_a, (1 - cos_a) * center_y - sin_a * center_x]\n        ], dtype=input.dtype, device=input.device)\n\n        # Create the affine grid\n        grid = F.affine_grid(rotation_matrix.unsqueeze(0), input.size(), align_corners=self.align_corners)\n\n        # Sample the input tensor using the grid\n        output = F.grid_sample(input, grid, mode=self.interpolation, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\n### Explanation:\n- **Initialization**: The `Rotate` class is initialized with parameters like `angle`, `center`, `interpolation`, `padding_mode`, and `align_corners`.\n- **Center Calculation**: If no center is provided, the center of the image is used.\n- **Rotation Matrix**: The rotation matrix is constructed using the angle in radians. The matrix is designed to rotate around the specified center.\n- **Affine Grid**: `F.affine_grid` is used to create a grid for sampling the input tensor based on the rotation matrix.\n- **Grid Sample**: `F.grid_sample` is used to apply the grid to the input tensor, effectively rotating it.\n\nThis implementation allows you to rotate an input tensor by a specified angle around a specified or calculated center, using the specified interpolation and padding modes.",
    "prompt": "**Task:** Write the `forward` method for the `Rotate` class. This method should rotate the input tensor anti-clockwise around its center. The method should return a tensor of the same shape as the input.\n\n\n**Class Context:**\n```python\nclass Rotate(nn.Module):\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Implement this function\n```\n\n**Requirements:**\n- The method should take the input tensor and rotate it by the specified angle.\n- The rotation should be performed around the provided center, or the center should be calculated if not provided.\n- Use the specified interpolation mode (`'bilinear'` or `'nearest'`), padding mode (`'zeros'`, `'border'`, or `'reflection'`), and alignment flag (`align_corners`).",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestRotate",
    "class": "Rotate",
    "stage": "Image",
    "task": "",
    "data": "Inference"
}