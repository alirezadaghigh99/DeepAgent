{
    "result": "Certainly! Below is a Python function `get_rotation_matrix2d` that calculates an affine matrix for 2D rotation. The function takes three inputs: `center`, `angle`, and `scale`, all of which are PyTorch tensors. The function returns a tensor representing the affine transformation matrix for each batch.\n\n```python\nimport torch\nimport math\n\ndef get_rotation_matrix2d(center: torch.Tensor, angle: torch.Tensor, scale: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculate the affine matrix of 2D rotation.\n\n    Args:\n        center (Tensor): Center of the rotation in the source image with shape (B, 2).\n        angle (Tensor): Rotation angle in degrees with shape (B).\n        scale (Tensor): Scale factor for x, y scaling with shape (B, 2).\n\n    Returns:\n        Tensor: Affine matrix of 2D rotation with shape (B, 2, 3).\n    \"\"\"\n    if center.dim() != 2 or center.size(1) != 2:\n        raise ValueError(\"center must have shape (B, 2)\")\n    if angle.dim() != 1:\n        raise ValueError(\"angle must have shape (B)\")\n    if scale.dim() != 2 or scale.size(1) != 2:\n        raise ValueError(\"scale must have shape (B, 2)\")\n\n    B = center.size(0)\n    angle_rad = angle * math.pi / 180.0\n\n    cos_a = torch.cos(angle_rad)\n    sin_a = torch.sin(angle_rad)\n\n    # Create the rotation matrix\n    rotation_matrix = torch.zeros((B, 2, 3), dtype=center.dtype, device=center.device)\n    rotation_matrix[:, 0, 0] = cos_a * scale[:, 0]\n    rotation_matrix[:, 0, 1] = -sin_a * scale[:, 1]\n    rotation_matrix[:, 1, 0] = sin_a * scale[:, 0]\n    rotation_matrix[:, 1, 1] = cos_a * scale[:, 1]\n\n    # Adjust the translation part to keep the center in place\n    rotation_matrix[:, 0, 2] = center[:, 0] - rotation_matrix[:, 0, 0] * center[:, 0] - rotation_matrix[:, 0, 1] * center[:, 1]\n    rotation_matrix[:, 1, 2] = center[:, 1] - rotation_matrix[:, 1, 0] * center[:, 0] - rotation_matrix[:, 1, 1] * center[:, 1]\n\n    return rotation_matrix\n\n# Example usage\ncenter = torch.tensor([[50.0, 50.0], [30.0, 30.0]])\nangle = torch.tensor([45.0, 90.0])\nscale = torch.tensor([[1.0, 1.0], [0.5, 0.5]])\n\naffine_matrices = get_rotation_matrix2d(center, angle, scale)\nprint(affine_matrices)\n```\n\n### Explanation:\n- **Inputs**:\n  - `center`: A tensor of shape `(B, 2)` representing the center of rotation for each batch.\n  - `angle`: A tensor of shape `(B)` representing the rotation angle in degrees for each batch.\n  - `scale`: A tensor of shape `(B, 2)` representing the scaling factors for x and y axes for each batch.\n\n- **Output**:\n  - A tensor of shape `(B, 2, 3)` representing the affine transformation matrix for each batch.\n\n- **Functionality**:\n  - The function first checks the shapes of the input tensors to ensure they are correct.\n  - It converts the angle from degrees to radians.\n  - It calculates the cosine and sine of the angle.\n  - It constructs the rotation matrix and adjusts the translation part to ensure the center of rotation maps to itself.\n\nThis function is useful for tasks involving image transformations, such as data augmentation in deep learning pipelines.",
    "prompt": "Generate a Python function called get_rotation_matrix2d that calculates an affine matrix of 2D rotation. The function takes three inputs: center (center of the rotation in the source image with shape (B, 2)), angle (rotation angle in degrees with shape (B)), and scale (scale factor for x, y scaling with shape (B, 2)). \n\nThe function returns the affine matrix of 2D rotation with shape (B, 2, 3). The rotation matrix is calculated based on the provided center, angle, and scale values. The transformation maps the rotation center to itself, but adjustments can be made if needed.\n\nEnsure that the inputs are of type Tensor and have the correct shapes before performing the calculations. The function also includes an example usage with sample input values. This function is often used in conjunction with the warp_affine function.",
    "function_name": "get_rotation_matrix2d",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp.py::TestRotationMatrix2d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Image"
}