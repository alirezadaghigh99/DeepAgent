{
    "result": "To generate the function `motion_from_essential`, we need to decompose the essential matrix \\( E \\) into the possible rotation matrices \\( R1 \\) and \\( R2 \\), and the translation vector \\( t \\). The essential matrix decomposition is a well-known problem in computer vision, often used in the context of recovering camera motion from epipolar geometry.\n\nHere's how you can implement the `motion_from_essential` function in Python using PyTorch:\n\n```python\nimport torch\n\ndef motion_from_essential(E_mat: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Decompose an essential matrix into the four possible camera poses.\n\n    Args:\n        E_mat (torch.Tensor): Essential matrix of shape (*, 3, 3).\n\n    Returns:\n        Rs (torch.Tensor): Rotation matrices of shape (*, 4, 3, 3).\n        Ts (torch.Tensor): Translation vectors of shape (*, 4, 3, 1).\n    \"\"\"\n    assert E_mat.shape[-2:] == (3, 3), \"E_mat must have shape (*, 3, 3)\"\n\n    # Define the W matrix used in the decomposition\n    W = torch.tensor([[0, -1, 0],\n                      [1, 0, 0],\n                      [0, 0, 1]], dtype=E_mat.dtype, device=E_mat.device)\n\n    # Perform SVD on the essential matrix\n    U, _, Vt = torch.linalg.svd(E_mat)\n\n    # Ensure a proper rotation matrix\n    if torch.det(U @ Vt) < 0:\n        Vt = -Vt\n\n    # Compute the two possible rotation matrices\n    R1 = U @ W @ Vt\n    R2 = U @ W.T @ Vt\n\n    # Compute the translation vector (up to scale)\n    t = U[:, :, 2].unsqueeze(-1)\n\n    # Stack the results to form the output tensors\n    Rs = torch.stack([R1, R1, R2, R2], dim=-3)\n    Ts = torch.stack([t, -t, t, -t], dim=-3)\n\n    return Rs, Ts\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks that the input `E_mat` has the correct shape of \\((*, 3, 3)\\). The `*` allows for batch processing of multiple essential matrices.\n\n2. **SVD Decomposition**: The essential matrix \\( E \\) is decomposed using Singular Value Decomposition (SVD) into matrices \\( U \\), \\( \\Sigma \\), and \\( V^T \\).\n\n3. **Rotation Matrices**: Two possible rotation matrices \\( R1 \\) and \\( R2 \\) are computed using the matrix \\( W \\) and its transpose \\( W^T \\).\n\n4. **Translation Vector**: The translation vector \\( t \\) is extracted from the third column of \\( U \\).\n\n5. **Output**: The function returns two tensors, `Rs` and `Ts`, containing the four possible solutions for the rotation and translation, respectively.\n\nThis function is useful in computer vision tasks where you need to determine the relative motion between two camera views given an essential matrix.",
    "prompt": "Generate a Python function called motion_from_essential that takes in a torch.Tensor E_mat representing an essential matrix and returns the four possible poses for the decomposition of the Essential matrix. The possible solutions are [R1,t], [R1,-t], [R2,t], [R2,-t]. The function checks the shape of the input tensor and raises an AssertionError if it does not meet the required shape. It returns the four possible solutions in the form of two tensors: Rs with shape (*, 4, 3, 3) and Ts with shape (*, 4, 3, 1).",
    "function_name": "motion_from_essential",
    "ground_truth": "kornia/geometry/epipolar/essential.py",
    "test": "tests/geometry/epipolar/test_essential.py::TestMotionFromEssential",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}