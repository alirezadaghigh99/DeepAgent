{
    "result": "To generate the `unproject` function for the `PinholeCamera` class, we need to transform 2D pixel coordinates into 3D world coordinates using the camera's intrinsic and extrinsic parameters. The intrinsic matrix is used to convert pixel coordinates to camera coordinates, and the extrinsic matrix is used to transform camera coordinates to world coordinates.\n\nHere's how you can implement the `unproject` function:\n\n```python\nimport torch\nfrom torch import Tensor\n\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n\n    def unproject(self, point_2d: Tensor, depth: Tensor) -> Tensor:\n        \"\"\"\n        Transform 2D pixel coordinates to 3D world coordinates.\n\n        Args:\n            point_2d (Tensor): Tensor of shape (*, 2) representing 2D pixel coordinates.\n            depth (Tensor): Tensor of shape (*, 1) representing depth values.\n\n        Returns:\n            Tensor: Tensor of shape (*, 3) representing 3D world coordinates.\n        \"\"\"\n        # Ensure the input tensors are of the correct shape\n        assert point_2d.shape[-1] == 2, \"point_2d should have shape (*, 2)\"\n        assert depth.shape[-1] == 1, \"depth should have shape (*, 1)\"\n\n        # Convert point_2d to homogeneous coordinates\n        ones = torch.ones_like(point_2d[..., :1])\n        point_2d_homogeneous = torch.cat((point_2d, ones), dim=-1)\n\n        # Invert the intrinsic matrix\n        intrinsics_inv = torch.inverse(self._intrinsics)\n\n        # Compute camera coordinates\n        camera_coords_homogeneous = torch.matmul(intrinsics_inv, point_2d_homogeneous.unsqueeze(-1)).squeeze(-1)\n        camera_coords = camera_coords_homogeneous * depth\n\n        # Convert camera coordinates to homogeneous coordinates\n        camera_coords_homogeneous = torch.cat((camera_coords, ones), dim=-1)\n\n        # Invert the extrinsic matrix\n        extrinsics_inv = torch.inverse(self._extrinsics)\n\n        # Compute world coordinates\n        world_coords_homogeneous = torch.matmul(extrinsics_inv, camera_coords_homogeneous.unsqueeze(-1)).squeeze(-1)\n\n        # Return the (x, y, z) world coordinates\n        return world_coords_homogeneous[..., :3]\n```\n\n### Explanation:\n1. **Homogeneous Coordinates**: The 2D pixel coordinates are converted to homogeneous coordinates by appending a 1. This is necessary for matrix operations involving transformations.\n\n2. **Intrinsic Matrix Inversion**: The intrinsic matrix is inverted to transform pixel coordinates to normalized camera coordinates.\n\n3. **Camera Coordinates**: The normalized camera coordinates are scaled by the depth to obtain the actual camera coordinates.\n\n4. **Extrinsic Matrix Inversion**: The extrinsic matrix is inverted to transform camera coordinates to world coordinates.\n\n5. **World Coordinates**: The final world coordinates are extracted from the homogeneous coordinates.\n\nThis function assumes that the intrinsic and extrinsic matrices are invertible and that the input tensors are properly shaped. Adjustments may be needed based on specific use cases or additional constraints.",
    "prompt": "Generate the `unproject` function for the following class to transform coordinates in the pixel frame to the world frame. The input is `self`, a `point_2d` tensor with shape `(*, 2)`, and a `depth` tensor with shape `(*, 1)`. The output is a tensor of `(x, y, z)` world coordinates with shape `(*, 3)`.\n\n```python\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n```",
    "function_name": "unproject",
    "ground_truth": "kornia/geometry/camera/pinhole.py",
    "test": "tests/geometry/camera/test_pinhole.py",
    "class": "PinholeCamera",
    "stage": "Image",
    "task": "",
    "data": "Inference"
}