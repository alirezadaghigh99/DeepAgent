{
    "result": "To implement the `forward` function for the `Affine` class, we need to construct an affine transformation matrix using the provided parameters (`angle`, `translation`, `scale_factor`, `shear`, and `center`) and apply this transformation to the input tensor. We'll use PyTorch's `torch.nn.functional` module to perform the affine transformation. Here's how you can implement the `forward` function:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom typing import Optional\n\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        super(Affine, self).__init__()\n        self.angle = angle\n        self.translation = translation\n        self.scale_factor = scale_factor\n        self.shear = shear\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        batch_size, channels, height, width = input.shape\n\n        # Default values for transformations\n        angle = self.angle if self.angle is not None else torch.zeros(batch_size)\n        translation = self.translation if self.translation is not None else torch.zeros(batch_size, 2)\n        scale_factor = self.scale_factor if self.scale_factor is not None else torch.ones(batch_size, 2)\n        shear = self.shear if self.shear is not None else torch.zeros(batch_size, 2)\n        center = self.center if self.center is not None else torch.tensor([width / 2, height / 2]).repeat(batch_size, 1)\n\n        # Convert angles from degrees to radians\n        angle_rad = angle * (torch.pi / 180.0)\n\n        # Compute the affine transformation matrix for each image in the batch\n        affine_matrices = []\n        for i in range(batch_size):\n            # Compute rotation matrix\n            cos_a = torch.cos(angle_rad[i])\n            sin_a = torch.sin(angle_rad[i])\n            rotation_matrix = torch.tensor([\n                [cos_a, -sin_a, 0],\n                [sin_a, cos_a, 0],\n                [0, 0, 1]\n            ])\n\n            # Compute scaling matrix\n            scale_matrix = torch.tensor([\n                [scale_factor[i, 0], 0, 0],\n                [0, scale_factor[i, 1], 0],\n                [0, 0, 1]\n            ])\n\n            # Compute shearing matrix\n            shear_x, shear_y = shear[i]\n            shear_matrix = torch.tensor([\n                [1, shear_x, 0],\n                [shear_y, 1, 0],\n                [0, 0, 1]\n            ])\n\n            # Compute translation matrix\n            tx, ty = translation[i]\n            translation_matrix = torch.tensor([\n                [1, 0, tx],\n                [0, 1, ty],\n                [0, 0, 1]\n            ])\n\n            # Compute center translation matrix\n            cx, cy = center[i]\n            center_translation_matrix = torch.tensor([\n                [1, 0, cx],\n                [0, 1, cy],\n                [0, 0, 1]\n            ])\n\n            # Compute inverse center translation matrix\n            inverse_center_translation_matrix = torch.tensor([\n                [1, 0, -cx],\n                [0, 1, -cy],\n                [0, 0, 1]\n            ])\n\n            # Combine all transformations\n            affine_matrix = (\n                center_translation_matrix @\n                translation_matrix @\n                rotation_matrix @\n                shear_matrix @\n                scale_matrix @\n                inverse_center_translation_matrix\n            )\n\n            # Extract the 2x3 part of the affine matrix\n            affine_matrices.append(affine_matrix[:2, :])\n\n        affine_matrices = torch.stack(affine_matrices)\n\n        # Apply the affine transformation\n        grid = F.affine_grid(affine_matrices, input.size(), align_corners=self.align_corners)\n        output = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\nThis implementation constructs an affine transformation matrix for each image in the batch using the specified parameters and applies the transformation using `F.affine_grid` and `F.grid_sample`. The function supports rotation, translation, scaling, and shearing transformations, and it can handle different interpolation modes and padding options.",
    "prompt": "Write a Python function `forward` for the `Affine` class that applies multiple elementary affine transformations (rotation, translation, scaling, and shearing) to a batch of input tensors. The function takes a 4D tensor with shape `[batch_size, channels, height, width]` as input and returns a transformed tensor of the same shape. The affine transformation is computed using parameters such as `angle`, `translation`, `scale_factor`, `shear`, and `center`, with optional interpolation modes and padding options.\n\n```python\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        # Initialization code...\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n``` \n\nThe `forward` function constructs an affine transformation matrix based on the provided parameters and applies this transformation to the input tensor.",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestAffine2d",
    "class": "Affine",
    "stage": "Image",
    "task": "",
    "data": "Model construction"
}