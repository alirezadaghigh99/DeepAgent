{
    "result": "Here's a Python function `tensor_to_image` that meets the specified requirements:\n\n```python\nimport torch\nimport numpy as np\n\ndef tensor_to_image(tensor: torch.Tensor, keepdim: bool = True, force_contiguous: bool = False) -> np.ndarray:\n    \"\"\"\n    Convert a PyTorch tensor image to a NumPy array image.\n\n    Args:\n        tensor (torch.Tensor): A PyTorch tensor of shape (H, W), (C, H, W), or (B, C, H, W).\n        keepdim (bool): Whether to retain the batch dimension. Defaults to True.\n        force_contiguous (bool): Whether to make the tensor contiguous. Defaults to False.\n\n    Returns:\n        np.ndarray: A NumPy array representing the image with shape (H, W), (H, W, C), or (B, H, W, C).\n\n    Raises:\n        TypeError: If the input is not a Tensor.\n        ValueError: If the input tensor's dimensions are not 2, 3, or 4.\n    \"\"\"\n    if not isinstance(tensor, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch Tensor.\")\n\n    if tensor.dim() not in {2, 3, 4}:\n        raise ValueError(\"Input tensor must have 2, 3, or 4 dimensions.\")\n\n    # Move tensor to CPU if it's on GPU\n    if tensor.is_cuda:\n        tensor = tensor.cpu()\n\n    # Make tensor contiguous if required\n    if force_contiguous:\n        tensor = tensor.contiguous()\n\n    # Convert tensor to NumPy array\n    array = tensor.numpy()\n\n    # Handle different shapes\n    if tensor.dim() == 2:\n        # (H, W)\n        return array\n    elif tensor.dim() == 3:\n        # (C, H, W) -> (H, W, C)\n        return np.transpose(array, (1, 2, 0))\n    elif tensor.dim() == 4:\n        # (B, C, H, W) -> (B, H, W, C)\n        array = np.transpose(array, (0, 2, 3, 1))\n        if not keepdim:\n            # Remove batch dimension if keepdim is False\n            return array.squeeze(axis=0)\n        return array\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input is a PyTorch tensor and if its dimensions are valid (2, 3, or 4).\n- **Device Handling**: If the tensor is on a GPU, it is moved to the CPU.\n- **Contiguity**: If `force_contiguous` is `True`, the tensor is made contiguous.\n- **Conversion**: The tensor is converted to a NumPy array.\n- **Shape Handling**: The function handles different input shapes and returns the appropriate output shape:\n  - `(H, W)` remains unchanged.\n  - `(C, H, W)` is transposed to `(H, W, C)`.\n  - `(B, C, H, W)` is transposed to `(B, H, W, C)`, and the batch dimension is optionally squeezed if `keepdim` is `False`.",
    "prompt": "Create a Python function `tensor_to_image` that converts a PyTorch tensor image to a NumPy array image. The function should:\n\n- Accept a tensor as input, which can have one of the following shapes: `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- Convert the tensor to a NumPy array, handling cases where the tensor is in GPU memory by copying it back to CPU.\n- Optionally, squeeze the dimensions if `keepdim` is `False`.\n- Ensure the tensor is contiguous if `force_contiguous` is `True`.\n- Return the converted image with the appropriate shape: `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nInput types:\n- `tensor`: A PyTorch tensor of shape `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- `keepdim`: A boolean indicating whether to retain the batch dimension.\n- `force_contiguous`: A boolean indicating whether to make the tensor contiguous.\n\nOutput:\n- Returns a NumPy array representing the image with the shape `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nErrors:\n- Raise a `TypeError` if the input is not a Tensor.\n- Raise a `ValueError` if the input tensor's dimensions are not 2, 3, or 4.",
    "function_name": "tensor_to_image",
    "ground_truth": "kornia/utils/image.py",
    "test": "tests/utils/test_image_utils.py::test_tensor_to_image",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}