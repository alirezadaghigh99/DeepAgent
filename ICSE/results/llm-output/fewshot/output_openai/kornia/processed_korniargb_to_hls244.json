{
    "result": "To create a function `rgb_to_hls` that converts an RGB image to HLS format using PyTorch, we need to follow the specified requirements. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef rgb_to_hls(image: torch.Tensor, eps: float = 1e-10) -> torch.Tensor:\n    \"\"\"\n    Convert an RGB image to HLS format.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, 3, H, W) and values in range (0, 1).\n        eps (float): Small epsilon value to avoid division by zero.\n\n    Returns:\n        torch.Tensor: HLS image tensor with the same shape as the input.\n\n    Raises:\n        TypeError: If the input is not a PyTorch tensor.\n        ValueError: If the input does not have a shape of (*, 3, H, W).\n    \"\"\"\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    if image.ndim < 3 or image.size(-3) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W).\")\n\n    # Separate the RGB channels\n    r, g, b = image.unbind(dim=-3)\n\n    # Calculate the max and min values across the RGB channels\n    max_rgb, _ = torch.max(image, dim=-3)\n    min_rgb, _ = torch.min(image, dim=-3)\n\n    # Calculate luminance\n    l = (max_rgb + min_rgb) / 2\n\n    # Calculate saturation\n    delta = max_rgb - min_rgb\n    s = torch.where(l < 0.5, delta / (max_rgb + min_rgb + eps), delta / (2 - max_rgb - min_rgb + eps))\n\n    # Calculate hue\n    delta_r = (((max_rgb - r) / 6) + (delta / 2)) / (delta + eps)\n    delta_g = (((max_rgb - g) / 6) + (delta / 2)) / (delta + eps)\n    delta_b = (((max_rgb - b) / 6) + (delta / 2)) / (delta + eps)\n\n    h = torch.zeros_like(l)\n    mask_r = (r == max_rgb)\n    mask_g = (g == max_rgb)\n    mask_b = (b == max_rgb)\n\n    h[mask_r] = delta_b[mask_r] - delta_g[mask_r]\n    h[mask_g] = (1 / 3) + delta_r[mask_g] - delta_b[mask_g]\n    h[mask_b] = (2 / 3) + delta_g[mask_b] - delta_r[mask_b]\n\n    h = (h + 1) % 1  # Ensure hue is in the range [0, 1]\n\n    # Stack the H, L, S components back together\n    hls = torch.stack((h, l, s), dim=-3)\n\n    return hls\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a random RGB image tensor with shape (2, 3, 4, 4)\n    random_image = torch.rand((2, 3, 4, 4))\n    hls_image = rgb_to_hls(random_image)\n    print(hls_image.shape)  # Should print: torch.Size([2, 3, 4, 4])\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input is a PyTorch tensor and if it has the correct shape.\n- **RGB to HLS Conversion**: The function calculates the luminance, saturation, and hue based on the RGB values.\n- **Handling Edge Cases**: The `eps` parameter is used to avoid division by zero.\n- **Output**: The function returns the HLS image with the same shape as the input.",
    "prompt": "Generate a Python function called rgb_to_hls that converts an RGB image to HLS format. The function takes in a PyTorch tensor called image representing the RGB image with shape (*, 3, H, W) and an epsilon value eps to avoid division by zero. The image data is assumed to be in the range of (0, 1).\n\nThe function returns the HLS version of the input image with the same shape (*, 3, H, W). If the input image is not a PyTorch tensor, a TypeError is raised. If the input size does not have a shape of (*, 3, H, W), a ValueError is raised.\n\nThe conversion process involves calculating the HLS components (hue, luminance, saturation) based on the RGB values of the input image. The resulting HLS image is returned as a PyTorch tensor.\n\nAn example usage of the rgb_to_hls function is provided in the code snippet, where a random input RGB image tensor is converted to HLS format. Raise the value error if there input not instance of image or there was a problem with shape",
    "function_name": "rgb_to_hls",
    "ground_truth": "kornia/color/hls.py",
    "test": "tests/color/test_hls.py::TestRgbToHls",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}