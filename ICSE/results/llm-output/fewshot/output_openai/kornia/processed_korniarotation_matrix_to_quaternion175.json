{
    "result": "Certainly! Below is a Python function `rotation_matrix_to_quaternion` that converts a 3x3 rotation matrix to a 4D quaternion vector. The function includes error handling for input types and sizes, and provides examples of usage.\n\n```python\nimport torch\n\ndef rotation_matrix_to_quaternion(rotation_matrix: torch.Tensor, eps: float = 1e-6) -> torch.Tensor:\n    \"\"\"\n    Converts a 3x3 rotation matrix to a 4D quaternion vector.\n\n    Args:\n        rotation_matrix (torch.Tensor): A tensor of shape (..., 3, 3) representing the rotation matrix.\n        eps (float): A small value to avoid division by zero. Defaults to 1e-6.\n\n    Returns:\n        torch.Tensor: A tensor of shape (..., 4) representing the quaternion in (w, x, y, z) format.\n\n    Raises:\n        ValueError: If the input is not a 3x3 matrix or if the last two dimensions are not 3x3.\n    \"\"\"\n    if rotation_matrix.ndim < 2 or rotation_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input must be a tensor with the last two dimensions of size 3x3.\")\n\n    # Initialize quaternion tensor\n    q = torch.zeros(rotation_matrix.shape[:-2] + (4,), dtype=rotation_matrix.dtype, device=rotation_matrix.device)\n\n    # Calculate the trace of the matrix\n    trace = rotation_matrix[..., 0, 0] + rotation_matrix[..., 1, 1] + rotation_matrix[..., 2, 2]\n\n    # Compute quaternion based on the trace\n    if torch.any(trace > 0):\n        s = torch.sqrt(trace + 1.0) * 2  # s = 4 * qw\n        q[..., 0] = 0.25 * s\n        q[..., 1] = (rotation_matrix[..., 2, 1] - rotation_matrix[..., 1, 2]) / s\n        q[..., 2] = (rotation_matrix[..., 0, 2] - rotation_matrix[..., 2, 0]) / s\n        q[..., 3] = (rotation_matrix[..., 1, 0] - rotation_matrix[..., 0, 1]) / s\n    else:\n        # Find the largest diagonal element\n        max_diag = torch.argmax(torch.tensor([rotation_matrix[..., 0, 0], rotation_matrix[..., 1, 1], rotation_matrix[..., 2, 2]]), dim=0)\n        if max_diag == 0:\n            s = torch.sqrt(1.0 + rotation_matrix[..., 0, 0] - rotation_matrix[..., 1, 1] - rotation_matrix[..., 2, 2]) * 2\n            q[..., 0] = (rotation_matrix[..., 2, 1] - rotation_matrix[..., 1, 2]) / s\n            q[..., 1] = 0.25 * s\n            q[..., 2] = (rotation_matrix[..., 0, 1] + rotation_matrix[..., 1, 0]) / s\n            q[..., 3] = (rotation_matrix[..., 0, 2] + rotation_matrix[..., 2, 0]) / s\n        elif max_diag == 1:\n            s = torch.sqrt(1.0 + rotation_matrix[..., 1, 1] - rotation_matrix[..., 0, 0] - rotation_matrix[..., 2, 2]) * 2\n            q[..., 0] = (rotation_matrix[..., 0, 2] - rotation_matrix[..., 2, 0]) / s\n            q[..., 1] = (rotation_matrix[..., 0, 1] + rotation_matrix[..., 1, 0]) / s\n            q[..., 2] = 0.25 * s\n            q[..., 3] = (rotation_matrix[..., 1, 2] + rotation_matrix[..., 2, 1]) / s\n        else:\n            s = torch.sqrt(1.0 + rotation_matrix[..., 2, 2] - rotation_matrix[..., 0, 0] - rotation_matrix[..., 1, 1]) * 2\n            q[..., 0] = (rotation_matrix[..., 1, 0] - rotation_matrix[..., 0, 1]) / s\n            q[..., 1] = (rotation_matrix[..., 0, 2] + rotation_matrix[..., 2, 0]) / s\n            q[..., 2] = (rotation_matrix[..., 1, 2] + rotation_matrix[..., 2, 1]) / s\n            q[..., 3] = 0.25 * s\n\n    return q\n\n# Example usage:\nrotation_matrix = torch.tensor([\n    [0.0, -1.0, 0.0],\n    [1.0, 0.0, 0.0],\n    [0.0, 0.0, 1.0]\n])\n\nquaternion = rotation_matrix_to_quaternion(rotation_matrix)\nprint(quaternion)  # Output: tensor([0.7071, 0.0000, 0.0000, 0.7071])\n```\n\nThis function checks if the input tensor has the correct shape and computes the quaternion based on the trace of the rotation matrix. It handles different cases based on the largest diagonal element to ensure numerical stability.",
    "prompt": "Generate a Python function called rotation_matrix_to_quaternion that converts a 3x3 rotation matrix to a 4d quaternion vector. The input parameters are a rotation matrix tensor and a small value eps to avoid zero division. The output is a quaternion tensor with components in (w, x, y, z) format. The function returns the quaternion tensor with shape (*, 4). The function includes examples of usage and error handling for input types and sizes.",
    "function_name": "rotation_matrix_to_quaternion",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestRotationMatrixToQuaternion",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}