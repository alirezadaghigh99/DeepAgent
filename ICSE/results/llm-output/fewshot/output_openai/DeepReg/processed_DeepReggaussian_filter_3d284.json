{
    "result": "To create a Python function called `gaussian_filter_3d` that defines a 3D Gaussian filter for smoothing, you can use TensorFlow to construct the Gaussian kernel. The function will take a parameter `kernel_sigma`, which can be either a list of deviations for each direction or an integer for isotropic deviation. Here's how you can implement this function:\n\n```python\nimport tensorflow as tf\nimport numpy as np\n\ndef gaussian_filter_3d(kernel_sigma):\n    \"\"\"\n    Create a 3D Gaussian filter for smoothing.\n\n    Args:\n        kernel_sigma (Union[int, List[int]]): Standard deviation for each direction.\n            If an integer is provided, the same standard deviation is used for all directions.\n\n    Returns:\n        tf.Tensor: A 3D Gaussian kernel tensor for smoothing.\n    \"\"\"\n    if isinstance(kernel_sigma, int):\n        kernel_sigma = [kernel_sigma] * 3\n    elif len(kernel_sigma) != 3:\n        raise ValueError(\"kernel_sigma must be an integer or a list of three integers.\")\n\n    # Calculate the kernel size for each dimension\n    kernel_size = [3 * k for k in kernel_sigma]\n\n    # Create a 3D grid of coordinates\n    coords = [np.arange(-size // 2 + 1, size // 2 + 1) for size in kernel_size]\n    x, y, z = np.meshgrid(*coords, indexing='ij')\n\n    # Calculate the Gaussian function\n    gaussian = np.exp(-(x**2 / (2 * kernel_sigma[0]**2) +\n                        y**2 / (2 * kernel_sigma[1]**2) +\n                        z**2 / (2 * kernel_sigma[2]**2)))\n\n    # Normalize the kernel\n    gaussian /= np.sum(gaussian)\n\n    # Convert the Gaussian kernel to a TensorFlow tensor\n    gaussian_kernel = tf.convert_to_tensor(gaussian, dtype=tf.float32)\n\n    return gaussian_kernel\n\n# Example usage:\n# kernel = gaussian_filter_3d([1, 2, 3])\n# print(kernel)\n```\n\n### Explanation:\n- **Input Handling**: The function checks if `kernel_sigma` is an integer or a list of three integers. If it's an integer, it creates a list with the same value for all three dimensions.\n- **Kernel Size**: The kernel size for each dimension is calculated as `3 * k` for each `k` in `kernel_sigma`.\n- **Coordinate Grid**: A 3D grid of coordinates is created using `np.meshgrid`.\n- **Gaussian Calculation**: The Gaussian function is applied to the grid, and the result is normalized so that the sum of all elements in the kernel is 1.\n- **Tensor Conversion**: The resulting Gaussian kernel is converted to a TensorFlow tensor for use in TensorFlow operations.\n\nThis function will generate a 3D Gaussian kernel that can be used for smoothing operations in 3D data.",
    "prompt": "Create a Python function called gaussian_filter_3d that defines a 3D Gaussian filter for smoothing. The function takes in a parameter called kernel_sigma, which can be either a list of deviations for each direction or an integer for isotropic deviation. The function returns a TensorFlow tensor representing a Gaussian kernel of shape [3*k for k in kernel_sigma]. The output is the Gaussian kernel tensor for 3D smoothing.",
    "function_name": "gaussian_filter_3d",
    "ground_truth": "deepreg/model/layer_util.py",
    "test": "test/unit/test_layer_util.py::TestGaussianFilter3D",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}