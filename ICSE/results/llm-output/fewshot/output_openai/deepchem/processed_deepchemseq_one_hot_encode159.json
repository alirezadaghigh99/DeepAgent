{
    "result": "Here's a Python function `seq_one_hot_encode` that one-hot encodes a list of genomic sequences. This function takes an iterable of genetic sequences and a string of possible letters, and returns a numpy array with the specified shape.\n\n```python\nimport numpy as np\nfrom typing import Union, Iterator\nfrom Bio.SeqRecord import SeqRecord\n\ndef seq_one_hot_encode(sequences: Union[np.ndarray, Iterator[SeqRecord]], letters: str = \"ATCGN\") -> np.ndarray:\n    \"\"\"\n    One hot encodes a list of genomic sequences.\n\n    Sequences encoded have shape (N_sequences, N_letters, sequence_length, 1).\n    These sequences will be processed as images with one color channel.\n\n    Parameters\n    ----------\n    sequences: np.ndarray or Iterator[Bio.SeqRecord]\n        Iterable object of genetic sequences\n    letters: str, optional (default \"ATCGN\")\n        String with the set of possible letters in the sequences.\n\n    Raises\n    ------\n    ValueError:\n        If sequences are of different lengths.\n\n    Returns\n    -------\n    np.ndarray\n        A numpy array of shape `(N_sequences, N_letters, sequence_length, 1)`.\n    \"\"\"\n    if isinstance(sequences, np.ndarray):\n        sequences = sequences.tolist()\n    else:\n        sequences = list(sequences)\n\n    # Check if all sequences have the same length\n    sequence_lengths = [len(seq) for seq in sequences]\n    if len(set(sequence_lengths)) != 1:\n        raise ValueError(\"All sequences must have the same length.\")\n\n    sequence_length = sequence_lengths[0]\n    N_sequences = len(sequences)\n    N_letters = len(letters)\n\n    # Create a mapping from letters to indices\n    letter_to_index = {letter: idx for idx, letter in enumerate(letters)}\n\n    # Initialize the one-hot encoded array\n    one_hot_encoded = np.zeros((N_sequences, N_letters, sequence_length, 1), dtype=np.float32)\n\n    for i, seq in enumerate(sequences):\n        for j, letter in enumerate(seq):\n            if letter in letter_to_index:\n                one_hot_encoded[i, letter_to_index[letter], j, 0] = 1.0\n\n    return one_hot_encoded\n```\n\n### Explanation:\n- **Input Handling**: The function accepts either a numpy array or an iterator of `SeqRecord` objects. It converts the input to a list for easier processing.\n- **Length Check**: It ensures all sequences have the same length, raising a `ValueError` if not.\n- **One-Hot Encoding**: It initializes a zero array of the desired shape and fills it by mapping each letter in the sequence to its corresponding index in the `letters` string.\n- **Output**: The function returns a numpy array with the shape `(N_sequences, N_letters, sequence_length, 1)`, suitable for processing as images with one color channel.",
    "prompt": "Create a Python function called seq_one_hot_encode that One hot encodes list of genomic sequences.\n\n    Sequences encoded have shape (N_sequences, N_letters, sequence_length, 1).\n    These sequences will be processed as images with one color channel.\n\n    Parameters\n    ----------\n    sequences: np.ndarray or Iterator[Bio.SeqRecord]\n        Iterable object of genetic sequences\n    letters: str, optional (default \"ATCGN\")\n        String with the set of possible letters in the sequences.\n\n    Raises\n    ------\n    ValueError:\n        If sequences are of different lengths.\n\n    Returns\n    -------\n    np.ndarray\n        A numpy array of shape `(N_sequences, N_letters, sequence_length, 1)`.",
    "function_name": "seq_one_hot_encode",
    "ground_truth": "deepchem/utils/genomics_utils.py",
    "test": "deepchem/utils/test/test_genomics_utils.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Text"
}