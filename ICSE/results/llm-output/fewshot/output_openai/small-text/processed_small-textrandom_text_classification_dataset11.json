{
    "result": "To create a function that generates a random text classification dataset, we can use PyTorch and some helper libraries to simulate text data. Below is a Python function called `random_text_classification_dataset` that generates such a dataset. This function will create random sequences of integers (representing words) and assign random labels to them. It will also ensure that all specified labels are present in the dataset.\n\n```python\nimport torch\nfrom torch.utils.data import Dataset\nimport random\nfrom typing import List, Optional, Union\n\nclass PytorchTextClassificationDataset(Dataset):\n    def __init__(self, data, labels, vocab_size, multi_label, target_labels):\n        self.data = data\n        self.labels = labels\n        self.vocab_size = vocab_size\n        self.multi_label = multi_label\n        self.target_labels = target_labels\n\n    def __len__(self):\n        return len(self.data)\n\n    def __getitem__(self, idx):\n        return self.data[idx], self.labels[idx]\n\ndef random_text_classification_dataset(\n    num_samples: int,\n    max_length: int,\n    num_classes: int,\n    multi_label: bool = False,\n    vocab_size: int = 1000,\n    device: Optional[torch.device] = None,\n    target_labels: Optional[List[str]] = None,\n    dtype: torch.dtype = torch.long\n) -> PytorchTextClassificationDataset:\n    \"\"\"\n    Generate a random text classification dataset.\n\n    Args:\n        num_samples (int): Number of samples in the dataset.\n        max_length (int): Maximum length of each text sample.\n        num_classes (int): Number of classes for classification.\n        multi_label (bool): If True, each sample can have multiple labels.\n        vocab_size (int): Size of the vocabulary.\n        device (torch.device, optional): Device to store the dataset.\n        target_labels (List[str], optional): List of target labels.\n        dtype (torch.dtype): Data type for the text data.\n\n    Returns:\n        PytorchTextClassificationDataset: Generated dataset.\n    \"\"\"\n    if target_labels is None:\n        target_labels = [f\"Class_{i}\" for i in range(num_classes)]\n    else:\n        if len(target_labels) != num_classes:\n            raise ValueError(\"Length of target_labels must match num_classes.\")\n\n    # Generate random text data\n    data = [torch.randint(1, vocab_size, (random.randint(1, max_length),), dtype=dtype) for _ in range(num_samples)]\n\n    # Generate random labels\n    if multi_label:\n        labels = [torch.randint(0, 2, (num_classes,), dtype=torch.float32) for _ in range(num_samples)]\n    else:\n        labels = [torch.randint(0, num_classes, (1,), dtype=torch.long) for _ in range(num_samples)]\n\n    # Ensure all labels are present\n    if not multi_label:\n        for i in range(num_classes):\n            if i >= num_samples:\n                break\n            labels[i] = torch.tensor([i], dtype=torch.long)\n\n    # Move data to the specified device\n    if device is not None:\n        data = [d.to(device) for d in data]\n        labels = [l.to(device) for l in labels]\n\n    return PytorchTextClassificationDataset(data, labels, vocab_size, multi_label, target_labels)\n\n# Example usage\ndataset = random_text_classification_dataset(\n    num_samples=100,\n    max_length=10,\n    num_classes=5,\n    multi_label=False,\n    vocab_size=50,\n    device=torch.device('cpu'),\n    target_labels=['A', 'B', 'C', 'D', 'E']\n)\n\nprint(f\"Number of samples: {len(dataset)}\")\nprint(f\"Sample data: {dataset[0]}\")\n```\n\nThis function creates a dataset with random text sequences and labels. It ensures that all classes are represented in the dataset and can handle both single-label and multi-label classification scenarios. The dataset is returned as a custom `PytorchTextClassificationDataset` object, which can be used with PyTorch's data loading utilities.",
    "prompt": "Generate a Python function called random_text_classification_dataset that generates a random text classification dataset. The function takes in parameters such as num_samples, max_length, num_classes, multi_label, vocab_size, device, target_labels, and dtype. It returns a PytorchTextClassificationDataset object with the generated dataset, vocabulary, multi_label setting, and target labels. The function ensures that all labels occur in the dataset and handles different scenarios based on the input parameters.",
    "function_name": "random_text_classification_dataset",
    "ground_truth": "tests/utils/datasets.py",
    "test": "tests/unit/small_text/initialization/test_strategies.py::RandomInitializationStratifiedTest",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Text"
}