{
    "result": "To implement the `random_initialization_stratified` function as described, we need to handle both single-label and multi-label stratified sampling. For single-label stratified sampling, we can use a helper function like `stratified_sampling`. For multi-label stratified sampling, we will use a function called `multilabel_stratified_subsets_sampling` when the `multilabel_strategy` is 'labelsets'. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef stratified_sampling(y, n_samples):\n    \"\"\"\n    Perform stratified sampling for single-label data.\n    \n    Args:\n        y (np.ndarray[int]): Array of class labels.\n        n_samples (int): Number of samples to draw.\n    \n    Returns:\n        np.ndarray[int]: Indices of the sampled data.\n    \"\"\"\n    unique_classes, class_counts = np.unique(y, return_counts=True)\n    class_ratios = class_counts / class_counts.sum()\n    samples_per_class = (class_ratios * n_samples).astype(int)\n    \n    indices = []\n    for cls, n_cls_samples in zip(unique_classes, samples_per_class):\n        cls_indices = np.where(y == cls)[0]\n        sampled_indices = np.random.choice(cls_indices, n_cls_samples, replace=False)\n        indices.extend(sampled_indices)\n    \n    return np.array(indices)\n\ndef multilabel_stratified_subsets_sampling(y, n_samples):\n    \"\"\"\n    Perform stratified sampling for multi-label data using 'labelsets' strategy.\n    \n    Args:\n        y (csr_matrix): Sparse matrix of class labels.\n        n_samples (int): Number of samples to draw.\n    \n    Returns:\n        np.ndarray[int]: Indices of the sampled data.\n    \"\"\"\n    # This is a placeholder for the actual implementation of the multilabel stratified sampling.\n    # You would need to implement the logic for 'labelsets' strategy here.\n    raise NotImplementedError(\"Multilabel stratified sampling is not implemented.\")\n\ndef random_initialization_stratified(y, n_samples=10, multilabel_strategy='labelsets'):\n    \"\"\"\n    Randomly draw a subset stratified by class labels.\n    \n    Args:\n        y (np.ndarray[int] or csr_matrix): Labels for stratification.\n        n_samples (int): Number of samples to draw.\n        multilabel_strategy (str): Strategy for multi-label data. Default is 'labelsets'.\n    \n    Returns:\n        np.ndarray[int]: Indices relative to y.\n    \n    Raises:\n        ValueError: If an invalid multilabel_strategy is provided.\n    \"\"\"\n    if isinstance(y, csr_matrix):\n        if multilabel_strategy == 'labelsets':\n            return multilabel_stratified_subsets_sampling(y, n_samples)\n        else:\n            raise ValueError(f'Invalid multilabel_strategy: {multilabel_strategy}')\n    else:\n        return stratified_sampling(y, n_samples)\n\n# Example usage:\n# y = np.array([0, 1, 0, 1, 2, 2, 1, 0, 2, 1])\n# indices = random_initialization_stratified(y, n_samples=5)\n# print(indices)\n```\n\n### Explanation:\n- **Single-label Stratified Sampling**: The `stratified_sampling` function calculates the number of samples to draw from each class based on their proportions in the dataset. It then randomly selects indices for each class.\n- **Multi-label Stratified Sampling**: The `multilabel_stratified_subsets_sampling` function is a placeholder for the actual implementation. You would need to implement the logic for the 'labelsets' strategy, which typically involves more complex handling of label combinations.\n- **Error Handling**: If an invalid `multilabel_strategy` is provided, a `ValueError` is raised.\n- **Default Parameters**: The function defaults to `n_samples=10` and `multilabel_strategy='labelsets'`.\n\nThis implementation provides a framework for handling both single-label and multi-label stratified sampling, with room to expand the multi-label functionality as needed.",
    "prompt": "Generate a Python function called random_initialization_stratified that randomly draws a subset stratified by class labels. The function takes in parameters y, which is an np.ndarray[int] or csr_matrix representing the labels to be used for stratification, n_samples which is an integer representing the number of samples to draw, and multilabel_strategy which is a string representing the multi-label strategy to be used in case of a multi-label labeling (default is 'labelsets'). \n\nThe function returns indices, which is an np.ndarray[int] representing the indices relative to y. If y is of type csr_matrix, the function uses the multilabel_strategy 'labelsets' to perform multilabel stratified subsets sampling using the function multilabel_stratified_subsets_sampling. If the multilabel_strategy is not 'labelsets', a ValueError is raised : ValueError(f'Invalid multilabel_strategy: {multilabel_strategy}'). If y is not a csr_matrix, the function performs stratified sampling using the function stratified_sampling. for the input the diefault is n_samples=10, multilabel_strategy='labelsets'",
    "function_name": "random_initialization_stratified",
    "ground_truth": "small_text/initialization/strategies.py",
    "test": "tests/unit/small_text/initialization/test_strategies.py::RandomInitializationStratifiedTest",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Text"
}