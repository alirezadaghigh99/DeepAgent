{
    "result": "To create the function `_calculate_true_positives_false_positives`, we need to follow the description provided. The function will calculate true positives (TP), false positives (FP), and optionally false negatives (FN) for object detection tasks using predicted and ground truth bounding boxes. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef _calculate_true_positives_false_positives(pred_bboxes, lab_bboxes, iou_threshold=0.5, return_false_negative=False):\n    \"\"\"\n    Calculate true positives (TP) and false positives (FP) for object detection tasks.\n\n    Args:\n        pred_bboxes (np.ndarray): Predicted bounding boxes, shape (N, 4).\n        lab_bboxes (np.ndarray): Ground truth bounding boxes, shape (M, 4).\n        iou_threshold (float): IoU threshold to determine true positives. Defaults to 0.5.\n        return_false_negative (bool): Whether to return false negatives. Defaults to False.\n\n    Returns:\n        tp (np.ndarray): Array of true positives.\n        fp (np.ndarray): Array of false positives.\n        fn (np.ndarray, optional): Array of false negatives, if return_false_negative is True.\n    \"\"\"\n    def iou(box1, box2):\n        \"\"\"Calculate Intersection over Union (IoU) between two bounding boxes.\"\"\"\n        x1 = max(box1[0], box2[0])\n        y1 = max(box1[1], box2[1])\n        x2 = min(box1[2], box2[2])\n        y2 = min(box1[3], box2[3])\n\n        inter_area = max(0, x2 - x1) * max(0, y2 - y1)\n        box1_area = (box1[2] - box1[0]) * (box1[3] - box1[1])\n        box2_area = (box2[2] - box2[0]) * (box2[3] - box2[1])\n\n        union_area = box1_area + box2_area - inter_area\n        return inter_area / union_area if union_area != 0 else 0\n\n    num_preds = pred_bboxes.shape[0]\n    num_labels = lab_bboxes.shape[0]\n\n    tp = np.zeros(num_preds, dtype=bool)\n    fp = np.zeros(num_preds, dtype=bool)\n    fn = np.zeros(num_labels, dtype=bool) if return_false_negative else None\n\n    if num_labels == 0:\n        # If no ground truth boxes, all predictions are false positives\n        fp[:] = True\n    else:\n        matched_labels = np.zeros(num_labels, dtype=bool)\n\n        for i, pred_box in enumerate(pred_bboxes):\n            ious = np.array([iou(pred_box, lab_box) for lab_box in lab_bboxes])\n            max_iou_idx = np.argmax(ious)\n            max_iou = ious[max_iou_idx]\n\n            if max_iou >= iou_threshold and not matched_labels[max_iou_idx]:\n                tp[i] = True\n                matched_labels[max_iou_idx] = True\n            else:\n                fp[i] = True\n\n        if return_false_negative:\n            fn = ~matched_labels\n\n    if return_false_negative:\n        return tp, fp, fn\n    else:\n        return tp, fp\n```\n\n### Explanation:\n- **IoU Calculation**: The function `iou` calculates the Intersection over Union between two bounding boxes.\n- **True Positives and False Positives**: For each predicted bounding box, the function calculates the IoU with all ground truth boxes. If the maximum IoU is above the threshold and the ground truth box has not been matched yet, it is considered a true positive. Otherwise, it is a false positive.\n- **False Negatives**: If `return_false_negative` is `True`, the function also calculates false negatives by checking which ground truth boxes have not been matched.\n- **Return Values**: The function returns arrays of true positives, false positives, and optionally false negatives.",
    "prompt": "Create a Python function called _calculate_true_positives_false_positives that calculates true positives (TP) and false positives (FP) for object detection tasks. The function takes in predicted bounding boxes (pred_bboxes) and ground truth bounding boxes (lab_bboxes) as numpy arrays, along with an optional Intersection over Union (IoU) threshold (iou_threshold) set to 0.5 by default. Additionally, there is a boolean parameter return_false_negative which, if set to True, will also return an array of False negatives.\n\nThe function initializes arrays for true positives and false positives based on the shapes of the input bounding boxes. It then calculates the IoU values between the predicted and ground truth bounding boxes and determines the true positives and false positives based on the IoU threshold. If there are no ground truth bounding boxes, all predictions are considered false positives.\n\nIf return_false_negative is True, the function also calculates false negatives and returns them along with true positives and false positives. Otherwise, it returns only true positives and false positives.\n\nOverall, the function provides a comprehensive evaluation of the detection performance by calculating true positives, false positives, and optionally false negatives.",
    "function_name": "_calculate_true_positives_false_positives",
    "ground_truth": "cleanlab/object_detection/filter.py",
    "test": "tests/test_object_detection.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Detection",
    "data": "Image"
}