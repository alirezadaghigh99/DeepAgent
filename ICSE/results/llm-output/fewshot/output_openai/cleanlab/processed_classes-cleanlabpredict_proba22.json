{
    "result": "To implement the `predict_proba` function for the `CleanLearning` class, you need to ensure that it correctly interfaces with the wrapped classifier `clf` to predict class probabilities. Here's how you can implement this function:\n\n```python\nclass CleanLearning(BaseEstimator):\n    def __init__(\n        self,\n        clf=None,\n        *,\n        seed=None,\n        cv_n_folds=5,\n        converge_latent_estimates=False,\n        pulearning=None,\n        find_label_issues_kwargs={},\n        label_quality_scores_kwargs={},\n        verbose=False,\n        low_memory=False,\n    ):\n        self.clf = clf\n        self.seed = seed\n        self.cv_n_folds = cv_n_folds\n        self.converge_latent_estimates = converge_latent_estimates\n        self.pulearning = pulearning\n        self.find_label_issues_kwargs = find_label_issues_kwargs\n        self.label_quality_scores_kwargs = label_quality_scores_kwargs\n        self.verbose = verbose\n        self.label_issues_df = None\n        self.label_issues_mask = None\n        self.sample_weight = None\n        self.confident_joint = None\n        self.py = None\n        self.ps = None\n        self.num_classes = None\n        self.noise_matrix = None\n        self.inverse_noise_matrix = None\n        self.clf_kwargs = None\n        self.clf_final_kwargs = None\n        self.low_memory = low_memory\n\n    def predict_proba(self, X, *args, **kwargs):\n        \"\"\"\n        Predict class probabilities using the wrapped classifier `clf`.\n\n        Parameters\n        ----------\n        X : np.ndarray or DatasetLike\n            Test data in the same format expected by your wrapped classifier.\n\n        Returns\n        -------\n        pred_probs : np.ndarray\n            ``(N x K)`` array of predicted class probabilities, one row for each test example.\n        \"\"\"\n        # Ensure X is two-dimensional if the default classifier is used\n        if self.clf is None:\n            raise ValueError(\"No classifier has been set for CleanLearning.\")\n        \n        if isinstance(X, np.ndarray) and X.ndim != 2:\n            raise ValueError(\"Input data X must be two-dimensional.\")\n\n        # Call clf.predict_proba with the processed arguments\n        pred_probs = self.clf.predict_proba(X, *args, **kwargs)\n        \n        return pred_probs\n```\n\n### Key Points:\n1. **Variable Arguments**: The function accepts `*args` and `**kwargs` to allow flexibility in passing additional arguments to `clf.predict_proba`.\n\n2. **Input Validation**: If the input `X` is a NumPy array, the function checks that it is two-dimensional. This ensures compatibility with most classifiers that expect 2D input.\n\n3. **Classifier Check**: The function raises an error if no classifier (`clf`) is set, as it cannot predict probabilities without a model.\n\n4. **Calling `predict_proba`**: The function calls `clf.predict_proba` with the provided arguments and returns the predicted probabilities.\n\nThis implementation assumes that `clf` is a scikit-learn-like classifier with a `predict_proba` method. Adjustments may be needed if `clf` has a different interface.",
    "prompt": "Generate a Python function `predict_proba` for the class `CleanLearning` that predicts class probabilities using the wrapped classifier `clf`. The function should:\nPredict class probabilities ``P(true label=k)`` using your wrapped classifier `clf`.\n        Works just like ``clf.predict_proba()``.\n\n        Parameters\n        ----------\n        X : np.ndarray or DatasetLike\n          Test data in the same format expected by your wrapped classifier.\n\n        Returns\n        -------\n        pred_probs : np.ndarray\n          ``(N x K)`` array of predicted class probabilities, one row for each test example.\n1. Accept variable arguments and keyword arguments.\n2. If the default classifier is used and input data `X` is provided, ensure `X` is two-dimensional.\n3. Call `clf.predict_proba` with the processed arguments and return the predicted class probabilities.\n\n```python\nclass CleanLearning(BaseEstimator):\n    def __init__(\n        self,\n        clf=None,\n        *,\n        seed=None,\n        cv_n_folds=5,\n        converge_latent_estimates=False,\n        pulearning=None,\n        find_label_issues_kwargs={},\n        label_quality_scores_kwargs={},\n        verbose=False,\n        low_memory=False,\n    ):\n        self.clf = clf\n        self.seed = seed\n        self.cv_n_folds = cv_n_folds\n        self.converge_latent_estimates = converge_latent_estimates\n        self.pulearning = pulearning\n        self.find_label_issues_kwargs = find_label_issues_kwargs\n        self.label_quality_scores_kwargs = label_quality_scores_kwargs\n        self.verbose = verbose\n        self.label_issues_df = None\n        self.label_issues_mask = None\n        self.sample_weight = None\n        self.confident_joint = None\n        self.py = None\n        self.ps = None\n        self.num_classes = None\n        self.noise_matrix = None\n        self.inverse_noise_matrix = None\n        self.clf_kwargs = None\n        self.clf_final_kwargs = None\n        self.low_memory = low_memory\n```",
    "function_name": "predict_proba",
    "ground_truth": "cleanlab/classification.py",
    "test": "tests/test_classification.py",
    "class": "CleanLearning",
    "stage": "",
    "task": "Classification",
    "data": "Inference"
}