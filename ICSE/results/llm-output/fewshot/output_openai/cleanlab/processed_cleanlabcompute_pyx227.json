{
    "result": "To implement the function `compute_pyx`, which calculates the posterior probabilities \\( P(\\text{true\\_label}=k|x) \\) from the predicted probabilities \\( P(\\text{label}=k|x) \\), the noise matrix, and the inverse noise matrix, you can follow these steps. The function will use matrix operations to transform the predicted probabilities using the noise matrices. Here's how you can write this function:\n\n```python\nimport numpy as np\n\ndef compute_pyx(pred_probs, noise_matrix, inverse_noise_matrix=None):\n    \"\"\"\n    Compute pyx := P(true_label=k|x) from pred_probs := P(label=k|x), noise_matrix, and inverse_noise_matrix.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        P(label=k|x) is a (N x K) matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example x and contains the model-predicted\n        probabilities that x belongs to each possible class.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape (K, K)) of the form P(label=k_s|true_label=k_y).\n\n    inverse_noise_matrix : np.ndarray, optional\n        A conditional probability matrix (of shape (K, K)) of the form P(true_label=k_y|label=k_s).\n        If None, it will be computed from the noise_matrix.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        P(true_label=k|x) is a (N, K) matrix of model-predicted probabilities.\n    \"\"\"\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )\n\n    # Ensure noise_matrix is square and matches the number of classes\n    K = pred_probs.shape[1]\n    if noise_matrix.shape != (K, K):\n        raise ValueError(\n            \"Input parameter np.ndarray 'noise_matrix' has shape \"\n            + str(np.shape(noise_matrix))\n            + \", but shape should be (K, K)\"\n        )\n\n    # Compute inverse_noise_matrix if not provided\n    if inverse_noise_matrix is None:\n        inverse_noise_matrix = np.linalg.pinv(noise_matrix)\n\n    # Ensure inverse_noise_matrix is square and matches the number of classes\n    if inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\n            \"Input parameter np.ndarray 'inverse_noise_matrix' has shape \"\n            + str(np.shape(inverse_noise_matrix))\n            + \", but shape should be (K, K)\"\n        )\n\n    # Compute P(true_label=k|x) using matrix multiplication\n    pyx = np.dot(pred_probs, inverse_noise_matrix)\n\n    return pyx\n```\n\n### Explanation:\n- **Input Validation**: The function first checks that `pred_probs` is a 2D array with shape \\((N, K)\\) and that `noise_matrix` and `inverse_noise_matrix` (if provided) are square matrices with shape \\((K, K)\\).\n- **Inverse Noise Matrix Calculation**: If `inverse_noise_matrix` is not provided, it is computed using the pseudo-inverse of the `noise_matrix`.\n- **Matrix Multiplication**: The core computation involves multiplying the predicted probabilities by the inverse noise matrix to obtain the posterior probabilities.\n\nThis function assumes that the noise matrices are well-formed and that the inverse noise matrix can be computed accurately.",
    "prompt": "\"Write a python function compute_pyx Compute ``pyx := P(true_label=k|x)`` from ``pred_probs := P(label=k|x)``, `noise_matrix` and\n    `inverse_noise_matrix`.\n\n    This method is ROBUST - meaning it works well even when the\n    noise matrices are estimated poorly by only using the diagonals of the\n    matrices which tend to be easy to estimate correctly.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        ``P(label=k|x)`` is a ``(N x K)`` matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of `noise_matrix` sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``)  of the form ``P(true_label=k_y|label=k_s)`` representing\n        the estimated fraction observed examples in each class `k_s`, that are\n        mislabeled examples from every other class `k_y`. If None, the\n        inverse_noise_matrix will be computed from `pred_probs` and `labels`.\n        Assumes columns of `inverse_noise_matrix` sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        ``P(true_label=k|x)`` is a  ``(N, K)`` matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )",
    "function_name": "compute_pyx",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}