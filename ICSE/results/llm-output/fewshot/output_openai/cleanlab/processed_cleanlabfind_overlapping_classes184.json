{
    "result": "To implement the `find_overlapping_classes` function as described, we need to handle different input scenarios and compute the overlapping classes based on the provided data. Here's a possible implementation:\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom typing import Optional, Iterable, Union\n\ndef find_overlapping_classes(\n    labels: Optional[Union[np.ndarray, list]] = None,\n    pred_probs: Optional[np.ndarray] = None,\n    asymmetric: bool = False,\n    class_names: Optional[Iterable[str]] = None,\n    num_examples: Optional[int] = None,\n    joint: Optional[np.ndarray] = None,\n    confident_joint: Optional[np.ndarray] = None\n) -> pd.DataFrame:\n    \"\"\"\n    Returns the pairs of classes that are often mislabeled as one another.\n\n    Parameters\n    ----------\n    labels : np.ndarray or list, optional\n        An array_like of noisy labels for the classification dataset.\n    pred_probs : np.ndarray, optional\n        An array of shape (N, K) of model-predicted probabilities.\n    asymmetric : bool, optional\n        If True, returns separate estimates for both pairs (class1, class2) and (class2, class1).\n    class_names : Iterable[str], optional\n        A list or other iterable of the string class names.\n    num_examples : int or None, optional\n        The number of examples in the dataset.\n    joint : np.ndarray, optional\n        An array of shape (K, K) representing the estimated joint distribution.\n    confident_joint : np.ndarray, optional\n        An array of shape (K, K) representing the confident joint.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\".\n    \"\"\"\n    if joint is not None and num_examples is None:\n        raise ValueError(\"If 'joint' is provided, 'num_examples' must also be provided.\")\n\n    if confident_joint is None:\n        if labels is None or pred_probs is None:\n            raise ValueError(\"Either 'confident_joint' or both 'labels' and 'pred_probs' must be provided.\")\n        # Compute the confident joint from labels and pred_probs\n        confident_joint = compute_confident_joint(labels, pred_probs)\n\n    if joint is None:\n        joint = confident_joint / confident_joint.sum()\n\n    if num_examples is None:\n        num_examples = int(confident_joint.sum())\n\n    overlapping_data = []\n    K = joint.shape[0]\n\n    for i in range(K):\n        for j in range(i + 1, K):\n            num_overlap = confident_joint[i, j] + confident_joint[j, i]\n            joint_prob = num_overlap / num_examples\n\n            if asymmetric:\n                overlapping_data.append((i, j, confident_joint[i, j], confident_joint[i, j] / num_examples))\n                overlapping_data.append((j, i, confident_joint[j, i], confident_joint[j, i] / num_examples))\n            else:\n                overlapping_data.append((i, j, num_overlap, joint_prob))\n\n    df = pd.DataFrame(overlapping_data, columns=[\"Class Index A\", \"Class Index B\", \"Num Overlapping Examples\", \"Joint Probability\"])\n    df = df.sort_values(by=\"Joint Probability\", ascending=False).reset_index(drop=True)\n\n    if class_names is not None:\n        df[\"Class Name A\"] = df[\"Class Index A\"].apply(lambda x: class_names[x])\n        df[\"Class Name B\"] = df[\"Class Index B\"].apply(lambda x: class_names[x])\n\n    return df\n\ndef compute_confident_joint(labels, pred_probs):\n    # Placeholder for the actual implementation of confident joint computation\n    # This function should compute the confident joint matrix from labels and pred_probs\n    # For now, we'll return a dummy matrix for demonstration purposes\n    K = pred_probs.shape[1]\n    return np.random.randint(0, 10, size=(K, K))\n```\n\n### Explanation:\n- **Inputs**: The function accepts various inputs, including `labels`, `pred_probs`, `joint`, `confident_joint`, and others. It checks for the necessary conditions and raises errors if the required inputs are not provided.\n- **Confident Joint**: If `confident_joint` is not provided, it is computed from `labels` and `pred_probs` using a placeholder function `compute_confident_joint`.\n- **Joint Matrix**: If `joint` is not provided, it is derived from the `confident_joint`.\n- **Overlapping Data**: The function iterates over class pairs to compute the number of overlapping examples and joint probability, considering whether the analysis is asymmetric.\n- **Output**: The results are stored in a Pandas DataFrame, which is sorted by joint probability in descending order. If `class_names` are provided, they are added to the DataFrame for better interpretability.\n\nThis implementation provides a basic structure and can be further refined based on specific requirements and the actual computation of the confident joint.",
    "prompt": "Generate a Python function called find_overlapping_classes that rReturns the pairs of classes that are often mislabeled as one another.\n    Consider merging the top pairs of classes returned by this method each into a single class.\n    If the dataset is labeled by human annotators, consider clearly defining the\n    difference between the classes prior to having annotators label the data.\n    This method provides two scores in the Pandas DataFrame that is returned:\n    * **Num Overlapping Examples**: The number of examples where the two classes overlap\n    * **Joint Probability**: `(num overlapping examples / total number of examples in the dataset`).\n    This method works by providing any one (and only one) of the following inputs:\n    1. ``labels`` and ``pred_probs``, or\n    2. ``joint`` and ``num_examples``, or\n    3. ``confident_joint``\n      Parameters\n    ----------\n    labels : np.ndarray or list, optional\n      An array_like (of length N) of noisy labels for the classification dataset, i.e. some labels may be erroneous.\n      Elements must be integers in the set 0, 1, ..., K-1, where K is the number of classes.\n      All the classes (0, 1, ..., and K-1) should be present in ``labels``, such that\n      ``len(set(labels)) == pred_probs.shape[1]`` for standard multi-class classification with single-labeled data (e.g. ``labels =  [1,0,2,1,1,0...]``).\n      For multi-label classification where each example can belong to multiple classes (e.g. ``labels = [[1,2],[1],[0],[],...]``),\n      your labels should instead satisfy: ``len(set(k for l in labels for k in l)) == pred_probs.shape[1])``.\n\n    pred_probs : np.ndarray, optional\n      An array of shape ``(N, K)`` of model-predicted probabilities,\n      ``P(label=k|x)``. Each row of this matrix corresponds\n      to an example `x` and contains the model-predicted probabilities that\n      `x` belongs to each possible class, for each of the K classes. The\n      columns must be ordered such that these probabilities correspond to\n      class 0, 1, ..., K-1. `pred_probs` should have been computed using 3 (or\n      higher) fold cross-validation.\n\n    asymmetric : bool, optional\n      If ``asymmetric=True``, returns separate estimates for both pairs (class1, class2) and (class2, class1). Use this\n      for finding \"is a\" relationships where for example \"class1 is a class2\".\n      In this case, num overlapping examples counts the number of examples that have been labeled as class1 which should actually have been labeled as class2.\n      If ``asymmetric=False``, the pair (class1, class2) will only be returned once with an arbitrary order.\n      In this case, their estimated score is the sum: ``score(class1, class2) + score(class2, class1))``.\n\n    class_names : Iterable[str]\n        A list or other iterable of the string class names. The list should be in the order that\n        matches the class indices. So if class 0 is 'dog' and class 1 is 'cat', then\n        ``class_names = ['dog', 'cat']``.\n\n    num_examples : int or None, optional\n        The number of examples in the dataset, i.e. ``len(labels)``. You only need to provide this if\n        you use this function with the joint, e.g. ``find_overlapping_classes(joint=joint)``, otherwise\n        this is automatically computed via ``sum(confident_joint)`` or ``len(labels)``.\n\n    joint : np.ndarray, optional\n        An array of shape ``(K, K)``, where K is the number of classes,\n        representing the estimated joint distribution of the noisy labels and\n        true labels. The sum of all entries in this matrix must be 1 (valid\n        probability distribution). Each entry in the matrix captures the co-occurence joint\n        probability of a true label and a noisy label, i.e. ``p(noisy_label=i, true_label=j)``.\n        **Important**. If you input the joint, you must also input `num_examples`.\n\n    confident_joint : np.ndarray, optional\n      An array of shape ``(K, K)`` representing the confident joint, the matrix used for identifying label issues, which\n      estimates a confident subset of the joint distribution of the noisy and true labels, ``P_{noisy label, true label}``.\n      Entry ``(j, k)`` in the matrix is the number of examples confidently counted into the pair of ``(noisy label=j, true label=k)`` classes.\n      The `confident_joint` can be computed using :py:func:`count.compute_confident_joint <cleanlab.count.compute_confident_joint>`.\n      If not provided, it is computed from the given (noisy) `labels` and `pred_probs`.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\" and a description of each below.\n        Each row corresponds to a pair of classes.\n\n        * *Class Index A*: the index of a class in 0, 1, ..., K-1.\n        * *Class Index B*: the index of a different class (from Class A) in 0, 1, ..., K-1.\n        * *Num Overlapping Examples*: estimated number of labels overlapping between the two classes.\n        * *Joint Probability*: the *Num Overlapping Examples* divided by the number of examples in the dataset.\n\n        By default, the DataFrame is ordered by \"Joint Probability\" descending.",
    "function_name": "find_overlapping_classes",
    "ground_truth": "cleanlab/dataset.py",
    "test": "tests/test_dataset.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}