{
    "result": "Here's a Python function `compute_ps_py_inv_noise_matrix` that computes `ps`, `py`, and the inverse noise matrix based on the given parameters:\n\n```python\nimport numpy as np\n\ndef compute_ps_py_inv_noise_matrix(labels: np.ndarray, noise_matrix: np.ndarray):\n    \"\"\"\n    Compute ps := P(labels=k), py := P(true_labels=k), and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n        A discrete vector of noisy labels, i.e., some labels may be erroneous.\n        *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.\n\n    Returns\n    -------\n    ps : np.ndarray\n        The probability distribution of the noisy labels.\n\n    py : np.ndarray\n        The probability distribution of the true labels.\n\n    inv_noise_matrix : np.ndarray\n        The inverse of the noise matrix.\n    \"\"\"\n    # Number of classes\n    K = noise_matrix.shape[0]\n\n    # Compute ps: the probability distribution of the noisy labels\n    ps = np.bincount(labels, minlength=K) / len(labels)\n\n    # Compute py: the probability distribution of the true labels\n    # py is obtained by solving the linear system: noise_matrix @ py = ps\n    py = np.linalg.solve(noise_matrix, ps)\n\n    # Compute the inverse noise matrix\n    inv_noise_matrix = np.linalg.inv(noise_matrix)\n\n    return ps, py, inv_noise_matrix\n```\n\n### Explanation:\n- **`ps`**: This is calculated as the normalized histogram of the noisy labels, giving the probability distribution of the observed labels.\n- **`py`**: This is derived by solving the linear system `noise_matrix @ py = ps`, which gives the probability distribution of the true labels.\n- **`inv_noise_matrix`**: This is simply the inverse of the given noise matrix, assuming it is invertible. This matrix can be used to map the observed label distribution back to the true label distribution.",
    "prompt": "Generate a Python function called compute_ps_py_inv_noise_matrix that Compute ``ps := P(labels=k), py := P(true_labels=k)``, and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n          A discrete vector of noisy labels, i.e. some labels may be erroneous.\n          *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.",
    "function_name": "compute_ps_py_inv_noise_matrix",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}