{
    "result": "To create a Python function `normalized_mse` that computes the normalized mean square error (NMSE) between two lists of NumPy arrays, `ref_outputs` and `approx_outputs`, you can follow the structure and style of the examples provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef normalized_mse(ref_outputs, approx_outputs):\n    \"\"\"\n    Compute the normalized mean square error (NMSE) between two lists of NumPy arrays.\n\n    The NMSE is defined as the mean square error (MSE) between the reference and approximate outputs,\n    normalized by the MSE between the reference output and zero.\n\n    Args:\n        ref_outputs (List[np.ndarray]): List of reference output arrays.\n        approx_outputs (List[np.ndarray]): List of approximate output arrays.\n\n    Returns:\n        float: The average NMSE across all pairs of arrays.\n    \"\"\"\n    if len(ref_outputs) != len(approx_outputs):\n        raise ValueError(\"The length of ref_outputs and approx_outputs must be the same.\")\n\n    total_nmse = 0.0\n    num_pairs = len(ref_outputs)\n\n    for ref, approx in zip(ref_outputs, approx_outputs):\n        if ref.shape != approx.shape:\n            raise ValueError(\"Shapes of reference and approximate outputs must match.\")\n\n        mse = np.mean((ref - approx) ** 2)\n        mse_ref_zero = np.mean(ref ** 2)\n\n        if mse_ref_zero == 0:\n            raise ValueError(\"MSE between reference output and zero is zero, cannot normalize.\")\n\n        nmse = mse / mse_ref_zero\n        total_nmse += nmse\n\n    average_nmse = total_nmse / num_pairs\n    return average_nmse\n```\n\n### Explanation:\n- **Input Validation**: The function first checks if the lengths of `ref_outputs` and `approx_outputs` are the same. It also checks if the shapes of corresponding arrays match.\n- **NMSE Calculation**: For each pair of arrays, it calculates the mean square error (MSE) between the reference and approximate outputs. It also calculates the MSE between the reference output and zero.\n- **Normalization**: The NMSE is computed by dividing the MSE by the MSE between the reference output and zero.\n- **Average NMSE**: The function accumulates the NMSE for each pair and returns the average NMSE across all pairs.\n\nThis function assumes that the inputs are valid NumPy arrays and that the reference outputs are not all zeros, as this would make normalization impossible.",
    "prompt": "Create a Python function `normalized_mse` that computes the normalized mean square error (NMSE) between two lists of NumPy arrays, `ref_outputs` and `approx_outputs`. The NMSE is defined as the mean square error (MSE) between the reference and approximate outputs, normalized by the MSE between the reference output and zero. The function iterates over corresponding elements in `ref_outputs` and `approx_outputs`, computes the NMSE for each pair, and then returns the average NMSE across all pairs as a single float value.",
    "function_name": "normalized_mse",
    "ground_truth": "nncf/quantization/algorithms/accuracy_control/rank_functions.py",
    "test": "tests/common/accuracy_control/test_ranking.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Regression",
    "data": ""
}