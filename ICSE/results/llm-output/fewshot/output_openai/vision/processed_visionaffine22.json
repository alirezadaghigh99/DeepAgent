{
    "result": "Certainly! Below is a Python function named `affine` that applies an affine transformation to an image while keeping the image center invariant. This function can handle both PIL Images and Tensors, and it includes parameters for rotation, translation, scaling, shearing, interpolation, fill, and an optional center of rotation.\n\n```python\nimport torch\nfrom torchvision.transforms import functional as F\nfrom PIL import Image\nfrom typing import Optional, Tuple, Union\n\ndef affine(\n    img: Union[Image.Image, torch.Tensor],\n    angle: float,\n    translate: Tuple[int, int],\n    scale: float,\n    shear: Tuple[float, float],\n    interpolation: str = 'bilinear',\n    fill: Optional[Union[int, Tuple[int, int, int]]] = None,\n    center: Optional[Tuple[int, int]] = None\n) -> Union[Image.Image, torch.Tensor]:\n    \"\"\"\n    Apply an affine transformation to an image while keeping the image center invariant.\n\n    Args:\n        img (PIL Image or Tensor): Image to be transformed.\n        angle (float): Rotation angle in degrees.\n        translate (tuple of int): Horizontal and vertical translations.\n        scale (float): Overall scale.\n        shear (tuple of float): Shear angle values (shear_x, shear_y).\n        interpolation (str): Interpolation mode ('nearest', 'bilinear', etc.).\n        fill (int or tuple of int, optional): Pixel fill value for areas outside the transformed image.\n        center (tuple of int, optional): Optional center of rotation. Defaults to the center of the image.\n\n    Returns:\n        Transformed image as a PIL Image or Tensor.\n    \"\"\"\n    if isinstance(img, torch.Tensor):\n        # Convert Tensor to PIL Image for transformation\n        img = F.to_pil_image(img)\n\n    # Get image size\n    width, height = img.size\n\n    # Default center is the center of the image\n    if center is None:\n        center = (width * 0.5, height * 0.5)\n\n    # Apply affine transformation\n    transformed_img = F.affine(\n        img,\n        angle=angle,\n        translate=translate,\n        scale=scale,\n        shear=shear,\n        interpolation=interpolation,\n        fill=fill,\n        center=center\n    )\n\n    if isinstance(img, torch.Tensor):\n        # Convert back to Tensor if the input was a Tensor\n        transformed_img = F.to_tensor(transformed_img)\n\n    return transformed_img\n```\n\n### Key Points:\n- **Input Types**: The function can handle both PIL Images and Tensors. If the input is a Tensor, it is converted to a PIL Image for the transformation and then converted back to a Tensor.\n- **Parameters**:\n  - `angle`: Specifies the rotation angle in degrees.\n  - `translate`: A tuple specifying horizontal and vertical translations.\n  - `scale`: A float specifying the overall scaling factor.\n  - `shear`: A tuple specifying shear angles in the x and y directions.\n  - `interpolation`: Specifies the interpolation mode (e.g., 'nearest', 'bilinear').\n  - `fill`: Specifies the pixel fill value for areas outside the transformed image.\n  - `center`: An optional parameter to specify the center of rotation. If not provided, the center of the image is used.\n- **Output**: The function returns the transformed image, maintaining the input type (PIL Image or Tensor).",
    "prompt": "Create a Python function called affine that applies an affine transformation on an image while keeping the image center invariant. The function takes in parameters such as img (PIL Image or Tensor), angle (rotation angle in degrees), translate (horizontal and vertical translations), scale (overall scale), shear (shear angle values), interpolation (desired interpolation mode), fill (pixel fill value for areas outside the transformed image), and center (optional center of rotation). The function returns the transformed image as a PIL Image or Tensor.",
    "function_name": "affine",
    "ground_truth": "torchvision/transforms/_functional_pil.py",
    "test": "test/test_transforms_tensor.py::test_random_affine_shear",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}