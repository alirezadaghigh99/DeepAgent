{
    "result": "To create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format, you can use the `PIL` library to handle image encoding. The function will accept images in CHW layout and a quality parameter between 1 and 100. Here's how you can implement this function:\n\n```python\nimport torch\nfrom PIL import Image\nimport io\nfrom typing import Union, List\n\ndef encode_jpeg(\n    images: Union[torch.Tensor, List[torch.Tensor]],\n    quality: int\n) -> Union[torch.Tensor, List[torch.Tensor]]:\n    \"\"\"\n    Encodes an input tensor or list of tensors representing images into JPEG format.\n\n    Args:\n        images (Union[torch.Tensor, List[torch.Tensor]]): Input image(s) in CHW layout.\n        quality (int): JPEG quality parameter between 1 and 100.\n\n    Returns:\n        Union[torch.Tensor, List[torch.Tensor]]: Tensor or list of tensors containing the raw bytes of the JPEG file(s).\n\n    Raises:\n        ValueError: If quality is not between 1 and 100 or if an empty list is passed as input.\n    \"\"\"\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n\n    if isinstance(images, list) and len(images) == 0:\n        raise ValueError(\"Input list of images is empty.\")\n\n    def encode_single_image(image: torch.Tensor) -> torch.Tensor:\n        if image.ndim != 3 or image.size(0) not in {1, 3}:\n            raise ValueError(\"Each image must be a 3D tensor with 1 or 3 channels in CHW layout.\")\n\n        # Convert single-channel images to 3-channel by repeating the channel\n        if image.size(0) == 1:\n            image = image.repeat(3, 1, 1)\n\n        # Convert the tensor to a PIL Image\n        image = image.permute(1, 2, 0).numpy()  # Convert to HWC layout\n        pil_image = Image.fromarray((image * 255).astype('uint8'))\n\n        # Encode the image to JPEG\n        buffer = io.BytesIO()\n        pil_image.save(buffer, format='JPEG', quality=quality)\n        jpeg_bytes = buffer.getvalue()\n\n        # Convert the bytes to a tensor\n        return torch.tensor(list(jpeg_bytes), dtype=torch.uint8)\n\n    if isinstance(images, torch.Tensor):\n        return encode_single_image(images)\n    else:\n        return [encode_single_image(img) for img in images]\n\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the quality is between 1 and 100 and raises a `ValueError` if not. It also checks if the input list is empty.\n- **Image Conversion**: Each image is converted from a CHW tensor to a PIL Image. If the image is single-channel, it is repeated to create a 3-channel image.\n- **JPEG Encoding**: The PIL Image is saved to a `BytesIO` buffer in JPEG format with the specified quality.\n- **Output**: The raw bytes of the JPEG image are converted to a tensor and returned. If the input was a list, a list of tensors is returned.",
    "prompt": "Create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format. The function accepts images in CHW layout and a quality parameter between 1 and 100 to control the output JPEG quality. The output is a tensor or list of tensors containing the raw bytes of the JPEG file(s). The function raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is passed as input.",
    "function_name": "encode_jpeg",
    "ground_truth": "torchvision/io/image.py",
    "test": "test/test_image.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}