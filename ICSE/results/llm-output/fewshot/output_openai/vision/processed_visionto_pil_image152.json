{
    "result": "Certainly! Below is a Python function `to_pil_image` that converts a tensor or a NumPy ndarray to a PIL Image. The function includes checks and conversions to handle different input types and formats:\n\n```python\nfrom PIL import Image\nimport numpy as np\nimport torch\n\ndef to_pil_image(pic, mode=None):\n    \"\"\"\n    Convert a tensor or a numpy.ndarray to a PIL Image.\n\n    Args:\n        pic (Tensor or numpy.ndarray): Image to be converted to PIL Image.\n        mode (str, optional): Mode to use for the PIL Image. If None, the mode is inferred.\n\n    Returns:\n        PIL.Image: Image converted to PIL format.\n    \"\"\"\n    if not (isinstance(pic, torch.Tensor) or isinstance(pic, np.ndarray)):\n        raise TypeError(f\"Input pic should be a torch.Tensor or numpy.ndarray. Got {type(pic)}.\")\n\n    if isinstance(pic, torch.Tensor):\n        if pic.ndimension() not in {2, 3}:\n            raise ValueError(f\"Input tensor should have 2 or 3 dimensions. Got {pic.ndimension()} dimensions.\")\n        pic = pic.cpu().numpy()\n\n    if isinstance(pic, np.ndarray):\n        if pic.ndim not in {2, 3}:\n            raise ValueError(f\"Input ndarray should have 2 or 3 dimensions. Got {pic.ndim} dimensions.\")\n\n    if pic.ndim == 2:\n        # Grayscale image\n        mode = mode or 'L'\n    elif pic.ndim == 3:\n        if pic.shape[0] == 1:\n            # Single channel image\n            pic = pic.squeeze(0)\n            mode = mode or 'L'\n        elif pic.shape[0] == 3:\n            # RGB image\n            pic = pic.transpose(1, 2, 0)\n            mode = mode or 'RGB'\n        elif pic.shape[0] == 4:\n            # RGBA image\n            pic = pic.transpose(1, 2, 0)\n            mode = mode or 'RGBA'\n        else:\n            raise ValueError(f\"Unsupported number of channels: {pic.shape[0]}\")\n\n    if pic.dtype == np.uint8:\n        return Image.fromarray(pic, mode=mode)\n    elif pic.dtype in {np.float32, np.float64}:\n        pic = (pic * 255).astype(np.uint8)\n        return Image.fromarray(pic, mode=mode)\n    else:\n        raise TypeError(f\"Unsupported data type: {pic.dtype}\")\n\n```\n\n### Key Points:\n- **Input Types**: The function accepts either a PyTorch tensor or a NumPy ndarray.\n- **Dimension Checks**: It checks if the input has 2 or 3 dimensions, which are typical for image data.\n- **Channel Handling**: It handles different channel configurations (grayscale, RGB, RGBA) and adjusts the mode accordingly.\n- **Data Type Conversion**: It converts floating-point data to `uint8` by scaling, which is common for image data.\n- **Error Handling**: It raises appropriate errors for unsupported types, dimensions, or data types.",
    "prompt": "Generate a Python function called to_pil_image that converts a tensor or an ndarray to a PIL Image. The function does not support torchscript. The input parameters are pic (Tensor or numpy.ndarray) and mode (optional). The function returns a PIL Image. The function performs various checks and conversions based on the input data before returning the PIL Image.",
    "function_name": "to_pil_image",
    "ground_truth": "torchvision/transforms/functional.py",
    "test": "test/test_transforms.py::TestToTensor",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}