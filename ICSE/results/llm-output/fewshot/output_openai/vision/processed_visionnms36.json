{
    "result": "To implement a function for non-maximum suppression (NMS) using PyTorch, you can follow the structure and style of the examples provided. Here's a Python function that performs NMS on a set of bounding boxes:\n\n```python\nimport torch\nfrom torchvision.ops import nms as torchvision_nms\nimport logging\n\ndef nms(boxes: torch.Tensor, scores: torch.Tensor, iou_threshold: float) -> torch.Tensor:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on bounding boxes based on their IoU values.\n\n    Args:\n        boxes (Tensor[N, 4]): Bounding box coordinates in (x1, y1, x2, y2) format.\n        scores (Tensor[N]): Scores for each bounding box.\n        iou_threshold (float): IoU threshold for suppression.\n\n    Returns:\n        Tensor: Indices of the boxes that have been kept after NMS, sorted in decreasing order of scores.\n    \"\"\"\n    # Ensure the input tensors are on the same device\n    if boxes.device != scores.device:\n        raise ValueError(\"boxes and scores must be on the same device\")\n\n    # Log the API usage\n    logging.info(\"Performing NMS with IoU threshold: %f\", iou_threshold)\n\n    # Check if torchvision's NMS is available\n    if not hasattr(torchvision.ops, 'nms'):\n        raise RuntimeError(\"torchvision.ops.nms is not available. Please ensure you have torchvision installed.\")\n\n    # Perform NMS using torchvision's implementation\n    keep_indices = torchvision_nms(boxes, scores, iou_threshold)\n\n    return keep_indices\n\n# Example usage:\n# boxes = torch.tensor([[10, 10, 20, 20], [15, 15, 25, 25], [30, 30, 40, 40]], dtype=torch.float32)\n# scores = torch.tensor([0.9, 0.8, 0.7], dtype=torch.float32)\n# iou_threshold = 0.5\n# kept_indices = nms(boxes, scores, iou_threshold)\n# print(kept_indices)\n```\n\n### Explanation:\n- **Inputs**:\n  - `boxes`: A tensor of shape `[N, 4]` containing the coordinates of the bounding boxes in `(x1, y1, x2, y2)` format.\n  - `scores`: A tensor of shape `[N]` containing the scores for each bounding box.\n  - `iou_threshold`: A float specifying the IoU threshold for suppression.\n\n- **Output**:\n  - Returns a tensor of indices of the boxes that are kept after applying NMS, sorted in decreasing order of their scores.\n\n- **Functionality**:\n  - The function checks if the `boxes` and `scores` tensors are on the same device.\n  - It logs the API usage for tracking purposes.\n  - It checks if the `nms` function from `torchvision.ops` is available.\n  - It uses `torchvision.ops.nms` to perform the NMS operation and returns the indices of the boxes that are kept.\n\nThis function is designed to be efficient and leverages PyTorch's built-in NMS functionality for optimal performance.",
    "prompt": "Generate a Python function called nms that performs non-maximum suppression (NMS) on a set of bounding boxes based on their intersection-over-union (IoU) values. The function takes three inputs: boxes (a Tensor of shape [N, 4] representing bounding box coordinates in (x1, y1, x2, y2) format), scores (a Tensor of shape [N] containing scores for each box), and iou_threshold (a float value specifying the IoU threshold for suppression).\n\nThe function iteratively removes lower scoring boxes that have an IoU greater than the specified threshold with another higher scoring box. The output is an int64 Tensor containing the indices of the boxes that have been kept after NMS, sorted in decreasing order of scores. Additionally, the function logs API usage and ensures that necessary operations are available before performing NMS using PyTorch's torchvision library.",
    "function_name": "nms",
    "ground_truth": "torchvision/ops/boxes.py",
    "test": "test/test_ops.py::TestNMS",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}