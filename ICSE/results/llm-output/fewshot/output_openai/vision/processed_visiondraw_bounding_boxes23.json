{
    "result": "To create a function `draw_bounding_boxes` that meets the specified requirements, we need to handle various aspects such as input validation, drawing operations, and optional parameters. Below is a Python function that implements these features using PyTorch and PIL for image manipulation:\n\n```python\nimport torch\nfrom typing import List, Optional, Union, Tuple\nfrom PIL import Image, ImageDraw, ImageFont\nimport warnings\n\ndef draw_bounding_boxes(\n    image: torch.Tensor,\n    boxes: torch.Tensor,\n    labels: Optional[List[str]] = None,\n    colors: Optional[Union[List[Union[str, Tuple[int, int, int]]], str, Tuple[int, int, int]]] = None,\n    fill: Optional[bool] = False,\n    width: int = 1,\n    font: Optional[str] = None,\n    font_size: Optional[int] = None,\n) -> torch.Tensor:\n    \"\"\"\n    Draws bounding boxes on a given RGB or grayscale image.\n\n    Args:\n        image (Tensor): Tensor of shape (C, H, W) and dtype uint8 or float.\n        boxes (Tensor): Tensor of size (N, 4) containing bounding boxes in (xmin, ymin, xmax, ymax) format.\n        labels (List[str], optional): Labels for the bounding boxes. Defaults to None.\n        colors (Union[List[Union[str, Tuple[int, int, int]]], str, Tuple[int, int, int]], optional):\n            Colors for each bounding box or a single color for all boxes.\n        fill (bool): Whether to fill the bounding boxes.\n        width (int): Width of the bounding box outline.\n        font (str, optional): Path to a TrueType font. Defaults to None.\n        font_size (int, optional): Font size for labels. Defaults to None.\n\n    Returns:\n        img (Tensor[C, H, W]): Image tensor (dtype=uint8) with bounding boxes drawn.\n    \"\"\"\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Input 'image' must be a torch.Tensor.\")\n    \n    if image.ndim != 3 or image.size(0) not in {1, 3}:\n        raise ValueError(\"Image must have shape (C, H, W) with C=1 or C=3.\")\n    \n    if image.dtype not in {torch.uint8, torch.float32, torch.float64}:\n        raise ValueError(\"Image dtype must be uint8 or float.\")\n    \n    if boxes.ndim != 2 or boxes.size(1) != 4:\n        raise ValueError(\"Boxes must have shape (N, 4).\")\n    \n    num_boxes = boxes.shape[0]\n    if num_boxes == 0:\n        warnings.warn(\"No bounding boxes provided. Returning the original image.\")\n        return image\n    \n    if labels is None:\n        labels = [None] * num_boxes\n    elif len(labels) != num_boxes:\n        raise ValueError(\"Number of labels must match the number of boxes.\")\n    \n    if colors is None:\n        colors = [\"red\"] * num_boxes\n    elif isinstance(colors, (str, tuple)):\n        colors = [colors] * num_boxes\n    elif len(colors) != num_boxes:\n        raise ValueError(\"Number of colors must match the number of boxes.\")\n    \n    if font is None:\n        if font_size is not None:\n            warnings.warn(\"Argument 'font_size' will be ignored since 'font' is not set.\")\n        txt_font = ImageFont.load_default()\n    else:\n        txt_font = ImageFont.truetype(font=font, size=font_size or 10)\n    \n    if image.size(0) == 1:\n        image = torch.tile(image, (3, 1, 1))\n    \n    original_dtype = image.dtype\n    if original_dtype.is_floating_point:\n        image = (image * 255).to(torch.uint8)\n    \n    img_to_draw = Image.fromarray(image.permute(1, 2, 0).cpu().numpy())\n    draw = ImageDraw.Draw(img_to_draw, \"RGBA\" if fill else \"RGB\")\n    \n    for bbox, color, label in zip(boxes.tolist(), colors, labels):\n        if fill:\n            fill_color = color + (100,)\n            draw.rectangle(bbox, outline=color, fill=fill_color, width=width)\n        else:\n            draw.rectangle(bbox, outline=color, width=width)\n        \n        if label is not None:\n            margin = width + 1\n            draw.text((bbox[0] + margin, bbox[1] + margin), label, fill=color, font=txt_font)\n    \n    out = torch.from_numpy(np.array(img_to_draw)).permute(2, 0, 1)\n    if original_dtype.is_floating_point:\n        out = out.to(original_dtype) / 255\n    \n    return out\n```\n\n### Key Features:\n- **Input Validation**: The function checks if the input image is a tensor, if its dimensions are correct, and if the dtype is either `uint8` or float. It also checks the format of the bounding boxes.\n- **Warnings and Errors**: It raises warnings if no bounding boxes are provided and errors if the number of labels or colors does not match the number of boxes.\n- **Drawing**: Uses PIL to draw rectangles and text on the image. Supports filling the boxes and custom fonts.\n- **Output**: Returns the modified image tensor with bounding boxes drawn.",
    "prompt": "Create a Python function `draw_bounding_boxes` that draws bounding boxes on a given RGB or grayscale image represented as a PyTorch tensor. The function should accept an image tensor (`image`) of shape `(C, H, W)` and dtype `uint8` or float, a tensor of bounding boxes (`boxes`) in `(xmin, ymin, xmax, ymax)` format, and optional parameters such as labels, colors, fill option, box width, font, and font size. The function should return the image tensor with the bounding boxes drawn on it.\n\n### Error Handling:\n- Raise a `TypeError` if the input `image` is not a tensor.\n- Raise a `ValueError` if the image dtype is not `uint8` or float, if the image dimensions are incorrect, or if the bounding boxes are not in the correct format.\n- Warn if no bounding boxes are provided or if the number of labels does not match the number of boxes.\n\nThe function should support options like filling the bounding boxes with a color, specifying the width of the bounding box edges, and adding labels with custom fonts. The output should be a tensor with the bounding boxes applied, suitable for further processing or visualization.",
    "function_name": "draw_bounding_boxes",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}