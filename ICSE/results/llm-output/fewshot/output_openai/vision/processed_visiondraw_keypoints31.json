{
    "result": "To create the `draw_keypoints` function as described, we need to handle image processing, drawing keypoints, and connecting them with lines. We'll use the `PIL` library for drawing and `torchvision` for handling image transformations. Here's how you can implement the function:\n\n```python\nimport torch\nfrom typing import Optional, List, Tuple, Union\nfrom PIL import Image, ImageDraw\nimport torchvision.transforms.functional as F\n\ndef draw_keypoints(\n    image: torch.Tensor,\n    keypoints: torch.Tensor,\n    connectivity: Optional[List[Tuple[int, int]]] = None,\n    colors: Optional[Union[str, Tuple[int, int, int]]] = \"red\",\n    radius: int = 3,\n    width: int = 2,\n    visibility: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n    \"\"\"\n    Draws keypoints and optional connectivity lines on a given RGB image.\n\n    Args:\n        image (Tensor): Tensor of shape (3, H, W) and dtype uint8 or float.\n        keypoints (Tensor): Tensor of shape (num_instances, K, 2) with (x, y) coordinates.\n        connectivity (List[Tuple[int, int]], optional): Pairs of keypoints to connect with lines.\n        colors (Union[str, Tuple[int, int, int]], optional): Color for keypoints and lines.\n        radius (int): Radius of each keypoint.\n        width (int): Width of the lines connecting keypoints.\n        visibility (Tensor, optional): Tensor of shape (num_instances, K) indicating visibility.\n\n    Returns:\n        Tensor: Image tensor with keypoints and connections drawn.\n    \"\"\"\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Input image must be a tensor.\")\n    \n    if image.dtype not in [torch.uint8, torch.float32, torch.float64]:\n        raise ValueError(\"Image dtype must be uint8 or float.\")\n    \n    if image.ndim != 3 or image.size(0) != 3:\n        raise ValueError(\"Image must have shape (3, H, W).\")\n    \n    num_instances, K, coords = keypoints.shape\n    if coords != 2:\n        raise ValueError(\"Keypoints tensor must have shape (num_instances, K, 2).\")\n    \n    if visibility is not None and visibility.shape != (num_instances, K):\n        raise ValueError(\"Visibility tensor must match the shape of keypoints tensor.\")\n    \n    original_dtype = image.dtype\n    if original_dtype.is_floating_point:\n        image = F.to_pil_image(image)\n    else:\n        image = F.to_pil_image(image.float() / 255.0)\n    \n    draw = ImageDraw.Draw(image)\n    \n    for i in range(num_instances):\n        for j in range(K):\n            if visibility is None or visibility[i, j]:\n                x, y = keypoints[i, j].tolist()\n                draw.ellipse(\n                    [(x - radius, y - radius), (x + radius, y + radius)],\n                    fill=colors,\n                    outline=colors\n                )\n        \n        if connectivity:\n            for start, end in connectivity:\n                if (visibility is None or (visibility[i, start] and visibility[i, end])):\n                    x1, y1 = keypoints[i, start].tolist()\n                    x2, y2 = keypoints[i, end].tolist()\n                    draw.line([(x1, y1), (x2, y2)], fill=colors, width=width)\n    \n    out = F.to_tensor(image)\n    if original_dtype.is_floating_point:\n        out = out.to(original_dtype)\n    else:\n        out = (out * 255).to(torch.uint8)\n    \n    return out\n```\n\n### Key Points:\n- **Input Validation**: The function checks if the input image is a tensor and validates its dtype and shape. It also checks the shape of the keypoints and visibility tensors.\n- **Drawing**: Uses `PIL` to draw keypoints as circles and lines for connectivity.\n- **Visibility**: Only draws keypoints and lines if they are marked as visible.\n- **Output**: Returns the modified image tensor with keypoints and connections drawn.",
    "prompt": "Create a Python function draw_keypoints that overlays keypoints on a given RGB image tensor. The function should accept the following parameters:\n\nimage: A tensor of shape (3, H, W) and dtype uint8 or float, representing the image.\nkeypoints: A tensor of shape (num_instances, K, 2), where K denotes the number of keypoints per instance, and each keypoint is represented by its (x, y) coordinates.\nconnectivity: An optional list of tuples, where each tuple contains two integers representing keypoints that should be connected with a line.\ncolors: An optional string or tuple specifying the color for the keypoints and lines. The color can be a string (e.g., \"red\") or an RGB tuple.\nradius: An integer specifying the radius of each keypoint.\nwidth: An integer specifying the width of the lines connecting the keypoints.\nvisibility: An optional tensor of shape (num_instances, K) that indicates whether each keypoint is visible (True) or not (False).\nThe function should validate the input tensors and ensure the image is in the correct format. It should draw each visible keypoint on the image, and if connectivity is provided, draw lines connecting the keypoints based on their visibility. The resulting image tensor should be returned with the keypoints and connections drawn.\n\nError Handling:\nRaise a TypeError if the input image is not a tensor.\nRaise a ValueError if the image dtype is not uint8 or float, if the image shape is incorrect, or if the keypoints tensor has an incorrect shape.\nRaise a ValueError if the visibility tensor does not match the shape of the keypoints tensor.",
    "function_name": "draw_keypoints",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py::test_draw_keypoints_visibility",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}