{
    "result": "To implement the `compute_pyx` function, we need to calculate the posterior probabilities `P(true_label=k|x)` using the given `pred_probs`, `noise_matrix`, and `inverse_noise_matrix`. The function should be robust, meaning it should work well even if the noise matrices are not perfectly estimated. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef compute_pyx(pred_probs, noise_matrix, inverse_noise_matrix):\n    # Validate input shape\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )\n    \n    # Validate noise matrices\n    if noise_matrix.shape != inverse_noise_matrix.shape:\n        raise ValueError(\"Noise matrix and inverse noise matrix must have the same shape.\")\n    \n    # Validate that the noise matrices are square and match the number of classes\n    K = pred_probs.shape[1]\n    if noise_matrix.shape[0] != K or noise_matrix.shape[1] != K:\n        raise ValueError(\"Noise matrices must be square and match the number of classes in pred_probs.\")\n    \n    # Compute pyx using the inverse noise matrix\n    # This is a matrix multiplication of pred_probs with the inverse_noise_matrix\n    pyx = np.dot(pred_probs, inverse_noise_matrix)\n    \n    # Normalize the rows to ensure they sum to 1, as they represent probabilities\n    pyx /= pyx.sum(axis=1, keepdims=True)\n    \n    return pyx\n```\n\n### Explanation:\n\n1. **Input Validation**: \n   - The function first checks if `pred_probs` is a 2D array with shape `(N, K)`, where `N` is the number of examples and `K` is the number of classes.\n   - It also checks that the `noise_matrix` and `inverse_noise_matrix` are square matrices with dimensions `(K, K)`.\n\n2. **Matrix Multiplication**:\n   - The core computation involves multiplying `pred_probs` with `inverse_noise_matrix`. This operation transforms the predicted probabilities into the posterior probabilities `P(true_label=k|x)`.\n\n3. **Normalization**:\n   - After computing the matrix product, each row of the resulting `pyx` matrix is normalized to ensure that the probabilities sum to 1. This step is crucial because the output should represent valid probability distributions over the classes.\n\nThis implementation assumes that the `inverse_noise_matrix` is already provided and correctly estimated. If the inverse noise matrix is not provided, additional steps would be needed to compute it from the `noise_matrix`. However, this is not covered in the current implementation.",
    "prompt": "\"Write a python function compute_pyx Compute ``pyx := P(true_label=k|x)`` from ``pred_probs := P(label=k|x)``, `noise_matrix` and\n    `inverse_noise_matrix`.\n\n    This method is ROBUST - meaning it works well even when the\n    noise matrices are estimated poorly by only using the diagonals of the\n    matrices which tend to be easy to estimate correctly.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        ``P(label=k|x)`` is a ``(N x K)`` matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of `noise_matrix` sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``)  of the form ``P(true_label=k_y|label=k_s)`` representing\n        the estimated fraction observed examples in each class `k_s`, that are\n        mislabeled examples from every other class `k_y`. If None, the\n        inverse_noise_matrix will be computed from `pred_probs` and `labels`.\n        Assumes columns of `inverse_noise_matrix` sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        ``P(true_label=k|x)`` is a  ``(N, K)`` matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )",
    "function_name": "compute_pyx",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}