{
    "result": "Here's a detailed implementation of the `compute_py` function, which calculates the prior probabilities of true class labels using different methods. The function includes input validation, computation based on the specified method, and error handling.\n\n```python\nimport numpy as np\n\ndef compute_py(ps, noise_matrix, inverse_noise_matrix, py_method, true_labels_class_counts):\n    # Validate inputs\n    if ps is None or noise_matrix is None or inverse_noise_matrix is None or py_method is None or true_labels_class_counts is None:\n        raise ValueError(\"All parameters must be provided.\")\n    \n    K = len(true_labels_class_counts)\n    if noise_matrix.shape != (K, K) or inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\"Noise matrices must be of shape (K, K).\")\n    \n    if len(ps) != K:\n        raise ValueError(\"The length of ps must match the number of classes K.\")\n    \n    # Initialize the output array\n    py = np.zeros(K)\n    \n    # Compute prior probabilities based on the specified method\n    if py_method == \"cnt\":\n        # Use true_labels_class_counts to compute prior probabilities\n        total_count = np.sum(true_labels_class_counts)\n        if total_count == 0:\n            raise ValueError(\"Total count of true labels must be greater than zero.\")\n        py = true_labels_class_counts / total_count\n    elif py_method == \"eqn\":\n        # Use inverse noise matrix and ps to compute prior probabilities\n        py = np.dot(inverse_noise_matrix, ps)\n    elif py_method == \"marginal\":\n        # Compute marginal probabilities from the noise matrix\n        py = np.sum(noise_matrix, axis=0) / np.sum(noise_matrix)\n    elif py_method == \"marginal_ps\":\n        # Use ps to adjust marginal probabilities\n        total_ps = np.sum(ps)\n        if total_ps == 0:\n            raise ValueError(\"Sum of ps must be greater than zero.\")\n        py = ps / total_ps\n    else:\n        raise ValueError(f\"Unsupported py_method: {py_method}\")\n    \n    # Clip values to ensure they are between 0 and 1\n    py = np.clip(py, 0, 1)\n    \n    return py\n\n# Example usage:\n# ps = np.array([0.2, 0.3, 0.5])\n# noise_matrix = np.array([[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.05, 0.15, 0.8]])\n# inverse_noise_matrix = np.linalg.inv(noise_matrix)\n# true_labels_class_counts = np.array([50, 30, 20])\n# py_method = \"cnt\"\n# py = compute_py(ps, noise_matrix, inverse_noise_matrix, py_method, true_labels_class_counts)\n# print(py)\n```\n\n### Key Points:\n1. **Input Validation**: The function checks if all required parameters are provided and if the shapes of the matrices are correct.\n2. **Method Selection**: The function computes the prior probabilities using one of four methods (`cnt`, `eqn`, `marginal`, `marginal_ps`), based on the `py_method` parameter.\n3. **Error Handling**: The function raises exceptions for invalid input shapes, unsupported methods, or zero sums where division is required.\n4. **Clipping**: The computed probabilities are clipped to ensure they fall within the range [0, 1].\n\nThis implementation provides a flexible way to compute prior probabilities using different methods, with robust error handling to ensure valid inputs.",
    "prompt": "Generate a Python function called compute_py that computes the prior probability of true class labels based on observed noisy labels, noise matrices, and inverse noise matrices. The function takes in parameters ps, noise_matrix, inverse_noise_matrix, py_method, and true_labels_class_counts. The function returns an array py of shape (K,) or (1, K) containing the prior probability of each true class label. The function includes error handling for invalid input shapes and missing parameters, and uses different methods (cnt, eqn, marginal, marginal_ps) to compute the prior probabilities based on the specified py_method. The output array py is clipped to ensure values are between 0 and 1.",
    "function_name": "compute_py",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}