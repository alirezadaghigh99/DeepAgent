{
    "result": "The function `find_overlapping_classes` is designed to identify pairs of classes that are often mislabeled as one another in a classification dataset. The function can work with different input combinations to compute the necessary statistics and return a DataFrame with the results. Below is the complete implementation of the function, including a placeholder for the `compute_confident_joint` function, which you would need to implement based on your specific requirements.\n\n```python\nimport numpy as np\nimport pandas as pd\n\ndef find_overlapping_classes(labels=None, pred_probs=None, asymmetric=False, class_names=None, \n                             num_examples=None, joint=None, confident_joint=None):\n    # Validate input combinations\n    if (labels is not None and pred_probs is not None) + (joint is not None and num_examples is not None) + (confident_joint is not None) != 1:\n        raise ValueError(\"Provide exactly one valid input combination.\")\n    \n    # Compute confident_joint if not provided\n    if confident_joint is None:\n        if labels is None or pred_probs is None:\n            raise ValueError(\"Labels and pred_probs are required to compute confident_joint.\")\n        # Compute confident_joint here (this is a placeholder for the actual computation)\n        confident_joint = compute_confident_joint(labels, pred_probs)\n    \n    # Use joint if provided, otherwise use confident_joint\n    joint_matrix = joint if joint is not None else confident_joint\n    \n    # Calculate number of examples if not provided\n    if num_examples is None:\n        num_examples = len(labels) if labels is not None else int(np.sum(confident_joint))\n    \n    # Initialize list to store overlapping class pairs\n    overlapping_classes = []\n    \n    # Iterate over class pairs to calculate overlap\n    num_classes = joint_matrix.shape[0]\n    for i in range(num_classes):\n        for j in range(num_classes):\n            if i != j:\n                num_overlap = joint_matrix[i, j] if asymmetric else joint_matrix[i, j] + joint_matrix[j, i]\n                joint_prob = num_overlap / num_examples\n                overlapping_classes.append((i, j, num_overlap, joint_prob))\n    \n    # Create DataFrame\n    df = pd.DataFrame(overlapping_classes, columns=[\"Class Index A\", \"Class Index B\", \n                                                    \"Num Overlapping Examples\", \"Joint Probability\"])\n    \n    # Sort by Joint Probability\n    df.sort_values(by=\"Joint Probability\", ascending=False, inplace=True)\n    \n    return df\n\n# Placeholder function for computing confident_joint\ndef compute_confident_joint(labels, pred_probs):\n    # Implement the logic to compute the confident joint matrix\n    # This is a placeholder and should be replaced with actual computation logic\n    num_classes = pred_probs.shape[1]\n    confident_joint = np.zeros((num_classes, num_classes))\n    # Example logic (to be replaced with actual computation):\n    for i, label in enumerate(labels):\n        predicted_class = np.argmax(pred_probs[i])\n        confident_joint[label, predicted_class] += 1\n    return confident_joint\n```\n\n### Key Points:\n- **Input Validation**: The function checks that exactly one valid input combination is provided.\n- **Confident Joint Calculation**: If `confident_joint` is not provided, it is computed using `labels` and `pred_probs`. The `compute_confident_joint` function is a placeholder and should be implemented with the logic specific to your dataset and requirements.\n- **Asymmetry Handling**: The function can handle both symmetric and asymmetric cases for overlapping class pairs.\n- **Output**: The function returns a DataFrame sorted by \"Joint Probability\" in descending order, highlighting the most significant overlaps.\n\nThis implementation provides a flexible way to identify and analyze class overlaps in a dataset, which can be useful for improving data labeling and model performance.",
    "prompt": "Generate a Python function called find_overlapping_classes that rReturns the pairs of classes that are often mislabeled as one another.\n    Consider merging the top pairs of classes returned by this method each into a single class.\n    If the dataset is labeled by human annotators, consider clearly defining the\n    difference between the classes prior to having annotators label the data.\n    This method provides two scores in the Pandas DataFrame that is returned:\n    * **Num Overlapping Examples**: The number of examples where the two classes overlap\n    * **Joint Probability**: `(num overlapping examples / total number of examples in the dataset`).\n    This method works by providing any one (and only one) of the following inputs:\n    1. ``labels`` and ``pred_probs``, or\n    2. ``joint`` and ``num_examples``, or\n    3. ``confident_joint``\n      Parameters\n    ----------\n    labels : np.ndarray or list, optional\n      An array_like (of length N) of noisy labels for the classification dataset, i.e. some labels may be erroneous.\n      Elements must be integers in the set 0, 1, ..., K-1, where K is the number of classes.\n      All the classes (0, 1, ..., and K-1) should be present in ``labels``, such that\n      ``len(set(labels)) == pred_probs.shape[1]`` for standard multi-class classification with single-labeled data (e.g. ``labels =  [1,0,2,1,1,0...]``).\n      For multi-label classification where each example can belong to multiple classes (e.g. ``labels = [[1,2],[1],[0],[],...]``),\n      your labels should instead satisfy: ``len(set(k for l in labels for k in l)) == pred_probs.shape[1])``.\n\n    pred_probs : np.ndarray, optional\n      An array of shape ``(N, K)`` of model-predicted probabilities,\n      ``P(label=k|x)``. Each row of this matrix corresponds\n      to an example `x` and contains the model-predicted probabilities that\n      `x` belongs to each possible class, for each of the K classes. The\n      columns must be ordered such that these probabilities correspond to\n      class 0, 1, ..., K-1. `pred_probs` should have been computed using 3 (or\n      higher) fold cross-validation.\n\n    asymmetric : bool, optional\n      If ``asymmetric=True``, returns separate estimates for both pairs (class1, class2) and (class2, class1). Use this\n      for finding \"is a\" relationships where for example \"class1 is a class2\".\n      In this case, num overlapping examples counts the number of examples that have been labeled as class1 which should actually have been labeled as class2.\n      If ``asymmetric=False``, the pair (class1, class2) will only be returned once with an arbitrary order.\n      In this case, their estimated score is the sum: ``score(class1, class2) + score(class2, class1))``.\n\n    class_names : Iterable[str]\n        A list or other iterable of the string class names. The list should be in the order that\n        matches the class indices. So if class 0 is 'dog' and class 1 is 'cat', then\n        ``class_names = ['dog', 'cat']``.\n\n    num_examples : int or None, optional\n        The number of examples in the dataset, i.e. ``len(labels)``. You only need to provide this if\n        you use this function with the joint, e.g. ``find_overlapping_classes(joint=joint)``, otherwise\n        this is automatically computed via ``sum(confident_joint)`` or ``len(labels)``.\n\n    joint : np.ndarray, optional\n        An array of shape ``(K, K)``, where K is the number of classes,\n        representing the estimated joint distribution of the noisy labels and\n        true labels. The sum of all entries in this matrix must be 1 (valid\n        probability distribution). Each entry in the matrix captures the co-occurence joint\n        probability of a true label and a noisy label, i.e. ``p(noisy_label=i, true_label=j)``.\n        **Important**. If you input the joint, you must also input `num_examples`.\n\n    confident_joint : np.ndarray, optional\n      An array of shape ``(K, K)`` representing the confident joint, the matrix used for identifying label issues, which\n      estimates a confident subset of the joint distribution of the noisy and true labels, ``P_{noisy label, true label}``.\n      Entry ``(j, k)`` in the matrix is the number of examples confidently counted into the pair of ``(noisy label=j, true label=k)`` classes.\n      The `confident_joint` can be computed using :py:func:`count.compute_confident_joint <cleanlab.count.compute_confident_joint>`.\n      If not provided, it is computed from the given (noisy) `labels` and `pred_probs`.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\" and a description of each below.\n        Each row corresponds to a pair of classes.\n\n        * *Class Index A*: the index of a class in 0, 1, ..., K-1.\n        * *Class Index B*: the index of a different class (from Class A) in 0, 1, ..., K-1.\n        * *Num Overlapping Examples*: estimated number of labels overlapping between the two classes.\n        * *Joint Probability*: the *Num Overlapping Examples* divided by the number of examples in the dataset.\n\n        By default, the DataFrame is ordered by \"Joint Probability\" descending.",
    "function_name": "find_overlapping_classes",
    "ground_truth": "cleanlab/dataset.py",
    "test": "tests/test_dataset.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}