{
    "result": "The function `compute_ps_py_inv_noise_matrix` is designed to compute the empirical distribution of noisy labels (`ps`), the true label distribution (`py`), and the inverse of the noise matrix. Below is the implementation of the function, following the structured approach you outlined:\n\n```python\nimport numpy as np\n\ndef compute_ps_py_inv_noise_matrix(labels, noise_matrix):\n    # Validate inputs\n    if not isinstance(labels, np.ndarray) or labels.ndim != 1:\n        raise ValueError(\"Labels must be a 1D numpy array.\")\n    \n    K = noise_matrix.shape[0]\n    if noise_matrix.shape != (K, K):\n        raise ValueError(\"Noise matrix must be a square matrix of shape (K, K).\")\n    \n    if not np.allclose(noise_matrix.sum(axis=0), 1):\n        raise ValueError(\"Columns of the noise matrix must sum to 1.\")\n    \n    # Compute ps: empirical distribution of noisy labels\n    label_counts = np.bincount(labels, minlength=K)\n    ps = label_counts / label_counts.sum()\n    \n    # Compute py: true label distribution\n    try:\n        py = np.linalg.solve(noise_matrix, ps)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Noise matrix is singular and cannot be inverted.\")\n    \n    # Compute inverse noise matrix\n    try:\n        inv_noise_matrix = np.linalg.inv(noise_matrix)\n    except np.linalg.LinAlgError:\n        raise ValueError(\"Noise matrix is singular and cannot be inverted.\")\n    \n    return ps, py, inv_noise_matrix\n\n# Example usage:\n# labels = np.array([0, 1, 1, 2, 2, 2])\n# noise_matrix = np.array([[0.9, 0.05, 0.05],\n#                          [0.1, 0.8, 0.1],\n#                          [0.05, 0.15, 0.8]])\n# ps, py, inv_noise_matrix = compute_ps_py_inv_noise_matrix(labels, noise_matrix)\n# print(\"ps:\", ps)\n# print(\"py:\", py)\n# print(\"Inverse Noise Matrix:\\n\", inv_noise_matrix)\n```\n\n### Key Points:\n\n1. **Input Validation**: The function checks if `labels` is a 1D numpy array and if `noise_matrix` is a square matrix with columns summing to 1. This ensures that the inputs are in the correct format.\n\n2. **Empirical Distribution (`ps`)**: The function calculates `ps` by counting the occurrences of each label and normalizing by the total number of labels.\n\n3. **True Label Distribution (`py`)**: The function solves the linear system `noise_matrix * py = ps` to find `py`. This step assumes that the noise matrix is accurate and invertible.\n\n4. **Inverse Noise Matrix**: The function computes the inverse of the noise matrix using `np.linalg.inv`. It handles potential errors if the matrix is singular.\n\n5. **Error Handling**: The function raises informative errors if the inputs are not valid or if the noise matrix cannot be inverted.\n\nThis implementation provides a robust solution for computing the required distributions and inverse noise matrix, assuming the input data is correctly formatted and the noise matrix is invertible.",
    "prompt": "Generate a Python function called compute_ps_py_inv_noise_matrix that Compute ``ps := P(labels=k), py := P(true_labels=k)``, and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n          A discrete vector of noisy labels, i.e. some labels may be erroneous.\n          *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.",
    "function_name": "compute_ps_py_inv_noise_matrix",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}