{
    "result": "Here's the implementation of the `noise_matrix_is_valid` function, following the structured approach you outlined:\n\n```python\nimport numpy as np\n\ndef noise_matrix_is_valid(noise_matrix: np.ndarray, py: np.ndarray, verbose: bool = False) -> bool:\n    \"\"\"\n    Check if the given noise_matrix is a learnable matrix.\n\n    Parameters:\n    - noise_matrix (np.ndarray): A square matrix representing label noise probabilities.\n    - py (np.ndarray): A vector representing the prior probabilities of each class.\n    - verbose (bool): If True, print detailed information about the process.\n\n    Returns:\n    - bool: True if the noise matrix is learnable, False otherwise.\n    \"\"\"\n    # Check if noise_matrix is square and matches the length of py\n    num_classes = noise_matrix.shape[0]\n    if noise_matrix.shape[0] != noise_matrix.shape[1] or len(py) != num_classes:\n        raise ValueError(\"noise_matrix must be square and match the length of py.\")\n\n    # Check if each row sums to 1\n    row_sums = noise_matrix.sum(axis=1)\n    if not np.allclose(row_sums, 1):\n        if verbose:\n            print(\"Each row of the noise_matrix must sum to 1.\")\n        return False\n\n    # Check if diagonal elements are greater than off-diagonal elements\n    for i in range(num_classes):\n        if noise_matrix[i, i] <= max(noise_matrix[i, :i].tolist() + noise_matrix[i, i+1:].tolist()):\n            if verbose:\n                print(f\"Diagonal element {noise_matrix[i, i]} is not greater than off-diagonal elements in row {i}.\")\n            return False\n\n    # Calculate expected accuracy\n    expected_accuracy = np.sum(np.diag(noise_matrix) * py)\n    random_baseline = 1 / num_classes\n\n    if verbose:\n        print(f\"Expected accuracy: {expected_accuracy}\")\n        print(f\"Random baseline: {random_baseline}\")\n\n    # Determine if the matrix is learnable\n    is_learnable = expected_accuracy > random_baseline\n    if verbose:\n        print(f\"Noise matrix is {'learnable' if is_learnable else 'not learnable'}.\")\n\n    return is_learnable\n```\n\n### Explanation of the Steps:\n\n1. **Check Matrix Dimensions**: \n   - Ensure that the `noise_matrix` is square and its dimensions match the length of `py`. This ensures that each class has a corresponding row and column in the matrix.\n\n2. **Calculate Row Sums**:\n   - Compute the sum of each row in the `noise_matrix`. Each row should sum to 1, as it represents a probability distribution of a label being flipped to other labels.\n\n3. **Check for Validity**:\n   - Verify that each row in the `noise_matrix` sums to 1. If not, the matrix is not valid.\n   - Ensure that the diagonal elements (probability of a label remaining the same) are greater than any off-diagonal elements (probability of a label being flipped to another label) in the same row.\n\n4. **Calculate Learnability**:\n   - Compute the expected accuracy by summing the product of the diagonal elements of the `noise_matrix` and the corresponding elements in `py`. This gives the expected probability of correctly classifying a sample.\n   - Compare this expected accuracy to the random baseline (1 divided by the number of classes). If the expected accuracy is greater, the matrix is considered learnable.\n\n5. **Return Result**:\n   - Return `True` if the matrix is learnable, otherwise return `False`.\n   - If `verbose` is `True`, print detailed information about each step and the final result.\n\nThis function ensures that the noise matrix is a valid probability distribution and that it is possible to achieve better than random performance, indicating that the matrix is learnable.",
    "prompt": "Generate a Python function called noise_matrix_is_valid that takes in a noise_matrix (np.ndarray), py (np.ndarray), and an optional verbose parameter. The function checks if the given noise_matrix is a learnable matrix, meaning it is possible to achieve better than random performance for the amount of noise in the matrix. The function calculates probabilities based on the input matrices and returns a boolean value indicating whether the noise matrix is learnable. The function includes detailed comments explaining the purpose of each step and the expected inputs and outputs.",
    "function_name": "noise_matrix_is_valid",
    "ground_truth": "cleanlab/benchmarking/noise_generation.py",
    "test": "tests/test_noise_generation.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}