{
    "result": "Here's the implementation of the `compute_sample_weight` function based on the outlined plan. This function calculates sample weights for unbalanced datasets, allowing for different class weight specifications and handling subsampling if needed.\n\n```python\nimport numpy as np\nfrom collections import Counter\n\ndef compute_sample_weight(class_weight, y, indices=None):\n    # Validate inputs\n    if not isinstance(y, (list, np.ndarray)):\n        raise ValueError(\"y must be array-like.\")\n    \n    if indices is not None and not isinstance(indices, (list, np.ndarray)):\n        raise ValueError(\"indices must be array-like or None.\")\n    \n    # Convert y to a numpy array for easier manipulation\n    y = np.array(y)\n    \n    # Handle subsample\n    if indices is not None:\n        y = y[indices]\n    \n    # Handle class weights\n    if class_weight == \"balanced\":\n        class_counts = Counter(y)\n        total_samples = len(y)\n        class_weight = {cls: total_samples / (len(class_counts) * count) for cls, count in class_counts.items()}\n    elif isinstance(class_weight, dict):\n        # Ensure all classes in y have a weight\n        class_weight = {cls: class_weight.get(cls, 1.0) for cls in set(y)}\n    elif class_weight is None:\n        class_weight = {cls: 1.0 for cls in set(y)}\n    else:\n        raise ValueError(\"class_weight must be 'balanced', a dict, or None.\")\n    \n    # Compute sample weights\n    sample_weight_vect = np.zeros(len(y), dtype=float)\n    for i, label in enumerate(y):\n        sample_weight_vect[i] = class_weight.get(label, 1.0)\n    \n    return sample_weight_vect\n\n# Example usage\ny = [0, 1, 0, 1, 1, 2]\nclass_weight = \"balanced\"\nsample_weights = compute_sample_weight(class_weight, y)\nprint(\"Sample Weights:\", sample_weights)\n\n# Example with indices\nindices = [0, 2, 4]\nsample_weights_with_indices = compute_sample_weight(class_weight, y, indices)\nprint(\"Sample Weights with Indices:\", sample_weights_with_indices)\n\n# Example with custom class weights\ncustom_class_weight = {0: 1.0, 1: 2.0, 2: 3.0}\nsample_weights_custom = compute_sample_weight(custom_class_weight, y)\nprint(\"Sample Weights with Custom Class Weights:\", sample_weights_custom)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if `y` is array-like and if `indices` is either `None` or array-like.\n\n2. **Subsample Handling**: If `indices` is provided, `y` is filtered to include only the specified indices.\n\n3. **Class Weight Handling**:\n   - If `class_weight` is `\"balanced\"`, weights are calculated inversely proportional to class frequencies.\n   - If `class_weight` is a dictionary, it uses the provided weights, ensuring all classes in `y` have a weight.\n   - If `class_weight` is `None`, all classes are assigned equal weights.\n\n4. **Sample Weight Calculation**: A numpy array `sample_weight_vect` is initialized and filled with weights based on the class of each sample in `y`.\n\n5. **Examples**: The function includes examples demonstrating usage with balanced weights, custom class weights, and subsampling.\n\nThis implementation should cover the typical scenarios for handling class imbalance in datasets.",
    "prompt": "Create a Python function called compute_sample_weight that estimates sample weights by class for unbalanced datasets. The function takes in three parameters: class_weight (dict, list of dicts, \"balanced\", or None), y (array-like, sparse matrix), and indices (array-like of shape (n_subsample,), default=None). \n\nThe class_weight parameter represents weights associated with classes, with options for different formats and the \"balanced\" mode for automatic adjustment based on class frequencies. The y parameter is an array of original class labels per sample, and the indices parameter is an array of indices to be used in a subsample.\n\nThe function returns a numpy array called sample_weight_vect of shape (n_samples,) containing the sample weights as applied to the original y. The function includes examples of usage and error handling for different scenarios.",
    "function_name": "compute_sample_weight",
    "ground_truth": "sklearn/utils/class_weight.py",
    "test": "sklearn/utils/tests/test_class_weight.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}