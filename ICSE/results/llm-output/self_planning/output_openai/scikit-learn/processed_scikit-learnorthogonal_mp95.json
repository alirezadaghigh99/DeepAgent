{
    "result": "Here's a detailed implementation of the `orthogonal_mp` function for the Orthogonal Matching Pursuit (OMP) algorithm, following the structured approach outlined in the plan:\n\n```python\nimport numpy as np\nfrom numpy.linalg import lstsq\n\ndef orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute=False, copy_X=True, return_path=False, return_n_iter=False):\n    # Validate inputs\n    X = np.asarray(X)\n    y = np.asarray(y)\n    \n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    \n    n_samples, n_features = X.shape\n    n_targets = y.shape[1]\n    \n    # Initialize variables\n    coef = np.zeros((n_features, n_targets))\n    residuals = y.copy()\n    selected_features = []\n    coef_path = []\n    n_iters = 0\n    \n    # Iterative feature selection\n    for target in range(n_targets):\n        selected_features = []\n        residuals[:, target] = y[:, target]\n        while len(selected_features) < (n_nonzero_coefs or n_features):\n            # Compute correlations\n            correlations = X.T @ residuals[:, target]\n            best_feature = np.argmax(np.abs(correlations))\n            \n            if best_feature in selected_features:\n                break\n            \n            selected_features.append(best_feature)\n            \n            # Solve least squares problem\n            X_selected = X[:, selected_features]\n            coef_selected, _, _, _ = lstsq(X_selected, y[:, target], rcond=None)\n            \n            # Update coefficients\n            coef[selected_features, target] = coef_selected\n            \n            # Update residuals\n            residuals[:, target] = y[:, target] - X_selected @ coef_selected\n            \n            # Check stopping criteria\n            if tol is not None and np.sum(residuals[:, target] ** 2) <= tol:\n                break\n            \n            n_iters += 1\n            \n            if return_path:\n                coef_path.append(coef.copy())\n    \n    # Return results\n    if return_n_iter and return_path:\n        return coef, coef_path, n_iters\n    elif return_n_iter:\n        return coef, n_iters\n    elif return_path:\n        return coef, coef_path\n    else:\n        return coef\n\n# Example usage\nX = np.random.rand(100, 10)\ny = np.random.rand(100)\ncoef = orthogonal_mp(X, y, n_nonzero_coefs=5)\nprint(\"Coefficients:\", coef)\n```\n\n### Explanation:\n\n1. **Input Validation and Preparation:**\n   - Convert `X` and `y` to numpy arrays.\n   - Ensure `y` is 2D for consistent processing, even if it has a single target.\n\n2. **Initialize Variables:**\n   - `coef` stores the coefficients for each feature and target.\n   - `residuals` is initialized as a copy of `y` to track the difference between the observed and predicted values.\n   - `selected_features` keeps track of the indices of features selected during the process.\n   - `coef_path` stores the path of coefficients if `return_path` is `True`.\n   - `n_iters` counts the number of iterations.\n\n3. **Iterative Feature Selection:**\n   - For each target, compute the correlation between the residual and each feature.\n   - Select the feature with the highest absolute correlation that hasn't been selected yet.\n   - Solve the least squares problem to update coefficients for the selected features.\n   - Update the residuals and check stopping criteria based on `n_nonzero_coefs` or `tol`.\n   - If `return_path` is `True`, append the current coefficients to `coef_path`.\n\n4. **Return Results:**\n   - Depending on the flags `return_n_iter` and `return_path`, return the appropriate results.\n\nThis implementation provides a flexible and customizable OMP algorithm, allowing users to specify constraints and receive detailed output as needed.",
    "prompt": "Generate a Python function called orthogonal_mp that implements the Orthogonal Matching Pursuit (OMP) algorithm. The function takes in input parameters X (array-like of shape (n_samples, n_features)) and y (ndarray of shape (n_samples,) or (n_samples, n_targets)), along with optional parameters such as n_nonzero_coefs, tol, precompute, copy_X, return_path, and return_n_iter. \n\nThe function solves n_targets OMP problems by finding the coefficients of the OMP solution based on the input data X and targets y. The OMP problem is defined as finding the coefficients that minimize the residual error subject to constraints on the number of non-zero coefficients or the maximum squared norm of the residual.\n\nThe function returns the coefficients (coef) of the OMP solution as an ndarray of shape (n_features,) or (n_features, n_targets), along with the number of active features across every target (n_iters) if return_n_iter is set to True. Additionally, the function provides options to return the coefficient path and the number of iterations.\n\nThe OMP algorithm is based on the work by Mallat and Zhang in 1993 and Rubinstein, Zibulevsky, and Elad in 2008. The function includes examples demonstrating the usage of orthogonal_mp with sample data.",
    "function_name": "orthogonal_mp",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Table"
}