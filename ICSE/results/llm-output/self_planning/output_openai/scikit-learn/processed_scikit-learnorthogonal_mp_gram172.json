{
    "result": "Here's the implementation of the `orthogonal_mp_gram` function following the structured approach you outlined. This function implements the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems:\n\n```python\nimport numpy as np\nfrom numpy.linalg import lstsq\n\ndef orthogonal_mp_gram(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):\n    # Validate inputs\n    X = np.array(X, copy=copy_X)\n    y = np.array(y)\n    n_samples, n_features = X.shape\n    \n    if n_nonzero_coefs is None:\n        n_nonzero_coefs = max(1, int(0.1 * n_features))\n    \n    if n_nonzero_coefs > n_features:\n        raise ValueError(\"Number of non-zero coefficients cannot exceed the number of features.\")\n    \n    if precompute in [True, 'auto']:\n        G = X.T @ X\n    else:\n        G = None\n    \n    # Initialize variables\n    indices = []\n    coef = np.zeros(n_features)\n    r = y.copy()\n    coef_path = []\n    \n    for n_iter in range(n_nonzero_coefs):\n        # Compute correlations\n        if G is not None:\n            correlations = X.T @ r\n        else:\n            correlations = np.dot(X.T, r)\n        \n        # Select the feature with the highest correlation\n        best_feature = np.argmax(np.abs(correlations))\n        indices.append(best_feature)\n        \n        # Solve least squares problem\n        X_selected = X[:, indices]\n        coef_selected, _, _, _ = lstsq(X_selected, y, rcond=None)\n        \n        # Update coefficients\n        coef[indices] = coef_selected\n        \n        # Update residual\n        r = y - X_selected @ coef_selected\n        \n        # Store coefficient path\n        if return_path:\n            coef_path.append(coef.copy())\n        \n        # Check for convergence\n        if tol is not None and np.sum(r**2) <= tol:\n            break\n    \n    # Prepare return values\n    result = [coef]\n    if return_path:\n        result.append(np.array(coef_path))\n    if return_n_iter:\n        result.append(n_iter + 1)\n    \n    return tuple(result) if len(result) > 1 else result[0]\n```\n\n### Explanation\n\n1. **Input Validation and Preparation:**\n   - The function first converts `X` and `y` to NumPy arrays and checks the dimensions.\n   - It sets `n_nonzero_coefs` to 10% of the number of features if not provided.\n   - It raises a `ValueError` if `n_nonzero_coefs` exceeds the number of features.\n\n2. **Precompute the Gram Matrix:**\n   - If `precompute` is `True` or `'auto'`, the Gram matrix `G = X^T X` is computed for efficiency.\n\n3. **Initialize Variables:**\n   - An empty list `indices` is used to store selected feature indices.\n   - `coef` is initialized as a zero array to store the coefficients.\n   - `r` is initialized as a copy of `y` to represent the residual.\n   - `coef_path` is used to store the coefficient path if `return_path` is `True`.\n\n4. **Iterative Feature Selection:**\n   - For each iteration, the function computes the correlation between the residual and each feature.\n   - It selects the feature with the highest absolute correlation and updates the list of selected features.\n   - It solves the least squares problem to update the coefficients for the selected features.\n   - It updates the residual `r` and checks for convergence if `tol` is provided.\n\n5. **Return Results:**\n   - The function returns the final coefficients, and optionally the coefficient path and number of iterations, based on the input flags `return_path` and `return_n_iter`.\n\nThis implementation efficiently handles the OMP algorithm with options for precomputation and additional output details.",
    "prompt": "Create a Python function `orthogonal_mp_gram` that implements the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems. The function should accept the following parameters:\n- `X`: A 2D array-like of shape `(n_samples, n_features)` representing the input data. Columns should be assumed to have unit norm.\n- `y`: A 1D or 2D array-like of shape `(n_samples,)` or `(n_samples, n_targets)` representing the target values.\n- `n_nonzero_coefs`: An integer specifying the desired number of non-zero coefficients in the solution. If `None`, this defaults to 10% of the number of features.\n- `tol`: A float specifying the maximum squared norm of the residual. If provided, this overrides `n_nonzero_coefs`.\n- `precompute`: A boolean or the string `'auto'` indicating whether to precompute the Gram matrix for faster computation when `n_targets` or `n_samples` is large.\n- `copy_X`: A boolean indicating whether to copy the input matrix `X` (default is `True`).\n- `return_path`: A boolean indicating whether to return the entire coefficient path for each iteration.\n- `return_n_iter`: A boolean indicating whether to return the number of iterations taken for convergence.\n\nThe function should return the coefficients of the OMP solution as a 1D or 2D NumPy array, depending on the input, with an option to return the number of iterations if `return_n_iter` is `True`. Handle edge cases such as when the number of non-zero coefficients exceeds the number of features by raising a `ValueError`. The function should use efficient computation techniques, including the option to precompute the Gram matrix if `precompute` is enabled.",
    "function_name": "orthogonal_mp_gram",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Classification",
    "data": "Table"
}