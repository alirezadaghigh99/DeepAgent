{
    "result": "Here's the implementation of the `contingency_matrix` function following the structured approach you outlined:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,)\n    - labels_pred: array-like of shape (n_samples,)\n    - eps: float, optional\n    - sparse: bool, optional\n    - dtype: numeric type, optional\n\n    Returns:\n    - Contingency matrix of shape [n_classes_true, n_classes_pred]\n    \"\"\"\n    # Convert inputs to numpy arrays\n    labels_true = np.asarray(labels_true)\n    labels_pred = np.asarray(labels_pred)\n\n    # Validate input lengths\n    if labels_true.shape[0] != labels_pred.shape[0]:\n        raise ValueError(\"labels_true and labels_pred must have the same length.\")\n\n    # Determine unique classes\n    classes_true = np.unique(labels_true)\n    classes_pred = np.unique(labels_pred)\n\n    # Create a mapping from class labels to indices\n    class_idx_true = {label: idx for idx, label in enumerate(classes_true)}\n    class_idx_pred = {label: idx for idx, label in enumerate(classes_pred)}\n\n    # Initialize the contingency matrix\n    n_classes_true = len(classes_true)\n    n_classes_pred = len(classes_pred)\n    if sparse:\n        contingency = csr_matrix((n_classes_true, n_classes_pred), dtype=dtype)\n    else:\n        contingency = np.zeros((n_classes_true, n_classes_pred), dtype=dtype or int)\n\n    # Populate the contingency matrix\n    for true_label, pred_label in zip(labels_true, labels_pred):\n        i = class_idx_true[true_label]\n        j = class_idx_pred[pred_label]\n        contingency[i, j] += 1\n\n    # Apply epsilon adjustment if needed\n    if eps is not None:\n        contingency = contingency.astype(float)\n        contingency += eps\n\n    return contingency\n\n# Example usage:\n# labels_true = [0, 0, 1, 1, 2, 2]\n# labels_pred = [0, 0, 1, 2, 2, 2]\n# print(contingency_matrix(labels_true, labels_pred))\n```\n\n### Explanation:\n\n1. **Import Libraries**: We import `numpy` for array operations and `scipy.sparse` for handling sparse matrices.\n\n2. **Function Definition**: The function `contingency_matrix` is defined with parameters for true labels, predicted labels, epsilon, sparse option, and data type.\n\n3. **Input Validation**: We ensure that `labels_true` and `labels_pred` are of the same length, raising a `ValueError` if not.\n\n4. **Determine Unique Classes**: We use `np.unique` to find unique classes in both true and predicted labels.\n\n5. **Initialize Contingency Matrix**: Depending on the `sparse` parameter, we initialize either a dense or sparse matrix.\n\n6. **Populate Contingency Matrix**: We iterate over the label pairs and increment the appropriate matrix cell.\n\n7. **Apply Epsilon Adjustment**: If `eps` is provided, we convert the matrix to float and add `eps` to each element.\n\n8. **Return the Matrix**: The function returns the contingency matrix, ensuring it is of the specified `dtype`.\n\nThis function provides a flexible way to compute a contingency matrix, accommodating both dense and sparse representations and allowing for adjustments to avoid zero entries.",
    "prompt": "Generate a Python function called contingency_matrix that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function takes in two array-like inputs: labels_true (ground truth class labels) and labels_pred (cluster labels). Additionally, it has optional parameters eps (float), sparse (bool), and dtype (numeric type). \n\nThe function returns a contingency matrix of shape [n_classes_true, n_classes_pred], where each element C[i, j] represents the number of samples in true class i and predicted class j. If eps is not None, the dtype of the output array will be float; otherwise, it will be an integer unless specified with the dtype argument. If sparse is True, a sparse CSR matrix will be returned. \n\nAn example usage of the function is provided in the docstring, where labels_true and labels_pred are given as input, and the resulting contingency matrix is shown.",
    "function_name": "contingency_matrix",
    "ground_truth": "sklearn/metrics/cluster/_supervised.py",
    "test": "sklearn/metrics/cluster/tests/test_supervised.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}