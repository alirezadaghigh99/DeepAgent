{
    "result": "Here's a complete implementation of the `from_estimator` function, which plots a calibration curve using a binary classifier and data. This function follows the steps outlined in your request:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.utils import check_array, check_consistent_length\nfrom sklearn.base import is_classifier\n\nclass CalibrationDisplay:\n    def __init__(self, prob_true, prob_pred, bin_edges):\n        self.prob_true = prob_true\n        self.prob_pred = prob_pred\n        self.bin_edges = bin_edges\n\ndef from_estimator(estimator, X, y, n_bins=10, strategy='uniform', pos_label=None, name=None, ref_line=True, ax=None, **kwargs):\n    # Validate inputs\n    if not is_classifier(estimator):\n        raise ValueError(\"The estimator should be a fitted binary classifier.\")\n    \n    X = check_array(X)\n    check_consistent_length(X, y)\n    \n    # Predict probabilities\n    if hasattr(estimator, \"predict_proba\"):\n        prob_pos = estimator.predict_proba(X)[:, 1]\n    else:\n        raise ValueError(\"The estimator does not have a predict_proba method.\")\n    \n    # Discretize probabilities\n    prob_true, prob_pred = calibration_curve(y, prob_pos, n_bins=n_bins, strategy=strategy, pos_label=pos_label)\n    \n    # Plot calibration curve\n    if ax is None:\n        ax = plt.gca()\n    \n    ax.plot(prob_pred, prob_true, marker='o', label=name, **kwargs)\n    \n    if ref_line:\n        ax.plot([0, 1], [0, 1], linestyle='--', color='gray')\n    \n    ax.set_xlabel(\"Mean predicted probability\")\n    ax.set_ylabel(\"Fraction of positives\")\n    ax.set_title(\"Calibration plot\")\n    \n    if name:\n        ax.legend(loc='best')\n    \n    # Return CalibrationDisplay\n    return CalibrationDisplay(prob_true=prob_true, prob_pred=prob_pred, bin_edges=None)\n\n# Example usage:\n# from sklearn.linear_model import LogisticRegression\n# estimator = LogisticRegression().fit(X_train, y_train)\n# display = from_estimator(estimator, X_test, y_test, n_bins=10)\n```\n\n### Key Points:\n\n1. **Validation**: The function checks if the estimator is a classifier and if the input data `X` and `y` are consistent in length.\n\n2. **Probability Prediction**: It uses the `predict_proba` method to get the predicted probabilities for the positive class. If the estimator does not have this method, an error is raised.\n\n3. **Calibration Curve**: The `calibration_curve` function from `sklearn` is used to compute the mean predicted probabilities and the fraction of positives for each bin.\n\n4. **Plotting**: The function uses `matplotlib` to plot the calibration curve. It optionally includes a reference line (y=x) to indicate perfect calibration.\n\n5. **Customization**: The plot can be customized with a name and additional keyword arguments. The `ax` parameter allows specifying the axes for the plot.\n\n6. **Return Value**: The function returns a `CalibrationDisplay` object containing the computed values, which can be useful for further analysis or testing.\n\nThis implementation provides a flexible and reusable way to visualize the calibration of binary classifiers.",
    "prompt": "Generate a Python function called from_estimator that plots a calibration curve using a binary classifier and data. The function takes in parameters such as estimator (fitted classifier), X (input values), y (binary target values), n_bins (number of bins for discretization), strategy (bin width strategy), pos_label (positive class label), name (label for curve), ref_line (whether to plot a reference line), ax (matplotlib axes), and additional keyword arguments. The function returns a CalibrationDisplay object that stores computed values.",
    "function_name": "from_estimator",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}