{
    "result": "The `cluster_qr` function you've outlined is designed to find the closest discrete partition to an eigenvector embedding using QR decomposition. Let's walk through the implementation step-by-step to ensure clarity and correctness:\n\n```python\nimport numpy as np\n\ndef cluster_qr(vectors):\n    \"\"\"\n    Finds the discrete partition closest to the eigenvector embedding.\n\n    Parameters:\n    - vectors: array-like, shape (n_samples, n_clusters)\n      The embedding space of the samples.\n\n    Returns:\n    - labels: array, shape (n_samples,)\n      The cluster labels of the vectors.\n    \"\"\"\n    # Step 1: Convert vectors to a NumPy array if necessary\n    vectors = np.asarray(vectors)\n    \n    # Validate the shape of the input\n    if vectors.ndim != 2:\n        raise ValueError(\"Input vectors must be a 2D array-like object.\")\n    \n    n_samples, n_clusters = vectors.shape\n    \n    # Step 2: Perform QR decomposition\n    Q, R = np.linalg.qr(vectors)\n    \n    # Step 3: Assign cluster labels based on the maximum value in each row of Q\n    labels = np.argmax(Q, axis=1)\n    \n    # Step 4: Return the cluster labels\n    return labels\n```\n\n### Explanation:\n\n1. **Input Validation and Preparation**:\n   - The function first ensures that the input `vectors` is a 2D array. If not, it raises a `ValueError`.\n   - It uses `np.asarray` to convert the input to a NumPy array, which is necessary for performing numerical operations efficiently.\n\n2. **QR Decomposition**:\n   - The QR decomposition is performed using `np.linalg.qr`, which decomposes the `vectors` matrix into an orthogonal matrix `Q` and an upper triangular matrix `R`.\n   - The orthogonal matrix `Q` is used to determine the cluster assignments.\n\n3. **Assign Cluster Labels**:\n   - For each sample (row) in the `Q` matrix, the function finds the index of the maximum value using `np.argmax(Q, axis=1)`. This index is used as the cluster label for that sample.\n   - This step effectively assigns each sample to the cluster whose corresponding eigenvector component is largest.\n\n4. **Output the Cluster Labels**:\n   - The function returns the array of cluster labels, which has the shape `(n_samples,)`.\n\nThis implementation is efficient and leverages the properties of QR decomposition to find the closest discrete partition to the eigenvector embedding. The use of `np.argmax` ensures that each sample is assigned to the cluster with the highest influence in the orthogonal space defined by `Q`.",
    "prompt": "Generate a Python function called cluster_qr that finds the discrete partition closest to the eigenvector embedding. The input is an array-like object called vectors with shape (n_samples, n_clusters) representing the embedding space of the samples. The output is an array of integers called labels with shape n_samples, representing the cluster labels of the vectors.",
    "function_name": "cluster_qr",
    "ground_truth": "sklearn/cluster/_spectral.py",
    "test": "sklearn/cluster/tests/test_spectral.py::test_spectral_clustering",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": ""
}