{
    "result": "Certainly! Let's walk through the implementation of the `johnson_lindenstrauss_min_dim` function, which calculates the minimum number of dimensions required for a random projection to ensure an `eps`-embedding with good probability, based on the Johnson-Lindenstrauss lemma.\n\nHere's the complete implementation:\n\n```python\nimport numpy as np\n\ndef johnson_lindenstrauss_min_dim(n_samples, eps):\n    \"\"\"\n    Calculate the minimum number of components required for a random projection\n    to ensure an eps-embedding with good probability for the given number of samples.\n\n    Parameters:\n    - n_samples: int or array-like, the number of samples.\n    - eps: float or array-like, the maximum distortion rate.\n\n    Returns:\n    - int or np.ndarray: The minimal number of components required.\n    \n    References:\n    - Johnson-Lindenstrauss lemma\n    \"\"\"\n    # Ensure inputs are array-like for consistent processing\n    n_samples = np.atleast_1d(n_samples)\n    eps = np.atleast_1d(eps)\n    \n    # Validate the distortion rate\n    if np.any(eps <= 0) or np.any(eps >= 1):\n        raise ValueError(\"eps must be between 0 and 1 (exclusive).\")\n    \n    # Calculate the minimum number of dimensions using the Johnson-Lindenstrauss bound\n    min_dim = (4 * np.log(n_samples)) / (eps**2 / 2 - eps**3 / 3)\n    \n    # Return the ceiling of the calculated dimensions as integers\n    return np.ceil(min_dim).astype(int)\n\n# Example usage:\n# Calculate the minimum number of dimensions for 1000 samples with a distortion rate of 0.1\nmin_components = johnson_lindenstrauss_min_dim(1000, 0.1)\nprint(min_components)\n\n# Example with array-like inputs\nn_samples_array = [100, 1000, 10000]\neps_array = [0.1, 0.2, 0.3]\nmin_components_array = johnson_lindenstrauss_min_dim(n_samples_array, eps_array)\nprint(min_components_array)\n```\n\n### Explanation:\n\n1. **Input Handling**: The function accepts both scalar and array-like inputs for `n_samples` and `eps`. The `np.atleast_1d` function ensures that these inputs are treated as arrays, which simplifies the computation and allows for element-wise operations.\n\n2. **Validation**: The function checks that the distortion rate `eps` is within the valid range (0, 1). If not, it raises a `ValueError`.\n\n3. **Calculation**: The formula derived from the Johnson-Lindenstrauss lemma is used to compute the minimum number of dimensions required. The formula is:\n   \\[\n   k \\geq \\frac{4 \\cdot \\ln(n)}{\\text{eps}^2 / 2 - \\text{eps}^3 / 3}\n   \\]\n   This ensures that the distances between points are preserved within the specified distortion rate.\n\n4. **Output**: The function returns the ceiling of the calculated dimensions as integers, which represents the minimum number of dimensions required.\n\n5. **Examples**: The function includes examples demonstrating how to use it with both scalar and array-like inputs.\n\nThis implementation provides a flexible and efficient way to determine the necessary dimensions for a random projection based on the Johnson-Lindenstrauss lemma.",
    "prompt": "Generate a Python function called johnson_lindenstrauss_min_dim that calculates the minimum number of components needed to guarantee a distortion rate within a specified range for a random projection. The function takes in the number of samples (n_samples) as an integer or array-like input and the maximum distortion rate (eps) as a float or array-like input. It returns the minimal number of components required to ensure an eps-embedding with good probability for the given number of samples. The function also includes references to the Johnson-Lindenstrauss lemma and provides examples of usage.",
    "function_name": "johnson_lindenstrauss_min_dim",
    "ground_truth": "sklearn/random_projection.py",
    "test": "sklearn/tests/test_random_projection.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Table"
}