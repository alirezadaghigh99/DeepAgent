{
    "result": "The function `axis_angle_to_rotation_matrix` converts a 3D vector of axis-angle rotations into a 3x3 rotation matrix using the Rodrigues' rotation formula. Here's a detailed breakdown of the implementation:\n\n```python\nimport torch\n\ndef axis_angle_to_rotation_matrix(axis_angle):\n    # Ensure input is a tensor\n    axis_angle = torch.tensor(axis_angle, dtype=torch.float32)\n    \n    # Compute the angle (magnitude of the vector)\n    angles = torch.norm(axis_angle, dim=1, keepdim=True)\n    \n    # Avoid division by zero by setting zero angles to one (will be handled later)\n    angles_safe = angles.clone()\n    angles_safe[angles_safe == 0] = 1.0\n    \n    # Normalize the axis\n    axis = axis_angle / angles_safe\n    \n    # Compute sine and cosine of angles\n    sin_theta = torch.sin(angles)\n    cos_theta = torch.cos(angles)\n    \n    # Compute the skew-symmetric matrix for each axis\n    K = torch.zeros((axis.shape[0], 3, 3), dtype=torch.float32)\n    K[:, 0, 1] = -axis[:, 2]\n    K[:, 0, 2] = axis[:, 1]\n    K[:, 1, 0] = axis[:, 2]\n    K[:, 1, 2] = -axis[:, 0]\n    K[:, 2, 0] = -axis[:, 1]\n    K[:, 2, 1] = axis[:, 0]\n    \n    # Compute the rotation matrix using Rodrigues' formula\n    I = torch.eye(3, dtype=torch.float32).unsqueeze(0)  # Identity matrix\n    R = I + sin_theta.unsqueeze(-1) * K + (1 - cos_theta.unsqueeze(-1)) * torch.bmm(K, K)\n    \n    # Handle zero angles by setting the corresponding rotation matrix to identity\n    R[angles.squeeze() == 0] = I\n    \n    return R\n\n# Example usage\ninput_tensor = torch.tensor([[0., 0., 0.], [1.5708, 0., 0.]])\nrotation_matrices = axis_angle_to_rotation_matrix(input_tensor)\nprint(rotation_matrices)\n```\n\n### Explanation:\n\n1. **Input Handling**: \n   - The function starts by ensuring the input is a PyTorch tensor of type `float32`.\n\n2. **Angle Calculation**:\n   - The angle of rotation is calculated as the norm (magnitude) of each vector in the input tensor.\n\n3. **Normalization**:\n   - To avoid division by zero, angles that are zero are temporarily set to one. This is corrected later by setting the corresponding rotation matrices to the identity matrix.\n\n4. **Axis Normalization**:\n   - Each axis vector is normalized by dividing by the computed angle, resulting in a unit vector.\n\n5. **Rodrigues' Rotation Formula**:\n   - The skew-symmetric matrix \\( K \\) is constructed for each axis.\n   - The rotation matrix \\( R \\) is computed using the formula:\n     \\[\n     R = I + \\sin(\\theta) \\cdot K + (1 - \\cos(\\theta)) \\cdot K^2\n     \\]\n   - Here, \\( I \\) is the identity matrix, and \\( K \\) is the skew-symmetric matrix of the axis.\n\n6. **Handling Zero Rotations**:\n   - For vectors with zero magnitude (i.e., no rotation), the corresponding rotation matrix is set to the identity matrix.\n\n7. **Output**:\n   - The function returns a tensor of rotation matrices with shape `(N, 3, 3)`.\n\nThis implementation efficiently converts axis-angle representations to rotation matrices, handling edge cases like zero rotations gracefully.",
    "prompt": "Write a python function axis_angle_to_rotation_matrix thatConvert 3d vector of axis-angle rotation to 3x3 rotation matrix.\n\n    Args:\n        axis_angle: tensor of 3d vector of axis-angle rotations in radians with shape :math:`(N, 3)`.\n\n    Returns:\n        tensor of rotation matrices of shape :math:`(N, 3, 3)`.\n\n    Example:\n        >>> input = tensor([[0., 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[1., 0., 0.],\n                 [0., 1., 0.],\n                 [0., 0., 1.]]])\n\n        >>> input = tensor([[1.5708, 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[ 1.0000e+00,  0.0000e+00,  0.0000e+00],\n                 [ 0.0000e+00, -3.6200e-06, -1.0000e+00],\n                 [ 0.0000e+00,  1.0000e+00, -3.6200e-06]]]]",
    "function_name": "axis_angle_to_rotation_matrix",
    "ground_truth": "kornia/geometry/conversions.py#L267",
    "test": "tests/geometry/test_conversions.py::TestAngleAxisToRotationMatrix",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}