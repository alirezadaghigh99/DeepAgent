{
    "result": "Here's the `spatial_gradient` function implemented in Python, following the outlined steps:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef spatial_gradient(input_image, mode='sobel', order=1, normalized=False):\n    # Validate inputs\n    if input_image.dim() != 4:\n        raise ValueError(\"Input image must have shape (B, C, H, W)\")\n    if mode not in ['sobel', 'diff']:\n        raise ValueError(\"Mode must be either 'sobel' or 'diff'\")\n    if not isinstance(order, int) or order < 1:\n        raise ValueError(\"Order must be a positive integer\")\n    if not isinstance(normalized, bool):\n        raise ValueError(\"Normalized must be a boolean\")\n\n    # Define kernels\n    if mode == 'sobel':\n        kernel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)\n        kernel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)\n    else:  # mode == 'diff'\n        kernel_x = torch.tensor([[-1, 0, 1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)\n        kernel_y = torch.tensor([[-1], [0], [1]], dtype=torch.float32).unsqueeze(0).unsqueeze(0)\n\n    # Apply convolution\n    B, C, H, W = input_image.shape\n    grad_x = F.conv2d(input_image.view(B * C, 1, H, W), kernel_x, padding=1, groups=1)\n    grad_y = F.conv2d(input_image.view(B * C, 1, H, W), kernel_y, padding=1, groups=1)\n\n    # Handle derivative order\n    for _ in range(1, order):\n        grad_x = F.conv2d(grad_x, kernel_x, padding=1, groups=1)\n        grad_y = F.conv2d(grad_y, kernel_y, padding=1, groups=1)\n\n    # Reshape to (B, C, 2, H, W)\n    grad_x = grad_x.view(B, C, H, W)\n    grad_y = grad_y.view(B, C, H, W)\n    gradients = torch.stack((grad_x, grad_y), dim=2)\n\n    # Normalize output if required\n    if normalized:\n        gradients = gradients / gradients.abs().max()\n\n    return gradients\n\n# Example usage\ninput_image = torch.rand(2, 3, 256, 256)  # Example input tensor\ngradients = spatial_gradient(input_image, mode='sobel', order=1, normalized=True)\nprint(gradients.shape)  # Should output: (2, 3, 2, 256, 256)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks that the input image tensor has the correct shape `(B, C, H, W)`, and validates the `mode`, `order`, and `normalized` parameters.\n\n2. **Kernel Definition**: Depending on the `mode`, it defines the appropriate kernels for computing the derivatives. The Sobel kernels are used for edge detection, while the difference kernels are simpler and compute basic differences.\n\n3. **Convolution**: The function applies 2D convolution to compute the gradients in the x and y directions. The input image is reshaped to handle each channel separately.\n\n4. **Derivative Order**: If the `order` is greater than 1, the convolution is applied multiple times to achieve higher-order derivatives.\n\n5. **Normalization**: If `normalized` is `True`, the gradients are normalized to a specific range.\n\n6. **Output**: The function returns the gradients stacked along a new dimension, resulting in a tensor of shape `(B, C, 2, H, W)`.\n\n### Example Usage:\n\nThe example demonstrates how to use the function with a random input tensor, specifying the Sobel mode, first-order derivatives, and normalization. The output shape is verified to be `(2, 3, 2, 256, 256)`, indicating the gradients in both x and y directions for each channel and batch.",
    "prompt": "Generate a Python function called spatial_gradient that computes the first-order image derivative in both x and y using a Sobel operator. The function takes in an input image tensor with shape (B, C, H, W), a mode parameter specifying the derivatives modality (either 'sobel' or 'diff'), an order parameter indicating the order of the derivatives, and a normalized parameter determining whether the output is normalized. The function returns the derivatives of the input feature map with shape (B, C, 2, H, W). The function also includes examples demonstrating its usage.",
    "function_name": "spatial_gradient",
    "ground_truth": "kornia/filters/sobel.py",
    "test": "tests/filters/test_sobel.py::TestSpatialGradient",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Image"
}