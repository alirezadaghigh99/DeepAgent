{
    "result": "Let's focus on implementing the `rgb_to_hls` function, which converts an RGB image to HLS format using PyTorch. Here's a step-by-step breakdown of the implementation:\n\n### `rgb_to_hls` Function\n\n**Plan:**\n\n1. **Validate Input:**\n   - Ensure the input is a PyTorch tensor.\n   - Check that the input tensor has the shape `(*, 3, H, W)`.\n\n2. **Convert RGB to HLS:**\n   - Extract the R, G, and B channels.\n   - Compute the maximum and minimum values across the RGB channels.\n   - Calculate luminance (L) as the average of the max and min values.\n   - Compute saturation (S) based on the luminance.\n   - Calculate hue (H) using the differences between the RGB channels.\n\n3. **Return HLS Image:**\n   - Stack the H, L, and S components back into a tensor and return it.\n\n**Implementation:**\n\n```python\nimport torch\n\ndef rgb_to_hls(image, eps=1e-10):\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    if image.shape[-3] != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W).\")\n\n    # Extract R, G, B channels\n    r, g, b = image.unbind(dim=-3)\n    \n    # Compute max and min across the RGB channels\n    max_rgb, _ = torch.max(image, dim=-3)\n    min_rgb, _ = torch.min(image, dim=-3)\n    \n    # Calculate luminance\n    l = (max_rgb + min_rgb) / 2\n    \n    # Calculate saturation\n    delta = max_rgb - min_rgb\n    s = torch.where(l < 0.5, delta / (max_rgb + min_rgb + eps), delta / (2.0 - max_rgb - min_rgb + eps))\n    \n    # Calculate hue\n    h = torch.zeros_like(l)\n    mask = delta > eps\n    h[mask] = torch.where(max_rgb == r, (g - b) / delta, h)[mask]\n    h[mask] = torch.where(max_rgb == g, 2.0 + (b - r) / delta, h)[mask]\n    h[mask] = torch.where(max_rgb == b, 4.0 + (r - g) / delta, h)[mask]\n    h = (h / 6.0) % 1.0\n    \n    # Stack H, L, S channels\n    hls = torch.stack((h, l, s), dim=-3)\n    return hls\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a random RGB image tensor with shape (1, 3, H, W)\n    image = torch.rand(1, 3, 256, 256)\n    hls_image = rgb_to_hls(image)\n    print(hls_image.shape)  # Should output: torch.Size([1, 3, 256, 256])\n```\n\n### Explanation:\n\n- **Input Validation:** The function first checks if the input is a PyTorch tensor and if it has the correct shape. If not, it raises appropriate errors.\n- **RGB to HLS Conversion:** The function calculates the HLS components using the RGB values. The hue calculation involves determining which channel (R, G, or B) is the maximum and then computing the hue based on the differences between the channels.\n- **Output:** The function returns the HLS image with the same shape as the input.\n\nThis implementation should meet the requirements for converting an RGB image to HLS format using PyTorch.",
    "prompt": "Generate a Python function called rgb_to_hls that converts an RGB image to HLS format. The function takes in a PyTorch tensor called image representing the RGB image with shape (*, 3, H, W) and an epsilon value eps to avoid division by zero. The image data is assumed to be in the range of (0, 1).\n\nThe function returns the HLS version of the input image with the same shape (*, 3, H, W). If the input image is not a PyTorch tensor, a TypeError is raised. If the input size does not have a shape of (*, 3, H, W), a ValueError is raised.\n\nThe conversion process involves calculating the HLS components (hue, luminance, saturation) based on the RGB values of the input image. The resulting HLS image is returned as a PyTorch tensor.\n\nAn example usage of the rgb_to_hls function is provided in the code snippet, where a random input RGB image tensor is converted to HLS format. Raise the value error if there input not instance of image or there was a problem with shape",
    "function_name": "rgb_to_hls",
    "ground_truth": "kornia/color/hls.py",
    "test": "tests/color/test_hls.py::TestRgbToHls",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}