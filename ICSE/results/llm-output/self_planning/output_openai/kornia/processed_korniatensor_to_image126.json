{
    "result": "Here's the `tensor_to_image` function that converts a PyTorch tensor image to a NumPy array image, following the steps you outlined:\n\n```python\nimport torch\nimport numpy as np\n\ndef tensor_to_image(tensor, keepdim=True, force_contiguous=False):\n    # Step 1: Input Validation\n    if not isinstance(tensor, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    if tensor.dim() not in [2, 3, 4]:\n        raise ValueError(\"Input tensor must have 2, 3, or 4 dimensions.\")\n    \n    # Step 2: Handle GPU Tensors\n    if tensor.is_cuda:\n        tensor = tensor.cpu()\n    \n    # Step 3: Ensure Contiguity\n    if force_contiguous:\n        tensor = tensor.contiguous()\n    \n    # Step 4: Convert to NumPy\n    np_image = tensor.numpy()\n    \n    # Step 5: Adjust Dimensions\n    if tensor.dim() == 2:\n        # Shape: (H, W)\n        return np_image\n    elif tensor.dim() == 3:\n        # Shape: (C, H, W) -> (H, W, C)\n        np_image = np.transpose(np_image, (1, 2, 0))\n    elif tensor.dim() == 4:\n        # Shape: (B, C, H, W) -> (B, H, W, C)\n        np_image = np.transpose(np_image, (0, 2, 3, 1))\n        if not keepdim and np_image.shape[0] == 1:\n            np_image = np_image.squeeze(0)\n    \n    # Step 6: Return the Result\n    return np_image\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input is a PyTorch tensor and if it has a valid number of dimensions (2, 3, or 4). If not, it raises an appropriate error.\n\n2. **Handle GPU Tensors**: If the tensor is on a GPU, it is moved to the CPU using `.cpu()`.\n\n3. **Ensure Contiguity**: If `force_contiguous` is `True`, the tensor is made contiguous using `.contiguous()`.\n\n4. **Convert to NumPy**: The tensor is converted to a NumPy array using `.numpy()`.\n\n5. **Adjust Dimensions**: \n   - For 2D tensors, the shape is `(H, W)`.\n   - For 3D tensors, the shape is adjusted from `(C, H, W)` to `(H, W, C)`.\n   - For 4D tensors, the shape is adjusted from `(B, C, H, W)` to `(B, H, W, C)`. If `keepdim` is `False` and the batch size is 1, the batch dimension is squeezed.\n\n6. **Return the Result**: The function returns the NumPy array with the appropriate shape.\n\nThis function should handle most common cases of converting PyTorch tensor images to NumPy arrays, including those stored on a GPU.",
    "prompt": "Create a Python function `tensor_to_image` that converts a PyTorch tensor image to a NumPy array image. The function should:\n\n- Accept a tensor as input, which can have one of the following shapes: `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- Convert the tensor to a NumPy array, handling cases where the tensor is in GPU memory by copying it back to CPU.\n- Optionally, squeeze the dimensions if `keepdim` is `False`.\n- Ensure the tensor is contiguous if `force_contiguous` is `True`.\n- Return the converted image with the appropriate shape: `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nInput types:\n- `tensor`: A PyTorch tensor of shape `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- `keepdim`: A boolean indicating whether to retain the batch dimension.\n- `force_contiguous`: A boolean indicating whether to make the tensor contiguous.\n\nOutput:\n- Returns a NumPy array representing the image with the shape `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nErrors:\n- Raise a `TypeError` if the input is not a Tensor.\n- Raise a `ValueError` if the input tensor's dimensions are not 2, 3, or 4.",
    "function_name": "tensor_to_image",
    "ground_truth": "kornia/utils/image.py",
    "test": "tests/utils/test_image_utils.py::test_tensor_to_image",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}