{
    "result": "To implement the `forward` function for the `Affine` class, we need to construct and apply an affine transformation matrix to a batch of input tensors. Here's the complete implementation:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom typing import Optional\n\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        super(Affine, self).__init__()\n        self.angle = angle if angle is not None else torch.tensor(0.0)\n        self.translation = translation if translation is not None else torch.tensor([0.0, 0.0])\n        self.scale_factor = scale_factor if scale_factor is not None else torch.tensor([1.0, 1.0])\n        self.shear = shear if shear is not None else torch.tensor([0.0, 0.0])\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        batch_size, channels, height, width = input.size()\n        \n        # Compute the center if not provided\n        if self.center is None:\n            self.center = torch.tensor([width / 2, height / 2])\n\n        # Compute rotation matrix\n        angle_rad = self.angle * (torch.pi / 180.0)\n        cos_a = torch.cos(angle_rad)\n        sin_a = torch.sin(angle_rad)\n        rotation_matrix = torch.tensor([\n            [cos_a, -sin_a, 0],\n            [sin_a, cos_a, 0],\n            [0, 0, 1]\n        ])\n\n        # Compute translation matrix\n        translation_matrix = torch.tensor([\n            [1, 0, self.translation[0]],\n            [0, 1, self.translation[1]],\n            [0, 0, 1]\n        ])\n\n        # Compute scaling matrix\n        scaling_matrix = torch.tensor([\n            [self.scale_factor[0], 0, 0],\n            [0, self.scale_factor[1], 0],\n            [0, 0, 1]\n        ])\n\n        # Compute shearing matrix\n        shear_x, shear_y = self.shear\n        shearing_matrix = torch.tensor([\n            [1, shear_x, 0],\n            [shear_y, 1, 0],\n            [0, 0, 1]\n        ])\n\n        # Compute centering matrix\n        center_x, center_y = self.center\n        centering_matrix = torch.tensor([\n            [1, 0, center_x],\n            [0, 1, center_y],\n            [0, 0, 1]\n        ])\n\n        # Compute decentering matrix\n        decentering_matrix = torch.tensor([\n            [1, 0, -center_x],\n            [0, 1, -center_y],\n            [0, 0, 1]\n        ])\n\n        # Combine transformations\n        affine_matrix = centering_matrix @ rotation_matrix @ scaling_matrix @ shearing_matrix @ decentering_matrix @ translation_matrix\n\n        # Extract the 2x3 part for affine_grid\n        affine_matrix = affine_matrix[:2, :]\n\n        # Create grid and apply transformation\n        grid = F.affine_grid(affine_matrix.unsqueeze(0).expand(batch_size, -1, -1), input.size(), align_corners=self.align_corners)\n        transformed = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return transformed\n```\n\n### Explanation\n\n- **Affine Matrix Construction**: The affine matrix is constructed by combining rotation, translation, scaling, shearing, and centering transformations. Each transformation is represented as a 3x3 matrix, and they are multiplied together to form the final affine matrix.\n- **Grid Sampling**: The `affine_grid` function creates a grid based on the affine matrix, and `grid_sample` applies this grid to the input tensor, effectively transforming it.\n- **Handling Defaults**: Default values are provided for all transformation parameters to ensure the function can handle cases where some parameters are not specified.\n\nThis implementation provides a flexible and efficient way to apply multiple affine transformations to a batch of images using PyTorch.",
    "prompt": "Write a Python function `forward` for the `Affine` class that applies multiple elementary affine transformations (rotation, translation, scaling, and shearing) to a batch of input tensors. The function takes a 4D tensor with shape `[batch_size, channels, height, width]` as input and returns a transformed tensor of the same shape. The affine transformation is computed using parameters such as `angle`, `translation`, `scale_factor`, `shear`, and `center`, with optional interpolation modes and padding options.\n\n```python\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        # Initialization code...\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n``` \n\nThe `forward` function constructs an affine transformation matrix based on the provided parameters and applies this transformation to the input tensor.",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestAffine2d",
    "class": "Affine",
    "stage": "Image",
    "task": "",
    "data": "Model construction"
}