{
    "result": "Here's the complete implementation of the `rgb_to_grayscale` function, following the steps outlined in your plan:\n\n```python\nimport torch\n\ndef rgb_to_grayscale(image, rgb_weights=None):\n    # Validate input shape\n    if image.ndim < 3 or image.shape[-3] != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    # Determine default weights based on data type\n    if rgb_weights is None:\n        if image.dtype == torch.uint8:\n            rgb_weights = torch.tensor([76, 150, 29], dtype=image.dtype, device=image.device)\n        elif torch.is_floating_point(image):\n            rgb_weights = torch.tensor([0.299, 0.587, 0.114], dtype=image.dtype, device=image.device)\n        else:\n            raise TypeError(\"Unsupported image data type\")\n    \n    # Normalize weights if they are not already\n    rgb_weights = rgb_weights / rgb_weights.sum()\n\n    # Validate weights\n    if not torch.isclose(rgb_weights.sum(), torch.tensor(1.0, dtype=rgb_weights.dtype, device=rgb_weights.device)):\n        raise ValueError(\"The sum of rgb_weights must be 1\")\n\n    # Convert RGB to Grayscale\n    grayscale = (image * rgb_weights.view(1, 3, 1, 1)).sum(dim=-3, keepdim=True)\n\n    # Return the grayscale image\n    return grayscale\n```\n\n### Key Points:\n\n1. **Input Shape Validation**: The function checks if the input tensor has at least three dimensions and that the third-to-last dimension has a size of 3, which corresponds to the RGB channels.\n\n2. **Default Weights**: The function assigns default weights based on the data type of the image. For `uint8` images, it uses integer weights `[76, 150, 29]`, and for floating-point images, it uses `[0.299, 0.587, 0.114]`.\n\n3. **Weight Normalization**: The weights are normalized to ensure their sum is 1, which is crucial for maintaining the correct intensity range in the grayscale image.\n\n4. **Grayscale Conversion**: The function multiplies each RGB channel by its corresponding weight and sums the results to produce the grayscale image.\n\n5. **Output Shape**: The grayscale image is returned with the shape `(*, 1, H, W)`, maintaining the batch and spatial dimensions of the input.\n\n6. **Device Compatibility**: The function ensures that the weights are on the same device as the input image, which is important for GPU compatibility.\n\nThis implementation should work for both `uint8` and floating-point images, and it will raise appropriate errors for unsupported data types or incorrect input shapes.",
    "prompt": "Create a Python function `rgb_to_grayscale` that converts an RGB image to its grayscale version. The function should:\n\n- Accept an `image` tensor with shape `(*, 3, H, W)` representing the RGB image.\n- Optionally accept `rgb_weights`, a tensor containing weights for the RGB channels. The sum of these weights should be 1.\n- If `rgb_weights` is not provided, default weights based on the image data type should be used: `[76, 150, 29]` for `uint8` images and `[0.299, 0.587, 0.114]` for floating-point images.\n- Validate that the input tensor has the correct shape and raise a `ValueError` if not.\n- Convert the RGB image to grayscale using the provided or default weights.\n- Return the grayscale image with shape `(*, 1, H, W)`.\n\nEnsure that the function handles different image data types correctly and raises a `TypeError` for unsupported types.",
    "function_name": "rgb_to_grayscale",
    "ground_truth": "kornia/color/gray.py",
    "test": "tests/color/test_gray.py::TestRgbToGrayscale",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}