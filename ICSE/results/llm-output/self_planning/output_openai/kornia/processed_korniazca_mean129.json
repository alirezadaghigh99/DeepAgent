{
    "result": "Here's the implementation of the `zca_mean` function following the structured approach you outlined. This function uses NumPy to perform the necessary tensor operations for ZCA whitening:\n\n```python\nimport numpy as np\n\ndef zca_mean(inp, dim, unbiased=True, eps=1e-5, return_inverse=False):\n    # Validate input tensor\n    if not isinstance(inp, np.ndarray):\n        raise TypeError(\"Input must be a numpy array.\")\n    if dim < 0 or dim >= inp.ndim:\n        raise ValueError(\"Invalid dimension specified.\")\n    \n    # Compute mean vector\n    mean_vector = np.mean(inp, axis=dim, keepdims=True)\n    \n    # Center the data\n    centered_data = inp - mean_vector\n    \n    # Reshape centered_data for covariance computation\n    if dim != 0:\n        centered_data = np.moveaxis(centered_data, dim, 0)\n    \n    # Compute covariance matrix\n    if unbiased:\n        cov_matrix = np.cov(centered_data, rowvar=True, bias=False)\n    else:\n        cov_matrix = np.cov(centered_data, rowvar=True, bias=True)\n    \n    # Add numerical stability\n    cov_matrix += np.eye(cov_matrix.shape[0]) * eps\n    \n    # Eigen decomposition\n    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n    \n    # Compute ZCA whitening matrix\n    zca_matrix = eigenvectors @ np.diag(1.0 / np.sqrt(eigenvalues)) @ eigenvectors.T\n    \n    # Compute inverse ZCA matrix if required\n    if return_inverse:\n        inverse_zca_matrix = eigenvectors @ np.diag(np.sqrt(eigenvalues)) @ eigenvectors.T\n        return zca_matrix, mean_vector.squeeze(), inverse_zca_matrix\n    \n    return zca_matrix, mean_vector.squeeze()\n\n# Example usage:\n# inp = np.random.rand(100, 10)  # Example input tensor\n# zca_matrix, mean_vector = zca_mean(inp, dim=0)\n```\n\n### Key Points:\n1. **Input Validation**: The function checks if the input is a NumPy array and if the specified dimension is valid.\n2. **Mean Calculation**: The mean is computed along the specified dimension, and the data is centered by subtracting this mean.\n3. **Covariance Matrix**: The covariance matrix is computed using `np.cov`, with the option to use an unbiased estimate.\n4. **Numerical Stability**: A small value `eps` is added to the diagonal of the covariance matrix to ensure numerical stability during eigen decomposition.\n5. **Eigen Decomposition**: The covariance matrix is decomposed into eigenvalues and eigenvectors.\n6. **ZCA Whitening Matrix**: The ZCA whitening matrix is computed using the eigenvalues and eigenvectors.\n7. **Inverse ZCA Matrix**: If requested, the inverse ZCA matrix is also computed and returned.\n\nThis function should work for any NumPy array input, provided the dimension specified is correct. Adjustments are made to handle the specified dimension correctly when computing the covariance matrix.",
    "prompt": "Generate a Python function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor. The function should take as input a tensor `inp`, the dimension `dim` along which the samples are located, a boolean `unbiased` to decide whether to use the unbiased estimate of the covariance matrix, a small value `eps` for numerical stability, and a boolean `return_inverse` to decide whether to return the inverse ZCA transform. The function should return a tuple containing the ZCA matrix, the mean vector, and optionally the inverse ZCA matrix. The tensor shapes should be validated, and appropriate exceptions should be raised if inputs are of incorrect types or dimensions. Include the necessary imports and tensor operations to perform the ZCA whitening process.",
    "function_name": "zca_mean",
    "ground_truth": "kornia/enhance/zca.py",
    "test": "tests/enhance/test_zca.py::TestZCA",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}