{
    "result": "Here's a detailed implementation of the `rotation_matrix_to_quaternion` function, following the steps outlined in your plan. This function converts a 3x3 rotation matrix to a quaternion in the format (w, x, y, z). It includes input validation, quaternion computation, normalization, and error handling.\n\n```python\nimport torch\n\ndef rotation_matrix_to_quaternion(rotation_matrix, eps=1e-6):\n    # Validate input\n    if not isinstance(rotation_matrix, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    \n    if rotation_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input must be a tensor with the last two dimensions being 3x3.\")\n    \n    if eps <= 0:\n        raise ValueError(\"Epsilon must be a small positive value.\")\n\n    # Initialize quaternion tensor\n    quaternion = torch.zeros(*rotation_matrix.shape[:-2], 4, dtype=rotation_matrix.dtype, device=rotation_matrix.device)\n\n    # Extract elements from the rotation matrix\n    r00 = rotation_matrix[..., 0, 0]\n    r11 = rotation_matrix[..., 1, 1]\n    r22 = rotation_matrix[..., 2, 2]\n    trace = r00 + r11 + r22\n\n    # Compute quaternion components\n    def compute_quaternion(trace, r00, r11, r22, eps):\n        if trace > 0:\n            s = 0.5 / torch.sqrt(trace + 1.0 + eps)\n            w = 0.25 / s\n            x = (rotation_matrix[..., 2, 1] - rotation_matrix[..., 1, 2]) * s\n            y = (rotation_matrix[..., 0, 2] - rotation_matrix[..., 2, 0]) * s\n            z = (rotation_matrix[..., 1, 0] - rotation_matrix[..., 0, 1]) * s\n        else:\n            if r00 > r11 and r00 > r22:\n                s = 2.0 * torch.sqrt(1.0 + r00 - r11 - r22 + eps)\n                w = (rotation_matrix[..., 2, 1] - rotation_matrix[..., 1, 2]) / s\n                x = 0.25 * s\n                y = (rotation_matrix[..., 0, 1] + rotation_matrix[..., 1, 0]) / s\n                z = (rotation_matrix[..., 0, 2] + rotation_matrix[..., 2, 0]) / s\n            elif r11 > r22:\n                s = 2.0 * torch.sqrt(1.0 + r11 - r00 - r22 + eps)\n                w = (rotation_matrix[..., 0, 2] - rotation_matrix[..., 2, 0]) / s\n                x = (rotation_matrix[..., 0, 1] + rotation_matrix[..., 1, 0]) / s\n                y = 0.25 * s\n                z = (rotation_matrix[..., 1, 2] + rotation_matrix[..., 2, 1]) / s\n            else:\n                s = 2.0 * torch.sqrt(1.0 + r22 - r00 - r11 + eps)\n                w = (rotation_matrix[..., 1, 0] - rotation_matrix[..., 0, 1]) / s\n                x = (rotation_matrix[..., 0, 2] + rotation_matrix[..., 2, 0]) / s\n                y = (rotation_matrix[..., 1, 2] + rotation_matrix[..., 2, 1]) / s\n                z = 0.25 * s\n        return w, x, y, z\n\n    w, x, y, z = compute_quaternion(trace, r00, r11, r22, eps)\n\n    # Assign to quaternion tensor\n    quaternion[..., 0] = w\n    quaternion[..., 1] = x\n    quaternion[..., 2] = y\n    quaternion[..., 3] = z\n\n    # Normalize the quaternion\n    quaternion = quaternion / torch.norm(quaternion, dim=-1, keepdim=True)\n\n    return quaternion\n\n# Example usage\nrotation_matrix = torch.tensor([[[1.0, 0.0, 0.0],\n                                 [0.0, 1.0, 0.0],\n                                 [0.0, 0.0, 1.0]]])\nquaternion = rotation_matrix_to_quaternion(rotation_matrix)\nprint(quaternion)\n```\n\n### Key Points:\n- **Input Validation**: The function checks if the input is a tensor and if it has the correct shape. It also checks that `eps` is a positive value.\n- **Quaternion Calculation**: The function computes the quaternion based on the trace of the rotation matrix, using different formulas depending on the trace value.\n- **Normalization**: The quaternion is normalized to ensure it represents a valid rotation.\n- **Error Handling**: The function raises informative errors if the input is not valid.\n\nThis implementation should work for converting 3x3 rotation matrices to quaternions, handling both single and batched inputs.",
    "prompt": "Generate a Python function called rotation_matrix_to_quaternion that converts a 3x3 rotation matrix to a 4d quaternion vector. The input parameters are a rotation matrix tensor and a small value eps to avoid zero division. The output is a quaternion tensor with components in (w, x, y, z) format. The function returns the quaternion tensor with shape (*, 4). The function includes examples of usage and error handling for input types and sizes.",
    "function_name": "rotation_matrix_to_quaternion",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestRotationMatrixToQuaternion",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}