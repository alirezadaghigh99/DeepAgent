{
    "result": "To implement the `undistort_points_kannala_brandt` function using the Gauss-Newton optimization algorithm, we need to follow the steps outlined in the plan. Below is a Python implementation using PyTorch for tensor operations:\n\n```python\nimport torch\n\ndef undistort_points_kannala_brandt(distorted_points_in_camera, params, max_iterations=10, convergence_threshold=1e-6):\n    # Extract parameters from the params tensor\n    fx, fy, cx, cy, k1, k2, k3, k4 = params[..., 0], params[..., 1], params[..., 2], params[..., 3], params[..., 4], params[..., 5], params[..., 6], params[..., 7]\n    \n    # Initialize undistorted points with the distorted points as the initial guess\n    undistorted_points = distorted_points_in_camera.clone()\n    \n    for _ in range(max_iterations):\n        # Compute the radial distance from the center\n        x = undistorted_points[..., 0]\n        y = undistorted_points[..., 1]\n        r = torch.sqrt(x**2 + y**2)\n        \n        # Compute the distortion using the Kannala-Brandt model\n        theta = torch.atan(r)\n        theta_d = theta * (1 + k1 * theta**2 + k2 * theta**4 + k3 * theta**6 + k4 * theta**8)\n        \n        # Compute the expected distorted points\n        scale = torch.where(r > 0, theta_d / r, torch.tensor(1.0, device=r.device))\n        x_distorted = scale * x\n        y_distorted = scale * y\n        \n        # Calculate the residual\n        residual_x = distorted_points_in_camera[..., 0] - x_distorted\n        residual_y = distorted_points_in_camera[..., 1] - y_distorted\n        residual = torch.stack((residual_x, residual_y), dim=-1)\n        \n        # Compute the Jacobian matrix\n        dtheta_dr = 1 / (1 + (r**2))\n        dtheta_d_dtheta = 1 + 3 * k1 * theta**2 + 5 * k2 * theta**4 + 7 * k3 * theta**6 + 9 * k4 * theta**8\n        dtheta_d_dr = dtheta_d_dtheta * dtheta_dr\n        \n        scale_prime = (dtheta_d_dr * r - theta_d) / (r**2)\n        scale_prime = torch.where(r > 0, scale_prime, torch.tensor(0.0, device=r.device))\n        \n        jacobian = torch.zeros_like(residual)\n        jacobian[..., 0, 0] = scale + x**2 * scale_prime\n        jacobian[..., 0, 1] = x * y * scale_prime\n        jacobian[..., 1, 0] = x * y * scale_prime\n        jacobian[..., 1, 1] = scale + y**2 * scale_prime\n        \n        # Gauss-Newton update\n        delta = torch.linalg.solve(jacobian, residual)\n        undistorted_points += delta\n        \n        # Check for convergence\n        if torch.max(torch.abs(delta)) < convergence_threshold:\n            break\n    \n    return undistorted_points\n\n# Example usage\ndistorted_points = torch.tensor([[0.5, 0.5], [0.1, -0.2]], dtype=torch.float32)\nparams = torch.tensor([800, 800, 320, 240, 0.1, 0.01, 0.001, 0.0001], dtype=torch.float32)\nundistorted_points = undistort_points_kannala_brandt(distorted_points, params)\nprint(undistorted_points)\n```\n\n### Explanation:\n- **Initialization**: We start by extracting the intrinsic and distortion parameters from the `params` tensor.\n- **Iterative Optimization**: We use the Gauss-Newton method to iteratively refine the estimate of the undistorted points.\n- **Distortion Model**: The Kannala-Brandt model is used to compute the expected distortion.\n- **Jacobian Calculation**: The Jacobian matrix is computed to facilitate the Gauss-Newton update.\n- **Convergence Check**: The iteration stops when the change in the estimate is below the specified threshold.\n\nThis implementation assumes that the input tensors are in the correct shape and that the device (CPU/GPU) is consistent across operations. Adjustments may be needed based on specific use cases or additional constraints.",
    "prompt": "Generate a Python function called undistort_points_kannala_brandt that undistorts one or more points from the camera frame into the canonical z=1 plane using the Kannala-Brandt model. The function takes two input parameters: distorted_points_in_camera, a Tensor representing the points to undistort with shape (..., 2), and params, a Tensor representing the parameters of the Kannala-Brandt distortion model with shape (..., 8). The function returns a Tensor representing the undistorted points with shape (..., 2). The function implements the Gauss-Newton optimization algorithm to iteratively undistort the points.",
    "function_name": "undistort_points_kannala_brandt",
    "ground_truth": "kornia/geometry/camera/distortion_kannala_brandt.py",
    "test": "tests/geometry/camera/test_distortion.py::TestDistortionKannalaBrandt",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}