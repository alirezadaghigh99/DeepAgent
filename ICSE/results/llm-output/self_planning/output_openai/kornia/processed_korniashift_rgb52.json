{
    "result": "Let's focus on implementing the `shift_rgb` function as described in your request. This function will take an image tensor and shift the RGB channels according to the provided shift values. Here's how you can implement it:\n\n```python\nimport torch\n\ndef shift_rgb(image, r_shift, g_shift, b_shift):\n    # Step 1: Verify Input\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Image must be a torch.Tensor\")\n    if image.ndim != 4 or image.shape[1] != 3:\n        raise ValueError(\"Image must have shape (N, 3, H, W) for an RGB image\")\n    if not (isinstance(r_shift, torch.Tensor) and isinstance(g_shift, torch.Tensor) and isinstance(b_shift, torch.Tensor)):\n        raise TypeError(\"Shift values must be torch.Tensors\")\n    if r_shift.shape != (image.shape[0],) or g_shift.shape != (image.shape[0],) or b_shift.shape != (image.shape[0],):\n        raise ValueError(\"Shift tensors must have shape (N,)\")\n\n    # Step 2: Apply Shifts\n    # Clone the image to avoid modifying the original tensor\n    shifted_image = image.clone()\n    \n    # Apply the shifts to each channel\n    shifted_image[:, 0, :, :] += r_shift.view(-1, 1, 1)  # Red channel\n    shifted_image[:, 1, :, :] += g_shift.view(-1, 1, 1)  # Green channel\n    shifted_image[:, 2, :, :] += b_shift.view(-1, 1, 1)  # Blue channel\n\n    # Step 3: Clamp Output Values\n    shifted_image = torch.clamp(shifted_image, 0, 1)\n\n    # Step 4: Return Modified Image\n    return shifted_image\n\n# Example usage\nimage = torch.tensor([[[[0.2000, 0.0000]],\n                       [[0.3000, 0.5000]],\n                       [[0.4000, 0.7000]]],\n                      [[[0.2000, 0.7000]],\n                       [[0.0000, 0.8000]],\n                       [[0.2000, 0.3000]]]])\n\nr_shift = torch.tensor([0.1000, 0.1000])\ng_shift = torch.tensor([0.3000, 0.3000])\nb_shift = torch.tensor([-0.3000, -0.3000])\n\nshifted_image = shift_rgb(image, r_shift, g_shift, b_shift)\nprint(shifted_image)\n```\n\n### Explanation:\n\n1. **Verify Input**: The function first checks if the input image is a valid tensor and has the correct shape for an RGB image. It also checks that the shift values are tensors of the correct shape.\n\n2. **Apply Shifts**: The function applies the specified shifts to each channel of the image. The shifts are applied by adding the shift values to the respective channels.\n\n3. **Clamp Output Values**: After applying the shifts, the function clamps the pixel values to ensure they remain within the valid range [0, 1].\n\n4. **Return Modified Image**: Finally, the function returns the modified image tensor.\n\nThis implementation ensures that the image is processed correctly and that any errors in input types or shapes are handled appropriately.",
    "prompt": "Generate a Python function named shift_rgb that shifts the RGB channels of an image. The function takes the following inputs: an image tensor of shape (N, C, H, W), where C is 3 (indicating an RGB image), and three tensors r_shift, g_shift, and b_shift of shape (N) that represent the shift values for the red, green, and blue channels, respectively.\n\nThe function should:\n\nVerify that the image is a valid tensor and a color image.\nApply the shifts to each channel.\nEnsure the output values are clamped between 0 and 1.\nReturn the modified image as a tensor of the same shape.\nThe function should handle errors by checking the tensor types and confirming that the input image is an RGB image.\"\nexample of input : image = tensor([[[[0.2000, 0.0000]],\n\n         [[0.3000, 0.5000]],\n\n         [[0.4000, 0.7000]]],\n\n\n        [[[0.2000, 0.7000]],\n\n         [[0.0000, 0.8000]],\n\n         [[0.2000, 0.3000]]]]), r_shift = tensor([0.1000]), g_shift = tensor([0.3000]), b_shift = tensor([-0.3000])",
    "function_name": "shift_rgb",
    "ground_truth": "kornia/enhance/shift_rgb.py",
    "test": "tests/enhance/test_shift_rgb.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Image"
}