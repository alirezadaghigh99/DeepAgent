{
    "result": "Here's a detailed implementation of the `match_snn` function based on the steps you've outlined. This function will validate the input shapes, compute the distance matrix if not provided, and apply the ratio test to find matching descriptors:\n\n```python\nimport torch\n\ndef match_snn(desc1, desc2, th=0.8, dm=None):\n    # Validate input shapes\n    if desc1.ndim != 2 or desc2.ndim != 2:\n        raise ValueError(\"desc1 and desc2 must be 2D tensors.\")\n    \n    if dm is not None and dm.shape != (desc1.size(0), desc2.size(0)):\n        raise ValueError(\"Precomputed distance matrix has incorrect shape.\")\n    \n    # Compute distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2, p=2)  # Euclidean distance\n    \n    # Check if desc2 has fewer than two descriptors\n    if desc2.size(0) < 2:\n        return torch.empty((0, 1)), torch.empty((0, 2), dtype=torch.long)\n    \n    # Find nearest neighbors\n    sorted_distances, sorted_indices = torch.sort(dm, dim=1)\n    nearest_distances = sorted_distances[:, 0]\n    second_nearest_distances = sorted_distances[:, 1]\n    nearest_indices = sorted_indices[:, 0]\n    \n    # Apply ratio test\n    ratio = nearest_distances / second_nearest_distances\n    mask = ratio <= th\n    \n    # Prepare output\n    matching_distances = nearest_distances[mask].unsqueeze(1)\n    matching_indices = torch.stack((torch.arange(desc1.size(0))[mask], nearest_indices[mask]), dim=1)\n    \n    return matching_distances, matching_indices\n\n# Example usage:\n# desc1 = torch.rand(10, 128)  # 10 descriptors of size 128\n# desc2 = torch.rand(15, 128)  # 15 descriptors of size 128\n# distances, indices = match_snn(desc1, desc2)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if `desc1` and `desc2` are 2D tensors. If a precomputed distance matrix `dm` is provided, it checks if its shape matches the expected dimensions.\n\n2. **Distance Matrix Calculation**: If `dm` is not provided, the function computes the Euclidean distance matrix between `desc1` and `desc2` using `torch.cdist`.\n\n3. **Descriptor Count Check**: If `desc2` has fewer than two descriptors, the function returns empty tensors because the ratio test requires at least two nearest neighbors.\n\n4. **Nearest Neighbors Identification**: The function sorts the distances for each descriptor in `desc1` to find the nearest and second nearest neighbors in `desc2`.\n\n5. **Ratio Test**: It calculates the ratio of the nearest to the second nearest distance and applies the threshold `th` to filter valid matches.\n\n6. **Output Preparation**: The function collects the distances and indices of descriptors that pass the ratio test, ensuring the output is formatted correctly.\n\nThis implementation efficiently handles the matching process and returns the desired results based on the specified conditions.",
    "prompt": "Create a Python function `match_snn` that takes in two tensors, `desc1` and `desc2`, representing batches of descriptors, a threshold `th` = 0.8, and an optional precomputed distance matrix `dm`. The function returns the distances and indices of descriptors from `desc1` that have nearest neighbors in `desc2`, satisfying the condition that the ratio of the first to the second nearest neighbor distance is less than or equal to `th`. If `desc2` has fewer than two descriptors, or if no matches meet the ratio threshold, the function returns an empty result. It checks the validity of the input shapes and then identifies the matching descriptors and their corresponding distances.Return:\n        - Descriptor distance of matching descriptors, shape of :math:`(B3, 1)`.\n        - Long tensor indexes of matching descriptors in desc1 and desc2. Shape: :math:`(B3, 2)`,\n          where 0 <= B3 <= B1.",
    "function_name": "match_snn",
    "ground_truth": "kornia/feature/matching.py#L48",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Detection",
    "data": "Image"
}