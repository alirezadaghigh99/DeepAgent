{
    "result": "Let's implement the `quaternion_exp_to_log` function as described in your plan. This function will apply the log map to a quaternion, ensuring that the input is a tensor with the correct shape and handling numerical stability with a clamping parameter `eps`.\n\nHere's the implementation:\n\n```python\nimport torch\n\ndef quaternion_exp_to_log(quaternion, eps=1e-8):\n    # Step 1: Check Input\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    if quaternion.shape[-1] != 4:\n        raise ValueError(\"Input tensor must have shape (*, 4).\")\n    \n    # Step 2: Unpack Quaternion\n    w = quaternion[..., 0]\n    x = quaternion[..., 1]\n    y = quaternion[..., 2]\n    z = quaternion[..., 3]\n    \n    # Step 3: Compute Quaternion Norm\n    vector_norm = torch.sqrt(x**2 + y**2 + z**2)\n    \n    # Step 4: Apply Log Map\n    # Clamp the vector norm to avoid division by zero\n    vector_norm_clamped = torch.clamp(vector_norm, min=eps)\n    \n    # Calculate the log map\n    theta = torch.acos(torch.clamp(w, min=-1.0, max=1.0))\n    scale = theta / vector_norm_clamped\n    \n    # Handle the case where vector_norm is zero\n    scale = torch.where(vector_norm < eps, torch.zeros_like(scale), scale)\n    \n    log_map = torch.stack((x * scale, y * scale, z * scale), dim=-1)\n    \n    # Step 5: Return Quaternion Log\n    return log_map\n\n# Example usage\nquaternion = torch.tensor((1., 0., 0., 0.))\nlog_map = quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\nprint(log_map)  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n\n1. **Check Input**: We ensure that the input is a tensor and has the correct shape of `(*, 4)`.\n\n2. **Unpack Quaternion**: We separate the quaternion into its scalar (`w`) and vector parts (`x, y, z`).\n\n3. **Compute Quaternion Norm**: We calculate the norm of the vector part of the quaternion.\n\n4. **Apply Log Map**: \n   - We compute the angle `theta` using the `acos` function on the scalar part `w`.\n   - We scale the vector part by `theta / vector_norm_clamped` to get the log map.\n   - We handle the case where the vector norm is zero by setting the scale to zero in such cases.\n\n5. **Return Quaternion Log**: The resulting tensor of shape `(*, 3)` is returned, representing the quaternion log map.\n\nThis function should work correctly for any valid quaternion input, providing a stable computation of the log map.",
    "prompt": "Generate a Python function called quaternion_exp_to_log that applies the log map to a quaternion. The input is a tensor called quaternion in (w, x, y, z) format and a float called eps for clamping. The output is a tensor of shape (*, 3) representing the quaternion log map. The function checks if the input is a Tensor and has a shape of (*, 4). It then unpacks the quaternion into a vector and scalar, computes the quaternion norm, and applies the log map to calculate the quaternion log. An example usage is provided with a sample quaternion input. >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_exp_to_log",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/epipolar/test_essential.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}