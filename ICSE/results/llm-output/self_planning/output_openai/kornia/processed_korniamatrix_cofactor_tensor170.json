{
    "result": "Here's the implementation of the `matrix_cofactor_tensor` function, which computes the cofactor matrix for each 3x3 matrix in a given tensor. The function follows the steps outlined in your plan:\n\n```python\nimport numpy as np\n\ndef matrix_cofactor_tensor(matrix):\n    # Validate input shape\n    if matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input tensor must have shape (*, 3, 3)\")\n\n    # Compute determinants\n    determinants = np.linalg.det(matrix)\n\n    # Check for singular matrices\n    if np.all(determinants == 0):\n        raise Exception(\"All input matrices are singular (determinants are zero)\")\n\n    # Function to compute the cofactor matrix of a single 3x3 matrix\n    def cofactor_3x3(mat):\n        cofactor_matrix = np.empty((3, 3))\n        for i in range(3):\n            for j in range(3):\n                # Create the 2x2 submatrix by excluding the current row and column\n                submatrix = np.delete(np.delete(mat, i, axis=0), j, axis=1)\n                # Compute the cofactor with the correct sign\n                cofactor_matrix[i, j] = ((-1) ** (i + j)) * np.linalg.det(submatrix)\n        return cofactor_matrix\n\n    # Compute cofactor matrices for each matrix in the input tensor\n    cofactor_matrices = np.array([cofactor_3x3(mat) for mat in matrix])\n\n    return cofactor_matrices\n\n# Example usage:\n# matrix = np.random.rand(5, 3, 3)  # Example tensor of shape (5, 3, 3)\n# cofactor_matrices = matrix_cofactor_tensor(matrix)\n# print(cofactor_matrices)\n```\n\n### Explanation:\n1. **Input Validation**: The function first checks if the input tensor has the correct shape, ensuring that each matrix is 3x3. If not, it raises a `ValueError`.\n\n2. **Determinant Calculation**: It calculates the determinant of each 3x3 matrix using `np.linalg.det`.\n\n3. **Singular Matrix Check**: If all matrices are singular (i.e., all determinants are zero), the function raises an `Exception`.\n\n4. **Cofactor Calculation**: For each element in a 3x3 matrix, the function computes the determinant of the corresponding 2x2 submatrix and applies the appropriate sign to get the cofactor.\n\n5. **Return**: The function returns a tensor containing the cofactor matrices, preserving the batch dimensions of the input tensor.\n\nThis implementation efficiently computes the cofactor matrices for a batch of 3x3 matrices, handling both input validation and singular matrix detection.",
    "prompt": "Create a Python function `matrix_cofactor_tensor` that:\n\n- Computes the cofactor matrix for a given tensor of matrices with shape `(*, 3, 3)`.\n- Accepts a single parameter:\n  - `matrix`: A tensor of shape `(*, 3, 3)` representing the input matrices.\n- Returns a tensor containing the cofactor matrices of the input matrices.\n\nErrors:\n- Raises an `Exception` if all input matrices are singular (i.e., their determinants are zero).",
    "function_name": "matrix_cofactor_tensor",
    "ground_truth": "kornia/geometry/epipolar/numeric.py#L31",
    "test": "tests/geometry/epipolar/test_essential.py::TestDecomposeEssentialMatrixNoSVD",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}