{
    "result": "Here's the implementation of the `rgb_to_yuv420` function, which converts an RGB image to the YUV 420 format. This function ensures that the input image is padded to have even dimensions if necessary, performs the RGB to YUV conversion, and subsamples the U and V channels to achieve the YUV 420 format.\n\n```python\nimport torch\nfrom typing import Tuple\n\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    # Check input dimensions\n    if image.dim() < 3 or image.size(-3) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W)\")\n\n    # Get the height and width\n    H, W = image.size(-2), image.size(-1)\n\n    # Pad if necessary to make H and W even\n    if H % 2 != 0 or W % 2 != 0:\n        padding = (0, W % 2, 0, H % 2)  # (left, right, top, bottom)\n        image = torch.nn.functional.pad(image, padding, mode='reflect')\n\n    # Convert RGB to YUV\n    r, g, b = image.unbind(dim=-3)\n    y = 0.299 * r + 0.587 * g + 0.114 * b\n    u = -0.14713 * r - 0.28886 * g + 0.436 * b\n    v = 0.615 * r - 0.51499 * g - 0.10001 * b\n\n    # Reshape Y to have a single channel\n    y = y.unsqueeze(-3)\n\n    # Subsample U and V\n    u_sub = (u[..., ::2, ::2] + u[..., 1::2, ::2] + u[..., ::2, 1::2] + u[..., 1::2, 1::2]) / 4\n    v_sub = (v[..., ::2, ::2] + v[..., 1::2, ::2] + v[..., ::2, 1::2] + v[..., 1::2, 1::2]) / 4\n\n    # Stack U and V to form the UV plane\n    uv = torch.stack((u_sub, v_sub), dim=-3)\n\n    return y, uv\n\n# Example usage\ninput_tensor = torch.rand(2, 3, 4, 6)\ny_plane, uv_plane = rgb_to_yuv420(input_tensor)\nprint(y_plane.shape)  # Should be (2, 1, 4, 6)\nprint(uv_plane.shape)  # Should be (2, 2, 2, 3)\n```\n\n### Explanation\n\n1. **Input Validation**: The function checks if the input tensor has the correct shape, i.e., `(*, 3, H, W)`. If not, it raises a `ValueError`.\n\n2. **Padding**: If the height (`H`) or width (`W`) is odd, the function pads the image using reflection padding to make them even. This ensures that the image can be evenly divided for subsampling.\n\n3. **RGB to YUV Conversion**: The function uses the standard conversion formula to convert RGB values to YUV. The coefficients used are based on the BT.601 standard.\n\n4. **Subsampling**: The U and V channels are subsampled by averaging over 2x2 blocks. This reduces the resolution of the chroma channels by half in both dimensions, which is characteristic of the YUV 420 format.\n\n5. **Output**: The function returns the Y channel and the subsampled UV channels as separate tensors. The Y channel retains the original resolution, while the UV channels are reduced to half the resolution in both dimensions.\n\nThis implementation ensures that the input image is correctly converted to the YUV 420 format, with appropriate handling of input dimensions and padding.",
    "prompt": "Generate a Python function called rgb_to_yuv420 that takes in a torch.Tensor representing an RGB image and returns a tuple of two torch.Tensors. The input image is assumed to be in the range of (0, 1) and needs to be padded to be evenly divisible by 2 horizontally and vertically. The function will output the YUV 420 (subsampled) version of the input image with chroma siting at (0.5, 0.5).\n\nThe function should have the following signature:\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nThe function converts the RGB image to YUV 420 format and returns:\n- A Tensor containing the Y plane with shape (*, 1, H, W)\n- A Tensor containing the UV planes with shape (*, 2, H/2, W/2)\n\nEnsure that the input image has a shape of (*, 3, H, W) where H and W are even numbers. If the input does not meet these requirements, appropriate errors will be raised.\n\nExample usage:\n```python\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```",
    "function_name": "rgb_to_yuv420",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestRgbToYuv420",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}