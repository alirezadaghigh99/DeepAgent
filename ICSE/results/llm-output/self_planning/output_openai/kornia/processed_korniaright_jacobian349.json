{
    "result": "The `right_jacobian` function you've outlined is designed to compute the right Jacobian of the special orthogonal group SO(3) for a batch of 3D rotation vectors. Let's walk through the implementation step-by-step to ensure clarity and correctness.\n\n### Implementation Details\n\n1. **Skew-Symmetric Matrix Conversion**:\n   - The `vector_to_skew_symmetric_matrix` function converts each 3D vector into a 3x3 skew-symmetric matrix. This is crucial for representing cross products in matrix form.\n\n2. **Norm Calculation**:\n   - `torch.norm` is used to compute the magnitude of each vector, which represents the angle of rotation.\n\n3. **Identity Matrix**:\n   - `torch.eye` creates a 3x3 identity matrix, which is used as a base for constructing the Jacobian.\n\n4. **Right Jacobian Calculation**:\n   - The right Jacobian is computed using the formula:\n     \\[\n     J_r(\\omega) = I - \\frac{\\sin(\\theta)}{\\theta} \\cdot \\text{skew}(\\omega) + \\frac{1 - \\cos(\\theta)}{\\theta^2} \\cdot \\text{skew}(\\omega)^2\n     \\]\n   - This formula accounts for the rotation represented by the vector.\n\n5. **Handling Small Angles**:\n   - For small angles, a Taylor expansion is used to approximate the trigonometric functions to avoid numerical instability.\n\n6. **Batch Processing**:\n   - The function processes a batch of vectors, making it efficient for applications involving multiple rotations.\n\nHere's the complete implementation:\n\n```python\nimport torch\n\ndef vector_to_skew_symmetric_matrix(vec):\n    \"\"\"\n    Convert a batch of 3D vectors to skew-symmetric matrices.\n    \"\"\"\n    zero = torch.zeros_like(vec[:, 0])\n    skew_matrices = torch.stack([\n        zero, -vec[:, 2], vec[:, 1],\n        vec[:, 2], zero, -vec[:, 0],\n        -vec[:, 1], vec[:, 0], zero\n    ], dim=-1).reshape(-1, 3, 3)\n    return skew_matrices\n\ndef right_jacobian(vec):\n    \"\"\"\n    Compute the right Jacobian of SO(3) for a batch of 3D vectors.\n    \"\"\"\n    B = vec.shape[0]\n    theta = torch.norm(vec, dim=1, keepdim=True)\n    theta_sq = theta ** 2\n    skew_matrices = vector_to_skew_symmetric_matrix(vec)\n    I = torch.eye(3, device=vec.device).unsqueeze(0).repeat(B, 1, 1)\n\n    # Use Taylor expansion for small angles\n    small_angle = theta < 1e-6\n    sin_theta_over_theta = torch.where(small_angle, 1 - theta_sq / 6, torch.sin(theta) / theta)\n    one_minus_cos_theta_over_theta_sq = torch.where(small_angle, 0.5 - theta_sq / 24, (1 - torch.cos(theta)) / theta_sq)\n\n    J_r = I - sin_theta_over_theta.unsqueeze(-1) * skew_matrices + one_minus_cos_theta_over_theta_sq.unsqueeze(-1) * torch.bmm(skew_matrices, skew_matrices)\n\n    return J_r\n```\n\n### Key Points\n\n- **Batch Processing**: The function is designed to handle a batch of vectors, making it suitable for applications like robotics or computer vision where multiple rotations are processed simultaneously.\n- **Numerical Stability**: The use of Taylor expansions for small angles ensures that the function remains stable and accurate even when the rotation angle is near zero.\n- **Efficiency**: By leveraging PyTorch's batch operations, the function is efficient and can be run on GPUs for large-scale computations.\n\nThis implementation should meet the requirements for computing the right Jacobian of SO(3) for a batch of 3D rotation vectors.",
    "prompt": "Generate a Python function called right_jacobian that computes the right Jacobian of So3. The input is a tensor called vec of shape (B, 3) and the output is a tensor of shape (3, 3) representing the right Jacobian matrix. The function uses vector_to_skew_symmetric_matrix, torch.norm, torch.eye, and matrix multiplication to calculate the right Jacobian matrix.",
    "function_name": "right_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}