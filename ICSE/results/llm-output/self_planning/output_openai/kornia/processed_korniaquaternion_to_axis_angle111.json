{
    "result": "Let's focus on implementing the `quaternion_to_axis_angle` function. This function will convert a quaternion to an axis-angle representation. Here's how you can implement it in Python using PyTorch for tensor operations:\n\n```python\nimport torch\n\ndef quaternion_to_axis_angle(quaternion):\n    # Check if the input is a tensor\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    # Check if the shape is Nx4 or 4\n    if quaternion.dim() == 1:\n        if quaternion.size(0) != 4:\n            raise ValueError(\"Input tensor must have shape [4] or [N, 4].\")\n    elif quaternion.dim() == 2:\n        if quaternion.size(1) != 4:\n            raise ValueError(\"Input tensor must have shape [4] or [N, 4].\")\n    else:\n        raise ValueError(\"Input tensor must have shape [4] or [N, 4].\")\n    \n    # Normalize the quaternion to ensure it is a unit quaternion\n    quaternion = quaternion / quaternion.norm(dim=-1, keepdim=True)\n    \n    # Unpack the quaternion components\n    w, x, y, z = quaternion[..., 0], quaternion[..., 1], quaternion[..., 2], quaternion[..., 3]\n    \n    # Compute the angle of rotation\n    angle = 2 * torch.acos(w)\n    \n    # Compute the axis of rotation\n    sin_theta_over_two = torch.sqrt(1 - w**2)\n    \n    # To avoid division by zero, use a small epsilon\n    epsilon = 1e-8\n    sin_theta_over_two = torch.where(sin_theta_over_two < epsilon, torch.tensor(epsilon, device=quaternion.device), sin_theta_over_two)\n    \n    axis = torch.stack((x, y, z), dim=-1) / sin_theta_over_two.unsqueeze(-1)\n    \n    # Handle the case where the angle is close to zero\n    axis = torch.where(angle.unsqueeze(-1) < epsilon, torch.tensor([1.0, 0.0, 0.0], device=quaternion.device), axis)\n    \n    # Return the axis-angle representation\n    return axis * angle.unsqueeze(-1)\n\n# Example usage\nquaternion = torch.tensor([1., 0., 0., 0.])\naxis_angle = quaternion_to_axis_angle(quaternion)\nprint(axis_angle)  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n\n1. **Input Check**: The function first checks if the input is a PyTorch tensor and whether it has the correct shape (either `[4]` or `[N, 4]`).\n\n2. **Normalization**: The quaternion is normalized to ensure it is a unit quaternion, which is necessary for a valid conversion.\n\n3. **Unpacking**: The components of the quaternion `(w, x, y, z)` are extracted.\n\n4. **Angle Calculation**: The angle of rotation is calculated using `2 * acos(w)`.\n\n5. **Axis Calculation**: The axis of rotation is calculated by normalizing the vector `(x, y, z)`. A small epsilon is used to avoid division by zero.\n\n6. **Handling Edge Cases**: If the angle is close to zero, the axis is set to a default value to avoid undefined behavior.\n\n7. **Output**: The function returns the axis-angle representation as a tensor.\n\nThis implementation should work for both single quaternions and batches of quaternions.",
    "prompt": "Generate a Python function called quaternion_to_axis_angle that converts a quaternion vector to an axis angle of rotation in radians. The input is a tensor called quaternion with quaternions in (w, x, y, z) format. The output is a tensor with the axis angle of rotation. The function checks if the input is a tensor and has a shape of Nx4 or 4. It then unpacks the input and computes the conversion using mathematical operations. The final output is a tensor with the axis angle values.Example:\n        >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_to_axis_angle(quaternion)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_to_axis_angle",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestQuaternionToAngleAxis",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}