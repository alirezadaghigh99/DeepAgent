{
    "result": "To implement the `project` function for the `PinholeCamera` class, we need to follow the steps outlined in your request. Here's the complete implementation:\n\n```python\nimport torch\nfrom torch import Tensor\n\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n\n    def project(self, point_3d: Tensor) -> Tensor:\n        # Step 1: Transform 3D points from world coordinates to camera coordinates\n        # Add a homogeneous coordinate (1) to the 3D points\n        ones = torch.ones(point_3d.shape[:-1] + (1,), device=point_3d.device)\n        point_3d_homogeneous = torch.cat([point_3d, ones], dim=-1)\n        \n        # Apply the extrinsic transformation\n        point_camera_homogeneous = point_3d_homogeneous @ self._extrinsics.T\n        \n        # Step 2: Project the 3D points in camera coordinates onto the 2D image plane\n        point_image_homogeneous = point_camera_homogeneous @ self._intrinsics.T\n        \n        # Step 3: Normalize the coordinates to get (u, v)\n        u = point_image_homogeneous[..., 0] / point_image_homogeneous[..., 2]\n        v = point_image_homogeneous[..., 1] / point_image_homogeneous[..., 2]\n        \n        # Combine u and v into a single tensor\n        uv_coordinates = torch.stack([u, v], dim=-1)\n        \n        return uv_coordinates\n```\n\n### Explanation of the Implementation:\n1. **Homogeneous Coordinates**: We start by converting the 3D points into homogeneous coordinates by appending a 1 to each point. This allows us to use matrix operations for transformations.\n\n2. **Extrinsic Transformation**: The extrinsic matrix is used to transform the points from world coordinates to camera coordinates. This involves multiplying the homogeneous 3D points by the transpose of the extrinsic matrix.\n\n3. **Intrinsic Projection**: The intrinsic matrix is then used to project the 3D camera coordinates onto the 2D image plane. This is done by multiplying the camera coordinates by the transpose of the intrinsic matrix.\n\n4. **Normalization**: To convert from homogeneous coordinates to 2D coordinates, we divide the x and y components by the z component (depth).\n\n5. **Output**: Finally, we stack the normalized x and y components to form the `(u, v)` coordinates, which are returned as a tensor of shape `(*, 2)`.\n\nThis implementation assumes that the intrinsic and extrinsic matrices are correctly defined and that the input `point_3d` tensor is in the correct shape and format.",
    "prompt": "\"Generate the `project` function for the following class to project a 3D point in world coordinates onto the 2D camera plane. The input is `self` and a `point_3d` tensor with shape `(*, 3)`, and the output is a tensor of `(u, v)` camera coordinates with shape `(*, 2)`.\n\n```python\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n```\"",
    "function_name": "project",
    "ground_truth": "kornia/geometry/camera/pinhole.py",
    "test": "tests/geometry/camera/test_pinhole.py",
    "class": "PinholeCamera",
    "stage": "Image",
    "task": "",
    "data": "pre-post process"
}