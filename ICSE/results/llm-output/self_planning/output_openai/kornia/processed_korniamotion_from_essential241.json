{
    "result": "Here's the implementation of the `motion_from_essential` function, which decomposes an essential matrix into four possible motion solutions. This function follows the structured approach you outlined:\n\n```python\nimport torch\n\ndef motion_from_essential(E_mat: torch.Tensor):\n    # Check the shape of the input tensor\n    assert E_mat.shape[-2:] == (3, 3), \"E_mat must have shape (*, 3, 3)\"\n    \n    # Prepare the W matrix\n    W = torch.tensor([[0, -1, 0],\n                      [1, 0, 0],\n                      [0, 0, 1]], dtype=E_mat.dtype, device=E_mat.device)\n    \n    # Perform SVD on the essential matrix\n    U, _, Vt = torch.svd(E_mat)\n    \n    # Ensure U and Vt are proper rotation matrices\n    if torch.det(U) < 0:\n        U = -U\n    if torch.det(Vt) < 0:\n        Vt = -Vt\n    \n    # Compute the two possible rotation matrices\n    R1 = U @ W @ Vt\n    R2 = U @ W.t() @ Vt\n    \n    # Ensure the rotation matrices have determinant +1\n    if torch.det(R1) < 0:\n        R1 = -R1\n    if torch.det(R2) < 0:\n        R2 = -R2\n    \n    # Extract the translation vector\n    t = U[:, 2].unsqueeze(-1)\n    \n    # Formulate the four possible solutions\n    Rs = torch.stack([R1, R1, R2, R2], dim=-3)\n    Ts = torch.stack([t, -t, t, -t], dim=-3)\n    \n    return Rs, Ts\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input tensor `E_mat` has the correct shape, which should be either (3, 3) for a single essential matrix or (*, 3, 3) for a batch of matrices. If not, it raises an `AssertionError`.\n\n2. **SVD Decomposition**: The function performs Singular Value Decomposition (SVD) on the essential matrix `E_mat` to obtain matrices `U`, `S`, and `Vt`.\n\n3. **Construct W Matrix**: The matrix `W` is defined as specified, which is used in the decomposition process.\n\n4. **Compute Possible Rotations**: Using `U`, `W`, and `Vt`, the function computes two possible rotation matrices `R1` and `R2`. It ensures that each rotation matrix has a determinant of +1, adjusting by negating the matrix if necessary.\n\n5. **Compute Possible Translations**: The translation vector `t` is extracted from the third column of `U`. The function considers both `t` and `-t` as possible translations.\n\n6. **Formulate Solutions**: The function combines the rotations and translations to form the four possible solutions: `[R1, t]`, `[R1, -t]`, `[R2, t]`, `[R2, -t]`.\n\n7. **Return Results**: The function returns the results as two tensors: `Rs` with shape (*, 4, 3, 3) and `Ts` with shape (*, 4, 3, 1).\n\nThis implementation should correctly decompose the essential matrix into the four possible motion solutions, ensuring that the input is validated and the output is structured as required.",
    "prompt": "Generate a Python function called motion_from_essential that takes in a torch.Tensor E_mat representing an essential matrix and returns the four possible poses for the decomposition of the Essential matrix. The possible solutions are [R1,t], [R1,-t], [R2,t], [R2,-t]. The function checks the shape of the input tensor and raises an AssertionError if it does not meet the required shape. It returns the four possible solutions in the form of two tensors: Rs with shape (*, 4, 3, 3) and Ts with shape (*, 4, 3, 1).",
    "function_name": "motion_from_essential",
    "ground_truth": "kornia/geometry/epipolar/essential.py",
    "test": "tests/geometry/epipolar/test_essential.py::TestMotionFromEssential",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}