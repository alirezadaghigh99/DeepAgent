{
    "result": "Let's implement the `match_nn` function based on the provided plan. This function will find the nearest neighbors in `desc2` for each vector in `desc1`, using PyTorch for tensor operations. Here's how you can implement it:\n\n```python\nimport torch\n\ndef _no_match(B1):\n    # Placeholder function to return when there are no matches\n    # Returns a tensor of zeros for distances and a tensor of -1 for indices\n    return torch.zeros((B1, 1)), torch.full((B1, 2), -1, dtype=torch.long)\n\ndef match_nn(desc1, desc2, dm=None):\n    # Step 1: Check Input Shapes\n    if desc1.dim() != 2 or desc2.dim() != 2:\n        raise ValueError(\"Input descriptors must be 2D tensors.\")\n    \n    B1, D1 = desc1.shape\n    B2, D2 = desc2.shape\n    \n    if D1 != D2:\n        raise ValueError(\"Descriptor dimensions must match.\")\n    \n    # Step 2: Handle Empty Descriptors\n    if B1 == 0 or B2 == 0:\n        return _no_match(B1)\n    \n    # Step 3: Compute Distance Matrix\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n    \n    # Step 4: Find Nearest Neighbors\n    min_distances, min_indices = torch.min(dm, dim=1)\n    \n    # Step 5: Construct Output Tensors\n    distances_tensor = min_distances.unsqueeze(1)  # Shape (B1, 1)\n    indices_tensor = torch.stack((torch.arange(B1), min_indices), dim=1)  # Shape (B1, 2)\n    \n    # Step 6: Return Results\n    return distances_tensor, indices_tensor\n\n# Example usage:\n# desc1 = torch.rand((5, 128))  # Example descriptor batch 1\n# desc2 = torch.rand((10, 128))  # Example descriptor batch 2\n# distances, indices = match_nn(desc1, desc2)\n# print(distances)\n# print(indices)\n```\n\n### Explanation:\n\n1. **Check Input Shapes**: The function first checks if the input descriptors `desc1` and `desc2` are 2D tensors and if their feature dimensions match.\n\n2. **Handle Empty Descriptors**: If either `desc1` or `desc2` is empty, the function returns a placeholder output using `_no_match`.\n\n3. **Compute Distance Matrix**: If the distance matrix `dm` is not provided, it computes the Euclidean distance matrix using `torch.cdist`.\n\n4. **Find Nearest Neighbors**: For each descriptor in `desc1`, it finds the nearest neighbor in `desc2` by identifying the minimum distance and its index.\n\n5. **Construct Output Tensors**: It constructs a tensor of matching descriptor distances and a tensor of indices indicating matches between `desc1` and `desc2`.\n\n6. **Return Results**: Finally, it returns the tensors of distances and indices.\n\nThis implementation assumes that the input tensors are compatible and does not include explicit error handling for incompatible inputs beyond the initial shape checks.",
    "prompt": "Create a Python function `match_nn` that:\n\n- Takes three parameters:\n  - `desc1`: A tensor containing a batch of descriptors with shape `(B1, D)`.\n  - `desc2`: A tensor containing another batch of descriptors with shape `(B2, D)`.\n  - `dm`: An optional precomputed distance matrix tensor of shape `(B1, B2)`. If not provided, the function computes the distance matrix using `torch.cdist`.\n\n- The function finds the nearest neighbors in `desc2` for each vector in `desc1`:\n  - Checks if the input descriptors have the correct shapes.\n  - If either `desc1` or `desc2` is empty, it returns a placeholder output using `_no_match`.\n  - If `dm` is not provided, it calculates the distance matrix between `desc1` and `desc2`.\n  - Finds the minimum distances and their corresponding indices in `desc2` for each vector in `desc1`.\n  - Constructs a tensor containing the indices of matching descriptors in `desc1` and `desc2`.\n\n- Returns:\n  - A tensor of matching descriptor distances with shape `(B1, 1)`.\n  - A tensor of long indices of matching descriptors in `desc1` and `desc2` with shape `(B1, 2)`.\n\nErrors:\n- The function assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs.",
    "function_name": "match_nn",
    "ground_truth": "kornia/feature/matching.py#L60",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}