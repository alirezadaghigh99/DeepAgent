{
    "result": "The `project_points` function you've outlined is designed to project 3D points onto a 2D camera plane using a camera matrix. Let's walk through the implementation and ensure it meets the requirements.\n\n### Key Steps in the Implementation\n\n1. **Input Validation**: The function checks that the input tensors have the correct shapes. The 3D points should have a shape of `(*, 3)`, and the camera matrix should have a shape of `(*, 3, 3)`.\n\n2. **Homogeneous Coordinates**: The function converts the 3D points into homogeneous coordinates by appending a 1 to each point. This is necessary for the matrix multiplication with the camera matrix.\n\n3. **Matrix Multiplication**: The function uses `torch.matmul` to multiply the 3D points in homogeneous coordinates by the camera matrix, projecting them onto the 2D plane.\n\n4. **Normalization**: The function normalizes the resulting 2D points by dividing by the third coordinate to convert from homogeneous to Cartesian coordinates.\n\n5. **Output**: The function returns the 2D points with shape `(*, 2)`.\n\n### Implementation\n\nHere's the complete implementation of the `project_points` function:\n\n```python\nimport torch\n\ndef project_points(points_3d, camera_matrix):\n    \"\"\"\n    Projects 3D points onto a 2D camera plane using the camera matrix.\n\n    Args:\n        points_3d (torch.Tensor): A tensor of shape (*, 3) representing 3D points.\n        camera_matrix (torch.Tensor): A tensor of shape (*, 3, 3) representing the camera matrix.\n\n    Returns:\n        torch.Tensor: A tensor of shape (*, 2) representing the projected 2D points.\n    \"\"\"\n    # Ensure the input tensors have the correct shapes\n    if points_3d.shape[-1] != 3:\n        raise ValueError(\"The last dimension of points_3d must be 3.\")\n    if camera_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"The last two dimensions of camera_matrix must be (3, 3).\")\n\n    # Convert 3D points to homogeneous coordinates\n    ones = torch.ones(*points_3d.shape[:-1], 1, dtype=points_3d.dtype, device=points_3d.device)\n    points_3d_homogeneous = torch.cat([points_3d, ones], dim=-1)\n\n    # Perform matrix multiplication to project points\n    projected_points_homogeneous = torch.matmul(points_3d_homogeneous.unsqueeze(-2), camera_matrix).squeeze(-2)\n\n    # Normalize to get Cartesian coordinates\n    u = projected_points_homogeneous[..., 0] / projected_points_homogeneous[..., 2]\n    v = projected_points_homogeneous[..., 1] / projected_points_homogeneous[..., 2]\n\n    # Return the 2D points\n    return torch.stack([u, v], dim=-1)\n\n# Example usage\npoints_3d = torch.rand(5, 3)  # Random 3D points\ncamera_matrix = torch.eye(3).expand(5, 3, 3)  # Identity matrix as camera matrix\nprojected_points = project_points(points_3d, camera_matrix)\nprint(projected_points)\n```\n\n### Explanation\n\n- **Homogeneous Coordinates**: By appending a 1 to each 3D point, the function can use matrix multiplication to apply the camera transformation.\n- **Matrix Multiplication**: The `torch.matmul` function is used to multiply the 3D points by the camera matrix.\n- **Normalization**: Dividing by the third coordinate is crucial to convert from homogeneous to Cartesian coordinates, resulting in the final 2D points.\n\nThis function is designed to handle batches of 3D points and camera matrices, making it flexible for various applications in computer vision and graphics. The example usage demonstrates projecting random 3D points using an identity matrix as the camera matrix, which should result in the same points being returned in 2D space.",
    "prompt": "Generate a Python function called project_points that takes in a 3D point tensor and a camera matrix tensor as input. The function projects the 3D point onto the 2D camera plane using the camera matrix. The input tensor for the 3D point should have shape (*, 3) and the camera matrix tensor should have shape (*, 3, 3). The function returns a tensor of (u, v) camera coordinates with shape (*, 2). An example usage of the function is provided where a random 3D point and an identity matrix as the camera matrix are used to project the point onto the camera plane, resulting in a tensor of camera coordinates.",
    "function_name": "project_points",
    "ground_truth": "kornia/geometry/camera/perspective.py",
    "test": "tests/geometry/camera/test_projections.py::TestProjectionZ1",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}