{
    "result": "The function `left_jacobian` you've outlined is designed to compute the left Jacobian of SO(3) for a batch of 3D vectors. This is a common operation in robotics and computer vision, where small rotations are often represented using vectors in the tangent space of the SO(3) manifold. Let's go through the implementation step-by-step:\n\n1. **Input and Output:**\n   - The input is a tensor `vec` of shape `(B, 3)`, where `B` is the batch size.\n   - The output is a tensor of shape `(B, 3, 3)`, representing the left Jacobian matrix for each vector in the batch.\n\n2. **Mathematical Operations:**\n   - **Norm Calculation:** The norm of each vector is calculated to determine the angle of rotation.\n   - **Skew-Symmetric Matrix:** For each vector, a skew-symmetric matrix is computed. This matrix is essential for using the Rodrigues' rotation formula.\n   - **Left Jacobian Calculation:** The left Jacobian is computed using trigonometric functions (sine and cosine) and the skew-symmetric matrix.\n\n3. **Implementation Details:**\n   - **Numerical Stability:** The norm is clamped to avoid division by zero, ensuring stability for small angles.\n   - **Vectorized Operations:** The function uses vectorized operations to efficiently compute the Jacobian for the entire batch.\n\nHere's the complete implementation:\n\n```python\nimport torch\n\ndef left_jacobian(vec):\n    \"\"\"\n    Computes the left Jacobian of SO(3) for a batch of vectors.\n\n    Parameters:\n    vec (torch.Tensor): A tensor of shape (B, 3) representing a batch of 3D vectors.\n\n    Returns:\n    torch.Tensor: A tensor of shape (B, 3, 3) representing the left Jacobian matrix for each vector.\n    \"\"\"\n    B = vec.shape[0]\n    norm = torch.norm(vec, dim=1, keepdim=True)\n    norm = norm.clamp(min=1e-8)  # Avoid division by zero\n\n    # Create skew-symmetric matrix\n    def skew_symmetric(v):\n        zero = torch.zeros_like(v[:, 0])\n        return torch.stack([\n            zero, -v[:, 2], v[:, 1],\n            v[:, 2], zero, -v[:, 0],\n            -v[:, 1], v[:, 0], zero\n        ], dim=1).reshape(-1, 3, 3)\n\n    skew_mat = skew_symmetric(vec)\n\n    # Compute the left Jacobian\n    identity = torch.eye(3, device=vec.device).unsqueeze(0).repeat(B, 1, 1)\n    sin_term = torch.sin(norm) / norm\n    cos_term = (1 - torch.cos(norm)) / (norm ** 2)\n\n    left_jacobian = identity + sin_term.unsqueeze(-1) * skew_mat + cos_term.unsqueeze(-1) * torch.bmm(skew_mat, skew_mat)\n\n    return left_jacobian\n\n# Example usage:\nvec = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\njacobian = left_jacobian(vec)\nprint(jacobian)\n```\n\n### Key Points:\n- **Skew-Symmetric Matrix:** This matrix is crucial for representing cross products in matrix form, which is used in the Rodrigues' rotation formula.\n- **Trigonometric Functions:** The sine and cosine terms are used to approximate the rotation for small angles.\n- **Batch Processing:** The function is designed to handle a batch of vectors efficiently, leveraging PyTorch's capabilities for batch operations.\n\nThis implementation should work well for computing the left Jacobian of SO(3) for a batch of vectors, ensuring both efficiency and numerical stability.",
    "prompt": "Generate a Python function called left_jacobian that computes the left Jacobian of So3. The input is a tensor called vec of shape (B, 3) where B is the batch size. The output is a tensor of shape (B, 3, 3) representing the left Jacobian matrix. The function uses the input tensor to calculate the left Jacobian matrix using specific mathematical operations",
    "function_name": "left_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3::test_left_jacobian",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}