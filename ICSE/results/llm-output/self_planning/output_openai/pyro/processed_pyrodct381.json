{
    "result": "To implement the Discrete Cosine Transform of type II (DCT-II) in PyTorch, scaled to be orthonormal, we can follow the steps outlined in your request. Here's the complete implementation:\n\n```python\nimport torch\nimport torch.fft\n\ndef dct(x: torch.Tensor, dim: int = -1) -> torch.Tensor:\n    \"\"\"\n    Perform a Discrete Cosine Transform of type II, scaled to be orthonormal.\n\n    :param x: The input signal.\n    :param dim: Dimension along which to compute DCT.\n    :return: The DCT-II of the input signal.\n    \"\"\"\n    # Get the size of the transform dimension\n    N = x.size(dim)\n    \n    # Compute the DCT using the real FFT\n    # Shift the input to prepare for FFT\n    x = torch.cat([x, x.flip(dims=[dim])], dim=dim)\n    \n    # Compute the real FFT\n    X = torch.fft.rfft(x, dim=dim)\n    \n    # Take the real part and scale\n    X_real = X.real\n    \n    # Create a scaling factor for orthonormality\n    scale = torch.sqrt(torch.tensor(2.0 / N, dtype=x.dtype, device=x.device))\n    \n    # Apply the scaling factor\n    X_real = X_real * scale\n    \n    # Adjust the first element scaling\n    X_real.index_fill_(dim, torch.tensor([0], device=x.device), X_real.index_select(dim, torch.tensor([0], device=x.device)) / torch.sqrt(torch.tensor(2.0, dtype=x.dtype, device=x.device)))\n    \n    return X_real\n\n# Example usage\nx = torch.randn(8)\ndct_result = dct(x)\nprint(dct_result)\n```\n\n### Explanation:\n\n1. **Input Preparation**: The input tensor `x` is concatenated with its flipped version along the specified dimension. This step is crucial for leveraging the symmetry properties of the DCT, which allows us to use the FFT to compute the DCT.\n\n2. **Real FFT**: We use `torch.fft.rfft` to compute the real FFT of the prepared input. This function is efficient for real-valued inputs and provides the necessary frequency components.\n\n3. **Scaling for Orthonormality**: The result is scaled by `sqrt(2/N)` to ensure the transform is orthonormal. This scaling ensures that the energy of the signal is preserved in the transform domain.\n\n4. **First Element Adjustment**: The first element of the result is further adjusted by dividing by `sqrt(2)`. This adjustment is necessary to match the orthonormal scaling used in the DCT-II.\n\n5. **Dimension Handling**: The function allows specifying the dimension along which to compute the DCT, making it flexible for multi-dimensional inputs.\n\nThis implementation provides a DCT-II that is equivalent to `scipy.fftpack.dct` with `norm=\"ortho\"`, ensuring compatibility with other scientific computing tools.",
    "prompt": "Write a python function dct in torch that Discrete cosine transform of type II, scaled to be orthonormal.\n\n    This is the inverse of :func:`idct_ii` , and is equivalent to\n    :func:`scipy.fftpack.dct` with ``norm=\"ortho\"``.\n\n    :param Tensor x: The input signal.\n    :param int dim: Dimension along which to compute DCT.\n    :rtype: Tensor",
    "function_name": "dct",
    "ground_truth": "pyro/ops/tensor_utils.py",
    "test": "tests/ops/test_tensor_utils.py::test_dct_dim",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Regression",
    "data": "Table"
}