{
    "result": "The function `gaussian_noise_image` is designed to add Gaussian noise to an input image tensor. Let's go through the implementation step by step, ensuring that it adheres to the specified requirements:\n\n1. **Validate Input Tensor**:\n   - Check if the input `image` tensor is of a floating-point data type. If not, raise a `ValueError`.\n   - Ensure that the `sigma` parameter is non-negative. If `sigma` is negative, raise a `ValueError`.\n\n2. **Generate Gaussian Noise**:\n   - Create a noise tensor with the same shape as the input `image` tensor using a Gaussian distribution with the specified `mean` and `sigma`.\n\n3. **Add Noise to Image**:\n   - Add the generated Gaussian noise to the input `image` tensor to produce a noisy image.\n\n4. **Clip the Output (if required)**:\n   - If the `clip` parameter is set to `True`, clip the values of the noisy image tensor to the range [0, 1].\n\n5. **Return the Noisy Image**:\n   - Return the resulting noisy image tensor.\n\nHere's the complete implementation:\n\n```python\nimport torch\n\ndef gaussian_noise_image(image, mean=0.0, sigma=0.1, clip=True):\n    # Step 1: Validate Input Tensor\n    if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")\n\n    # Step 2: Generate Gaussian Noise\n    noise = torch.normal(mean=mean, std=sigma, size=image.size(), dtype=image.dtype, device=image.device)\n\n    # Step 3: Add Noise to Image\n    noisy_image = image + noise\n\n    # Step 4: Clip the Output (if required)\n    if clip:\n        noisy_image = torch.clamp(noisy_image, 0.0, 1.0)\n\n    # Step 5: Return the Noisy Image\n    return noisy_image\n```\n\n### Key Points:\n- **Floating-point Check**: The function checks if the input tensor is of a floating-point type using `image.is_floating_point()`.\n- **Non-negative Sigma**: The function ensures `sigma` is non-negative, raising an error if it isn't.\n- **Noise Generation**: Gaussian noise is generated using `torch.normal`, which allows specifying the mean and standard deviation.\n- **Clipping**: The `torch.clamp` function is used to ensure the values remain within the [0, 1] range if `clip` is `True`.\n\nThis function is useful for simulating noise in image data, which can be beneficial for tasks like data augmentation in machine learning.",
    "prompt": "Write a Python function `gaussian_noise_image` that adds Gaussian noise to an input image tensor. The function should accept the following parameters: `image` (a float tensor), `mean` (mean of the Gaussian noise, defaulting to 0.0), `sigma` (standard deviation of the Gaussian noise, defaulting to 0.1), and `clip` (a boolean indicating whether to clip the output values to the [0, 1] range, defaulting to `True`). The function should return the noisy image tensor. Ensure that the input tensor is of a floating-point dtype and that `sigma` is non-negative, raising a `ValueError` if these conditions are not met.  if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")",
    "function_name": "gaussian_noise_image",
    "ground_truth": "torchvision/transforms/v2/functional/_misc.py",
    "test": "test/test_transforms_v2.py::TestGaussianNoise",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}