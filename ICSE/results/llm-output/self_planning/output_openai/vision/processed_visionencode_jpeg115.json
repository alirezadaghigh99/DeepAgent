{
    "result": "The `encode_jpeg` function you've outlined is well-structured and follows the steps necessary to encode images into JPEG format using the PIL library. Let's go through the implementation and ensure everything is clear and correct:\n\n1. **Input Validation**: The function checks if the input is a tensor or a list of tensors and validates the `quality` parameter. It raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is provided.\n\n2. **Preparation for Encoding**: The function handles both single tensor inputs and lists of tensors. It ensures that each tensor is in the CHW format, which is typical for image data in deep learning frameworks like PyTorch.\n\n3. **JPEG Encoding**: The function converts each tensor from CHW to HWC format, which is required by most image processing libraries. It then uses PIL to convert the numpy array to an image and encodes it to JPEG format with the specified quality.\n\n4. **Return Encoded Data**: The function collects the encoded JPEG bytes and returns them as a tensor or a list of tensors, depending on the input type.\n\n5. **Error Handling**: The function includes error handling for invalid input formats and quality values.\n\nHere's the complete implementation:\n\n```python\nfrom PIL import Image\nimport io\nimport torch\n\ndef encode_jpeg(images, quality):\n    # Validate quality parameter\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n\n    # Check if input is a list or a single tensor\n    if isinstance(images, torch.Tensor):\n        images = [images]\n    elif isinstance(images, list) and not images:\n        raise ValueError(\"Input list of images cannot be empty.\")\n    \n    encoded_images = []\n\n    for img_tensor in images:\n        # Ensure the tensor is in CHW format\n        if img_tensor.ndim != 3 or img_tensor.shape[0] not in {1, 3}:\n            raise ValueError(\"Each image tensor must be in CHW format with 1 or 3 channels.\")\n\n        # Convert CHW to HWC\n        img_hwc = img_tensor.permute(1, 2, 0).numpy()\n\n        # Convert to PIL Image\n        img_pil = Image.fromarray((img_hwc * 255).astype('uint8'))\n\n        # Encode to JPEG\n        with io.BytesIO() as output:\n            img_pil.save(output, format='JPEG', quality=quality)\n            jpeg_bytes = output.getvalue()\n\n        # Convert bytes to tensor\n        encoded_images.append(torch.tensor(list(jpeg_bytes), dtype=torch.uint8))\n\n    # Return a single tensor if input was a single tensor, else a list\n    return encoded_images[0] if len(encoded_images) == 1 else encoded_images\n```\n\n### Key Points:\n- **CHW to HWC Conversion**: The `permute` function is used to rearrange the dimensions of the tensor from (Channels, Height, Width) to (Height, Width, Channels), which is necessary for PIL.\n- **Image Scaling**: The image data is scaled by multiplying by 255 to convert from a range of [0, 1] to [0, 255], which is the standard range for image pixel values.\n- **Byte Conversion**: The JPEG bytes are converted to a tensor of type `uint8`, which is suitable for representing raw byte data.\n\nThis function should work well for encoding images into JPEG format with the specified quality, handling both single and multiple image inputs.",
    "prompt": "Create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format. The function accepts images in CHW layout and a quality parameter between 1 and 100 to control the output JPEG quality. The output is a tensor or list of tensors containing the raw bytes of the JPEG file(s). The function raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is passed as input.",
    "function_name": "encode_jpeg",
    "ground_truth": "torchvision/io/image.py",
    "test": "test/test_image.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}