{
    "result": "The `rotate` function you've outlined is designed to handle both PIL Images and torch Tensors, allowing for flexible image rotation with various options for interpolation, expansion, center of rotation, and fill value. Below is the complete implementation of the `rotate` function, including the helper function `_interpolation_modes_from_int` to convert integer interpolation modes to `InterpolationMode` enums:\n\n```python\nfrom PIL import Image\nimport torch\nfrom torchvision.transforms import InterpolationMode\nimport torchvision.transforms.functional as F\n\ndef rotate(img, angle, interpolation=InterpolationMode.NEAREST, expand=False, center=None, fill=0):\n    # Validate inputs\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Argument angle should be int or float\")\n    \n    if isinstance(interpolation, int):\n        interpolation = _interpolation_modes_from_int(interpolation)\n    elif not isinstance(interpolation, InterpolationMode):\n        raise TypeError(\n            \"Argument interpolation should be a InterpolationMode or a corresponding Pillow integer constant\"\n        )\n    \n    if center is not None and not isinstance(center, (list, tuple)):\n        raise TypeError(\"Argument center should be a sequence\")\n    \n    # Handle PIL Image\n    if isinstance(img, Image.Image):\n        return img.rotate(angle, resample=interpolation.value, expand=expand, center=center, fillcolor=fill)\n    \n    # Handle torch Tensor\n    elif isinstance(img, torch.Tensor):\n        if img.ndim < 2:\n            raise ValueError(\"Input tensor should have at least 2 dimensions\")\n        \n        # Ensure interpolation is valid for tensors\n        if interpolation not in [InterpolationMode.NEAREST, InterpolationMode.BILINEAR]:\n            raise ValueError(\"For tensors, only NEAREST and BILINEAR interpolation modes are supported\")\n        \n        return F.rotate(img, angle, interpolation=interpolation, expand=expand, center=center, fill=fill)\n    \n    else:\n        raise TypeError(\"Input img should be a PIL Image or a torch Tensor\")\n\ndef _interpolation_modes_from_int(value):\n    # Convert integer to InterpolationMode\n    if value == 0:\n        return InterpolationMode.NEAREST\n    elif value == 2:\n        return InterpolationMode.BILINEAR\n    else:\n        raise ValueError(\"Unsupported interpolation mode integer\")\n```\n\n### Key Points:\n\n1. **Input Validation**: The function checks if the `angle` is a number and if the `interpolation` is a valid mode. It also checks if `center` is a sequence if provided.\n\n2. **Image Type Handling**: The function distinguishes between PIL Images and torch Tensors, applying the appropriate rotation method for each.\n\n3. **Interpolation Modes**: The function supports `NEAREST` and `BILINEAR` interpolation modes for torch Tensors, while PIL Images can use any mode supported by the `rotate` method.\n\n4. **Expand and Center Options**: The function allows for optional expansion of the output image and specification of the rotation center.\n\n5. **Fill Value**: The `fill` parameter specifies the pixel value for areas outside the transformed image.\n\nThis implementation provides a comprehensive solution for rotating images in both PIL and torch formats, making it versatile for various image processing tasks.",
    "prompt": "Write a python function rotate that Rotate the image by angle.\n    If the image is torch Tensor, it is expected\n    to have [..., H, W] shape, where ... means an arbitrary number of leading dimensions.\n\n    Args:\n        img (PIL Image or Tensor): image to be rotated.\n        angle (number): rotation angle value in degrees, counter-clockwise.\n        interpolation (InterpolationMode): Desired interpolation enum defined by\n            :class:`torchvision.transforms.InterpolationMode`. Default is ``InterpolationMode.NEAREST``.\n            If input is Tensor, only ``InterpolationMode.NEAREST``, ``InterpolationMode.BILINEAR`` are supported.\n            The corresponding Pillow integer constants, e.g. ``PIL.Image.BILINEAR`` are accepted as well.\n        expand (bool, optional): Optional expansion flag.\n            If true, expands the output image to make it large enough to hold the entire rotated image.\n            If false or omitted, make the output image the same size as the input image.\n            Note that the expand flag assumes rotation around the center and no translation.\n        center (sequence, optional): Optional center of rotation. Origin is the upper left corner.\n            Default is the center of the image.\n        fill (sequence or number, optional): Pixel fill value for the area outside the transformed\n            image. If given a number, the value is used for all bands respectively. Returns:\n        PIL Image or Tensor: Rotated image.\n\n    if not torch.jit.is_scripting() and not torch.jit.is_tracing():\n        _log_api_usage_once(rotate)\n\n    if isinstance(interpolation, int):\n        interpolation = _interpolation_modes_from_int(interpolation)\n    elif not isinstance(interpolation, InterpolationMode):\n        raise TypeError(\n            \"Argument interpolation should be a InterpolationMode or a corresponding Pillow integer constant\"\n        )\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Argument angle should be int or float\")\n\n    if center is not None and not isinstance(center, (list, tuple)):\n        raise TypeError(\"Argument center should be a sequence\")",
    "function_name": "rotate",
    "ground_truth": "torchvision/transforms/functional.py",
    "test": "test/test_functional_tensor.py::TestRotate::test_rotate",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}