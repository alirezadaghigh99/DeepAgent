{
    "result": "Let's focus on implementing the `draw_keypoints` function, which overlays keypoints on a given RGB image tensor. This function will handle input validation, draw keypoints, and optionally draw lines connecting keypoints based on the provided connectivity and visibility information.\n\nHere's the complete implementation of the `draw_keypoints` function:\n\n```python\nimport torch\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef draw_keypoints(image, keypoints, connectivity=None, colors='red', \n                   radius=3, width=1, visibility=None):\n    # Validate inputs\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Image must be a tensor.\")\n    if image.dtype not in [torch.uint8, torch.float]:\n        raise ValueError(\"Image dtype must be uint8 or float.\")\n    if image.shape[0] != 3:\n        raise ValueError(\"Image shape must be (3, H, W).\")\n    if keypoints.shape[-1] != 2:\n        raise ValueError(\"Keypoints must have shape (num_instances, K, 2).\")\n    if visibility is not None and visibility.shape != keypoints.shape[:-1]:\n        raise ValueError(\"Visibility shape must match keypoints shape.\")\n\n    # Convert image to numpy for plotting\n    if image.dtype == torch.float:\n        image = (image * 255).byte()\n    image_np = image.permute(1, 2, 0).cpu().numpy()\n\n    # Create a plot\n    fig, ax = plt.subplots()\n    ax.imshow(image_np)\n\n    # Draw keypoints\n    num_instances, num_keypoints, _ = keypoints.shape\n    for i in range(num_instances):\n        for j in range(num_keypoints):\n            if visibility is None or visibility[i, j]:\n                x, y = keypoints[i, j]\n                circle = plt.Circle((x, y), radius, color=colors, fill=True)\n                ax.add_patch(circle)\n\n    # Draw connections\n    if connectivity is not None:\n        for i in range(num_instances):\n            for (start, end) in connectivity:\n                if (visibility is None or (visibility[i, start] and visibility[i, end])):\n                    x_start, y_start = keypoints[i, start]\n                    x_end, y_end = keypoints[i, end]\n                    ax.plot([x_start, x_end], [y_start, y_end], color=colors, linewidth=width)\n\n    # Remove axes and return the image\n    ax.axis('off')\n    plt.show()\n\n    # Convert the image back to tensor if needed\n    return torch.from_numpy(image_np).permute(2, 0, 1)\n\n# Example usage\n# image = torch.rand(3, 100, 100)  # Example image tensor\n# keypoints = torch.tensor([[[10, 10], [20, 20], [30, 30]]])  # Example keypoints\n# draw_keypoints(image, keypoints, connectivity=[(0, 1), (1, 2)], colors='blue', radius=5, width=2)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if the image is a tensor, if its dtype is either `uint8` or `float`, and if its shape is `(3, H, W)`. It also validates the shape of the keypoints and visibility tensors.\n\n2. **Image Conversion**: If the image is of type `float`, it is scaled to `uint8` for visualization. The image is then converted to a NumPy array for use with Matplotlib.\n\n3. **Plotting**: A Matplotlib figure is created, and the image is displayed. Keypoints are drawn as circles, and lines are drawn between connected keypoints if specified.\n\n4. **Visibility**: Keypoints and connections are only drawn if they are marked as visible in the visibility tensor.\n\n5. **Return**: The function displays the image with keypoints and connections overlaid. The image is returned as a tensor in its original format.\n\nThis function provides a flexible way to visualize keypoints and their connections on an image, with options for customizing colors, radius, and line width.",
    "prompt": "Create a Python function draw_keypoints that overlays keypoints on a given RGB image tensor. The function should accept the following parameters:\n\nimage: A tensor of shape (3, H, W) and dtype uint8 or float, representing the image.\nkeypoints: A tensor of shape (num_instances, K, 2), where K denotes the number of keypoints per instance, and each keypoint is represented by its (x, y) coordinates.\nconnectivity: An optional list of tuples, where each tuple contains two integers representing keypoints that should be connected with a line.\ncolors: An optional string or tuple specifying the color for the keypoints and lines. The color can be a string (e.g., \"red\") or an RGB tuple.\nradius: An integer specifying the radius of each keypoint.\nwidth: An integer specifying the width of the lines connecting the keypoints.\nvisibility: An optional tensor of shape (num_instances, K) that indicates whether each keypoint is visible (True) or not (False).\nThe function should validate the input tensors and ensure the image is in the correct format. It should draw each visible keypoint on the image, and if connectivity is provided, draw lines connecting the keypoints based on their visibility. The resulting image tensor should be returned with the keypoints and connections drawn.\n\nError Handling:\nRaise a TypeError if the input image is not a tensor.\nRaise a ValueError if the image dtype is not uint8 or float, if the image shape is incorrect, or if the keypoints tensor has an incorrect shape.\nRaise a ValueError if the visibility tensor does not match the shape of the keypoints tensor.",
    "function_name": "draw_keypoints",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py::test_draw_keypoints_visibility",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}