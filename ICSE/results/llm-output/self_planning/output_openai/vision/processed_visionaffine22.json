{
    "result": "Here's a detailed implementation of the `affine` function, which applies an affine transformation to an image while keeping the image center invariant. This function supports both PIL Images and PyTorch Tensors, and it includes input validation, center determination, matrix construction, and transformation application.\n\n```python\nfrom PIL import Image\nimport numpy as np\nimport torch\nimport torchvision.transforms.functional as F\n\ndef affine(img, angle, translate, scale, shear, interpolation=Image.BILINEAR, fill=0, center=None):\n    # Validate input image type\n    if not isinstance(img, (Image.Image, torch.Tensor)):\n        raise TypeError(\"img should be a PIL Image or a Tensor\")\n\n    # Validate other parameters\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"angle should be a number\")\n    if not (isinstance(translate, (tuple, list)) and len(translate) == 2):\n        raise TypeError(\"translate should be a tuple or list of length 2\")\n    if not isinstance(scale, (int, float)):\n        raise TypeError(\"scale should be a number\")\n    if not (isinstance(shear, (tuple, list)) and len(shear) == 2):\n        raise TypeError(\"shear should be a tuple or list of length 2\")\n    if not isinstance(fill, (int, tuple, list)):\n        raise TypeError(\"fill should be an int or a tuple/list of ints\")\n\n    # Determine the center of rotation\n    if center is None:\n        if isinstance(img, Image.Image):\n            width, height = img.size\n        else:  # Tensor\n            _, _, height, width = img.shape\n        center = (width / 2, height / 2)\n\n    # Construct the affine transformation matrix\n    matrix = F._get_inverse_affine_matrix(center, angle, translate, scale, shear)\n\n    # Apply the affine transformation\n    if isinstance(img, Image.Image):\n        transformed_img = img.transform(\n            img.size, Image.AFFINE, matrix, resample=interpolation, fillcolor=fill\n        )\n    else:  # Tensor\n        transformed_img = F.affine(\n            img, angle, translate, scale, shear, interpolation=interpolation, fill=fill, center=center\n        )\n\n    return transformed_img\n\n# Example usage:\n# img = Image.open('path_to_image.jpg')\n# transformed_img = affine(img, angle=30, translate=(10, 20), scale=1.0, shear=(5, 5))\n# transformed_img.show()\n```\n\n### Key Points:\n\n1. **Input Validation**: The function checks if the input image is either a PIL Image or a PyTorch Tensor. It also validates the types and structures of other parameters.\n\n2. **Center of Rotation**: If the `center` is not provided, it defaults to the center of the image, calculated based on the image dimensions.\n\n3. **Affine Transformation Matrix**: The function uses `torchvision.transforms.functional._get_inverse_affine_matrix` to compute the transformation matrix. This internal function calculates the inverse of the affine transformation matrix needed for the transformation.\n\n4. **Transformation Application**: \n   - For PIL Images, the `transform` method is used with the calculated matrix.\n   - For Tensors, `torchvision.transforms.functional.affine` is used, which directly applies the transformation.\n\n5. **Interpolation and Fill**: The function supports different interpolation modes and allows specifying a fill color for areas outside the transformed image.\n\nThis implementation provides a flexible and robust way to apply affine transformations to images in Python, supporting both PIL and PyTorch formats.",
    "prompt": "Create a Python function called affine that applies an affine transformation on an image while keeping the image center invariant. The function takes in parameters such as img (PIL Image or Tensor), angle (rotation angle in degrees), translate (horizontal and vertical translations), scale (overall scale), shear (shear angle values), interpolation (desired interpolation mode), fill (pixel fill value for areas outside the transformed image), and center (optional center of rotation). The function returns the transformed image as a PIL Image or Tensor.",
    "function_name": "affine",
    "ground_truth": "torchvision/transforms/_functional_pil.py",
    "test": "test/test_transforms_tensor.py::test_random_affine_shear",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}