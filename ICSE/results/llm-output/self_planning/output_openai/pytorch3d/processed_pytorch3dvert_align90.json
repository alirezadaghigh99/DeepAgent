{
    "result": "Here's a detailed implementation of the `vert_align` function, following the steps outlined in the plan:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef vert_align(feats, verts, return_packed=False, interp_mode='bilinear', padding_mode='zeros', align_corners=True):\n    # Validate verts input\n    if isinstance(verts, torch.Tensor):\n        if verts.dim() != 3 or verts.size(2) != 3:\n            raise ValueError(\"verts must be a tensor of shape (N, V, 3)\")\n    elif hasattr(verts, 'verts_padded') or hasattr(verts, 'points_padded'):\n        verts = verts.verts_padded if hasattr(verts, 'verts_padded') else verts.points_padded\n    else:\n        raise ValueError(\"verts must have the expected shape or attributes\")\n\n    # Validate feats input\n    if isinstance(feats, torch.Tensor):\n        feats = [feats]\n    elif not all(isinstance(f, torch.Tensor) and f.dim() == 4 for f in feats):\n        raise ValueError(\"feats must be a tensor of shape (N, C, H, W) or a list of such tensors\")\n\n    # Check batch dimension consistency\n    if len(feats) != verts.size(0):\n        raise ValueError(\"Batch dimensions of feats and verts must match\")\n\n    # Sample features\n    sampled_feats = []\n    for feat in feats:\n        N, C, H, W = feat.shape\n        verts_xy = verts[..., :2]  # Extract (x, y) positions\n        verts_xy = verts_xy.view(N, -1, 1, 2)  # Reshape for grid_sample\n\n        # Sample features using grid_sample\n        sampled = F.grid_sample(feat, verts_xy, mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners)\n        sampled = sampled.view(N, C, -1).permute(0, 2, 1)  # Reshape to (N, V, C)\n        sampled_feats.append(sampled)\n\n    # Concatenate features if feats is a list\n    if len(sampled_feats) > 1:\n        sampled_feats = torch.cat(sampled_feats, dim=2)\n    else:\n        sampled_feats = sampled_feats[0]\n\n    # Return packed features if requested\n    if return_packed:\n        sampled_feats = sampled_feats.view(-1, sampled_feats.size(2))\n\n    return sampled_feats\n```\n\n### Explanation:\n\n1. **Input Validation**:\n   - The function first checks if `verts` is a tensor of shape `(N, V, 3)` or an object with `verts_padded` or `points_padded` attributes. If not, it raises a `ValueError`.\n   - It then checks if `feats` is a tensor of shape `(N, C, H, W)` or a list of such tensors. If not, it raises a `ValueError`.\n   - The batch dimensions (`N`) of `feats` and `verts` are checked for consistency.\n\n2. **Feature Sampling**:\n   - For each feature map in `feats`, the function extracts the `(x, y)` positions from `verts` and reshapes them for use with `grid_sample`.\n   - `grid_sample` is used to sample features at the vertex positions, with the specified interpolation and padding modes, and corner alignment.\n\n3. **Concatenation and Packing**:\n   - If `feats` is a list, the sampled features from each feature map are concatenated along the channel dimension.\n   - If `return_packed` is `True`, the features are reshaped into a packed representation.\n\n4. **Return**:\n   - The function returns the sampled features as a tensor, either in the shape `(N, V, C)` or `(sum(V), C)` if packed.\n\nThis implementation should handle the specified requirements and provide the desired functionality for vertex alignment.",
    "prompt": "Create a Python function vert_align that performs \"vertex alignment\" or \"perceptual feature pooling,\" which samples vertex features from a feature map based on vertex positions. The function takes the following parameters:\n\nfeats: A tensor of shape (N, C, H, W) representing image features from which to sample, or a list of such tensors, each with potentially different C, H, or W dimensions.\nverts: A tensor of shape (N, V, 3) representing the (x, y, z) vertex positions, or an object with verts_padded or points_padded attributes. The (x, y) coordinates should be normalized such that (-1, -1) corresponds to the top-left and (1, 1) to the bottom-right of the feature map.\nreturn_packed: A boolean flag indicating whether to return packed features. Defaults to False.\ninterp_mode: A string specifying the interpolation mode ('bilinear' or 'nearest'). Defaults to 'bilinear'.\npadding_mode: A string specifying how to handle vertices outside the [-1, 1] range ('zeros', 'reflection', or 'border'). Defaults to 'zeros'.\nalign_corners: A boolean indicating whether to align corners geometrically. If True, extrema refer to the center points of corner pixels; if False, they refer to the corner points of the input's corner pixels. Defaults to True.\nReturns:\nfeats_sampled: A tensor of shape (N, V, C) giving sampled features for each vertex. If feats is a list, the function returns concatenated features in shape (N, V, sum(C_n)) where C_n = feats[n].shape[1]. If return_packed = True, the features are transformed to a packed representation of shape (sum(V), C).\nError Handling:\nRaise a ValueError if verts does not have the expected shape or attributes.\nRaise a ValueError if feats does not have the expected shape (N, C, H, W) or if the batch dimensions of feats and verts do not match.",
    "function_name": "vert_align",
    "ground_truth": "pytorch3d/ops/vert_align.py",
    "test": "tests/test_vert_align.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}