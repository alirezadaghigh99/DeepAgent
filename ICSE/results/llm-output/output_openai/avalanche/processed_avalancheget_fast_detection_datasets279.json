{
    "result": "To create a function that generates synthetic datasets for object detection tasks, we need to simulate images and their corresponding detection targets. The function will ensure that the generated data meets the specified requirements, such as the number of samples per class and the number of test images. Here's how you can implement this function:\n\n```python\nimport numpy as np\nimport random\n\ndef get_fast_detection_datasets(n_images, max_elements_per_image, n_samples_per_class, n_classes, seed, image_size, n_test_images):\n    # Set the random seed for reproducibility\n    random.seed(seed)\n    np.random.seed(seed)\n    \n    # Assertions to ensure valid input\n    assert n_test_images > 0, \"Number of test images must be greater than zero.\"\n    assert n_test_images < n_images, \"Number of test images must be less than the total number of images.\"\n    \n    # Calculate the total number of required samples\n    total_required_samples = n_samples_per_class * n_classes\n    max_possible_samples = n_images * max_elements_per_image\n    \n    # Ensure we have enough capacity to generate the required samples\n    assert max_possible_samples >= total_required_samples, (\n        \"The total number of possible samples is less than the required samples per class.\"\n    )\n    \n    # Generate synthetic data\n    def generate_image_data(n_images):\n        images = []\n        targets = []\n        \n        for _ in range(n_images):\n            # Create a blank image\n            image = np.zeros((image_size, image_size, 3), dtype=np.uint8)\n            \n            # Randomly decide the number of elements in this image\n            n_elements = random.randint(1, max_elements_per_image)\n            \n            # Generate random detection targets\n            image_targets = []\n            for _ in range(n_elements):\n                # Randomly choose a class\n                class_id = random.randint(0, n_classes - 1)\n                \n                # Randomly generate a bounding box\n                x_min = random.uniform(0, image_size)\n                y_min = random.uniform(0, image_size)\n                x_max = random.uniform(x_min, image_size)\n                y_max = random.uniform(y_min, image_size)\n                \n                # Append the target (class_id, bounding box)\n                image_targets.append((class_id, (x_min, y_min, x_max, y_max)))\n            \n            images.append(image)\n            targets.append(image_targets)\n        \n        return images, targets\n    \n    # Generate training and testing datasets\n    train_images, train_targets = generate_image_data(n_images - n_test_images)\n    test_images, test_targets = generate_image_data(n_test_images)\n    \n    return (train_images, train_targets), (test_images, test_targets)\n\n# Example usage\ntrain_data, test_data = get_fast_detection_datasets(\n    n_images=100,\n    max_elements_per_image=5,\n    n_samples_per_class=10,\n    n_classes=3,\n    seed=42,\n    image_size=64,\n    n_test_images=20\n)\n\nprint(f\"Number of training images: {len(train_data[0])}\")\nprint(f\"Number of test images: {len(test_data[0])}\")\n```\n\n### Explanation:\n- **Random Seed**: We set the random seed for both `random` and `numpy` to ensure reproducibility.\n- **Assertions**: We use assertions to ensure that the number of test images is valid and that the dataset can accommodate the required number of samples per class.\n- **Synthetic Data Generation**: We generate synthetic images and detection targets. Each image is a blank array, and each target is a tuple containing a class ID and a bounding box.\n- **Bounding Boxes**: The bounding boxes are randomly generated within the image dimensions.\n- **Return**: The function returns two datasets: one for training and one for testing, each containing images and their corresponding detection targets.",
    "prompt": "Write a Python function `get_fast_detection_datasets` that generates synthetic datasets for object detection tasks. The function should accept the following inputs: `n_images` (number of total images), `max_elements_per_image` (maximum number of objects per image), `n_samples_per_class` (number of samples per class), `n_classes` (number of different classes), `seed` (random seed for reproducibility), `image_size` (size of each image), and `n_test_images` (number of images to be used for testing). The function should ensure that the number of generated images and elements per image are sufficient to cover the required samples per class and that the number of test images is within valid bounds. Use assertions to check that the total number of samples is greater than or equal to the required samples per class and that the number of test images is less than the total number of images and greater than zero. The function should return two datasets, one for training and one for testing, each containing images and corresponding detection targets.",
    "function_name": "get_fast_detection_datasets",
    "ground_truth": "tests/unit_tests_utils.py",
    "test": "tests/benchmarks/utils/test_transformations.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}