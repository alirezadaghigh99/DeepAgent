{
    "result": "To compute the normalized mean square error (NMSE) between two lists of NumPy arrays, we can follow these steps:\n\n1. Calculate the mean square error (MSE) between each pair of corresponding arrays from `ref_outputs` and `approx_outputs`.\n2. Calculate the MSE between each reference array and a zero array of the same shape.\n3. Normalize the MSE from step 1 by dividing it by the MSE from step 2.\n4. Average the NMSE values across all pairs to get the final result.\n\nHere's the implementation of the `normalized_mse` function:\n\n```python\nimport numpy as np\n\ndef normalized_mse(ref_outputs, approx_outputs):\n    \"\"\"\n    Compute the normalized mean square error (NMSE) between two lists of NumPy arrays.\n\n    Parameters:\n    ref_outputs (list of np.ndarray): List of reference output arrays.\n    approx_outputs (list of np.ndarray): List of approximate output arrays.\n\n    Returns:\n    float: The average NMSE across all pairs of arrays.\n    \"\"\"\n    if len(ref_outputs) != len(approx_outputs):\n        raise ValueError(\"The lists ref_outputs and approx_outputs must have the same length.\")\n    \n    nmse_values = []\n    \n    for ref, approx in zip(ref_outputs, approx_outputs):\n        if ref.shape != approx.shape:\n            raise ValueError(\"Each pair of arrays must have the same shape.\")\n        \n        mse = np.mean((ref - approx) ** 2)\n        mse_ref_zero = np.mean(ref ** 2)\n        \n        if mse_ref_zero == 0:\n            raise ValueError(\"MSE between reference output and zero is zero, cannot normalize.\")\n        \n        nmse = mse / mse_ref_zero\n        nmse_values.append(nmse)\n    \n    average_nmse = np.mean(nmse_values)\n    return average_nmse\n```\n\n### Explanation:\n\n- **Input Validation**: The function first checks if the lengths of `ref_outputs` and `approx_outputs` are the same. It also checks if each pair of arrays has the same shape.\n- **MSE Calculation**: For each pair of arrays, it calculates the MSE between the reference and approximate outputs.\n- **Normalization**: It calculates the MSE between the reference output and a zero array, then normalizes the MSE by dividing it by this value.\n- **Error Handling**: If the MSE between the reference output and zero is zero, it raises an error to avoid division by zero.\n- **Average NMSE**: Finally, it computes the average NMSE across all pairs and returns it.\n\nThis function provides a robust way to compute the NMSE for lists of NumPy arrays, ensuring that the inputs are valid and handling potential edge cases.",
    "prompt": "Create a Python function `normalized_mse` that computes the normalized mean square error (NMSE) between two lists of NumPy arrays, `ref_outputs` and `approx_outputs`. The NMSE is defined as the mean square error (MSE) between the reference and approximate outputs, normalized by the MSE between the reference output and zero. The function iterates over corresponding elements in `ref_outputs` and `approx_outputs`, computes the NMSE for each pair, and then returns the average NMSE across all pairs as a single float value.",
    "function_name": "normalized_mse",
    "ground_truth": "nncf/quantization/algorithms/accuracy_control/rank_functions.py",
    "test": "tests/common/accuracy_control/test_ranking.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Regression",
    "data": ""
}