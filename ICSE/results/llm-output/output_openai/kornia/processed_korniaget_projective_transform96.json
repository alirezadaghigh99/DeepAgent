{
    "result": "To create the `get_projective_transform` function, we need to compute a 3D transformation matrix that includes translation, rotation, and scaling. The function will take the center of rotation, rotation angles, and scale factors as inputs and return the corresponding transformation matrix.\n\nHere's how you can implement this function in Python using PyTorch:\n\n```python\nimport torch\nimport math\n\ndef get_projective_transform(center, angles, scales):\n    # Check input shapes\n    assert center.shape[-1] == 3, \"Center must have shape (B, 3)\"\n    assert angles.shape[-1] == 3, \"Angles must have shape (B, 3)\"\n    assert scales.shape[-1] == 3, \"Scales must have shape (B, 3)\"\n    \n    # Check if center and angles have the same device and dtype\n    assert center.device == angles.device, \"Center and angles must be on the same device\"\n    assert center.dtype == angles.dtype, \"Center and angles must have the same dtype\"\n    \n    B = center.shape[0]\n    \n    # Convert angles from degrees to radians\n    angles_rad = angles * (math.pi / 180.0)\n    \n    # Compute cosines and sines of the angles\n    cos_angles = torch.cos(angles_rad)\n    sin_angles = torch.sin(angles_rad)\n    \n    # Rotation matrices for each axis\n    Rx = torch.eye(3, device=center.device, dtype=center.dtype).repeat(B, 1, 1)\n    Ry = torch.eye(3, device=center.device, dtype=center.dtype).repeat(B, 1, 1)\n    Rz = torch.eye(3, device=center.device, dtype=center.dtype).repeat(B, 1, 1)\n    \n    Rx[:, 1, 1] = cos_angles[:, 0]\n    Rx[:, 1, 2] = -sin_angles[:, 0]\n    Rx[:, 2, 1] = sin_angles[:, 0]\n    Rx[:, 2, 2] = cos_angles[:, 0]\n    \n    Ry[:, 0, 0] = cos_angles[:, 1]\n    Ry[:, 0, 2] = sin_angles[:, 1]\n    Ry[:, 2, 0] = -sin_angles[:, 1]\n    Ry[:, 2, 2] = cos_angles[:, 1]\n    \n    Rz[:, 0, 0] = cos_angles[:, 2]\n    Rz[:, 0, 1] = -sin_angles[:, 2]\n    Rz[:, 1, 0] = sin_angles[:, 2]\n    Rz[:, 1, 1] = cos_angles[:, 2]\n    \n    # Combined rotation matrix\n    R = torch.bmm(Rz, torch.bmm(Ry, Rx))\n    \n    # Scale matrix\n    S = torch.diag_embed(scales)\n    \n    # Combined rotation and scale\n    RS = torch.bmm(R, S)\n    \n    # Translation to the center\n    T = torch.eye(4, device=center.device, dtype=center.dtype).repeat(B, 1, 1)\n    T[:, :3, 3] = center\n    \n    # Create the final transformation matrix\n    transform = torch.zeros((B, 3, 4), device=center.device, dtype=center.dtype)\n    transform[:, :3, :3] = RS\n    transform[:, :3, 3] = center - torch.bmm(RS, center.unsqueeze(-1)).squeeze(-1)\n    \n    return transform\n\n# Example usage:\n# center = torch.tensor([[0.0, 0.0, 0.0]], dtype=torch.float32)\n# angles = torch.tensor([[45.0, 45.0, 45.0]], dtype=torch.float32)\n# scales = torch.tensor([[1.0, 1.0, 1.0]], dtype=torch.float32)\n# transform = get_projective_transform(center, angles, scales)\n# print(transform)\n```\n\nThis function computes the transformation matrix by first creating individual rotation matrices for each axis, then combining them with scaling, and finally applying the translation to the center. The result is a batch of 3D transformation matrices that can be used to project 3D points according to the specified rotation, scaling, and translation.",
    "prompt": "Create a Python function get_projective_transform that calculates the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function takes the following parameters:\n\ncenter: A tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\nangles: A tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\nscales: A tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\nThe function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.Raise an AssertionError if center or angles do not have the expected shape.\nRaise an AssertionError if center and angles do not share the same device and dtype.",
    "function_name": "get_projective_transform",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp3d.py::TestGetRotationMatrix3d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}