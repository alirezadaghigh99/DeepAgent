{
    "result": "To extract image patches from a pyramid of images based on Local Affine Frames (LAFs), we need to follow these steps:\n\n1. **Normalize LAFs (if required):** This involves ensuring that the affine transformations are in a consistent form, typically by normalizing the scale component.\n\n2. **Build an image pyramid:** This involves creating downsampled versions of the input image at different scales.\n\n3. **Determine the appropriate pyramid level for each LAF:** This is based on the scale of the LAF, which dictates the level of detail required.\n\n4. **Extract patches:** For each LAF, extract the corresponding patch from the appropriate pyramid level.\n\n5. **Return the patches:** The patches should be returned in a tensor of shape `(B, N, CH, PS, PS)`.\n\nHere's a Python function implementing the above logic using PyTorch:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef extract_patches_from_pyramid(img, laf, patch_size=32, normalize_lafs=False):\n    B, CH, H, W = img.shape\n    _, N, _, _ = laf.shape\n    \n    # Function to normalize LAFs\n    def normalize_lafs(lafs):\n        # Normalize the scale of the LAFs\n        scales = torch.sqrt(lafs[:, :, 0, 0]**2 + lafs[:, :, 0, 1]**2)\n        lafs[:, :, 0, :2] /= scales.unsqueeze(-1)\n        lafs[:, :, 1, :2] /= scales.unsqueeze(-1)\n        return lafs\n\n    # Optionally normalize LAFs\n    if normalize_lafs:\n        laf = normalize_lafs(laf)\n\n    # Create image pyramid\n    pyramid = [img]\n    current_img = img\n    while min(current_img.shape[-2:]) >= patch_size:\n        current_img = F.interpolate(current_img, scale_factor=0.5, mode='bilinear', align_corners=False)\n        pyramid.append(current_img)\n\n    # Determine the appropriate pyramid level for each LAF\n    scales = torch.sqrt(laf[:, :, 0, 0]**2 + laf[:, :, 0, 1]**2)\n    pyramid_levels = torch.clamp((scales.log2() + 0.5).long(), min=0, max=len(pyramid) - 1)\n\n    # Extract patches\n    patches = torch.zeros(B, N, CH, patch_size, patch_size, device=img.device)\n    for b in range(B):\n        for n in range(N):\n            level = pyramid_levels[b, n].item()\n            current_img = pyramid[level]\n            scale_factor = 2 ** level\n\n            # Transform LAF to the current pyramid level\n            laf_scaled = laf[b, n].clone()\n            laf_scaled[:, 2] /= scale_factor\n\n            # Extract patch using grid_sample\n            grid = F.affine_grid(laf_scaled.unsqueeze(0), torch.Size((1, CH, patch_size, patch_size)), align_corners=False)\n            patch = F.grid_sample(current_img[b:b+1], grid, align_corners=False)\n            patches[b, n] = patch.squeeze(0)\n\n    return patches\n\n# Example usage:\n# img = torch.randn(2, 3, 256, 256)  # Batch of 2 images, 3 channels, 256x256\n# laf = torch.randn(2, 5, 2, 3)      # Batch of 2, 5 LAFs per image\n# patches = extract_patches_from_pyramid(img, laf, patch_size=32, normalize_lafs=True)\n```\n\n### Explanation:\n- **Normalization:** The `normalize_lafs` function ensures that the LAFs have a consistent scale.\n- **Pyramid Construction:** The image pyramid is constructed by iteratively downsampling the image by a factor of 2 until the smallest dimension is less than the patch size.\n- **Pyramid Level Selection:** The appropriate pyramid level for each LAF is determined based on the scale of the LAF.\n- **Patch Extraction:** For each LAF, the affine transformation is applied to extract the patch from the selected pyramid level using `affine_grid` and `grid_sample`.\n\nThis function handles various cases, including when no patches need to be extracted at a particular pyramid level, by ensuring that the pyramid level is clamped within valid bounds.",
    "prompt": "Write a Python function that extracts image patches from a pyramid of images based on input Local Affine Frames (LAFs). The function should take as input an image tensor `img` of shape `(B, CH, H, W)` and LAFs `laf` of shape `(B, N, 2, 3)`. Optionally, normalize the LAFs before extraction. The function should return a tensor of extracted patches of shape `(B, N, CH, PS, PS)`. The extraction should be done at the appropriate pyramid level based on the scale of each LAF. Ensure that the function handles various cases, such as when no patches need to be extracted at a particular pyramid level.",
    "function_name": "extract_patches_from_pyramid",
    "ground_truth": "kornia/feature/laf.py",
    "test": "tests/feature/test_laf.py::TestExtractPatchesPyr",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}