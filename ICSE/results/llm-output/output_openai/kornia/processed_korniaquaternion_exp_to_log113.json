{
    "result": "To implement the `quaternion_exp_to_log` function, we need to follow these steps:\n\n1. **Check Input Type and Shape**: Ensure the input is a PyTorch tensor and has the correct shape.\n2. **Unpack the Quaternion**: Separate the scalar part (w) from the vector part (x, y, z).\n3. **Compute the Norm of the Vector Part**: This is used to determine the angle for the log map.\n4. **Apply the Log Map**: Use the quaternion logarithm formula to compute the log map.\n5. **Clamp Values**: Use the `eps` parameter to avoid division by zero or undefined operations.\n\nHere's the implementation of the function:\n\n```python\nimport torch\n\ndef quaternion_exp_to_log(quaternion, eps=1e-8):\n    # Check if input is a tensor\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    # Check if the shape is (*, 4)\n    if quaternion.shape[-1] != 4:\n        raise ValueError(\"Input tensor must have shape (*, 4).\")\n    \n    # Unpack the quaternion into scalar (w) and vector (x, y, z) parts\n    w = quaternion[..., 0]\n    xyz = quaternion[..., 1:]\n    \n    # Compute the norm of the vector part\n    norm_xyz = torch.norm(xyz, dim=-1)\n    \n    # Clamp the norm to avoid division by zero\n    norm_xyz_clamped = torch.clamp(norm_xyz, min=eps)\n    \n    # Compute the angle\n    angle = torch.acos(torch.clamp(w, min=-1.0, max=1.0))\n    \n    # Compute the log map\n    log_map = (angle / norm_xyz_clamped).unsqueeze(-1) * xyz\n    \n    # Handle the case where the norm is zero (pure real quaternion)\n    log_map = torch.where(norm_xyz.unsqueeze(-1) < eps, torch.zeros_like(log_map), log_map)\n    \n    return log_map\n\n# Example usage\nquaternion = torch.tensor((1., 0., 0., 0.))\nresult = quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\nprint(result)  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n\n- **Input Check**: The function first checks if the input is a tensor and has the correct shape.\n- **Unpacking**: The quaternion is split into its scalar and vector components.\n- **Norm Calculation**: The norm of the vector part is calculated and clamped to avoid division by zero.\n- **Log Map Calculation**: The quaternion logarithm is computed using the formula: \n  \\[\n  \\text{log}(q) = \\frac{\\theta}{\\|v\\|} v\n  \\]\n  where \\( \\theta = \\cos^{-1}(w) \\) and \\( v = (x, y, z) \\).\n- **Handling Edge Cases**: If the quaternion is purely real (i.e., the vector part is zero), the log map is zero.\n\nThis function should work for any batch of quaternions provided as a tensor with shape `(*, 4)`.",
    "prompt": "Generate a Python function called quaternion_exp_to_log that applies the log map to a quaternion. The input is a tensor called quaternion in (w, x, y, z) format and a float called eps for clamping. The output is a tensor of shape (*, 3) representing the quaternion log map. The function checks if the input is a Tensor and has a shape of (*, 4). It then unpacks the quaternion into a vector and scalar, computes the quaternion norm, and applies the log map to calculate the quaternion log. An example usage is provided with a sample quaternion input. >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_exp_to_log",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/epipolar/test_essential.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}