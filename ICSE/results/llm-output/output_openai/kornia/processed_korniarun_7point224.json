{
    "result": "To implement the 7-point algorithm for computing the fundamental matrix, we need to follow several steps. The algorithm involves normalizing the input points, constructing a linear system, solving it using Singular Value Decomposition (SVD), and then using the results to form a cubic polynomial. Solving this polynomial gives us the potential fundamental matrices.\n\nHere's a step-by-step implementation of the `run_7point` function:\n\n```python\nimport numpy as np\n\ndef normalize_points(points):\n    \"\"\" Normalize a set of points so that the centroid is at the origin and the average distance to the origin is sqrt(2). \"\"\"\n    centroid = np.mean(points, axis=1, keepdims=True)\n    centered_points = points - centroid\n    scale = np.sqrt(2) / np.mean(np.linalg.norm(centered_points, axis=2, keepdims=True), axis=1, keepdims=True)\n    normalized_points = centered_points * scale\n    T = np.zeros((points.shape[0], 3, 3))\n    T[:, 0, 0] = scale[:, 0, 0]\n    T[:, 1, 1] = scale[:, 0, 0]\n    T[:, 0, 2] = -scale[:, 0, 0] * centroid[:, 0, 0]\n    T[:, 1, 2] = -scale[:, 0, 0] * centroid[:, 0, 1]\n    T[:, 2, 2] = 1\n    return normalized_points, T\n\ndef construct_matrix(points1, points2):\n    \"\"\" Construct the matrix A used in the 7-point algorithm. \"\"\"\n    B, N, _ = points1.shape\n    A = np.zeros((B, N, 9))\n    A[:, :, 0] = points1[:, :, 0] * points2[:, :, 0]\n    A[:, :, 1] = points1[:, :, 1] * points2[:, :, 0]\n    A[:, :, 2] = points2[:, :, 0]\n    A[:, :, 3] = points1[:, :, 0] * points2[:, :, 1]\n    A[:, :, 4] = points1[:, :, 1] * points2[:, :, 1]\n    A[:, :, 5] = points2[:, :, 1]\n    A[:, :, 6] = points1[:, :, 0]\n    A[:, :, 7] = points1[:, :, 1]\n    A[:, :, 8] = 1\n    return A\n\ndef solve_fundamental_matrix(A):\n    \"\"\" Solve for the fundamental matrix using SVD. \"\"\"\n    B = A.shape[0]\n    F_matrices = []\n    for i in range(B):\n        _, _, Vt = np.linalg.svd(A[i])\n        F1 = Vt[-1].reshape(3, 3)\n        F2 = Vt[-2].reshape(3, 3)\n        F_matrices.append((F1, F2))\n    return F_matrices\n\ndef compute_polynomial(F1, F2):\n    \"\"\" Compute the coefficients of the cubic polynomial. \"\"\"\n    def det(F):\n        return np.linalg.det(F)\n    \n    a0 = det(F1)\n    a1 = (det(F1 + F2) - a0 - det(F2))\n    a2 = (det(F1 - F2) - a0 - det(F2))\n    a3 = det(F2)\n    \n    return a0, a1, a2, a3\n\ndef solve_cubic(a0, a1, a2, a3):\n    \"\"\" Solve the cubic polynomial a0 + a1*x + a2*x^2 + a3*x^3 = 0. \"\"\"\n    roots = np.roots([a3, a2, a1, a0])\n    return roots\n\ndef run_7point(points1, points2):\n    assert points1.shape == points2.shape, \"Input point sets must have the same shape.\"\n    B, N, C = points1.shape\n    assert N == 7 and C == 2, \"Each batch must contain exactly 7 points with 2 coordinates each.\"\n\n    # Normalize points\n    norm_points1, T1 = normalize_points(points1)\n    norm_points2, T2 = normalize_points(points2)\n\n    # Construct matrix A\n    A = construct_matrix(norm_points1, norm_points2)\n\n    # Solve for fundamental matrices\n    F_matrices = solve_fundamental_matrix(A)\n\n    # Compute potential fundamental matrices\n    all_F = []\n    for i in range(B):\n        F1, F2 = F_matrices[i]\n        a0, a1, a2, a3 = compute_polynomial(F1, F2)\n        roots = solve_cubic(a0, a1, a2, a3)\n        \n        # Compute the fundamental matrices for each root\n        for root in roots:\n            if np.isreal(root):\n                F = root.real * F1 + (1 - root.real) * F2\n                # Denormalize the fundamental matrix\n                F = T2[i].T @ F @ T1[i]\n                all_F.append(F)\n\n    # Reshape the result\n    m = len(all_F) // B\n    all_F = np.array(all_F).reshape(B, m, 3, 3)\n    return all_F\n\n# Example usage:\n# points1 = np.random.rand(1, 7, 2)\n# points2 = np.random.rand(1, 7, 2)\n# F_matrices = run_7point(points1, points2)\n# print(F_matrices.shape)  # Should be (1, 3*m, 3)\n```\n\nThis implementation includes the normalization of points, construction of the matrix for the linear system, solving using SVD, and handling the cubic polynomial to find the potential fundamental matrices. The function is designed to handle batches of point sets and returns the fundamental matrices for each batch.",
    "prompt": "Create a Python function `run_7point` that computes the fundamental matrix using the 7-point algorithm. The function should:\n\n- Accept two sets of points (`points1`, `points2`) as input, each of shape `(B, N, 2)`, where `B` is the batch size, and `N` is the number of points (exactly 7).\n- Normalize the points, construct a linear system, and solve it using SVD to obtain two fundamental matrices.\n- Use these matrices to form a cubic polynomial, solve for its roots, and compute up to three potential fundamental matrices.\n- Handle edge cases where matrices might be non-invertible and ensure numerical stability.\n- Return the computed fundamental matrices in the shape `(B, 3*m, 3)`, where `m` can be 1, 2, or 3.\n\nErrors:\n- The function should raise `AssertionError` if the input tensors do not have the expected shapes.\n- Handle cases where matrix inversion is problematic, ensuring robust solutions are returned.",
    "function_name": "run_7point",
    "ground_truth": "kornia/geometry/epipolar/fundamental.py#L76",
    "test": "tests/geometry/epipolar/test_fundamental.py::TestFindFundamental",
    "class": "",
    "stage": "Model Construction",
    "task": "Detection",
    "data": "Image"
}