{
    "result": "To implement the `forward` method for the `AdjustHue` class, we need to adjust the hue of an RGB image tensor. The input tensor is expected to have pixel values in the range [0, 1] and a shape of `(*, 3, H, W)`, where `*` represents any number of leading dimensions (such as batch size).\n\nThe hue adjustment involves converting the RGB image to the HSV (Hue, Saturation, Value) color space, modifying the hue channel, and then converting it back to RGB. Here's how you can implement this:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom torch.nn import Module\n\nclass AdjustHue(Module):\n    def __init__(self, hue_factor: float):\n        super().__init__()\n        self.hue_factor = hue_factor\n\n    def forward(self, input: Tensor) -> Tensor:\n        # Ensure the input is a float tensor\n        if not input.is_floating_point():\n            raise TypeError('Input tensor should be a float tensor with values in the range [0, 1]')\n\n        # Check the input shape\n        if input.size(-3) != 3:\n            raise ValueError('Input tensor should have 3 channels in the last but two dimension')\n\n        # Convert RGB to HSV\n        hsv = self.rgb_to_hsv(input)\n\n        # Adjust the hue\n        h, s, v = hsv.unbind(dim=-3)\n        h = (h + self.hue_factor) % 1.0  # Wrap around hue values\n        hsv_adjusted = torch.stack((h, s, v), dim=-3)\n\n        # Convert back to RGB\n        return self.hsv_to_rgb(hsv_adjusted)\n\n    def rgb_to_hsv(self, rgb: Tensor) -> Tensor:\n        r, g, b = rgb.unbind(dim=-3)\n        maxc = torch.max(rgb, dim=-3).values\n        minc = torch.min(rgb, dim=-3).values\n        v = maxc\n        deltac = maxc - minc\n        s = deltac / maxc.clamp(min=1e-5)\n\n        # Hue calculation\n        rc = (maxc - r) / deltac\n        gc = (maxc - g) / deltac\n        bc = (maxc - b) / deltac\n\n        h = torch.zeros_like(maxc)\n        h[maxc == r] = (bc - gc)[maxc == r]\n        h[maxc == g] = (2.0 + rc - bc)[maxc == g]\n        h[maxc == b] = (4.0 + gc - rc)[maxc == b]\n        h = (h / 6.0) % 1.0\n\n        return torch.stack((h, s, v), dim=-3)\n\n    def hsv_to_rgb(self, hsv: Tensor) -> Tensor:\n        h, s, v = hsv.unbind(dim=-3)\n        i = (h * 6.0).floor()\n        f = (h * 6.0) - i\n        i = i.to(torch.int32) % 6\n\n        p = v * (1.0 - s)\n        q = v * (1.0 - f * s)\n        t = v * (1.0 - (1.0 - f) * s)\n\n        conditions = [\n            (i == 0, torch.stack((v, t, p), dim=-3)),\n            (i == 1, torch.stack((q, v, p), dim=-3)),\n            (i == 2, torch.stack((p, v, t), dim=-3)),\n            (i == 3, torch.stack((p, q, v), dim=-3)),\n            (i == 4, torch.stack((t, p, v), dim=-3)),\n            (i == 5, torch.stack((v, p, q), dim=-3)),\n        ]\n\n        rgb = torch.zeros_like(hsv)\n        for condition, value in conditions:\n            rgb = torch.where(condition.unsqueeze(-3), value, rgb)\n\n        return rgb\n```\n\n### Explanation:\n1. **Input Validation**: We first check if the input tensor is a floating-point tensor and has 3 channels in the appropriate dimension.\n\n2. **RGB to HSV Conversion**: We convert the RGB image to HSV using the `rgb_to_hsv` method. This involves calculating the hue, saturation, and value based on the RGB components.\n\n3. **Hue Adjustment**: The hue is adjusted by adding the `hue_factor` and wrapping it around using modulo 1.0 to ensure it stays within the valid range [0, 1].\n\n4. **HSV to RGB Conversion**: After adjusting the hue, we convert the HSV image back to RGB using the `hsv_to_rgb` method.\n\nThis implementation should correctly adjust the hue of the input image tensor.",
    "prompt": "**Task:** Write the `forward` method for the `AdjustHue` class. This method should adjust the hue of the input image tensor by a specified hue factor.\n**Class Context:**\n```python\nclass AdjustHue(Module):\n    def forward(self, input: Tensor) -> Tensor:\n        # Implement this function\n```\n- The method should apply the hue adjustment to the input tensor using the provided `hue_factor`.\n- The input tensor is expected to be an RGB image with pixel values in the range [0, 1] and of shape `(*, 3, H, W)`\nThis prompt instructs the user to implement the `forward` method for adjusting the hue of an image tensor using the provided `hue_factor`.",
    "function_name": "forward",
    "ground_truth": "kornia/enhance/adjust.py",
    "test": "tests/enhance/test_adjust.py::TestAdjustHue",
    "class": "AdjustHue",
    "stage": "Training",
    "task": "",
    "data": "Image"
}