{
    "result": "To convert a YUV420 image to RGB in PyTorch, we need to follow these steps:\n\n1. **Upsample the UV planes**: Since the UV planes are subsampled by a factor of 2 in both dimensions, we need to upsample them to match the dimensions of the Y plane.\n\n2. **Convert YUV to RGB**: Once we have the YUV444 format, we can convert it to RGB using a standard conversion formula.\n\nBelow is the implementation of the `yuv420_to_rgb` function, including a helper function `yuv_to_rgb` for the conversion:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef yuv_to_rgb(yuv):\n    # YUV to RGB conversion matrix\n    # Assuming YUV is in the range Y: [0, 1], U, V: [-0.5, 0.5]\n    # RGB will be in the range [0, 1]\n    y, u, v = yuv[:, 0, :, :], yuv[:, 1, :, :], yuv[:, 2, :, :]\n    \n    r = y + 1.402 * v\n    g = y - 0.344136 * u - 0.714136 * v\n    b = y + 1.772 * u\n    \n    rgb = torch.stack((r, g, b), dim=1)\n    return rgb.clamp(0, 1)\n\ndef yuv420_to_rgb(imagey, imageuv):\n    # Check input types and shapes\n    assert isinstance(imagey, torch.Tensor), \"imagey must be a torch Tensor\"\n    assert isinstance(imageuv, torch.Tensor), \"imageuv must be a torch Tensor\"\n    assert imagey.shape[1] == 1, \"imagey must have shape (*, 1, H, W)\"\n    assert imageuv.shape[1] == 2, \"imageuv must have shape (*, 2, H/2, W/2)\"\n    \n    batch_size, _, H, W = imagey.shape\n    _, _, H_uv, W_uv = imageuv.shape\n    \n    assert H == 2 * H_uv and W == 2 * W_uv, \"imageuv dimensions must be half of imagey dimensions\"\n    \n    # Upsample UV to match Y dimensions\n    imageuv_upsampled = F.interpolate(imageuv, size=(H, W), mode='bilinear', align_corners=False)\n    \n    # Concatenate Y and upsampled UV to form YUV444\n    yuv444 = torch.cat((imagey, imageuv_upsampled), dim=1)\n    \n    # Convert YUV444 to RGB\n    rgb = yuv_to_rgb(yuv444)\n    \n    return rgb\n\n# Example usage:\n# imagey = torch.rand((1, 1, 4, 4))  # Example Y plane\n# imageuv = torch.rand((1, 2, 2, 2)) - 0.5  # Example UV plane\n# rgb_image = yuv420_to_rgb(imagey, imageuv)\n```\n\n### Explanation:\n\n- **Input Validation**: The function checks that the inputs are torch Tensors and have the expected shapes.\n\n- **Upsampling**: The `F.interpolate` function is used to upsample the UV planes to match the Y plane's dimensions. The `bilinear` mode is used for smooth upsampling, and `align_corners=False` is set to ensure proper scaling.\n\n- **YUV to RGB Conversion**: The `yuv_to_rgb` function applies the standard conversion formula to transform YUV values to RGB. The resulting RGB values are clamped to the range [0, 1].\n\nThis function assumes that the input images are already padded to be evenly divisible by 2, as specified in the problem statement.",
    "prompt": "Create a Python function called yuv420_to_rgb that converts a YUV420 image to RGB. The function takes two torch Tensors as input: imagey for the Y (luma) image plane with shape (*, 1, H, W) and imageuv for the UV (chroma) image planes with shape (*, 2, H/2, W/2). The output is the RGB version of the image with shape (*, 3, H, W). The function assumes that the image data is in the range of (0, 1) for luma and (-0.5, 0.5) for chroma, and that the input needs to be padded to be evenly divisible by 2 horizontally and vertically. The chroma siting is assumed to be (0.5, 0.5).\n\nEnsure that the input imagey and imageuv are torch Tensors, have the correct shapes, and meet the specified requirements. The function first upsamples the input images and then converts the YUV444 tensor to RGB using a separate function called yuv_to_rgb.",
    "function_name": "yuv420_to_rgb",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestYuv420ToRgb",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}