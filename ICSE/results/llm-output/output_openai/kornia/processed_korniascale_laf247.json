{
    "result": "To create the `scale_laf` function, we need to understand the structure of a Local Affine Frame (LAF) represented by a tensor of shape `(B, N, 2, 3)`. In this representation:\n\n- `B` is the batch size.\n- `N` is the number of LAFs per batch.\n- The last two dimensions `(2, 3)` represent the affine transformation matrix, where:\n  - The first two columns `(2, 2)` represent the linear transformation (region part).\n  - The last column `(2, 1)` represents the translation (center of the LAF).\n\nThe task is to scale the region part of the LAF by a `scale_coef`, which means multiplying the first two columns of the LAF by this coefficient. The center (last column) should remain unchanged.\n\nHere's how you can implement the `scale_laf` function:\n\n```python\nimport torch\n\ndef scale_laf(laf, scale_coef):\n    \"\"\"\n    Scales the region part of a Local Affine Frame (LAF) by a scale coefficient.\n\n    Parameters:\n    - laf (torch.Tensor): A tensor of shape (B, N, 2, 3) representing the LAFs.\n    - scale_coef (float or torch.Tensor): The scale coefficient.\n\n    Returns:\n    - torch.Tensor: The scaled LAF of the same shape as the input.\n\n    Raises:\n    - TypeError: If scale_coef is neither a float nor a torch.Tensor.\n    \"\"\"\n    if not isinstance(scale_coef, (float, torch.Tensor)):\n        raise TypeError(\"scale_coef must be either a float or a torch.Tensor\")\n\n    # Ensure scale_coef is a tensor for consistent operations\n    if isinstance(scale_coef, float):\n        scale_coef = torch.tensor(scale_coef, dtype=laf.dtype, device=laf.device)\n\n    # Scale the region part (first two columns) of the LAF\n    scaled_laf = laf.clone()\n    scaled_laf[..., :2] *= scale_coef\n\n    return scaled_laf\n\n# Example usage:\n# laf = torch.rand((B, N, 2, 3))\n# scale_coef = 2.0\n# scaled_laf = scale_laf(laf, scale_coef)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if `scale_coef` is either a float or a tensor. If not, it raises a `TypeError`.\n\n2. **Tensor Conversion**: If `scale_coef` is a float, it is converted to a tensor to ensure compatibility with tensor operations.\n\n3. **Scaling Operation**: The function scales the first two columns of the LAF (the region part) by `scale_coef`. This is done using element-wise multiplication.\n\n4. **Return**: The function returns the scaled LAF, maintaining the original shape `(B, N, 2, 3)`.\n\nThis implementation ensures that the center of the LAF remains unchanged while the region part is scaled appropriately.",
    "prompt": "Create a function `scale_laf` that multiplies the region part of a Local Affine Frame (LAF) by a `scale_coef`, keeping the center, shape, and orientation unchanged but altering the region area. The function accepts a tensor `laf` of shape `(B, N, 2, 3)` and a `scale_coef`, which can be either a float or a tensor. It returns the scaled LAF of the same shape. A `TypeError` is raised if `scale_coef` is neither a float nor a tensor.",
    "function_name": "scale_laf",
    "ground_truth": "kornia/feature/laf.py#L133",
    "test": "tests/feature/test_laf.py::TestScaleLAF",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}