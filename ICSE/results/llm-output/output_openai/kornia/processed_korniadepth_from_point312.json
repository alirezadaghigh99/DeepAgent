{
    "result": "To compute the depth of a point transformed by a rigid transform, we need to apply the transformation to the 3D point and then extract the depth component. The depth is typically considered as the z-component of the transformed point in the camera's coordinate system.\n\nHere's a Python function `depth_from_point` that performs this operation:\n\n```python\nimport numpy as np\n\ndef depth_from_point(R, t, X):\n    \"\"\"\n    Return the depth of a point transformed by a rigid transform.\n\n    Args:\n       R: The rotation matrix with shape (*, 3, 3).\n       t: The translation vector with shape (*, 3, 1).\n       X: The 3d points with shape (*, 3).\n\n    Returns:\n       The depth value per point with shape (*, 1).\n    \"\"\"\n    # Ensure inputs are numpy arrays\n    R = np.asarray(R)\n    t = np.asarray(t)\n    X = np.asarray(X)\n\n    # Check the shapes of the inputs\n    assert R.shape[-2:] == (3, 3), \"Rotation matrix R must have shape (*, 3, 3)\"\n    assert t.shape[-2:] == (3, 1), \"Translation vector t must have shape (*, 3, 1)\"\n    assert X.shape[-1] == 3, \"3D points X must have shape (*, 3)\"\n\n    # Apply the rigid transformation: X' = R * X + t\n    # Reshape X to ensure it is compatible for matrix multiplication\n    X_transformed = np.matmul(R, X[..., np.newaxis]) + t\n\n    # Extract the z-component (depth) from the transformed points\n    depth = X_transformed[..., 2, :]  # Get the z-component\n\n    return depth\n\n# Example usage:\n# R = np.array([[[1, 0, 0], [0, 1, 0], [0, 0, 1]]])  # Identity rotation\n# t = np.array([[[0], [0], [0]]])  # Zero translation\n# X = np.array([[1, 2, 3]])  # A single 3D point\n# depth = depth_from_point(R, t, X)\n# print(depth)  # Output: [[3]]\n```\n\n### Explanation:\n- **Inputs**:\n  - `R`: Rotation matrix of shape `(*, 3, 3)`.\n  - `t`: Translation vector of shape `(*, 3, 1)`.\n  - `X`: 3D points of shape `(*, 3)`.\n\n- **Transformation**:\n  - The transformation is applied using the formula \\( X' = R \\cdot X + t \\).\n  - We use `np.matmul` to perform matrix multiplication between `R` and `X`.\n\n- **Depth Extraction**:\n  - The depth is the z-component of the transformed point, which is accessed using `X_transformed[..., 2, :]`.\n\nThis function assumes that the inputs are compatible in terms of batch dimensions, and it handles broadcasting automatically due to the use of numpy's broadcasting rules.",
    "prompt": "Write a python function depth_from_point that Return the depth of a point transformed by a rigid transform.\n\n    Args:\n       R: The rotation matrix with shape :math:`(*, 3, 3)`.\n       t: The translation vector with shape :math:`(*, 3, 1)`.\n       X: The 3d points with shape :math:`(*, 3)`.\n\n    Returns:\n       The depth value per point with shape :math:`(*, 1)`.",
    "function_name": "depth_from_point",
    "ground_truth": "kornia/geometry/epipolar/projection.py#L151",
    "test": "tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution",
    "class": "",
    "stage": "Inference",
    "task": "Prediction",
    "data": "Image"
}