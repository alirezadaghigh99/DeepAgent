{
    "result": "To create the `tensor_to_image` function, we need to handle several tasks: checking the input type, managing the device (CPU/GPU), reshaping the tensor, and converting it to a NumPy array. Here's how you can implement this function:\n\n```python\nimport torch\nimport numpy as np\n\ndef tensor_to_image(tensor, keepdim=True, force_contiguous=False):\n    # Check if the input is a PyTorch tensor\n    if not isinstance(tensor, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    # Check the number of dimensions\n    if tensor.dim() not in {2, 3, 4}:\n        raise ValueError(\"Input tensor must have 2, 3, or 4 dimensions.\")\n    \n    # Move tensor to CPU if it's on GPU\n    if tensor.is_cuda:\n        tensor = tensor.cpu()\n    \n    # Make tensor contiguous if required\n    if force_contiguous:\n        tensor = tensor.contiguous()\n    \n    # Convert tensor to NumPy array\n    array = tensor.numpy()\n    \n    # Handle different shapes\n    if tensor.dim() == 2:\n        # Shape: (H, W)\n        return array\n    elif tensor.dim() == 3:\n        # Shape: (C, H, W) -> (H, W, C)\n        array = np.transpose(array, (1, 2, 0))\n        return array\n    elif tensor.dim() == 4:\n        # Shape: (B, C, H, W) -> (B, H, W, C)\n        array = np.transpose(array, (0, 2, 3, 1))\n        if not keepdim:\n            # Remove the batch dimension if keepdim is False\n            array = np.squeeze(array, axis=0)\n        return array\n\n# Example usage:\n# tensor = torch.randn(3, 224, 224)  # Example tensor\n# image = tensor_to_image(tensor)\n```\n\n### Explanation:\n\n1. **Type and Dimension Checks**: The function first checks if the input is a PyTorch tensor and whether it has 2, 3, or 4 dimensions. If not, it raises appropriate errors.\n\n2. **Device Management**: If the tensor is on a GPU, it is moved to the CPU using `tensor.cpu()`.\n\n3. **Contiguity**: If `force_contiguous` is `True`, the tensor is made contiguous using `tensor.contiguous()`. This ensures that the memory layout is suitable for conversion to a NumPy array.\n\n4. **Conversion and Reshaping**:\n   - For a 2D tensor `(H, W)`, it directly converts to a NumPy array.\n   - For a 3D tensor `(C, H, W)`, it transposes to `(H, W, C)` to match the typical image format.\n   - For a 4D tensor `(B, C, H, W)`, it transposes to `(B, H, W, C)`. If `keepdim` is `False`, it squeezes the batch dimension.\n\nThis function should handle most common cases for converting PyTorch tensors to NumPy arrays suitable for image processing tasks.",
    "prompt": "Create a Python function `tensor_to_image` that converts a PyTorch tensor image to a NumPy array image. The function should:\n\n- Accept a tensor as input, which can have one of the following shapes: `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- Convert the tensor to a NumPy array, handling cases where the tensor is in GPU memory by copying it back to CPU.\n- Optionally, squeeze the dimensions if `keepdim` is `False`.\n- Ensure the tensor is contiguous if `force_contiguous` is `True`.\n- Return the converted image with the appropriate shape: `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nInput types:\n- `tensor`: A PyTorch tensor of shape `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- `keepdim`: A boolean indicating whether to retain the batch dimension.\n- `force_contiguous`: A boolean indicating whether to make the tensor contiguous.\n\nOutput:\n- Returns a NumPy array representing the image with the shape `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nErrors:\n- Raise a `TypeError` if the input is not a Tensor.\n- Raise a `ValueError` if the input tensor's dimensions are not 2, 3, or 4.",
    "function_name": "tensor_to_image",
    "ground_truth": "kornia/utils/image.py",
    "test": "tests/utils/test_image_utils.py::test_tensor_to_image",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}