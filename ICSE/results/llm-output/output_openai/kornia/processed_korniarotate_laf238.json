{
    "result": "To create the `rotate_laf` function, we need to apply a rotation to each Local Affine Frame (LAF) in the input tensor. The LAF is represented by a tensor of shape `(B, N, 2, 3)`, where `B` is the batch size, `N` is the number of LAFs, and each LAF consists of a 2x3 matrix. The rotation angles are provided in degrees in a tensor of shape `(B, N, 1)`.\n\nHere's how you can implement the `rotate_laf` function:\n\n```python\nimport torch\n\ndef rotate_laf(LAF, angles_degrees):\n    # Check if the input LAF has the correct shape\n    if LAF.ndim != 4 or LAF.shape[2:] != (2, 3):\n        raise ValueError(\"Input LAF must have shape (B, N, 2, 3)\")\n    \n    # Check if angles_degrees has the correct shape\n    if angles_degrees.ndim != 3 or angles_degrees.shape[2] != 1:\n        raise ValueError(\"angles_degrees must have shape (B, N, 1)\")\n    \n    # Convert angles from degrees to radians\n    angles_radians = angles_degrees * (torch.pi / 180.0)\n    \n    # Compute the rotation matrices\n    cos_angles = torch.cos(angles_radians)\n    sin_angles = torch.sin(angles_radians)\n    \n    # Create the rotation matrices of shape (B, N, 2, 2)\n    rotation_matrices = torch.zeros((LAF.shape[0], LAF.shape[1], 2, 2), device=LAF.device, dtype=LAF.dtype)\n    rotation_matrices[:, :, 0, 0] = cos_angles.squeeze(-1)\n    rotation_matrices[:, :, 0, 1] = -sin_angles.squeeze(-1)\n    rotation_matrices[:, :, 1, 0] = sin_angles.squeeze(-1)\n    rotation_matrices[:, :, 1, 1] = cos_angles.squeeze(-1)\n    \n    # Apply the rotation to the 2x2 part of each LAF\n    # LAF[:, :, :2, :2] is the 2x2 matrix part of each LAF\n    rotated_LAF_2x2 = torch.matmul(rotation_matrices, LAF[:, :, :2, :2])\n    \n    # Construct the rotated LAF by combining the rotated 2x2 part with the original translation part\n    rotated_LAF = torch.cat((rotated_LAF_2x2, LAF[:, :, :2, 2:]), dim=-1)\n    \n    return rotated_LAF\n\n# Example usage:\n# LAF = torch.randn(2, 3, 2, 3)  # Example LAF tensor\n# angles_degrees = torch.tensor([[[30.0], [45.0], [60.0]], [[90.0], [120.0], [150.0]]])  # Example angles\n# rotated_LAF = rotate_laf(LAF, angles_degrees)\n# print(rotated_LAF)\n```\n\n### Explanation:\n1. **Input Validation**: The function first checks if the input tensors `LAF` and `angles_degrees` have the expected shapes. If not, it raises a `ValueError`.\n\n2. **Angle Conversion**: The rotation angles are converted from degrees to radians since trigonometric functions in PyTorch use radians.\n\n3. **Rotation Matrix Construction**: For each angle, a 2x2 rotation matrix is constructed using the cosine and sine of the angle.\n\n4. **Matrix Multiplication**: The rotation matrix is applied to the 2x2 part of each LAF using matrix multiplication.\n\n5. **Reconstruction of LAF**: The rotated 2x2 part is combined with the original translation part (the last column of the LAF) to form the rotated LAF.\n\nThis function will correctly rotate each LAF by the specified angles and return the rotated LAFs.",
    "prompt": "Create a function `rotate_laf` that applies an additional rotation to a Local Affine Frame (LAF). The function takes in a tensor `LAF` of shape `(B, N, 2, 3)` and a tensor `angles_degrees` of shape `(B, N, 1)` representing rotation angles in degrees. It returns the rotated LAF with the same shape. The function raises an error if the input LAF is not properly structured.",
    "function_name": "rotate_laf",
    "ground_truth": "kornia/feature/laf.py#L70",
    "test": "tests/feature/test_laf.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}