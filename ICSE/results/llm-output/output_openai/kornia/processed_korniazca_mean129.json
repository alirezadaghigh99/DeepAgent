{
    "result": "To implement the `zca_mean` function, we need to perform ZCA whitening on a given input tensor. ZCA whitening is a preprocessing step that decorrelates the data while preserving the original structure as much as possible. Here's how you can implement this function in Python using NumPy:\n\n```python\nimport numpy as np\n\ndef zca_mean(inp, dim=0, unbiased=True, eps=1e-5, return_inverse=False):\n    \"\"\"\n    Computes the ZCA whitening matrix and mean vector for a given input tensor.\n\n    Parameters:\n    - inp: np.ndarray, the input tensor.\n    - dim: int, the dimension along which the samples are located.\n    - unbiased: bool, whether to use the unbiased estimate of the covariance matrix.\n    - eps: float, a small value for numerical stability.\n    - return_inverse: bool, whether to return the inverse ZCA transform.\n\n    Returns:\n    - A tuple containing the ZCA matrix, the mean vector, and optionally the inverse ZCA matrix.\n    \"\"\"\n    # Validate input types\n    if not isinstance(inp, np.ndarray):\n        raise TypeError(\"Input must be a numpy ndarray.\")\n    if not isinstance(dim, int):\n        raise TypeError(\"Dimension must be an integer.\")\n    if not isinstance(unbiased, bool):\n        raise TypeError(\"Unbiased must be a boolean.\")\n    if not isinstance(eps, (float, int)):\n        raise TypeError(\"Eps must be a float or int.\")\n    if not isinstance(return_inverse, bool):\n        raise TypeError(\"Return_inverse must be a boolean.\")\n\n    # Validate dimension\n    if dim < 0 or dim >= inp.ndim:\n        raise ValueError(\"Dimension is out of bounds for the input tensor.\")\n\n    # Move the specified dimension to the first axis\n    inp = np.moveaxis(inp, dim, 0)\n\n    # Compute the mean along the specified dimension\n    mean_vector = np.mean(inp, axis=0)\n\n    # Center the data\n    centered_data = inp - mean_vector\n\n    # Compute the covariance matrix\n    n_samples = centered_data.shape[0]\n    if unbiased:\n        cov_matrix = np.dot(centered_data.T, centered_data) / (n_samples - 1)\n    else:\n        cov_matrix = np.dot(centered_data.T, centered_data) / n_samples\n\n    # Singular Value Decomposition\n    U, S, V = np.linalg.svd(cov_matrix)\n\n    # Compute the ZCA whitening matrix\n    S_inv_sqrt = np.diag(1.0 / np.sqrt(S + eps))\n    zca_matrix = np.dot(U, np.dot(S_inv_sqrt, U.T))\n\n    # Optionally compute the inverse ZCA matrix\n    if return_inverse:\n        S_sqrt = np.diag(np.sqrt(S + eps))\n        zca_inverse_matrix = np.dot(U, np.dot(S_sqrt, U.T))\n        return zca_matrix, mean_vector, zca_inverse_matrix\n\n    return zca_matrix, mean_vector\n\n# Example usage:\n# inp = np.random.rand(100, 10)  # 100 samples, 10 features\n# zca_matrix, mean_vector = zca_mean(inp, dim=0, unbiased=True, eps=1e-5, return_inverse=False)\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input tensor is a NumPy array and if the other parameters are of the correct types.\n- **Dimension Handling**: The specified dimension is moved to the first axis to simplify operations.\n- **Mean and Centering**: The mean is computed along the specified dimension, and the data is centered by subtracting the mean.\n- **Covariance Matrix**: The covariance matrix is computed, with an option for an unbiased estimate.\n- **SVD and ZCA Matrix**: Singular Value Decomposition (SVD) is used to compute the ZCA whitening matrix. A small `eps` is added for numerical stability.\n- **Inverse ZCA Matrix**: If requested, the inverse ZCA matrix is also computed and returned.\n\nThis function should work for any input tensor with samples along the specified dimension, providing a robust implementation of ZCA whitening.",
    "prompt": "Generate a Python function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor. The function should take as input a tensor `inp`, the dimension `dim` along which the samples are located, a boolean `unbiased` to decide whether to use the unbiased estimate of the covariance matrix, a small value `eps` for numerical stability, and a boolean `return_inverse` to decide whether to return the inverse ZCA transform. The function should return a tuple containing the ZCA matrix, the mean vector, and optionally the inverse ZCA matrix. The tensor shapes should be validated, and appropriate exceptions should be raised if inputs are of incorrect types or dimensions. Include the necessary imports and tensor operations to perform the ZCA whitening process.",
    "function_name": "zca_mean",
    "ground_truth": "kornia/enhance/zca.py",
    "test": "tests/enhance/test_zca.py::TestZCA",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}