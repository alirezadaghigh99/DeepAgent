{
    "result": "To convert an RGB image to YUV 420 format using PyTorch, we need to follow these steps:\n\n1. **Check Input Dimensions**: Ensure the input tensor has the shape `(*, 3, H, W)` and that `H` and `W` are even numbers. If not, raise an error.\n\n2. **Convert RGB to YUV**: Use the standard conversion formula to transform the RGB values to YUV.\n\n3. **Subsample the UV Channels**: For YUV 420, the U and V channels are subsampled by a factor of 2 in both dimensions.\n\n4. **Return the Y and UV Tensors**: The Y channel should have the shape `(*, 1, H, W)`, and the UV channels should have the shape `(*, 2, H/2, W/2)`.\n\nHere's the implementation of the `rgb_to_yuv420` function:\n\n```python\nimport torch\nfrom typing import Tuple\n\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    if image.dim() < 3 or image.size(-3) != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n    \n    H, W = image.size(-2), image.size(-1)\n    \n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width of the image must be even numbers\")\n    \n    # RGB to YUV conversion matrix\n    rgb_to_yuv_matrix = torch.tensor([\n        [0.299, 0.587, 0.114],\n        [-0.14713, -0.28886, 0.436],\n        [0.615, -0.51499, -0.10001]\n    ], dtype=image.dtype, device=image.device)\n    \n    # Reshape image to (N, 3, H, W) for batch processing\n    original_shape = image.shape\n    image = image.view(-1, 3, H, W)\n    \n    # Convert RGB to YUV\n    yuv_image = torch.tensordot(image.permute(0, 2, 3, 1), rgb_to_yuv_matrix, dims=([3], [1]))\n    yuv_image = yuv_image.permute(0, 3, 1, 2)  # (N, 3, H, W)\n    \n    # Extract Y, U, V channels\n    Y = yuv_image[:, 0:1, :, :]  # (N, 1, H, W)\n    U = yuv_image[:, 1:2, :, :]  # (N, 1, H, W)\n    V = yuv_image[:, 2:3, :, :]  # (N, 1, H, W)\n    \n    # Subsample U and V channels\n    U_subsampled = U[:, :, ::2, ::2]  # (N, 1, H/2, W/2)\n    V_subsampled = V[:, :, ::2, ::2]  # (N, 1, H/2, W/2)\n    \n    # Concatenate U and V channels\n    UV = torch.cat((U_subsampled, V_subsampled), dim=1)  # (N, 2, H/2, W/2)\n    \n    # Reshape back to original batch size\n    Y = Y.view(*original_shape[:-3], 1, H, W)\n    UV = UV.view(*original_shape[:-3], 2, H // 2, W // 2)\n    \n    return Y, UV\n\n# Example usage:\n# input = torch.rand(2, 3, 4, 6)\n# Y, UV = rgb_to_yuv420(input)\n# print(Y.shape)  # Should be (2, 1, 4, 6)\n# print(UV.shape)  # Should be (2, 2, 2, 3)\n```\n\nThis function ensures that the input image is correctly formatted and performs the conversion and subsampling as required for YUV 420 format. The use of `torch.tensordot` and `permute` helps in efficiently applying the conversion matrix to the RGB image.",
    "prompt": "Generate a Python function called rgb_to_yuv420 that takes in a torch.Tensor representing an RGB image and returns a tuple of two torch.Tensors. The input image is assumed to be in the range of (0, 1) and needs to be padded to be evenly divisible by 2 horizontally and vertically. The function will output the YUV 420 (subsampled) version of the input image with chroma siting at (0.5, 0.5).\n\nThe function should have the following signature:\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nThe function converts the RGB image to YUV 420 format and returns:\n- A Tensor containing the Y plane with shape (*, 1, H, W)\n- A Tensor containing the UV planes with shape (*, 2, H/2, W/2)\n\nEnsure that the input image has a shape of (*, 3, H, W) where H and W are even numbers. If the input does not meet these requirements, appropriate errors will be raised.\n\nExample usage:\n```python\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```",
    "function_name": "rgb_to_yuv420",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestRgbToYuv420",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}