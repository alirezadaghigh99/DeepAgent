{
    "result": "To undistort an image using the given intrinsic camera matrix and distortion coefficients, we can leverage OpenCV's distortion correction functions. However, since the input is a PyTorch tensor, we'll need to convert it to a format compatible with OpenCV, perform the undistortion, and then convert it back to a PyTorch tensor.\n\nHere's a function that accomplishes this:\n\n```python\nimport torch\nimport cv2\nimport numpy as np\n\ndef undistort_image(image: torch.Tensor, K: torch.Tensor, dist: torch.Tensor) -> torch.Tensor:\n    # Ensure the input is a 4D tensor\n    assert image.ndim == 4, \"Image must be a 4D tensor with shape (*, C, H, W)\"\n    assert K.ndim == 3 and K.shape[-2:] == (3, 3), \"K must be a 3D tensor with shape (*, 3, 3)\"\n    assert dist.ndim == 2, \"dist must be a 2D tensor with shape (*, n)\"\n    \n    # Get the batch size and image dimensions\n    batch_size, channels, height, width = image.shape\n    \n    # Prepare the output tensor\n    undistorted_images = torch.empty_like(image)\n    \n    for i in range(batch_size):\n        # Convert the image to a numpy array and transpose to (H, W, C)\n        img_np = image[i].permute(1, 2, 0).cpu().numpy()\n        \n        # Convert K and dist to numpy arrays\n        K_np = K[i].cpu().numpy()\n        dist_np = dist[i].cpu().numpy()\n        \n        # Undistort the image using OpenCV\n        undistorted_img_np = cv2.undistort(img_np, K_np, dist_np)\n        \n        # Convert the undistorted image back to a torch tensor and permute to (C, H, W)\n        undistorted_images[i] = torch.from_numpy(undistorted_img_np).permute(2, 0, 1)\n    \n    return undistorted_images\n\n# Example usage\nimg = torch.rand(1, 3, 5, 5)\nK = torch.eye(3)[None]\ndist_coeff = torch.rand(1, 4)\nout = undistort_image(img, K, dist_coeff)\nprint(out.shape)  # Should print: torch.Size([1, 3, 5, 5])\n```\n\n### Explanation:\n- **Input Validation**: The function checks that the input image is a 4D tensor and that the intrinsic matrix `K` and distortion coefficients `dist` have the correct shapes.\n- **Batch Processing**: The function processes each image in the batch individually.\n- **Conversion to NumPy**: Since OpenCV works with NumPy arrays, the function converts the PyTorch tensor to a NumPy array.\n- **Undistortion**: The `cv2.undistort` function is used to correct the image for lens distortion.\n- **Conversion Back to PyTorch**: The undistorted image is converted back to a PyTorch tensor and permuted to match the original shape.\n\nThis function assumes that the distortion coefficients are compatible with OpenCV's `cv2.undistort` function, which typically supports radial and tangential distortion. If you need to handle more complex distortion models (e.g., thin prism, tilt), you might need to use more advanced functions like `cv2.initUndistortRectifyMap` and `cv2.remap`.",
    "prompt": "Generate a Python function called undistort_image that compensates an image for lens distortion. The function takes in three inputs: image (a torch.Tensor representing the input image with shape (*, C, H, W)), K (a torch.Tensor representing the intrinsic camera matrix with shape (*, 3, 3)), and dist (a torch.Tensor representing the distortion coefficients with shape (*, n)). The distortion coefficients include radial, tangential, thin prism, and tilt distortion models.\n\nThe function returns an undistorted image with the same shape as the input image (*, C, H, W). \n\nFor example:\n```python\nimg = torch.rand(1, 3, 5, 5)\nK = torch.eye(3)[None]\ndist_coeff = torch.rand(1, 4)\nout = undistort_image(img, K, dist_coeff)\nout.shape\n```\n\nThe output shape of the undistorted image will be torch.Size([1, 3, 5, 5).",
    "function_name": "undistort_image",
    "ground_truth": "kornia/geometry/calibration/undistort.py",
    "test": "tests/geometry/calibration/test_undistort.py::TestUndistortImage",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}