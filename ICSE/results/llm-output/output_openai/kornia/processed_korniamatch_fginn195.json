{
    "result": "To implement the `match_fginn` function, we need to perform the following steps:\n\n1. Compute the pairwise distances between descriptors in `desc1` and `desc2`.\n2. Apply a threshold to filter out matches based on descriptor distance.\n3. Optionally, perform a mutual nearest neighbor check.\n4. Consider spatial constraints using `lafs1` and `lafs2` with the `spatial_th` threshold.\n5. Return the distances and indices of the matching descriptors.\n\nHere's a possible implementation:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:\n    # Compute pairwise descriptor distances\n    if dm is None:\n        dm = torch.cdist(desc1, desc2, p=2)  # Euclidean distance\n\n    # Find the nearest neighbors in desc2 for each vector in desc1\n    min_dist, min_idx = torch.min(dm, dim=1)\n\n    # Apply descriptor distance threshold\n    valid_matches = min_dist < th\n\n    # Filter matches based on spatial threshold\n    if spatial_th > 0:\n        spatial_dist = torch.cdist(lafs1[:, :2, 2], lafs2[:, :2, 2], p=2)\n        valid_spatial = spatial_dist[torch.arange(len(min_idx)), min_idx] < spatial_th\n        valid_matches &= valid_spatial\n\n    # Apply mutual nearest neighbor check if specified\n    if mutual:\n        reverse_min_dist, reverse_min_idx = torch.min(dm, dim=0)\n        mutual_matches = reverse_min_idx[min_idx] == torch.arange(len(min_idx))\n        valid_matches &= mutual_matches\n\n    # Get the indices of valid matches\n    matched_indices1 = torch.arange(len(min_idx))[valid_matches]\n    matched_indices2 = min_idx[valid_matches]\n    matched_distances = min_dist[valid_matches]\n\n    return matched_distances, torch.stack((matched_indices1, matched_indices2), dim=1)\n\n# Example usage:\n# desc1, desc2, lafs1, lafs2 are Tensors with appropriate dimensions\n# matched_distances, matched_indices = match_fginn(desc1, desc2, lafs1, lafs2)\n```\n\n### Explanation:\n\n- **Distance Calculation**: We use `torch.cdist` to compute the pairwise Euclidean distances between descriptors in `desc1` and `desc2`.\n- **Thresholding**: We filter matches based on a descriptor distance threshold `th`.\n- **Spatial Filtering**: We compute spatial distances using the last column of `lafs1` and `lafs2` (assuming these are affine transformation matrices) and apply a spatial threshold `spatial_th`.\n- **Mutual Nearest Neighbor**: If `mutual` is `True`, we ensure that the nearest neighbor relationship is mutual.\n- **Output**: The function returns the distances and indices of the valid matches.",
    "prompt": "Generate a Python function called match_fginn that finds nearest neighbors in desc2 for each vector in desc1. The inputs are Tensors desc1, desc2, lafs1, lafs2, th, spatial_th, mutual, and dm. The function returns a tuple of Tensors containing the descriptor distance of matching descriptors and the long tensor indexes of matching descriptors in desc1 and desc2. The function also performs a mutual nearest neighbor check if specified.\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:",
    "function_name": "match_fginn",
    "ground_truth": "kornia/feature/matching.py",
    "test": "tests/feature/test_matching.py::TestMatchFGINN",
    "class": "",
    "stage": "Inference",
    "task": "Detection",
    "data": "Image"
}