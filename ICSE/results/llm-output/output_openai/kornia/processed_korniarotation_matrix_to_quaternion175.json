{
    "result": "To convert a 3x3 rotation matrix to a quaternion, we can use a mathematical approach that involves calculating the trace of the matrix and using it to determine the quaternion components. Below is a Python function that performs this conversion, including error handling for input types and sizes, and usage examples.\n\n```python\nimport numpy as np\n\ndef rotation_matrix_to_quaternion(rotation_matrix, eps=1e-6):\n    \"\"\"\n    Convert a 3x3 rotation matrix to a quaternion (w, x, y, z).\n\n    Parameters:\n    rotation_matrix (np.ndarray): A tensor of shape (..., 3, 3) representing the rotation matrices.\n    eps (float): A small value to avoid division by zero.\n\n    Returns:\n    np.ndarray: A tensor of shape (..., 4) representing the quaternions in (w, x, y, z) format.\n    \"\"\"\n    # Validate input\n    if not isinstance(rotation_matrix, np.ndarray):\n        raise TypeError(\"Input must be a numpy ndarray.\")\n    if rotation_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"The last two dimensions of the input must be 3x3.\")\n    \n    # Prepare the output quaternion array\n    shape = rotation_matrix.shape[:-2]\n    quaternions = np.zeros(shape + (4,))\n\n    # Iterate over the input tensor\n    for index in np.ndindex(shape):\n        R = rotation_matrix[index]\n        trace = np.trace(R)\n\n        if trace > eps:\n            s = 2.0 * np.sqrt(trace + 1.0)\n            quaternions[index] = np.array([\n                0.25 * s,\n                (R[2, 1] - R[1, 2]) / s,\n                (R[0, 2] - R[2, 0]) / s,\n                (R[1, 0] - R[0, 1]) / s\n            ])\n        else:\n            if R[0, 0] > R[1, 1] and R[0, 0] > R[2, 2]:\n                s = 2.0 * np.sqrt(1.0 + R[0, 0] - R[1, 1] - R[2, 2])\n                quaternions[index] = np.array([\n                    (R[2, 1] - R[1, 2]) / s,\n                    0.25 * s,\n                    (R[0, 1] + R[1, 0]) / s,\n                    (R[0, 2] + R[2, 0]) / s\n                ])\n            elif R[1, 1] > R[2, 2]:\n                s = 2.0 * np.sqrt(1.0 + R[1, 1] - R[0, 0] - R[2, 2])\n                quaternions[index] = np.array([\n                    (R[0, 2] - R[2, 0]) / s,\n                    (R[0, 1] + R[1, 0]) / s,\n                    0.25 * s,\n                    (R[1, 2] + R[2, 1]) / s\n                ])\n            else:\n                s = 2.0 * np.sqrt(1.0 + R[2, 2] - R[0, 0] - R[1, 1])\n                quaternions[index] = np.array([\n                    (R[1, 0] - R[0, 1]) / s,\n                    (R[0, 2] + R[2, 0]) / s,\n                    (R[1, 2] + R[2, 1]) / s,\n                    0.25 * s\n                ])\n\n    return quaternions\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define a sample rotation matrix\n    rotation_matrix = np.array([\n        [0.0, -1.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n\n    # Convert to quaternion\n    quaternion = rotation_matrix_to_quaternion(rotation_matrix)\n    print(\"Quaternion:\", quaternion)\n\n    # Define a batch of rotation matrices\n    batch_rotation_matrices = np.array([\n        [\n            [0.0, -1.0, 0.0],\n            [1.0, 0.0, 0.0],\n            [0.0, 0.0, 1.0]\n        ],\n        [\n            [1.0, 0.0, 0.0],\n            [0.0, 1.0, 0.0],\n            [0.0, 0.0, 1.0]\n        ]\n    ])\n\n    # Convert batch to quaternions\n    batch_quaternions = rotation_matrix_to_quaternion(batch_rotation_matrices)\n    print(\"Batch Quaternions:\", batch_quaternions)\n```\n\nThis function handles both single and batch inputs of rotation matrices and converts them to quaternions. It includes error handling for incorrect input types and sizes, ensuring robustness. The example usage demonstrates how to convert both a single rotation matrix and a batch of rotation matrices to quaternions.",
    "prompt": "Generate a Python function called rotation_matrix_to_quaternion that converts a 3x3 rotation matrix to a 4d quaternion vector. The input parameters are a rotation matrix tensor and a small value eps to avoid zero division. The output is a quaternion tensor with components in (w, x, y, z) format. The function returns the quaternion tensor with shape (*, 4). The function includes examples of usage and error handling for input types and sizes.",
    "function_name": "rotation_matrix_to_quaternion",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestRotationMatrixToQuaternion",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}