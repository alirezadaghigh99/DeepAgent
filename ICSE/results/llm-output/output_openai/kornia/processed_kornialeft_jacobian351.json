{
    "result": "To compute the left Jacobian of the special orthogonal group SO(3), we need to use the exponential map and its derivative properties. The left Jacobian is particularly useful in robotics and 3D transformations, especially when dealing with small angle approximations and perturbations.\n\nHere's a Python function that computes the left Jacobian for a batch of 3D vectors using PyTorch:\n\n```python\nimport torch\n\ndef skew_symmetric(vec):\n    \"\"\"\n    Create a skew-symmetric matrix from a batch of 3D vectors.\n    \n    Args:\n        vec (torch.Tensor): A tensor of shape (B, 3).\n        \n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 3) representing skew-symmetric matrices.\n    \"\"\"\n    B = vec.shape[0]\n    zero = torch.zeros(B, 1, 1, device=vec.device, dtype=vec.dtype)\n    vec = vec.unsqueeze(-1)  # Shape (B, 3, 1)\n    \n    skew = torch.cat([\n        zero, -vec[:, 2:3], vec[:, 1:2],\n        vec[:, 2:3], zero, -vec[:, 0:1],\n        -vec[:, 1:2], vec[:, 0:1], zero\n    ], dim=1).reshape(B, 3, 3)\n    \n    return skew\n\ndef left_jacobian(vec):\n    \"\"\"\n    Compute the left Jacobian of SO(3) for a batch of 3D vectors.\n    \n    Args:\n        vec (torch.Tensor): A tensor of shape (B, 3).\n        \n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 3) representing the left Jacobian matrices.\n    \"\"\"\n    B = vec.shape[0]\n    angle = vec.norm(dim=1, keepdim=True)  # Shape (B, 1)\n    angle_sq = angle ** 2\n    \n    # Handle the case where angle is very small\n    small_angle = angle < 1e-8\n    angle = angle + small_angle * 1e-8  # Avoid division by zero\n    \n    # Compute the skew-symmetric matrix\n    skew = skew_symmetric(vec)\n    \n    # Compute the left Jacobian\n    sin_angle = torch.sin(angle)\n    cos_angle = torch.cos(angle)\n    \n    term1 = (sin_angle / angle).unsqueeze(-1)  # Shape (B, 1, 1)\n    term2 = ((1 - cos_angle) / angle_sq).unsqueeze(-1)  # Shape (B, 1, 1)\n    \n    I = torch.eye(3, device=vec.device, dtype=vec.dtype).unsqueeze(0)  # Shape (1, 3, 3)\n    \n    J_left = I + term1 * skew + term2 * torch.bmm(skew, skew)\n    \n    # Handle small angles separately to avoid numerical instability\n    J_left[small_angle.squeeze()] = I + 0.5 * skew[small_angle.squeeze()]\n    \n    return J_left\n\n# Example usage:\n# vec = torch.randn(5, 3)  # Batch of 5 vectors\n# jacobian = left_jacobian(vec)\n# print(jacobian.shape)  # Should print (5, 3, 3)\n```\n\nThis function computes the left Jacobian for a batch of 3D vectors. It handles small angles separately to avoid numerical instability, which is crucial for accurate computations in practice. The `skew_symmetric` function is used to create skew-symmetric matrices from the input vectors, which are then used in the computation of the left Jacobian.",
    "prompt": "Generate a Python function called left_jacobian that computes the left Jacobian of So3. The input is a tensor called vec of shape (B, 3) where B is the batch size. The output is a tensor of shape (B, 3, 3) representing the left Jacobian matrix. The function uses the input tensor to calculate the left Jacobian matrix using specific mathematical operations",
    "function_name": "left_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3::test_left_jacobian",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}