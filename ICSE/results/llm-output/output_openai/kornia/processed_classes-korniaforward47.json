{
    "result": "To implement the `forward` method for the `Affine` class, we need to construct an affine transformation matrix using the provided parameters: `angle`, `translation`, `scale_factor`, `shear`, and `center`. We will then apply this transformation to the input tensor using PyTorch's `grid_sample` function, which allows for flexible interpolation and padding options.\n\nHere's how you can implement the `forward` method:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom typing import Optional\n\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        super(Affine, self).__init__()\n        self.angle = angle\n        self.translation = translation\n        self.scale_factor = scale_factor\n        self.shear = shear\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        batch_size, channels, height, width = input.size()\n        \n        # Default values for transformations if not provided\n        if self.angle is None:\n            self.angle = torch.zeros(batch_size, device=input.device)\n        if self.translation is None:\n            self.translation = torch.zeros(batch_size, 2, device=input.device)\n        if self.scale_factor is None:\n            self.scale_factor = torch.ones(batch_size, 2, device=input.device)\n        if self.shear is None:\n            self.shear = torch.zeros(batch_size, 2, device=input.device)\n        if self.center is None:\n            self.center = torch.tensor([width / 2, height / 2], device=input.device).expand(batch_size, 2)\n\n        # Convert angles from degrees to radians\n        angle_rad = self.angle * torch.pi / 180.0\n\n        # Compute the affine transformation matrix for each sample in the batch\n        cos_a = torch.cos(angle_rad)\n        sin_a = torch.sin(angle_rad)\n        sx, sy = self.scale_factor[:, 0], self.scale_factor[:, 1]\n        shx, shy = self.shear[:, 0], self.shear[:, 1]\n        tx, ty = self.translation[:, 0], self.translation[:, 1]\n        cx, cy = self.center[:, 0], self.center[:, 1]\n\n        # Construct the affine transformation matrix\n        affine_matrices = torch.zeros(batch_size, 2, 3, device=input.device)\n        affine_matrices[:, 0, 0] = cos_a / sx - shy * sin_a / sy\n        affine_matrices[:, 0, 1] = sin_a / sx + shy * cos_a / sy\n        affine_matrices[:, 0, 2] = (1 - cos_a / sx + shy * sin_a / sy) * cx - (sin_a / sx + shy * cos_a / sy) * cy + tx\n        affine_matrices[:, 1, 0] = -sin_a / sx + shx * cos_a / sy\n        affine_matrices[:, 1, 1] = cos_a / sx + shx * sin_a / sy\n        affine_matrices[:, 1, 2] = (sin_a / sx - shx * cos_a / sy) * cx + (1 - cos_a / sx - shx * sin_a / sy) * cy + ty\n\n        # Create a grid for sampling\n        grid = F.affine_grid(affine_matrices, input.size(), align_corners=self.align_corners)\n\n        # Apply the affine transformation using grid_sample\n        output = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\n### Explanation:\n\n1. **Initialization**: The constructor initializes the transformation parameters. If any parameter is not provided, it defaults to a no-op transformation (e.g., zero angle, no translation, unit scale).\n\n2. **Forward Method**:\n   - **Default Values**: If any transformation parameter is not provided, it defaults to a no-op value.\n   - **Angle Conversion**: Convert angles from degrees to radians for trigonometric functions.\n   - **Affine Matrix Construction**: Construct the affine transformation matrix for each sample in the batch. This matrix combines rotation, scaling, shearing, and translation.\n   - **Grid Creation**: Use `affine_grid` to create a grid for sampling the input tensor.\n   - **Transformation Application**: Use `grid_sample` to apply the affine transformation to the input tensor, with specified interpolation and padding modes.\n\nThis implementation allows for flexible and efficient application of affine transformations to a batch of images.",
    "prompt": "Write a Python function `forward` for the `Affine` class that applies multiple elementary affine transformations (rotation, translation, scaling, and shearing) to a batch of input tensors. The function takes a 4D tensor with shape `[batch_size, channels, height, width]` as input and returns a transformed tensor of the same shape. The affine transformation is computed using parameters such as `angle`, `translation`, `scale_factor`, `shear`, and `center`, with optional interpolation modes and padding options.\n\n```python\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        # Initialization code...\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n``` \n\nThe `forward` function constructs an affine transformation matrix based on the provided parameters and applies this transformation to the input tensor.",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestAffine2d",
    "class": "Affine",
    "stage": "Image",
    "task": "",
    "data": "Model construction"
}