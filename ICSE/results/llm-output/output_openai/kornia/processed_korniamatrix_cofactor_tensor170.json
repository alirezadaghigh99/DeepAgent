{
    "result": "To create a Python function `matrix_cofactor_tensor` that computes the cofactor matrix for a given tensor of 3x3 matrices, we need to follow these steps:\n\n1. **Understand the Cofactor Matrix**: The cofactor matrix of a 3x3 matrix is another 3x3 matrix where each element is the cofactor of the corresponding element in the original matrix. The cofactor of an element \\( a_{ij} \\) is given by \\( (-1)^{i+j} \\times \\text{det}(M_{ij}) \\), where \\( M_{ij} \\) is the 2x2 minor matrix obtained by removing the i-th row and j-th column from the original matrix.\n\n2. **Compute the Determinant**: The determinant of a 3x3 matrix is needed to check if the matrix is singular. The determinant is also used in the computation of cofactors.\n\n3. **Handle Tensors of Matrices**: The input is a tensor of shape `(*, 3, 3)`, where `*` can be any number of dimensions. We need to compute the cofactor matrix for each 3x3 matrix in this tensor.\n\n4. **Check for Singular Matrices**: If all matrices in the tensor are singular (i.e., their determinants are zero), raise an exception.\n\nHere's the implementation of the function:\n\n```python\nimport numpy as np\n\ndef matrix_cofactor_tensor(matrix):\n    # Ensure the input is a numpy array\n    matrix = np.asarray(matrix)\n    \n    # Check the shape of the input\n    if matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Each matrix must be of shape 3x3.\")\n    \n    # Compute the determinant of each 3x3 matrix\n    dets = np.linalg.det(matrix)\n    \n    # Check if all matrices are singular\n    if np.all(dets == 0):\n        raise Exception(\"All input matrices are singular (determinant is zero).\")\n    \n    # Function to compute the cofactor matrix of a single 3x3 matrix\n    def cofactor_matrix(mat):\n        cofactor = np.empty((3, 3))\n        for i in range(3):\n            for j in range(3):\n                # Minor matrix\n                minor = np.delete(np.delete(mat, i, axis=0), j, axis=1)\n                # Cofactor\n                cofactor[i, j] = ((-1) ** (i + j)) * np.linalg.det(minor)\n        return cofactor\n    \n    # Vectorized computation of cofactor matrices\n    cofactor_matrices = np.apply_along_axis(cofactor_matrix, -2, matrix)\n    \n    return cofactor_matrices\n\n# Example usage:\n# tensor = np.array([[[1, 2, 3], [0, 1, 4], [5, 6, 0]], [[2, 0, 1], [3, 0, 0], [5, 1, 1]]])\n# cofactor_tensor = matrix_cofactor_tensor(tensor)\n# print(cofactor_tensor)\n```\n\n### Explanation:\n\n- **Input Validation**: The function first checks if the input tensor has the correct shape, i.e., the last two dimensions should be 3x3.\n- **Determinant Calculation**: It calculates the determinant of each 3x3 matrix using `np.linalg.det`.\n- **Singular Check**: If all determinants are zero, it raises an exception.\n- **Cofactor Calculation**: It defines a helper function `cofactor_matrix` to compute the cofactor matrix for a single 3x3 matrix.\n- **Vectorized Application**: It uses `np.apply_along_axis` to apply the `cofactor_matrix` function along the appropriate axis of the tensor, effectively computing the cofactor matrix for each 3x3 matrix in the input tensor.\n\nThis function should work efficiently for tensors of any shape `(*, 3, 3)`, where `*` can be any number of dimensions.",
    "prompt": "Create a Python function `matrix_cofactor_tensor` that:\n\n- Computes the cofactor matrix for a given tensor of matrices with shape `(*, 3, 3)`.\n- Accepts a single parameter:\n  - `matrix`: A tensor of shape `(*, 3, 3)` representing the input matrices.\n- Returns a tensor containing the cofactor matrices of the input matrices.\n\nErrors:\n- Raises an `Exception` if all input matrices are singular (i.e., their determinants are zero).",
    "function_name": "matrix_cofactor_tensor",
    "ground_truth": "kornia/geometry/epipolar/numeric.py#L31",
    "test": "tests/geometry/epipolar/test_essential.py::TestDecomposeEssentialMatrixNoSVD",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}