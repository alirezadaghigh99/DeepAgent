{
    "result": "To create a Python function called `spatial_gradient` that computes the first-order image derivative using a Sobel operator or simple finite differences, we can utilize PyTorch for efficient tensor operations. The function will handle both 'sobel' and 'diff' modes, and it will support normalization of the output. Here's how you can implement this:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef spatial_gradient(input_image, mode='sobel', order=1, normalized=False):\n    \"\"\"\n    Computes the first-order image derivative in both x and y directions.\n\n    Parameters:\n    - input_image: torch.Tensor of shape (B, C, H, W)\n    - mode: str, either 'sobel' or 'diff'\n    - order: int, the order of the derivatives (only 1 is supported in this implementation)\n    - normalized: bool, whether to normalize the output\n\n    Returns:\n    - torch.Tensor of shape (B, C, 2, H, W) containing the derivatives\n    \"\"\"\n    if order != 1:\n        raise ValueError(\"Only first-order derivatives are supported in this implementation.\")\n\n    B, C, H, W = input_image.shape\n\n    if mode == 'sobel':\n        # Sobel kernels\n        sobel_x = torch.tensor([[1, 0, -1], [2, 0, -2], [1, 0, -1]], dtype=input_image.dtype, device=input_image.device).view(1, 1, 3, 3)\n        sobel_y = torch.tensor([[1, 2, 1], [0, 0, 0], [-1, -2, -1]], dtype=input_image.dtype, device=input_image.device).view(1, 1, 3, 3)\n\n        # Apply Sobel filter\n        grad_x = F.conv2d(input_image.view(B * C, 1, H, W), sobel_x, padding=1)\n        grad_y = F.conv2d(input_image.view(B * C, 1, H, W), sobel_y, padding=1)\n\n    elif mode == 'diff':\n        # Finite difference kernels\n        diff_x = torch.tensor([[0, 0, 0], [-1, 0, 1], [0, 0, 0]], dtype=input_image.dtype, device=input_image.device).view(1, 1, 3, 3)\n        diff_y = torch.tensor([[0, -1, 0], [0, 0, 0], [0, 1, 0]], dtype=input_image.dtype, device=input_image.device).view(1, 1, 3, 3)\n\n        # Apply finite difference filter\n        grad_x = F.conv2d(input_image.view(B * C, 1, H, W), diff_x, padding=1)\n        grad_y = F.conv2d(input_image.view(B * C, 1, H, W), diff_y, padding=1)\n\n    else:\n        raise ValueError(\"Mode must be either 'sobel' or 'diff'.\")\n\n    # Reshape to (B, C, 2, H, W)\n    grad_x = grad_x.view(B, C, H, W)\n    grad_y = grad_y.view(B, C, H, W)\n    gradients = torch.stack((grad_x, grad_y), dim=2)\n\n    if normalized:\n        # Normalize the gradients\n        magnitude = torch.sqrt(grad_x ** 2 + grad_y ** 2 + 1e-6)\n        gradients = gradients / magnitude.unsqueeze(2)\n\n    return gradients\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a random image tensor with shape (B, C, H, W)\n    input_image = torch.rand(1, 1, 5, 5)  # Example with a single image, single channel\n\n    # Compute gradients using Sobel operator\n    sobel_gradients = spatial_gradient(input_image, mode='sobel', normalized=True)\n    print(\"Sobel Gradients:\\n\", sobel_gradients)\n\n    # Compute gradients using finite differences\n    diff_gradients = spatial_gradient(input_image, mode='diff', normalized=False)\n    print(\"Finite Difference Gradients:\\n\", diff_gradients)\n```\n\n### Explanation:\n- **Input Parameters**:\n  - `input_image`: A tensor of shape (B, C, H, W) representing a batch of images.\n  - `mode`: Specifies the method for computing derivatives ('sobel' or 'diff').\n  - `order`: The order of derivatives (only first-order is supported here).\n  - `normalized`: If `True`, the gradients are normalized by their magnitude.\n\n- **Output**:\n  - A tensor of shape (B, C, 2, H, W) containing the x and y derivatives.\n\n- **Implementation Details**:\n  - The Sobel and finite difference kernels are defined and applied using 2D convolution.\n  - The gradients are computed for each channel separately and then stacked.\n  - Normalization is applied if specified, using the magnitude of the gradient vectors.\n\nThis function provides a flexible way to compute image gradients, which are useful in various image processing and computer vision tasks.",
    "prompt": "Generate a Python function called spatial_gradient that computes the first-order image derivative in both x and y using a Sobel operator. The function takes in an input image tensor with shape (B, C, H, W), a mode parameter specifying the derivatives modality (either 'sobel' or 'diff'), an order parameter indicating the order of the derivatives, and a normalized parameter determining whether the output is normalized. The function returns the derivatives of the input feature map with shape (B, C, 2, H, W). The function also includes examples demonstrating its usage.",
    "function_name": "spatial_gradient",
    "ground_truth": "kornia/filters/sobel.py",
    "test": "tests/filters/test_sobel.py::TestSpatialGradient",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Image"
}