{
    "result": "To implement the function `sample_is_valid_for_homography` that checks the oriented constraint for homography estimation, we need to follow these steps:\n\n1. **Check Input Shapes**: Ensure that `points1` and `points2` have the same shape `(B, 4, 2)`.\n\n2. **Convert to Homogeneous Coordinates**: Convert the 2D points to homogeneous coordinates by appending a 1 to each point, resulting in a shape of `(B, 4, 3)`.\n\n3. **Oriented Constraint Check**: Implement the oriented constraint as described in Marquez-Neila2015. This involves checking the orientation of the quadrilateral formed by the points.\n\n4. **Return Validity Mask**: Return a mask indicating whether each batch is valid for homography estimation.\n\nHere's how you can implement this in Python using PyTorch:\n\n```python\nimport torch\n\ndef sample_is_valid_for_homography(points1, points2):\n    # Check if the input shapes are equal\n    if points1.shape != points2.shape:\n        raise ValueError(\"Input tensors must have the same shape.\")\n    \n    B, N, C = points1.shape\n    if N != 4 or C != 2:\n        raise ValueError(\"Each input tensor must have shape (B, 4, 2).\")\n    \n    # Convert points to homogeneous coordinates\n    ones = torch.ones((B, 4, 1), dtype=points1.dtype, device=points1.device)\n    points1_h = torch.cat([points1, ones], dim=-1)  # Shape: (B, 4, 3)\n    points2_h = torch.cat([points2, ones], dim=-1)  # Shape: (B, 4, 3)\n    \n    # Function to compute the cross product of two vectors\n    def cross_product(v1, v2):\n        return torch.cross(v1, v2, dim=-1)\n    \n    # Compute the cross products for the oriented constraint\n    def oriented_constraint(p):\n        # Compute cross products of consecutive edges\n        cross1 = cross_product(p[:, 1] - p[:, 0], p[:, 2] - p[:, 0])\n        cross2 = cross_product(p[:, 2] - p[:, 1], p[:, 3] - p[:, 1])\n        cross3 = cross_product(p[:, 3] - p[:, 2], p[:, 0] - p[:, 2])\n        cross4 = cross_product(p[:, 0] - p[:, 3], p[:, 1] - p[:, 3])\n        \n        # Compute the signs of the z-components of the cross products\n        sign1 = torch.sign(cross1[:, 2])\n        sign2 = torch.sign(cross2[:, 2])\n        sign3 = torch.sign(cross3[:, 2])\n        sign4 = torch.sign(cross4[:, 2])\n        \n        # Check if all signs are the same (either all positive or all negative)\n        return (sign1 == sign2) & (sign2 == sign3) & (sign3 == sign4)\n    \n    # Check the oriented constraint for both sets of points\n    valid1 = oriented_constraint(points1_h)\n    valid2 = oriented_constraint(points2_h)\n    \n    # A sample is valid if both sets of points satisfy the oriented constraint\n    valid_mask = valid1 & valid2\n    \n    return valid_mask\n\n# Example usage:\n# points1 = torch.rand((B, 4, 2))\n# points2 = torch.rand((B, 4, 2))\n# valid_mask = sample_is_valid_for_homography(points1, points2)\n```\n\nThis function checks the oriented constraint for each batch of points and returns a boolean mask indicating whether each sample is valid for homography estimation. The oriented constraint ensures that the quadrilateral formed by the points has a consistent orientation, which is necessary for a valid homography.",
    "prompt": "Generate a Python function called sample_is_valid_for_homography that implements the oriented constraint check from Marquez-Neila2015. The function takes two input tensors, points1 and points2, each with a shape of (B, 4, 2), where B is the batch size. The function returns a mask with the minimal sample that is good for homography estimation, with a shape of (B, 3, 3). The function first checks if the shapes of points1 and points2 are equal, then converts the points to homogeneous coordinates. and finally determines if the sample is valid for homography estimation. The output is a tensor representing the validity of the sample for each batch.",
    "function_name": "sample_is_valid_for_homography",
    "ground_truth": "kornia/geometry/homography.py",
    "test": "tests/geometry/test_homography.py::TestSampleValidation",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}