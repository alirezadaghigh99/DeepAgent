{
    "result": "To implement the `match_snn` function, we need to follow these steps:\n\n1. **Input Validation**: Ensure that the input tensors `desc1` and `desc2` have the correct dimensions. They should be 2D tensors where the first dimension represents the batch size and the second dimension represents the descriptor size.\n\n2. **Distance Calculation**: If a precomputed distance matrix `dm` is not provided, compute the pairwise Euclidean distances between descriptors in `desc1` and `desc2`.\n\n3. **Nearest Neighbor Search**: For each descriptor in `desc1`, find the two nearest neighbors in `desc2`.\n\n4. **Ratio Test**: Apply the ratio test to ensure that the ratio of the distance to the nearest neighbor to the distance to the second nearest neighbor is less than or equal to the threshold `th`.\n\n5. **Return Results**: Return the distances and indices of the matching descriptors that satisfy the ratio test.\n\nHere's the implementation of the `match_snn` function:\n\n```python\nimport torch\n\ndef match_snn(desc1, desc2, th=0.8, dm=None):\n    # Validate input shapes\n    if desc1.ndim != 2 or desc2.ndim != 2:\n        raise ValueError(\"desc1 and desc2 must be 2D tensors.\")\n    \n    B1, D1 = desc1.shape\n    B2, D2 = desc2.shape\n    \n    if D1 != D2:\n        raise ValueError(\"Descriptors in desc1 and desc2 must have the same dimension.\")\n    \n    if B2 < 2:\n        # If desc2 has fewer than two descriptors, return empty results\n        return torch.empty(0, 1), torch.empty(0, 2, dtype=torch.long)\n    \n    # Compute the distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2, p=2)  # Euclidean distance\n    \n    # Find the two nearest neighbors for each descriptor in desc1\n    sorted_distances, sorted_indices = torch.sort(dm, dim=1)\n    \n    # Get the nearest and second nearest distances and their indices\n    nn1_distances = sorted_distances[:, 0]\n    nn2_distances = sorted_distances[:, 1]\n    nn1_indices = sorted_indices[:, 0]\n    nn2_indices = sorted_indices[:, 1]\n    \n    # Apply the ratio test\n    ratio = nn1_distances / nn2_distances\n    valid_mask = ratio <= th\n    \n    # Filter the results based on the ratio test\n    matching_distances = nn1_distances[valid_mask].unsqueeze(1)\n    matching_indices = torch.stack((torch.arange(B1)[valid_mask], nn1_indices[valid_mask]), dim=1)\n    \n    return matching_distances, matching_indices\n\n# Example usage:\n# desc1 = torch.rand(5, 128)  # 5 descriptors of dimension 128\n# desc2 = torch.rand(10, 128) # 10 descriptors of dimension 128\n# distances, indices = match_snn(desc1, desc2, th=0.8)\n# print(distances)\n# print(indices)\n```\n\n### Explanation:\n- **Input Validation**: We check that both `desc1` and `desc2` are 2D tensors and that their descriptor dimensions match.\n- **Distance Calculation**: If the distance matrix `dm` is not provided, we compute it using `torch.cdist`, which calculates the pairwise Euclidean distances.\n- **Nearest Neighbor Search**: We sort the distances to find the nearest and second nearest neighbors.\n- **Ratio Test**: We compute the ratio of the nearest to the second nearest distance and apply the threshold.\n- **Return Results**: We return the distances and indices of the descriptors that pass the ratio test. The indices are returned as a long tensor with the first column representing indices in `desc1` and the second column representing indices in `desc2`.",
    "prompt": "Create a Python function `match_snn` that takes in two tensors, `desc1` and `desc2`, representing batches of descriptors, a threshold `th` = 0.8, and an optional precomputed distance matrix `dm`. The function returns the distances and indices of descriptors from `desc1` that have nearest neighbors in `desc2`, satisfying the condition that the ratio of the first to the second nearest neighbor distance is less than or equal to `th`. If `desc2` has fewer than two descriptors, or if no matches meet the ratio threshold, the function returns an empty result. It checks the validity of the input shapes and then identifies the matching descriptors and their corresponding distances.Return:\n        - Descriptor distance of matching descriptors, shape of :math:`(B3, 1)`.\n        - Long tensor indexes of matching descriptors in desc1 and desc2. Shape: :math:`(B3, 2)`,\n          where 0 <= B3 <= B1.",
    "function_name": "match_snn",
    "ground_truth": "kornia/feature/matching.py#L48",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Detection",
    "data": "Image"
}