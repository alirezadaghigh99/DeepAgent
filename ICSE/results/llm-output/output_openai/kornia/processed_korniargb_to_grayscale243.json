{
    "result": "To create the `rgb_to_grayscale` function, we need to handle several tasks:\n\n1. **Input Validation**: Ensure the input tensor has the correct shape and data type.\n2. **Default Weights**: Use different default weights based on the data type of the image.\n3. **Grayscale Conversion**: Apply the weights to convert the RGB image to grayscale.\n4. **Output Shape**: Ensure the output tensor has the shape `(*, 1, H, W)`.\n\nHere's the implementation of the function:\n\n```python\nimport torch\n\ndef rgb_to_grayscale(image, rgb_weights=None):\n    # Validate input shape\n    if image.ndim < 3 or image.shape[-3] != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    # Determine default weights based on data type\n    if rgb_weights is None:\n        if image.dtype == torch.uint8:\n            rgb_weights = torch.tensor([76, 150, 29], dtype=torch.float32) / 255.0\n        elif torch.is_floating_point(image):\n            rgb_weights = torch.tensor([0.299, 0.587, 0.114], dtype=image.dtype)\n        else:\n            raise TypeError(\"Unsupported image data type. Supported types are uint8 and floating point.\")\n\n    # Validate that rgb_weights sum to 1\n    if not torch.isclose(rgb_weights.sum(), torch.tensor(1.0, dtype=rgb_weights.dtype)):\n        raise ValueError(\"The sum of rgb_weights must be 1.\")\n\n    # Ensure rgb_weights is a tensor\n    rgb_weights = torch.tensor(rgb_weights, dtype=image.dtype)\n\n    # Convert to grayscale\n    # Reshape rgb_weights to (3, 1, 1) to apply it across the H and W dimensions\n    grayscale_image = (image * rgb_weights.view(1, 3, 1, 1)).sum(dim=-3, keepdim=True)\n\n    return grayscale_image\n\n# Example usage:\n# image = torch.rand((2, 3, 256, 256), dtype=torch.float32)  # Example RGB image\n# grayscale_image = rgb_to_grayscale(image)\n# print(grayscale_image.shape)  # Should be (2, 1, 256, 256)\n```\n\n### Explanation:\n\n- **Input Validation**: The function checks if the input tensor has at least 3 dimensions and that the third-to-last dimension has a size of 3, which corresponds to the RGB channels.\n  \n- **Default Weights**: Depending on whether the image is of type `uint8` or a floating-point type, different default weights are used. The weights are normalized to sum to 1.\n\n- **Grayscale Conversion**: The RGB image is converted to grayscale by applying the weights to each channel and summing them up. The weights are reshaped to `(3, 1, 1)` to broadcast correctly across the height and width dimensions.\n\n- **Output Shape**: The resulting grayscale image has the shape `(*, 1, H, W)`, where `*` represents any leading dimensions.\n\nThis function should handle typical use cases for converting RGB images to grayscale in PyTorch, while also providing flexibility with custom weights.",
    "prompt": "Create a Python function `rgb_to_grayscale` that converts an RGB image to its grayscale version. The function should:\n\n- Accept an `image` tensor with shape `(*, 3, H, W)` representing the RGB image.\n- Optionally accept `rgb_weights`, a tensor containing weights for the RGB channels. The sum of these weights should be 1.\n- If `rgb_weights` is not provided, default weights based on the image data type should be used: `[76, 150, 29]` for `uint8` images and `[0.299, 0.587, 0.114]` for floating-point images.\n- Validate that the input tensor has the correct shape and raise a `ValueError` if not.\n- Convert the RGB image to grayscale using the provided or default weights.\n- Return the grayscale image with shape `(*, 1, H, W)`.\n\nEnsure that the function handles different image data types correctly and raises a `TypeError` for unsupported types.",
    "function_name": "rgb_to_grayscale",
    "ground_truth": "kornia/color/gray.py",
    "test": "tests/color/test_gray.py::TestRgbToGrayscale",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}