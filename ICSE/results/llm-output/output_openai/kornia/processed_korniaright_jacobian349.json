{
    "result": "To compute the right Jacobian of the special orthogonal group SO(3), we need to use the skew-symmetric matrix representation of a vector and some properties of the exponential map on SO(3). The right Jacobian is useful in various applications, such as robotics and computer vision, where small perturbations in rotation are considered.\n\nHere's a Python function that computes the right Jacobian of SO(3) using PyTorch:\n\n```python\nimport torch\n\ndef vector_to_skew_symmetric_matrix(vec):\n    \"\"\"\n    Convert a batch of 3D vectors to their corresponding skew-symmetric matrices.\n    \n    Args:\n        vec (torch.Tensor): A tensor of shape (B, 3) representing a batch of 3D vectors.\n        \n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 3) representing the skew-symmetric matrices.\n    \"\"\"\n    B = vec.shape[0]\n    skew_matrices = torch.zeros((B, 3, 3), dtype=vec.dtype, device=vec.device)\n    skew_matrices[:, 0, 1] = -vec[:, 2]\n    skew_matrices[:, 0, 2] = vec[:, 1]\n    skew_matrices[:, 1, 0] = vec[:, 2]\n    skew_matrices[:, 1, 2] = -vec[:, 0]\n    skew_matrices[:, 2, 0] = -vec[:, 1]\n    skew_matrices[:, 2, 1] = vec[:, 0]\n    return skew_matrices\n\ndef right_jacobian(vec):\n    \"\"\"\n    Compute the right Jacobian of SO(3) for a batch of 3D vectors.\n    \n    Args:\n        vec (torch.Tensor): A tensor of shape (B, 3) representing a batch of 3D vectors.\n        \n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 3) representing the right Jacobian matrices.\n    \"\"\"\n    B = vec.shape[0]\n    theta = torch.norm(vec, dim=1, keepdim=True)  # Shape: (B, 1)\n    theta_sq = theta ** 2\n\n    # Handle the case where theta is very small\n    small_angle = theta < 1e-8\n\n    # Compute the skew-symmetric matrix\n    skew_matrix = vector_to_skew_symmetric_matrix(vec)  # Shape: (B, 3, 3)\n\n    # Compute the right Jacobian using the series expansion\n    I = torch.eye(3, dtype=vec.dtype, device=vec.device).unsqueeze(0)  # Shape: (1, 3, 3)\n    A = (1 - torch.cos(theta)) / theta_sq\n    B = (theta - torch.sin(theta)) / (theta_sq * theta)\n\n    # Right Jacobian matrix\n    J_right = I + A.unsqueeze(-1) * skew_matrix + B.unsqueeze(-1) * torch.bmm(skew_matrix, skew_matrix)\n\n    # For small angles, use the first-order approximation\n    J_right[small_angle] = I + 0.5 * skew_matrix[small_angle]\n\n    return J_right\n\n# Example usage:\nvec = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=torch.float32)\njacobian = right_jacobian(vec)\nprint(jacobian)\n```\n\nThis function computes the right Jacobian for a batch of 3D vectors. It handles small angles by using a first-order approximation to avoid numerical instability. The function uses PyTorch operations to ensure that it can handle batches of vectors efficiently.",
    "prompt": "Generate a Python function called right_jacobian that computes the right Jacobian of So3. The input is a tensor called vec of shape (B, 3) and the output is a tensor of shape (3, 3) representing the right Jacobian matrix. The function uses vector_to_skew_symmetric_matrix, torch.norm, torch.eye, and matrix multiplication to calculate the right Jacobian matrix.",
    "function_name": "right_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}