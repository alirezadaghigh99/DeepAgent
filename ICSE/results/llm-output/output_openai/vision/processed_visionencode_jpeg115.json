{
    "result": "To create a Python function `encode_jpeg` that encodes images into JPEG format, we can use the `PIL` (Python Imaging Library) module, which is part of the `Pillow` package. This library provides extensive capabilities for image processing, including encoding images into various formats like JPEG.\n\nHere's how you can implement the `encode_jpeg` function:\n\n```python\nfrom PIL import Image\nimport io\nimport torch\n\ndef encode_jpeg(images, quality):\n    \"\"\"\n    Encodes an input tensor or list of tensors representing images into JPEG format.\n\n    Parameters:\n    - images: A tensor or list of tensors in CHW layout representing the images.\n    - quality: An integer between 1 and 100 to control the output JPEG quality.\n\n    Returns:\n    - A tensor or list of tensors containing the raw bytes of the JPEG file(s).\n\n    Raises:\n    - ValueError: If the quality is not between 1 and 100 or if an empty list is passed as input.\n    \"\"\"\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n\n    if isinstance(images, torch.Tensor):\n        images = [images]\n\n    if not images:\n        raise ValueError(\"Input list of images is empty.\")\n\n    jpeg_bytes_list = []\n\n    for img_tensor in images:\n        if img_tensor.ndim != 3 or img_tensor.size(0) != 3:\n            raise ValueError(\"Each image tensor must be in CHW format with 3 channels.\")\n\n        # Convert the tensor to a PIL Image\n        img = img_tensor.permute(1, 2, 0).clamp(0, 1)  # Convert CHW to HWC and clamp values\n        img = (img * 255).byte().cpu().numpy()  # Scale to [0, 255] and convert to numpy array\n        pil_img = Image.fromarray(img)\n\n        # Encode the image to JPEG\n        with io.BytesIO() as output:\n            pil_img.save(output, format='JPEG', quality=quality)\n            jpeg_bytes = output.getvalue()\n\n        # Convert the bytes to a tensor\n        jpeg_bytes_tensor = torch.tensor(list(jpeg_bytes), dtype=torch.uint8)\n        jpeg_bytes_list.append(jpeg_bytes_tensor)\n\n    if len(jpeg_bytes_list) == 1:\n        return jpeg_bytes_list[0]\n    else:\n        return jpeg_bytes_list\n\n# Example usage:\n# image_tensor = torch.rand(3, 256, 256)  # Example image tensor in CHW format\n# jpeg_bytes = encode_jpeg(image_tensor, quality=90)\n```\n\n### Explanation:\n\n1. **Input Validation**:\n   - The function checks if the `quality` parameter is between 1 and 100.\n   - It raises a `ValueError` if the input list of images is empty.\n\n2. **Image Processing**:\n   - The function supports both a single tensor and a list of tensors. If a single tensor is provided, it is converted into a list for uniform processing.\n   - Each image tensor is expected to be in CHW format with 3 channels (RGB).\n\n3. **Conversion to JPEG**:\n   - Each image tensor is permuted to HWC format, clamped to ensure values are between 0 and 1, scaled to [0, 255], and converted to a numpy array.\n   - The numpy array is then converted to a PIL Image.\n   - The PIL Image is saved to a `BytesIO` object in JPEG format with the specified quality.\n   - The raw bytes are extracted and converted to a tensor of type `torch.uint8`.\n\n4. **Output**:\n   - The function returns a tensor or a list of tensors containing the raw JPEG bytes, depending on whether the input was a single tensor or a list of tensors.",
    "prompt": "Create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format. The function accepts images in CHW layout and a quality parameter between 1 and 100 to control the output JPEG quality. The output is a tensor or list of tensors containing the raw bytes of the JPEG file(s). The function raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is passed as input.",
    "function_name": "encode_jpeg",
    "ground_truth": "torchvision/io/image.py",
    "test": "test/test_image.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}