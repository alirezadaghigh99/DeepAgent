{
    "result": "To implement the `rotate` function that can handle both PIL Images and PyTorch Tensors, we need to consider the different ways these data types are manipulated. For PIL Images, we can use the `rotate` method provided by the PIL library. For Tensors, we need to use PyTorch's functional transformations. Below is a possible implementation of the `rotate` function:\n\n```python\nfrom PIL import Image\nimport torch\nimport torchvision.transforms.functional as F\nfrom torchvision.transforms import InterpolationMode\n\ndef rotate(img, angle, interpolation=InterpolationMode.NEAREST, expand=False, center=None, fill=0):\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Argument angle should be int or float\")\n\n    if center is not None and not isinstance(center, (list, tuple)):\n        raise TypeError(\"Argument center should be a sequence\")\n\n    if isinstance(interpolation, int):\n        interpolation = _interpolation_modes_from_int(interpolation)\n    elif not isinstance(interpolation, InterpolationMode):\n        raise TypeError(\n            \"Argument interpolation should be a InterpolationMode or a corresponding Pillow integer constant\"\n        )\n\n    if isinstance(img, Image.Image):\n        # Handle PIL Image\n        return img.rotate(angle, resample=interpolation.value, expand=expand, center=center, fillcolor=fill)\n    elif isinstance(img, torch.Tensor):\n        # Handle Tensor\n        if img.ndim < 2:\n            raise ValueError(\"Tensor should have at least 2 dimensions\")\n        return F.rotate(img, angle, interpolation=interpolation, expand=expand, center=center, fill=fill)\n    else:\n        raise TypeError(\"img should be PIL Image or Tensor\")\n\ndef _interpolation_modes_from_int(interpolation):\n    # Map integer constants to InterpolationMode\n    if interpolation == Image.NEAREST:\n        return InterpolationMode.NEAREST\n    elif interpolation == Image.BILINEAR:\n        return InterpolationMode.BILINEAR\n    elif interpolation == Image.BICUBIC:\n        return InterpolationMode.BICUBIC\n    else:\n        raise ValueError(\"Unsupported interpolation mode\")\n```\n\n### Explanation:\n\n1. **Type Checking**: The function first checks if the `angle` is a number and if `center` is a sequence. It also checks if `interpolation` is either an `InterpolationMode` or a valid integer constant.\n\n2. **PIL Image Handling**: If the input image is a PIL Image, the function uses the `rotate` method from the PIL library. The `resample` parameter is set using the `interpolation.value` to match the desired interpolation mode.\n\n3. **Tensor Handling**: If the input is a PyTorch Tensor, the function uses `torchvision.transforms.functional.rotate` to perform the rotation. This function supports the `expand`, `center`, and `fill` parameters.\n\n4. **Interpolation Mode Mapping**: The helper function `_interpolation_modes_from_int` maps integer constants to `InterpolationMode` enums, allowing for compatibility with both PIL and PyTorch conventions.\n\nThis implementation should cover the basic requirements for rotating images in both PIL and Tensor formats, with support for different interpolation modes and optional parameters like `expand`, `center`, and `fill`.",
    "prompt": "Write a python function rotate that Rotate the image by angle.\n    If the image is torch Tensor, it is expected\n    to have [..., H, W] shape, where ... means an arbitrary number of leading dimensions.\n\n    Args:\n        img (PIL Image or Tensor): image to be rotated.\n        angle (number): rotation angle value in degrees, counter-clockwise.\n        interpolation (InterpolationMode): Desired interpolation enum defined by\n            :class:`torchvision.transforms.InterpolationMode`. Default is ``InterpolationMode.NEAREST``.\n            If input is Tensor, only ``InterpolationMode.NEAREST``, ``InterpolationMode.BILINEAR`` are supported.\n            The corresponding Pillow integer constants, e.g. ``PIL.Image.BILINEAR`` are accepted as well.\n        expand (bool, optional): Optional expansion flag.\n            If true, expands the output image to make it large enough to hold the entire rotated image.\n            If false or omitted, make the output image the same size as the input image.\n            Note that the expand flag assumes rotation around the center and no translation.\n        center (sequence, optional): Optional center of rotation. Origin is the upper left corner.\n            Default is the center of the image.\n        fill (sequence or number, optional): Pixel fill value for the area outside the transformed\n            image. If given a number, the value is used for all bands respectively. Returns:\n        PIL Image or Tensor: Rotated image.\n\n    if not torch.jit.is_scripting() and not torch.jit.is_tracing():\n        _log_api_usage_once(rotate)\n\n    if isinstance(interpolation, int):\n        interpolation = _interpolation_modes_from_int(interpolation)\n    elif not isinstance(interpolation, InterpolationMode):\n        raise TypeError(\n            \"Argument interpolation should be a InterpolationMode or a corresponding Pillow integer constant\"\n        )\n\n    if not isinstance(angle, (int, float)):\n        raise TypeError(\"Argument angle should be int or float\")\n\n    if center is not None and not isinstance(center, (list, tuple)):\n        raise TypeError(\"Argument center should be a sequence\")",
    "function_name": "rotate",
    "ground_truth": "torchvision/transforms/functional.py",
    "test": "test/test_functional_tensor.py::TestRotate::test_rotate\n\"",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}