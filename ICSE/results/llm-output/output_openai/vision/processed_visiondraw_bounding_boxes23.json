{
    "result": "To create the `draw_bounding_boxes` function, we will use PyTorch for tensor operations and the `PIL` library for drawing on images. The function will handle both RGB and grayscale images, and it will allow customization of bounding box appearance and labels. Here's how you can implement this function:\n\n```python\nimport torch\nfrom PIL import Image, ImageDraw, ImageFont\nimport warnings\n\ndef draw_bounding_boxes(image, boxes, labels=None, colors=None, fill=False, box_width=2, font=None, font_size=10):\n    # Error handling for input types and shapes\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"The image must be a PyTorch tensor.\")\n    \n    if image.dtype not in [torch.uint8, torch.float32, torch.float64]:\n        raise ValueError(\"The image dtype must be uint8 or float.\")\n    \n    if image.ndim != 3 or image.shape[0] not in [1, 3]:\n        raise ValueError(\"The image must have shape (C, H, W) with C being 1 or 3.\")\n    \n    if boxes.ndim != 2 or boxes.shape[1] != 4:\n        raise ValueError(\"Bounding boxes must be a 2D tensor with shape (N, 4).\")\n    \n    if labels is not None and len(labels) != len(boxes):\n        warnings.warn(\"The number of labels does not match the number of boxes.\")\n    \n    if len(boxes) == 0:\n        warnings.warn(\"No bounding boxes provided.\")\n        return image\n\n    # Convert image to PIL format\n    if image.dtype != torch.uint8:\n        image = (image * 255).to(torch.uint8)\n    \n    if image.shape[0] == 1:\n        mode = 'L'\n        image_pil = Image.fromarray(image.squeeze(0).numpy(), mode=mode)\n    else:\n        mode = 'RGB'\n        image_pil = Image.fromarray(image.permute(1, 2, 0).numpy(), mode=mode)\n    \n    draw = ImageDraw.Draw(image_pil, 'RGBA' if fill else 'RGB')\n\n    # Default color\n    default_color = (255, 0, 0, 128) if fill else (255, 0, 0)\n\n    # Load font\n    if font is None:\n        try:\n            font = ImageFont.truetype(\"arial.ttf\", font_size)\n        except IOError:\n            font = ImageFont.load_default()\n    \n    # Draw each bounding box\n    for i, box in enumerate(boxes):\n        xmin, ymin, xmax, ymax = box.tolist()\n        color = colors[i] if colors and i < len(colors) else default_color\n        \n        if fill:\n            draw.rectangle([xmin, ymin, xmax, ymax], outline=color, fill=color, width=box_width)\n        else:\n            draw.rectangle([xmin, ymin, xmax, ymax], outline=color, width=box_width)\n        \n        if labels and i < len(labels):\n            text_size = draw.textsize(labels[i], font=font)\n            text_location = (xmin, ymin - text_size[1])\n            draw.rectangle([text_location, (xmin + text_size[0], ymin)], fill=color)\n            draw.text((xmin, ymin - text_size[1]), labels[i], fill=(255, 255, 255), font=font)\n\n    # Convert back to tensor\n    image_with_boxes = torch.from_numpy(np.array(image_pil))\n    if mode == 'L':\n        image_with_boxes = image_with_boxes.unsqueeze(0)\n    else:\n        image_with_boxes = image_with_boxes.permute(2, 0, 1)\n    \n    return image_with_boxes\n\n# Example usage:\n# image_tensor = torch.rand(3, 100, 100)  # Example image tensor\n# boxes_tensor = torch.tensor([[10, 10, 50, 50], [60, 60, 90, 90]])  # Example boxes\n# result_image = draw_bounding_boxes(image_tensor, boxes_tensor, labels=[\"Box1\", \"Box2\"])\n```\n\n### Key Points:\n- The function checks for valid input types and shapes, raising errors or warnings as needed.\n- It supports both RGB and grayscale images.\n- Bounding boxes can be customized with colors, filled or outlined, and labeled with text.\n- The function uses `PIL` for drawing, which is flexible and widely used for image manipulation in Python.\n- The output is a PyTorch tensor, making it easy to integrate into a PyTorch-based workflow.",
    "prompt": "Create a Python function `draw_bounding_boxes` that draws bounding boxes on a given RGB or grayscale image represented as a PyTorch tensor. The function should accept an image tensor (`image`) of shape `(C, H, W)` and dtype `uint8` or float, a tensor of bounding boxes (`boxes`) in `(xmin, ymin, xmax, ymax)` format, and optional parameters such as labels, colors, fill option, box width, font, and font size. The function should return the image tensor with the bounding boxes drawn on it.\n\n### Error Handling:\n- Raise a `TypeError` if the input `image` is not a tensor.\n- Raise a `ValueError` if the image dtype is not `uint8` or float, if the image dimensions are incorrect, or if the bounding boxes are not in the correct format.\n- Warn if no bounding boxes are provided or if the number of labels does not match the number of boxes.\n\nThe function should support options like filling the bounding boxes with a color, specifying the width of the bounding box edges, and adding labels with custom fonts. The output should be a tensor with the bounding boxes applied, suitable for further processing or visualization.",
    "function_name": "draw_bounding_boxes",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}