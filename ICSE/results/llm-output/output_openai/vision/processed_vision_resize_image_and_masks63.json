{
    "result": "To create the `_resize_image_and_masks` function, we need to handle resizing of both the image and any associated masks. The function should be flexible enough to resize to a fixed size or based on scaling factors determined by `self_min_size` and `self_max_size`. Additionally, it should handle special cases for TorchScript and ONNX tracing, which typically involve ensuring compatibility with these frameworks' requirements.\n\nHere's a possible implementation of the function:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef _resize_image_and_masks(image, self_min_size, self_max_size, target=None, fixed_size=None):\n    \"\"\"\n    Resizes an image tensor and its corresponding masks, if provided.\n\n    Parameters:\n    - image: A Tensor representing the image to be resized, with shape (C, H, W).\n    - self_min_size: An integer specifying the minimum size for the image's smaller dimension when resizing.\n    - self_max_size: An integer specifying the maximum size for the image's larger dimension when resizing.\n    - target: An optional dictionary containing additional data, such as masks, that should be resized alongside the image.\n    - fixed_size: An optional tuple (height, width) specifying the fixed dimensions to which the image should be resized.\n\n    Returns:\n    - A tuple containing:\n      - The resized image tensor.\n      - The resized target dictionary if it was provided, with resized masks if present.\n    \"\"\"\n    # Determine the original size of the image\n    _, original_height, original_width = image.shape\n\n    if fixed_size is not None:\n        # Resize to the fixed size\n        new_height, new_width = fixed_size\n    else:\n        # Calculate the scale factor\n        min_original_size = float(min(original_height, original_width))\n        max_original_size = float(max(original_height, original_width))\n\n        # Compute the scaling factor\n        scale_factor = self_min_size / min_original_size\n\n        # Ensure the scaled size does not exceed the max size\n        if max_original_size * scale_factor > self_max_size:\n            scale_factor = self_max_size / max_original_size\n\n        # Calculate new dimensions\n        new_height = int(round(original_height * scale_factor))\n        new_width = int(round(original_width * scale_factor))\n\n    # Resize the image\n    resized_image = F.interpolate(image.unsqueeze(0), size=(new_height, new_width), mode='bilinear', align_corners=False).squeeze(0)\n\n    # Resize the masks if present in the target\n    if target is not None and \"masks\" in target:\n        masks = target[\"masks\"]\n        # Resize masks using nearest neighbor to preserve categorical values\n        resized_masks = F.interpolate(masks.unsqueeze(1).float(), size=(new_height, new_width), mode='nearest').squeeze(1)\n        target[\"masks\"] = resized_masks\n\n    return resized_image, target\n\n# Example usage:\n# image = torch.randn(3, 256, 256)  # Example image tensor\n# target = {\"masks\": torch.randn(5, 256, 256)}  # Example target with masks\n# resized_image, resized_target = _resize_image_and_masks(image, 300, 500, target)\n```\n\n### Key Points:\n- **Interpolation Modes**: The image is resized using bilinear interpolation, which is suitable for continuous data like images. Masks are resized using nearest neighbor interpolation to preserve discrete values.\n- **Scaling Logic**: If `fixed_size` is not provided, the function calculates a scaling factor based on `self_min_size` and `self_max_size` to ensure the resized image fits within these bounds.\n- **TorchScript and ONNX**: The function is designed to be compatible with TorchScript and ONNX by avoiding operations that are not supported by these frameworks, such as certain Python list operations or in-place modifications.\n- **Handling of Optional Target**: The function checks if the `target` dictionary is provided and contains masks, resizing them if necessary.",
    "prompt": "Create a Python function _resize_image_and_masks that resizes an image tensor and its corresponding masks, if provided. The function allows resizing to either a fixed size or a size determined by scaling factors, and it handles special cases for TorchScript and ONNX tracing.\n\nParameters:\nimage: A Tensor representing the image to be resized, with shape (C, H, W).\nself_min_size: An integer specifying the minimum size for the image's smaller dimension when resizing.\nself_max_size: An integer specifying the maximum size for the image's larger dimension when resizing.\ntarget: An optional dictionary containing additional data, such as masks, that should be resized alongside the image. The dictionary may contain a key \"masks\" with a tensor of shape (N, H, W).\nfixed_size: An optional tuple (height, width) specifying the fixed dimensions to which the image should be resized.\nReturns:\nA tuple containing:\nThe resized image tensor.\nThe resized target dictionary if it was provided, with resized masks if present.",
    "function_name": "_resize_image_and_masks",
    "ground_truth": "torchvision/models/detection/transform.py",
    "test": "test/test_models_detection_negative_samples.py::TestModelsDetectionNegativeSamples",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}