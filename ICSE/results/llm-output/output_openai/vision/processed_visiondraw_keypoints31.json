{
    "result": "To create the `draw_keypoints` function, we need to handle image processing and drawing operations. We'll use the `torch` library for tensor operations and `PIL` (Python Imaging Library) for drawing on images. Below is the implementation of the `draw_keypoints` function:\n\n```python\nimport torch\nfrom PIL import Image, ImageDraw\nimport numpy as np\n\ndef draw_keypoints(image, keypoints, connectivity=None, colors='red', radius=3, width=2, visibility=None):\n    # Validate image tensor\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"The input image must be a tensor.\")\n    \n    if image.dtype not in [torch.uint8, torch.float]:\n        raise ValueError(\"The image dtype must be uint8 or float.\")\n    \n    if image.ndim != 3 or image.shape[0] != 3:\n        raise ValueError(\"The image must have shape (3, H, W).\")\n    \n    # Validate keypoints tensor\n    if not isinstance(keypoints, torch.Tensor) or keypoints.ndim != 3 or keypoints.shape[2] != 2:\n        raise ValueError(\"Keypoints must be a tensor of shape (num_instances, K, 2).\")\n    \n    num_instances, K, _ = keypoints.shape\n    \n    # Validate visibility tensor\n    if visibility is not None:\n        if not isinstance(visibility, torch.Tensor) or visibility.shape != (num_instances, K):\n            raise ValueError(\"Visibility must be a tensor of shape (num_instances, K).\")\n    \n    # Convert image to PIL format\n    if image.dtype == torch.float:\n        image = (image * 255).byte()\n    image_np = image.permute(1, 2, 0).cpu().numpy()\n    pil_image = Image.fromarray(image_np)\n    draw = ImageDraw.Draw(pil_image)\n    \n    # Draw keypoints and connections\n    for i in range(num_instances):\n        for j in range(K):\n            if visibility is None or visibility[i, j]:\n                x, y = keypoints[i, j].tolist()\n                draw.ellipse((x - radius, y - radius, x + radius, y + radius), fill=colors, outline=colors)\n        \n        if connectivity:\n            for start, end in connectivity:\n                if (visibility is None or (visibility[i, start] and visibility[i, end])):\n                    x_start, y_start = keypoints[i, start].tolist()\n                    x_end, y_end = keypoints[i, end].tolist()\n                    draw.line((x_start, y_start, x_end, y_end), fill=colors, width=width)\n    \n    # Convert back to tensor\n    result_image = torch.from_numpy(np.array(pil_image)).permute(2, 0, 1)\n    \n    return result_image\n\n# Example usage:\n# image_tensor = torch.rand(3, 100, 100)  # Example image tensor\n# keypoints_tensor = torch.tensor([[[10, 10], [20, 20], [30, 30]]])  # Example keypoints\n# result = draw_keypoints(image_tensor, keypoints_tensor)\n```\n\n### Explanation:\n- **Input Validation**: The function checks if the input image is a tensor and if it has the correct shape and dtype. It also validates the keypoints and visibility tensors.\n- **Image Conversion**: The image tensor is converted to a PIL image for easy drawing. If the image is in float format, it is scaled to 0-255 and converted to `uint8`.\n- **Drawing**: The function uses `ImageDraw` to draw keypoints as circles and optionally connect them with lines based on the `connectivity` list.\n- **Output**: The modified image is converted back to a tensor and returned.\n\nThis function should handle most common use cases for overlaying keypoints on images, with error handling for incorrect inputs.",
    "prompt": "Create a Python function draw_keypoints that overlays keypoints on a given RGB image tensor. The function should accept the following parameters:\n\nimage: A tensor of shape (3, H, W) and dtype uint8 or float, representing the image.\nkeypoints: A tensor of shape (num_instances, K, 2), where K denotes the number of keypoints per instance, and each keypoint is represented by its (x, y) coordinates.\nconnectivity: An optional list of tuples, where each tuple contains two integers representing keypoints that should be connected with a line.\ncolors: An optional string or tuple specifying the color for the keypoints and lines. The color can be a string (e.g., \"red\") or an RGB tuple.\nradius: An integer specifying the radius of each keypoint.\nwidth: An integer specifying the width of the lines connecting the keypoints.\nvisibility: An optional tensor of shape (num_instances, K) that indicates whether each keypoint is visible (True) or not (False).\nThe function should validate the input tensors and ensure the image is in the correct format. It should draw each visible keypoint on the image, and if connectivity is provided, draw lines connecting the keypoints based on their visibility. The resulting image tensor should be returned with the keypoints and connections drawn.\n\nError Handling:\nRaise a TypeError if the input image is not a tensor.\nRaise a ValueError if the image dtype is not uint8 or float, if the image shape is incorrect, or if the keypoints tensor has an incorrect shape.\nRaise a ValueError if the visibility tensor does not match the shape of the keypoints tensor.",
    "function_name": "draw_keypoints",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py::test_draw_keypoints_visibility",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}