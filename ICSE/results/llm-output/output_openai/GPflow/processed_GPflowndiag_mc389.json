{
    "result": "To complete the `ndiag_mc` function, we need to implement the logic for computing the Gaussian expectation integrals using Monte Carlo sampling. The function should handle multiple functions, support broadcasting, and optionally compute in log-space. Here's a possible implementation:\n\n```python\nimport tensorflow as tf\nfrom typing import Callable, Iterable, Union, Optional\nfrom gpflow.base import TensorType\nfrom gpflow.utilities import to_default_float\n\ndef ndiag_mc(\n    funcs: Union[Callable[..., tf.Tensor], Iterable[Callable[..., tf.Tensor]]],\n    S: int,\n    Fmu: TensorType,\n    Fvar: TensorType,\n    logspace: bool = False,\n    epsilon: Optional[TensorType] = None,\n    **Ys: TensorType,\n) -> tf.Tensor:\n    \"\"\"\n    Computes N Gaussian expectation integrals of one or more functions\n    using Monte Carlo samples. The Gaussians must be independent.\n\n    `Fmu`, `Fvar`, `Ys` should all have same shape, with overall size `N`.\n\n    :param funcs: the integrand(s):\n        Callable or Iterable of Callables that operates elementwise\n    :param S: number of Monte Carlo sampling points\n    :param Fmu: array/tensor\n    :param Fvar: array/tensor\n    :param logspace: if True, funcs are the log-integrands and this calculates\n        the log-expectation of exp(funcs)\n    :param Ys: arrays/tensors; deterministic arguments to be passed by name\n    :return: shape is the same as that of the first Fmu\n    \"\"\"\n    if not isinstance(funcs, Iterable):\n        funcs = [funcs]\n\n    N, Din = tf.shape(Fmu)\n    if epsilon is None:\n        epsilon = tf.random.normal((S, N, Din), dtype=Fmu.dtype)\n\n    # Sample from the Gaussian distribution\n    samples = Fmu[None, :, :] + tf.sqrt(Fvar)[None, :, :] * epsilon\n\n    # Evaluate each function on the samples\n    results = []\n    for func in funcs:\n        func_values = func(samples, **{k: v[None, ...] for k, v in Ys.items()})\n        if logspace:\n            # Compute log-expectation of exp(func)\n            log_mean = tf.reduce_logsumexp(func_values, axis=0) - tf.math.log(to_default_float(S))\n            results.append(log_mean)\n        else:\n            # Compute expectation\n            mean = tf.reduce_mean(func_values, axis=0)\n            results.append(mean)\n\n    # Stack results for each function\n    return tf.stack(results, axis=0)\n```\n\n### Explanation:\n\n1. **Input Handling**: The function accepts either a single callable or an iterable of callables. If a single callable is provided, it is wrapped in a list for uniform processing.\n\n2. **Sampling**: Monte Carlo samples are generated from a Gaussian distribution defined by `Fmu` and `Fvar`. If `epsilon` is not provided, it is generated using `tf.random.normal`.\n\n3. **Function Evaluation**: Each function is evaluated on the sampled points. The deterministic arguments `Ys` are broadcasted to match the sample dimensions.\n\n4. **Expectation Calculation**: \n   - If `logspace` is `True`, the function computes the log-expectation of the exponentiated function values using `tf.reduce_logsumexp`.\n   - Otherwise, it computes the mean of the function values.\n\n5. **Output**: The results for each function are stacked along a new axis, resulting in a tensor of shape `[n_funs, N, P]`.\n\nThis implementation assumes that the functions are elementwise and that broadcasting is handled correctly by TensorFlow operations. Adjustments may be needed based on specific use cases or additional constraints.",
    "prompt": "Complete the following function :\n@check_shapes(\n    \"Fmu: [N, Din]\",\n    \"Fvar: [N, Din]\",\n    \"Ys.values(): [broadcast N, .]\",\n    \"return: [broadcast n_funs, N, P]\",\n)\ndef ndiag_mc(\n    funcs: Union[Callable[..., tf.Tensor], Iterable[Callable[..., tf.Tensor]]],\n    S: int,\n    Fmu: TensorType,\n    Fvar: TensorType,\n    logspace: bool = False,\n    epsilon: Optional[TensorType] = None,\n    **Ys: TensorType,\n) -> tf.Tensor:\n    \"\"\"\n    Computes N Gaussian expectation integrals of one or more functions\n    using Monte Carlo samples. The Gaussians must be independent.\n\n    `Fmu`, `Fvar`, `Ys` should all have same shape, with overall size `N`.\n\n    :param funcs: the integrand(s):\n        Callable or Iterable of Callables that operates elementwise\n    :param S: number of Monte Carlo sampling points\n    :param Fmu: array/tensor\n    :param Fvar: array/tensor\n    :param logspace: if True, funcs are the log-integrands and this calculates\n        the log-expectation of exp(funcs)\n    :param Ys: arrays/tensors; deterministic arguments to be passed by name\n    :return: shape is the same as that of the first Fmu\n    \"\"\"",
    "function_name": "ndiag_mc",
    "ground_truth": "gpflow/quadrature/deprecated.py",
    "test": "tests/gpflow/quadrature/test_quadrature.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Prediction",
    "data": "tabular"
}