{
    "result": "To implement the `multivariate_normal` function with the specified shape checks, we can use TensorFlow and a decorator for shape validation. The function will compute the log-density of a multivariate normal distribution given samples, means, and the Cholesky decomposition of the covariance matrix. Here's how you can implement it:\n\n```python\nimport tensorflow as tf\nimport numpy as np\nfrom typing import Callable\n\n# Define a decorator for shape checking\ndef check_shapes(*shape_specs: str) -> Callable:\n    def decorator(func: Callable) -> Callable:\n        def wrapper(*args, **kwargs):\n            # Parse the shape specifications\n            shape_dict = {}\n            for spec, arg in zip(shape_specs, args):\n                name, shape = spec.split(\":\")\n                name = name.strip()\n                shape = shape.strip().strip(\"[]\").split(\", \")\n                shape_dict[name] = shape\n\n                # Check the shape of the argument\n                arg_shape = arg.shape.as_list()\n                for dim, expected in zip(arg_shape, shape):\n                    if expected.startswith(\"broadcast\"):\n                        continue\n                    elif expected.isdigit():\n                        if dim != int(expected):\n                            raise ValueError(f\"Expected dimension {expected} but got {dim} for {name}\")\n                    elif expected == \"D\":\n                        if \"D\" in shape_dict and shape_dict[\"D\"] != dim:\n                            raise ValueError(f\"Inconsistent dimension D for {name}\")\n                        shape_dict[\"D\"] = dim\n                    elif expected == \"N\":\n                        if \"N\" in shape_dict and shape_dict[\"N\"] != dim:\n                            raise ValueError(f\"Inconsistent dimension N for {name}\")\n                        shape_dict[\"N\"] = dim\n\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@check_shapes(\n    \"x: [D, broadcast N]\",\n    \"mu: [D, broadcast N]\",\n    \"L: [D, D]\",\n    \"return: [N]\",\n)\ndef multivariate_normal(x: tf.Tensor, mu: tf.Tensor, L: tf.Tensor) -> tf.Tensor:\n    \"\"\"\n    Computes the log-density of a multivariate normal.\n\n    :param x: sample(s) for which we want the density\n    :param mu: mean(s) of the normal distribution\n    :param L: Cholesky decomposition of the covariance matrix\n    :return: log densities\n    \"\"\"\n    # Ensure x and mu are 2D\n    x = tf.convert_to_tensor(x)\n    mu = tf.convert_to_tensor(mu)\n    L = tf.convert_to_tensor(L)\n\n    # Compute the difference\n    y = x - mu\n\n    # Solve for z in Lz = y\n    z = tf.linalg.triangular_solve(L, y, lower=True)\n\n    # Compute the quadratic term\n    quadratic_term = tf.reduce_sum(tf.square(z), axis=0)\n\n    # Compute the log determinant of L\n    log_det_L = tf.reduce_sum(tf.math.log(tf.linalg.diag_part(L)))\n\n    # Compute the log density\n    D = tf.cast(tf.shape(x)[0], x.dtype)\n    log_density = -0.5 * (D * tf.math.log(2 * np.pi) + 2 * log_det_L + quadratic_term)\n\n    return log_density\n\n# Example usage\nD = 3\nN = 2\nx = tf.random.normal((D, N))\nmu = tf.random.normal((D, N))\nL = tf.linalg.cholesky(tf.eye(D))\n\nlog_densities = multivariate_normal(x, mu, L)\nprint(log_densities)\n```\n\n### Explanation:\n- **Shape Checking**: The `check_shapes` decorator is used to ensure that the input tensors have the expected shapes. It checks the dimensions of the input tensors against the specified shapes.\n- **Cholesky Decomposition**: The function assumes that `L` is the lower triangular matrix from the Cholesky decomposition of the covariance matrix.\n- **Log-Density Calculation**: The function calculates the log-density using the formula for the multivariate normal distribution, which involves solving a triangular system and computing the quadratic form and log determinant.\n\nThis implementation assumes that the input tensors are compatible with broadcasting rules, and it uses TensorFlow operations to perform the necessary calculations.",
    "prompt": "\"Write the multivariate_normal function as follow :\n@check_shapes(\n    \"x: [D, broadcast N]\",\n    \"mu: [D, broadcast N]\",\n    \"L: [D, D]\",\n    \"return: [N]\",\n)\ndef multivariate_normal(x: TensorType, mu: TensorType, L: TensorType) -> tf.Tensor:\n    \"\"\"\n    Computes the log-density of a multivariate normal.\n\n    :param x: sample(s) for which we want the density\n    :param mu: mean(s) of the normal distribution\n    :param L: Cholesky decomposition of the covariance matrix\n    :return: log densities\n    \"\"\"",
    "function_name": "multivariate_normal",
    "ground_truth": "gpflow/logdensities.py",
    "test": "tests/gpflow/test_logdensities.py::test_multivariate_normal",
    "class": "",
    "stage": "Model Construction",
    "task": "Prediction",
    "data": "tabular"
}