{
    "result": "```python\n    if Dout is None:\n        Dout = func(means[0:1]).shape[1:]\n\n    # Gauss-Hermite quadrature points and weights\n    gh_x, gh_w = np.polynomial.hermite.hermgauss(H)\n    gh_x = tf.constant(gh_x, dtype=means.dtype)\n    gh_w = tf.constant(gh_w, dtype=means.dtype)\n\n    # Reshape and tile the quadrature points\n    gh_x = tf.reshape(gh_x, [1, H, 1])\n    gh_x = tf.tile(gh_x, [Din, 1, 1])\n\n    # Compute the Cholesky decomposition of the covariance matrices\n    chol_covs = tf.linalg.cholesky(covs)\n\n    # Compute the quadrature points\n    expanded_means = tf.expand_dims(means, 1)  # Shape: [N, 1, Din]\n    expanded_chol_covs = tf.expand_dims(chol_covs, 1)  # Shape: [N, 1, Din, Din]\n    gh_x = tf.expand_dims(gh_x, 0)  # Shape: [1, H, Din]\n\n    # Transform the quadrature points\n    transformed_points = expanded_means + tf.matmul(gh_x, expanded_chol_covs)\n\n    # Evaluate the function at the quadrature points\n    func_values = func(tf.reshape(transformed_points, [-1, Din]))\n    func_values = tf.reshape(func_values, [-1, H] + list(Dout))\n\n    # Compute the weighted sum of the function values\n    weighted_sum = tf.tensordot(func_values, gh_w, axes=[[1], [0]])\n\n    # Normalize by the square root of pi\n    result = weighted_sum / np.sqrt(np.pi)\n\n    return result\n```\n\nThis function uses Gauss-Hermite quadrature to approximate the integral of a function with respect to a multivariate Gaussian distribution. It computes the quadrature points and weights, transforms the points using the Cholesky decomposition of the covariance matrices, evaluates the function at these points, and then computes the weighted sum of the function values. The result is normalized by the square root of \u03c0.",
    "prompt": "Complete the following function \n@check_shapes(\n    \"means: [N, Din]\",\n    \"covs: [N, Din, Din]\",\n    \"return: [N, Dout...]\",\n)\ndef mvnquad(\n    func: Callable[[tf.Tensor], tf.Tensor],\n    means: TensorType,\n    covs: TensorType,\n    H: int,\n    Din: Optional[int] = None,\n    Dout: Optional[Tuple[int, ...]] = None,\n) -> tf.Tensor:\n    \"\"\"\n    Computes N Gaussian expectation integrals of a single function 'f'\n    using Gauss-Hermite quadrature.\n\n    :param f: integrand function. Takes one input of shape ?xD.\n    :param H: Number of Gauss-Hermite evaluation points.\n    :param Din: Number of input dimensions. Needs to be known at call-time.\n    :param Dout: Number of output dimensions. Defaults to (). Dout is assumed\n        to leave out the item index, i.e. f actually maps (?xD)->(?x*Dout).\n    :return: quadratures\n    \"\"\"\n    # Figure out input shape information\n    if Din is None:\n        Din = means.shape[1]\n\n    if Din is None:\n        raise ValueError(\n            \"If `Din` is passed as `None`, `means` must have a known shape. \"\n            \"Running mvnquad in `autoflow` without specifying `Din` and `Dout` \"\n            \"is problematic. Consider using your own session.\"\n        )  # pragma: no cover",
    "function_name": "mvnquad",
    "ground_truth": "gpflow/quadrature/deprecated.py",
    "test": "tests/gpflow/quadrature/test_quadrature.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Prediction",
    "data": "tabular"
}