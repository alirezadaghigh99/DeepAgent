{
    "result": "To create the `look_at_rotation` function, we need to handle both tuple/list inputs and PyTorch tensor inputs. The function will normalize the input vectors, compute the camera's coordinate axes, and construct the rotation matrix. Here's how you can implement this:\n\n```python\nimport torch\nimport numpy as np\n\ndef normalize(v):\n    \"\"\"Normalize a vector or a batch of vectors.\"\"\"\n    if isinstance(v, torch.Tensor):\n        return v / torch.norm(v, dim=-1, keepdim=True)\n    else:\n        v = np.array(v)\n        return v / np.linalg.norm(v, axis=-1, keepdims=True)\n\ndef look_at_rotation(camera_position, at, up, device='cpu'):\n    # Convert inputs to tensors if they are not already\n    if not isinstance(camera_position, torch.Tensor):\n        camera_position = torch.tensor(camera_position, dtype=torch.float32, device=device)\n    if not isinstance(at, torch.Tensor):\n        at = torch.tensor(at, dtype=torch.float32, device=device)\n    if not isinstance(up, torch.Tensor):\n        up = torch.tensor(up, dtype=torch.float32, device=device)\n\n    # Ensure the inputs are of shape (N, 3)\n    if camera_position.dim() == 1:\n        camera_position = camera_position.unsqueeze(0)\n    if at.dim() == 1:\n        at = at.unsqueeze(0)\n    if up.dim() == 1:\n        up = up.unsqueeze(0)\n\n    # Calculate the forward (z) axis\n    z_axis = normalize(at - camera_position)\n\n    # Calculate the right (x) axis\n    x_axis = normalize(torch.cross(up, z_axis))\n\n    # Handle the case where the x-axis is close to zero\n    # If x_axis is zero, it means up and z_axis are collinear, so we need a different up vector\n    zero_x_mask = torch.norm(x_axis, dim=-1) < 1e-6\n    if zero_x_mask.any():\n        alternative_up = torch.tensor([0.0, 1.0, 0.0], device=device).expand_as(up)\n        alternative_x_axis = normalize(torch.cross(alternative_up, z_axis))\n        x_axis = torch.where(zero_x_mask.unsqueeze(-1), alternative_x_axis, x_axis)\n\n    # Calculate the true up (y) axis\n    y_axis = torch.cross(z_axis, x_axis)\n\n    # Concatenate the axes to form the rotation matrix\n    R = torch.stack((x_axis, y_axis, z_axis), dim=-1)\n\n    # Return the transposed matrix to transform from world to view coordinates\n    return R.transpose(-1, -2)\n\n# Example usage:\ncamera_position = [(0, 0, 0), (1, 1, 1)]\nat = [(0, 0, -1), (1, 1, 0)]\nup = [(0, 1, 0), (0, 1, 0)]\ndevice = 'cpu'\n\nR = look_at_rotation(camera_position, at, up, device)\nprint(R)\n```\n\n### Explanation:\n1. **Normalization**: The `normalize` function ensures that each vector is a unit vector. It handles both numpy arrays and PyTorch tensors.\n\n2. **Input Handling**: The function checks if the inputs are lists/tuples and converts them to PyTorch tensors. It also ensures that the inputs are of shape `(N, 3)`.\n\n3. **Axis Calculation**:\n   - **Z-axis**: Points from the camera position to the target (`at`).\n   - **X-axis**: Perpendicular to both the `up` vector and the `z_axis`. If the `x_axis` is close to zero, it indicates that the `up` vector is collinear with the `z_axis`, and an alternative `up` vector is used.\n   - **Y-axis**: Perpendicular to both the `z_axis` and the `x_axis`.\n\n4. **Rotation Matrix**: The axes are stacked to form the rotation matrix, which is then transposed to convert from world coordinates to view coordinates.\n\nThis function should work for both single and batched inputs, handling edge cases where the `up` vector might be collinear with the view direction.",
    "prompt": "Generate a Python function called look_at_rotation that takes in the camera_position, at, up vectors, and device type as inputs. The function returns a batched rotation matrix R representing the transformation from world coordinates to view coordinates. The camera_position, at, and up vectors can be 3-element tuples/lists or torch tensors of shape (1, 3) or (N, 3), where N is the batch size. The function normalizes the input vectors, calculates the x, y, and z axes, and handles cases where the x-axis is close to zero. Finally, it concatenates the axes to form the rotation matrix R and returns the transposed matrix.",
    "function_name": "look_at_rotation",
    "ground_truth": "pytorch3d/renderer/cameras.py",
    "test": "tests/test_cameras.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Detection",
    "data": "Image"
}