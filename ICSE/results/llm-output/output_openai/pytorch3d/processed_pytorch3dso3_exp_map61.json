{
    "result": "To implement the `so3_exp_map` function, we will use the Rodrigues' rotation formula to convert a batch of logarithmic representations of rotation matrices into actual rotation matrices. The formula is particularly useful for converting a rotation vector (axis-angle representation) into a rotation matrix. Here's how you can implement this in Python using PyTorch:\n\n```python\nimport torch\n\ndef so3_exp_map(log_rot: torch.Tensor, eps: float = 0.0001) -> torch.Tensor:\n    \"\"\"\n    Converts a batch of logarithmic representations of rotation matrices\n    to a batch of 3x3 rotation matrices using the Rodrigues formula.\n\n    Parameters:\n    - log_rot: torch.Tensor of shape (minibatch, 3), representing the rotation vectors.\n    - eps: float, a small value to handle the singularity around log(R) = 0.\n\n    Returns:\n    - A torch.Tensor of shape (minibatch, 3, 3) representing the rotation matrices.\n    \"\"\"\n    if log_rot.ndim != 2 or log_rot.shape[1] != 3:\n        raise ValueError(\"Input log_rot must have shape (minibatch, 3)\")\n\n    # Compute the angle (theta) from the rotation vector\n    theta = torch.norm(log_rot, dim=1, keepdim=True)  # Shape: (minibatch, 1)\n\n    # Normalize the rotation vector to get the rotation axis\n    axis = log_rot / (theta + eps)  # Shape: (minibatch, 3)\n\n    # Compute the skew-symmetric cross-product matrix of the axis\n    K = torch.zeros((log_rot.size(0), 3, 3), device=log_rot.device)\n    K[:, 0, 1] = -axis[:, 2]\n    K[:, 0, 2] = axis[:, 1]\n    K[:, 1, 0] = axis[:, 2]\n    K[:, 1, 2] = -axis[:, 0]\n    K[:, 2, 0] = -axis[:, 1]\n    K[:, 2, 1] = axis[:, 0]\n\n    # Compute the rotation matrices using Rodrigues' formula\n    I = torch.eye(3, device=log_rot.device).unsqueeze(0)  # Shape: (1, 3, 3)\n    theta = theta.unsqueeze(-1)  # Shape: (minibatch, 1, 1)\n\n    # Rodrigues' rotation formula\n    R = I + torch.sin(theta) * K + (1 - torch.cos(theta)) * torch.bmm(K, K)\n\n    return R\n\n# Example usage:\n# log_rot = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\n# rotation_matrices = so3_exp_map(log_rot)\n# print(rotation_matrices)\n```\n\n### Explanation:\n- **Input Validation**: We first check if the input tensor `log_rot` has the correct shape `(minibatch, 3)`. If not, a `ValueError` is raised.\n- **Angle and Axis Extraction**: We compute the angle `theta` as the norm of each rotation vector. The axis is obtained by normalizing the rotation vector.\n- **Skew-Symmetric Matrix**: We construct the skew-symmetric matrix `K` for each axis.\n- **Rodrigues' Formula**: We apply the Rodrigues' rotation formula to compute the rotation matrix `R` for each input vector.\n- **Singularity Handling**: The `eps` parameter is used to avoid division by zero when the angle is very small.\n\nThis function will convert a batch of rotation vectors into a batch of rotation matrices, handling the singularity at zero rotation by clamping with `eps`.",
    "prompt": "Create a Python function called so3_exp_map that takes in a torch.Tensor log_rot representing a batch of logarithmic representations of rotation matrices and an optional float eps set to 0.0001. The function converts the logarithmic representations to a batch of 3x3 rotation matrices using the Rodrigues formula. The input log_rot should be a batch of vectors of shape (minibatch, 3) and the output should be a batch of rotation matrices of shape (minibatch, 3, 3). The function handles a singularity around log(R) = 0 by clamping it with the eps argument. If the input log_rot is of incorrect shape, a ValueError is raised. The function returns the batch of rotation matrices after conversion. Reference to Rodrigues' rotation formula is provided for further information.",
    "function_name": "so3_exp_map",
    "ground_truth": "pytorch3d/transforms/so3.py",
    "test": "tests/test_so3.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}