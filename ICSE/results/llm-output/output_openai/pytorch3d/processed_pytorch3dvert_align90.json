{
    "result": "To implement the `vert_align` function, we need to handle several tasks:\n\n1. Validate the input shapes and attributes.\n2. Normalize the vertex positions to match the feature map dimensions.\n3. Sample the features from the feature map using the specified interpolation and padding modes.\n4. Concatenate features if multiple feature maps are provided.\n5. Optionally return the features in a packed format.\n\nHere's how you can implement this function:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef vert_align(feats, verts, return_packed=False, interp_mode='bilinear', padding_mode='zeros', align_corners=True):\n    # Check if feats is a list of tensors or a single tensor\n    if isinstance(feats, list):\n        for f in feats:\n            if len(f.shape) != 4:\n                raise ValueError(\"Each feature map in the list must have shape (N, C, H, W).\")\n        batch_size = feats[0].shape[0]\n    else:\n        if len(feats.shape) != 4:\n            raise ValueError(\"feats must have shape (N, C, H, W).\")\n        feats = [feats]\n        batch_size = feats[0].shape[0]\n\n    # Check verts shape or attributes\n    if hasattr(verts, 'verts_padded'):\n        verts = verts.verts_padded()\n    elif hasattr(verts, 'points_padded'):\n        verts = verts.points_padded()\n    elif len(verts.shape) != 3 or verts.shape[2] != 3:\n        raise ValueError(\"verts must have shape (N, V, 3) or have verts_padded/points_padded attributes.\")\n\n    if verts.shape[0] != batch_size:\n        raise ValueError(\"Batch size of feats and verts must match.\")\n\n    # Prepare to collect sampled features\n    sampled_features = []\n\n    for feat in feats:\n        N, C, H, W = feat.shape\n\n        # Normalize vertex positions to the feature map size\n        x = verts[:, :, 0].unsqueeze(-1)\n        y = verts[:, :, 1].unsqueeze(-1)\n        grid = torch.cat((x, y), dim=-1)\n\n        # Sample features using grid_sample\n        sampled_feat = F.grid_sample(\n            feat, grid.view(N, 1, -1, 2), mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners\n        )\n\n        # Reshape to (N, V, C)\n        sampled_feat = sampled_feat.view(N, C, -1).permute(0, 2, 1)\n        sampled_features.append(sampled_feat)\n\n    # Concatenate features from different feature maps\n    feats_sampled = torch.cat(sampled_features, dim=-1)\n\n    # Return packed features if requested\n    if return_packed:\n        feats_sampled = feats_sampled.view(-1, feats_sampled.shape[-1])\n\n    return feats_sampled\n```\n\n### Explanation:\n\n- **Input Validation**: The function checks if `feats` is a list or a single tensor and validates their shapes. It also checks the shape or attributes of `verts`.\n- **Vertex Normalization**: The vertex positions are assumed to be normalized in the range `[-1, 1]`, which is compatible with `torch.nn.functional.grid_sample`.\n- **Feature Sampling**: The function uses `grid_sample` to sample features from the feature map based on the vertex positions. The `grid_sample` function supports different interpolation and padding modes.\n- **Feature Concatenation**: If multiple feature maps are provided, their sampled features are concatenated along the channel dimension.\n- **Return Packed Features**: If `return_packed` is `True`, the function reshapes the output to a packed format.\n\nThis function should handle the specified requirements and error conditions effectively.",
    "prompt": "Create a Python function vert_align that performs \"vertex alignment\" or \"perceptual feature pooling,\" which samples vertex features from a feature map based on vertex positions. The function takes the following parameters:\n\nfeats: A tensor of shape (N, C, H, W) representing image features from which to sample, or a list of such tensors, each with potentially different C, H, or W dimensions.\nverts: A tensor of shape (N, V, 3) representing the (x, y, z) vertex positions, or an object with verts_padded or points_padded attributes. The (x, y) coordinates should be normalized such that (-1, -1) corresponds to the top-left and (1, 1) to the bottom-right of the feature map.\nreturn_packed: A boolean flag indicating whether to return packed features. Defaults to False.\ninterp_mode: A string specifying the interpolation mode ('bilinear' or 'nearest'). Defaults to 'bilinear'.\npadding_mode: A string specifying how to handle vertices outside the [-1, 1] range ('zeros', 'reflection', or 'border'). Defaults to 'zeros'.\nalign_corners: A boolean indicating whether to align corners geometrically. If True, extrema refer to the center points of corner pixels; if False, they refer to the corner points of the input's corner pixels. Defaults to True.\nReturns:\nfeats_sampled: A tensor of shape (N, V, C) giving sampled features for each vertex. If feats is a list, the function returns concatenated features in shape (N, V, sum(C_n)) where C_n = feats[n].shape[1]. If return_packed = True, the features are transformed to a packed representation of shape (sum(V), C).\nError Handling:\nRaise a ValueError if verts does not have the expected shape or attributes.\nRaise a ValueError if feats does not have the expected shape (N, C, H, W) or if the batch dimensions of feats and verts do not match.",
    "function_name": "vert_align",
    "ground_truth": "pytorch3d/ops/vert_align.py",
    "test": "tests/test_vert_align.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}