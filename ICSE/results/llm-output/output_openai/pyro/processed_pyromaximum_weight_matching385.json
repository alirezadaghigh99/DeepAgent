{
    "result": "To implement a function `maximum_weight_matching` that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching, we can use the `scipy.optimize.linear_sum_assignment` function, which is an implementation of the Hungarian algorithm. This algorithm finds the optimal assignment that maximizes the total weight (or minimizes the total cost) for a given cost matrix.\n\nHere's how you can implement this in Python using PyTorch for tensor operations and SciPy for the optimization:\n\n```python\nimport torch\nfrom scipy.optimize import linear_sum_assignment\n\ndef maximum_weight_matching(logits: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Perform maximum weight matching on the input logits tensor and return the optimal assignments.\n\n    Args:\n        logits (torch.Tensor): A 2D tensor of shape (n, m) representing the weight matrix.\n\n    Returns:\n        torch.Tensor: A 1D tensor of shape (n,) where each element is the index of the matched column\n                      for each row in the input logits tensor.\n    \"\"\"\n    # Convert logits to numpy array for use with scipy\n    logits_np = logits.detach().cpu().numpy()\n\n    # Since linear_sum_assignment finds the minimum cost, we need to convert the problem\n    # to a maximization problem by negating the logits\n    row_ind, col_ind = linear_sum_assignment(-logits_np)\n\n    # Create a tensor to store the optimal assignments\n    assignments = torch.full((logits.size(0),), -1, dtype=torch.int64)\n\n    # Fill the assignments tensor with the column indices of the optimal matching\n    assignments[row_ind] = torch.tensor(col_ind, dtype=torch.int64)\n\n    return assignments\n\n# Example usage:\n# logits = torch.tensor([[1.0, 2.0, 3.0], [4.0, 6.0, 5.0], [7.0, 8.0, 9.0]])\n# assignments = maximum_weight_matching(logits)\n# print(assignments)  # Output: tensor([2, 1, 0])\n```\n\n### Explanation:\n- **Input**: The function takes a 2D tensor `logits` of shape `(n, m)`, where `n` is the number of rows and `m` is the number of columns. Each element in the tensor represents the weight of assigning a particular row to a particular column.\n- **Negation**: Since `linear_sum_assignment` minimizes the cost, we negate the logits to convert the problem into a maximization problem.\n- **Assignment**: The function returns a 1D tensor of shape `(n,)`, where each element is the index of the column that is optimally matched to the corresponding row.\n\nThis function does not compute gradients, as it uses the `.detach()` method to ensure that the logits are not part of the computational graph.",
    "prompt": "Generate a Python function maximum_weight_matching that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching. The function performs a matching process and returns the best assignment for each element in the input without computing gradients.",
    "function_name": "maximum_weight_matching",
    "ground_truth": "pyro/distributions/one_two_matching.py",
    "test": "tests/distributions/test_one_two_matching.py::test_mode_phylo",
    "class": "",
    "stage": "Inference",
    "task": "prediction",
    "data": "Table"
}