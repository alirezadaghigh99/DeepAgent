{
    "result": "To create a function called `extract_patches_2d` that reshapes a 2D image into a collection of patches, we can use NumPy for efficient array manipulation. The function will take parameters for the image data, patch size, maximum number of patches, and a random state for reproducibility. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef extract_patches_2d(image, patch_size, max_patches=None, random_state=None):\n    \"\"\"\n    Extracts patches from a 2D image.\n\n    Parameters:\n    - image: np.ndarray\n        The original image data. Should be a 2D array or a 3D array with channels.\n    - patch_size: tuple of int\n        The size of the patches (patch_height, patch_width).\n    - max_patches: int, optional\n        The maximum number of patches to extract. If None, extracts all patches.\n    - random_state: int or np.random.RandomState, optional\n        Random state for reproducibility.\n\n    Returns:\n    - patches: np.ndarray\n        An array of patches extracted from the image.\n    \"\"\"\n    if random_state is not None:\n        np.random.seed(random_state)\n\n    image_height, image_width = image.shape[:2]\n    patch_height, patch_width = patch_size\n\n    # Calculate the number of patches that can be extracted\n    max_possible_patches = (image_height - patch_height + 1) * (image_width - patch_width + 1)\n\n    if max_patches is None:\n        max_patches = max_possible_patches\n    else:\n        max_patches = min(max_patches, max_possible_patches)\n\n    patches = []\n    for _ in range(max_patches):\n        i = np.random.randint(0, image_height - patch_height + 1)\n        j = np.random.randint(0, image_width - patch_width + 1)\n        patch = image[i:i + patch_height, j:j + patch_width]\n        patches.append(patch)\n\n    return np.array(patches)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a sample image (e.g., 8x8 with 3 channels)\n    sample_image = np.random.rand(8, 8, 3)\n\n    # Define patch size\n    patch_size = (3, 3)\n\n    # Extract patches\n    patches = extract_patches_2d(sample_image, patch_size, max_patches=5, random_state=42)\n\n    # Print the shape of the patches array\n    print(\"Extracted patches shape:\", patches.shape)\n\n    # Print the patches\n    for i, patch in enumerate(patches):\n        print(f\"Patch {i+1}:\\n\", patch)\n```\n\n### Explanation:\n\n- **Parameters**:\n  - `image`: The input image, which can be a 2D or 3D array (e.g., grayscale or RGB).\n  - `patch_size`: A tuple specifying the height and width of each patch.\n  - `max_patches`: The maximum number of patches to extract. If not specified, all possible patches are extracted.\n  - `random_state`: Used to ensure reproducibility of the random patch extraction.\n\n- **Functionality**:\n  - The function calculates the maximum number of patches that can be extracted based on the image and patch sizes.\n  - It randomly selects starting points for each patch and extracts the patch from the image.\n  - The extracted patches are stored in a list and converted to a NumPy array before returning.\n\n- **Example Usage**:\n  - A sample image is created using random values.\n  - Patches of size 3x3 are extracted from this image.\n  - The function prints the shape of the extracted patches and the patches themselves.\n\nThis function is useful for tasks like data augmentation or preparing data for machine learning models that require fixed-size inputs.",
    "prompt": "Generate a Python function called extract_patches_2d that reshapes a 2D image into a collection of patches. The function takes in parameters including the original image data, patch size, maximum number of patches to extract, and random state for sampling. It returns an array of patches extracted from the image, with the shape of the patches specified by the patch height, patch width, and number of channels in the image. The function also includes examples demonstrating how to use it with sample image data.",
    "function_name": "extract_patches_2d",
    "ground_truth": "sklearn/feature_extraction/image.py",
    "test": "sklearn/feature_extraction/tests/test_image.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}