{
    "result": "To create a function `calibration_curve` that computes the true and predicted probabilities for a calibration curve, we can follow these steps:\n\n1. Discretize the predicted probabilities into bins.\n2. Calculate the fraction of positives and the mean predicted probability for each bin.\n\nHere's the implementation of the `calibration_curve` function:\n\n```python\nimport numpy as np\nfrom sklearn.utils import column_or_1d\nfrom sklearn.utils.validation import _deprecate_positional_args\n\ndef calibration_curve(y_true, y_prob, pos_label=None, n_bins=5, strategy='uniform'):\n    y_true = column_or_1d(y_true)\n    y_prob = column_or_1d(y_prob)\n\n    if pos_label is None:\n        pos_label = 1\n\n    # Binarize y_true according to pos_label\n    y_true = (y_true == pos_label).astype(int)\n\n    if strategy not in ['uniform', 'quantile']:\n        raise ValueError(\"Invalid strategy '{}'. Strategy must be 'uniform' or 'quantile'.\".format(strategy))\n\n    if strategy == 'uniform':\n        bins = np.linspace(0., 1., n_bins + 1)\n    elif strategy == 'quantile':\n        bins = np.percentile(y_prob, np.linspace(0, 100, n_bins + 1))\n\n    binids = np.digitize(y_prob, bins) - 1\n\n    prob_true = np.zeros(n_bins)\n    prob_pred = np.zeros(n_bins)\n\n    for i in range(n_bins):\n        mask = binids == i\n        if np.any(mask):\n            prob_true[i] = np.mean(y_true[mask])\n            prob_pred[i] = np.mean(y_prob[mask])\n\n    return prob_true, prob_pred\n\n# Example usage\nif __name__ == \"__main__\":\n    y_true = np.array([0, 0, 1, 1])\n    y_prob = np.array([0.1, 0.4, 0.35, 0.8])\n\n    prob_true, prob_pred = calibration_curve(y_true, y_prob, pos_label=1, n_bins=3, strategy='uniform')\n    print(\"Uniform strategy:\")\n    print(\"Fraction of positives:\", prob_true)\n    print(\"Mean predicted probability:\", prob_pred)\n\n    prob_true, prob_pred = calibration_curve(y_true, y_prob, pos_label=1, n_bins=3, strategy='quantile')\n    print(\"\\nQuantile strategy:\")\n    print(\"Fraction of positives:\", prob_true)\n    print(\"Mean predicted probability:\", prob_pred)\n```\n\n### Explanation:\n\n- **Binarization**: The `y_true` array is binarized based on the `pos_label` to ensure that we are working with binary classification.\n- **Binning Strategy**: The function supports two strategies for binning:\n  - **Uniform**: Divides the interval [0, 1] into `n_bins` equal-width bins.\n  - **Quantile**: Divides the data into `n_bins` bins with an equal number of samples.\n- **Bin Assignment**: The `np.digitize` function is used to assign each probability to a bin.\n- **Calculation**: For each bin, the function calculates the mean of the true labels (`prob_true`) and the mean of the predicted probabilities (`prob_pred`).\n\nThis function can be used to evaluate the calibration of a probabilistic classifier by comparing the predicted probabilities with the actual outcomes.",
    "prompt": "Generate a Python function called calibration_curve that computes true and predicted probabilities for a calibration curve. The function takes in the following parameters:\n\n- y_true: array-like of shape (n_samples), representing the true targets.\n- y_prob: array-like of shape (n_samples), representing the probabilities of the positive class.\n- pos_label: int, float, bool, or str, default=None, indicating the label of the positive class.\n- n_bins: int, default=5, specifying the number of bins to discretize the [0, 1] interval.\n- strategy: {'uniform', 'quantile'}, default='uniform', determining the strategy used to define the widths of the bins.\n\nThe function returns two arrays:\n- prob_true: ndarray of shape (n_bins,) or smaller, representing the proportion of samples whose class is the positive class in each bin (fraction of positives).\n- prob_pred: ndarray of shape (n_bins,) or smaller, representing the mean predicted probability in each bin.\n\nThe function also includes examples demonstrating how to use it with sample data.",
    "function_name": "calibration_curve",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py::test_calibration_display_pos_label",
    "class": "",
    "stage": "Inference",
    "task": "Classification",
    "data": "Table"
}