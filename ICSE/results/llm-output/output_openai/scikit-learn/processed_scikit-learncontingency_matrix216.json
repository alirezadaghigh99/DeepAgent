{
    "result": "Here's a Python function `contingency_matrix` that constructs a contingency matrix based on the given specifications:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,), Ground truth class labels.\n    - labels_pred: array-like of shape (n_samples,), Cluster labels.\n    - eps: float, optional, If not None, a small value added to all entries of the contingency matrix.\n    - sparse: bool, optional, If True, return a sparse CSR matrix.\n    - dtype: numeric type, optional, Desired data type of the output matrix.\n\n    Returns:\n    - C: ndarray or sparse matrix of shape (n_classes_true, n_classes_pred), Contingency matrix.\n\n    Example:\n    >>> labels_true = [0, 0, 1, 1, 2, 2]\n    >>> labels_pred = [0, 0, 1, 1, 0, 2]\n    >>> contingency_matrix(labels_true, labels_pred)\n    array([[2, 0, 0],\n           [0, 2, 0],\n           [1, 0, 1]])\n    \"\"\"\n    labels_true = np.asarray(labels_true)\n    labels_pred = np.asarray(labels_pred)\n\n    classes_true, class_idx_true = np.unique(labels_true, return_inverse=True)\n    classes_pred, class_idx_pred = np.unique(labels_pred, return_inverse=True)\n\n    n_classes_true = classes_true.shape[0]\n    n_classes_pred = classes_pred.shape[0]\n\n    if dtype is None:\n        dtype = np.float64 if eps is not None else np.int64\n\n    # Initialize the contingency matrix\n    C = np.zeros((n_classes_true, n_classes_pred), dtype=dtype)\n\n    # Populate the contingency matrix\n    for i in range(labels_true.size):\n        C[class_idx_true[i], class_idx_pred[i]] += 1\n\n    if eps is not None:\n        C = C.astype(np.float64)\n        C += eps\n\n    if sparse:\n        C = csr_matrix(C)\n\n    return C\n\n# Example usage\nif __name__ == \"__main__\":\n    labels_true = [0, 0, 1, 1, 2, 2]\n    labels_pred = [0, 0, 1, 1, 0, 2]\n    print(contingency_matrix(labels_true, labels_pred))\n```\n\n### Explanation:\n- **Input Parameters:**\n  - `labels_true` and `labels_pred` are the ground truth and predicted labels, respectively.\n  - `eps` is an optional parameter that, if provided, adds a small value to all entries of the contingency matrix to avoid zero entries.\n  - `sparse` determines whether the output should be a sparse matrix.\n  - `dtype` allows specifying the desired data type of the output matrix.\n\n- **Function Logic:**\n  - Convert input labels to numpy arrays.\n  - Use `np.unique` to find unique classes and their indices.\n  - Initialize a contingency matrix `C` with zeros.\n  - Populate the matrix by iterating over the samples and incrementing the appropriate cell in `C`.\n  - If `eps` is provided, convert `C` to float and add `eps`.\n  - If `sparse` is `True`, convert `C` to a sparse CSR matrix.\n\n- **Example Usage:**\n  - The example provided in the docstring demonstrates how to use the function and what output to expect.",
    "prompt": "Generate a Python function called contingency_matrix that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function takes in two array-like inputs: labels_true (ground truth class labels) and labels_pred (cluster labels). Additionally, it has optional parameters eps (float), sparse (bool), and dtype (numeric type). \n\nThe function returns a contingency matrix of shape [n_classes_true, n_classes_pred], where each element C[i, j] represents the number of samples in true class i and predicted class j. If eps is not None, the dtype of the output array will be float; otherwise, it will be an integer unless specified with the dtype argument. If sparse is True, a sparse CSR matrix will be returned. \n\nAn example usage of the function is provided in the docstring, where labels_true and labels_pred are given as input, and the resulting contingency matrix is shown.",
    "function_name": "contingency_matrix",
    "ground_truth": "sklearn/metrics/cluster/_supervised.py",
    "test": "sklearn/metrics/cluster/tests/test_supervised.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}