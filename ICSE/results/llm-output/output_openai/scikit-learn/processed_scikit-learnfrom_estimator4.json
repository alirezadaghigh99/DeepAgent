{
    "result": "To create a function `from_estimator` that plots a calibration curve using a binary classifier and data, we can utilize the `calibration_curve` function from `sklearn.calibration` and `matplotlib` for plotting. The function will compute the calibration curve and plot it on the provided axes. Here's how you can implement this:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.base import is_classifier\nfrom sklearn.utils import check_array, check_consistent_length\nfrom sklearn.utils.multiclass import type_of_target\nfrom sklearn.exceptions import NotFittedError\n\nclass CalibrationDisplay:\n    \"\"\"A class to store the computed values of the calibration curve.\"\"\"\n    def __init__(self, prob_true, prob_pred, estimator_name):\n        self.prob_true = prob_true\n        self.prob_pred = prob_pred\n        self.estimator_name = estimator_name\n\n    def plot(self, ax=None, name=None, ref_line=True, **kwargs):\n        if ax is None:\n            ax = plt.gca()\n\n        name = self.estimator_name if name is None else name\n        ax.plot(self.prob_pred, self.prob_true, marker='o', label=name, **kwargs)\n        if ref_line:\n            ax.plot([0, 1], [0, 1], 'k:', label='Perfectly calibrated')\n\n        ax.set_xlabel('Mean predicted probability')\n        ax.set_ylabel('Fraction of positives')\n        ax.set_ylim([-0.05, 1.05])\n        ax.legend(loc='best')\n\n        return ax\n\ndef from_estimator(estimator, X, y, n_bins=10, strategy='uniform', pos_label=None, name=None, ref_line=True, ax=None, **kwargs):\n    # Check if the estimator is a classifier\n    if not is_classifier(estimator):\n        raise ValueError(\"The provided estimator is not a classifier.\")\n\n    # Check if the estimator is fitted\n    if not hasattr(estimator, \"predict_proba\"):\n        raise NotFittedError(\"The estimator does not have a predict_proba method. Ensure it is fitted.\")\n\n    # Validate input data\n    X = check_array(X)\n    y = check_array(y, ensure_2d=False)\n    check_consistent_length(X, y)\n\n    # Determine the positive class label\n    if pos_label is None:\n        pos_label = 1\n\n    # Check if y is binary\n    if type_of_target(y) != 'binary':\n        raise ValueError(\"Only binary classification is supported.\")\n\n    # Get predicted probabilities for the positive class\n    prob_pos = estimator.predict_proba(X)[:, 1]\n\n    # Compute the calibration curve\n    prob_true, prob_pred = calibration_curve(y, prob_pos, n_bins=n_bins, strategy=strategy, pos_label=pos_label)\n\n    # Create a CalibrationDisplay object\n    display = CalibrationDisplay(prob_true, prob_pred, estimator_name=name or estimator.__class__.__name__)\n\n    # Plot the calibration curve\n    display.plot(ax=ax, name=name, ref_line=ref_line, **kwargs)\n\n    return display\n```\n\n### Explanation:\n- **CalibrationDisplay Class**: This class is used to store the computed values of the calibration curve and provides a method to plot these values.\n- **from_estimator Function**: This function takes a fitted classifier and data, computes the calibration curve, and plots it.\n  - It checks if the estimator is a classifier and if it is fitted.\n  - It validates the input data and ensures that the target `y` is binary.\n  - It computes the predicted probabilities for the positive class and uses `calibration_curve` to compute the calibration curve.\n  - It creates a `CalibrationDisplay` object to store the results and plot the curve.\n- **Plotting**: The function uses `matplotlib` to plot the calibration curve and optionally a reference line for perfect calibration.\n\nThis function should be used with a fitted binary classifier and appropriate data to visualize how well the predicted probabilities are calibrated.",
    "prompt": "Generate a Python function called from_estimator that plots a calibration curve using a binary classifier and data. The function takes in parameters such as estimator (fitted classifier), X (input values), y (binary target values), n_bins (number of bins for discretization), strategy (bin width strategy), pos_label (positive class label), name (label for curve), ref_line (whether to plot a reference line), ax (matplotlib axes), and additional keyword arguments. The function returns a CalibrationDisplay object that stores computed values.",
    "function_name": "from_estimator",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}