{
    "result": "To implement a `confusion_matrix` function in Python, we can follow the description provided. The function will compute the confusion matrix for a given set of true labels and predicted labels. It will also support optional parameters for specifying labels, sample weights, and normalization. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef confusion_matrix(y_true, y_pred, labels=None, sample_weight=None, normalize=None):\n    # Convert inputs to numpy arrays\n    y_true = np.asarray(y_true)\n    y_pred = np.asarray(y_pred)\n    \n    # Determine the unique labels\n    if labels is None:\n        labels = np.unique(np.concatenate((y_true, y_pred)))\n    else:\n        labels = np.asarray(labels)\n    \n    n_labels = labels.size\n    label_to_index = {label: index for index, label in enumerate(labels)}\n    \n    # Initialize the confusion matrix\n    C = np.zeros((n_labels, n_labels), dtype=np.int64)\n    \n    # Populate the confusion matrix\n    for true, pred in zip(y_true, y_pred):\n        if true in label_to_index and pred in label_to_index:\n            true_index = label_to_index[true]\n            pred_index = label_to_index[pred]\n            C[true_index, pred_index] += 1\n    \n    # Apply sample weights if provided\n    if sample_weight is not None:\n        sample_weight = np.asarray(sample_weight)\n        for i, (true, pred) in enumerate(zip(y_true, y_pred)):\n            if true in label_to_index and pred in label_to_index:\n                true_index = label_to_index[true]\n                pred_index = label_to_index[pred]\n                C[true_index, pred_index] += sample_weight[i] - 1\n    \n    # Normalize the confusion matrix if required\n    if normalize is not None:\n        with np.errstate(all='ignore'):\n            if normalize == 'true':\n                C = C / C.sum(axis=1, keepdims=True)\n            elif normalize == 'pred':\n                C = C / C.sum(axis=0, keepdims=True)\n            elif normalize == 'all':\n                C = C / C.sum()\n            else:\n                raise ValueError(\"normalize must be one of {'true', 'pred', 'all', None}\")\n            C = np.nan_to_num(C)  # Replace NaNs with zeros\n    \n    return C\n\n# Example usage:\n# y_true = [0, 1, 2, 2, 0, 1]\n# y_pred = [0, 2, 1, 2, 0, 1]\n# print(confusion_matrix(y_true, y_pred))\n```\n\n### Explanation:\n\n1. **Input Conversion**: Convert `y_true` and `y_pred` to numpy arrays for easier manipulation.\n\n2. **Label Handling**: If `labels` is not provided, determine the unique labels from `y_true` and `y_pred`. Otherwise, use the provided labels.\n\n3. **Confusion Matrix Initialization**: Create a zero matrix of size `(n_labels, n_labels)`.\n\n4. **Matrix Population**: Iterate over `y_true` and `y_pred` to populate the confusion matrix.\n\n5. **Sample Weights**: If `sample_weight` is provided, adjust the counts in the confusion matrix accordingly.\n\n6. **Normalization**: Normalize the matrix based on the specified method (`'true'`, `'pred'`, or `'all'`).\n\n7. **Return**: Return the computed confusion matrix.\n\nThis function should cover the basic requirements for computing a confusion matrix with optional normalization and sample weighting.",
    "prompt": "Generate a Python function called confusion_matrix that Compute confusion matrix to evaluate the accuracy of a classification.\n\n    By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`\n    is equal to the number of observations known to be in group :math:`i` and\n    predicted to be in group :math:`j`.\n\n    Thus in binary classification, the count of true negatives is\n    :math:`C_{0,0}`, false negatives is :math:`C_{1,0}`, true positives is\n    :math:`C_{1,1}` and false positives is :math:`C_{0,1}`.\n\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples,)\n        Ground truth (correct) target values.\n\n    y_pred : array-like of shape (n_samples,)\n        Estimated targets as returned by a classifier.\n\n    labels : array-like of shape (n_classes), default=None\n        List of labels to index the matrix. This may be used to reorder\n        or select a subset of labels.\n        If ``None`` is given, those that appear at least once\n        in ``y_true`` or ``y_pred`` are used in sorted order.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights.\n\n        .. versionadded:: 0.18\n\n    normalize : {'true', 'pred', 'all'}, default=None\n        Normalizes confusion matrix over the true (rows), predicted (columns)\n        conditions or all the population. If None, confusion matrix will not be\n        normalized.\n\n    Returns\n    -------\n    C : ndarray of shape (n_classes, n_classes)\n        Confusion matrix whose i-th row and j-th\n        column entry indicates the number of\n        samples with true label being i-th class\n        and predicted label being j-th class.",
    "function_name": "confusion_matrix",
    "ground_truth": "sklearn/metrics/_classification.py",
    "test": "sklearn/metrics/tests/test_classification.py::test_zero_division_nan_no_warning",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": ""
}