{
    "result": "Here's a Python implementation of the Orthogonal Matching Pursuit (OMP) algorithm, encapsulated in a function called `orthogonal_mp`. This function includes various optional parameters to control the behavior of the algorithm, such as the number of non-zero coefficients, tolerance, and whether to return the coefficient path or the number of iterations.\n\n```python\nimport numpy as np\nfrom numpy.linalg import norm, lstsq\n\ndef orthogonal_mp(X, y, n_nonzero_coefs=None, tol=None, precompute=False, copy_X=True, return_path=False, return_n_iter=False):\n    \"\"\"\n    Orthogonal Matching Pursuit (OMP) algorithm.\n\n    Parameters:\n    - X: array-like of shape (n_samples, n_features)\n    - y: ndarray of shape (n_samples,) or (n_samples, n_targets)\n    - n_nonzero_coefs: int, optional\n        Desired number of non-zero entries in the solution.\n    - tol: float, optional\n        Maximum norm of the residual.\n    - precompute: bool, optional\n        Whether to precompute Gram matrix.\n    - copy_X: bool, optional\n        Whether to copy X.\n    - return_path: bool, optional\n        Whether to return the entire coefficient path.\n    - return_n_iter: bool, optional\n        Whether to return the number of iterations.\n\n    Returns:\n    - coef: ndarray of shape (n_features,) or (n_features, n_targets)\n    - n_iters: int, optional\n        Number of active features across every target.\n    \"\"\"\n    if copy_X:\n        X = X.copy()\n    \n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    \n    n_samples, n_features = X.shape\n    n_targets = y.shape[1]\n    \n    if n_nonzero_coefs is None and tol is None:\n        raise ValueError(\"Either n_nonzero_coefs or tol must be provided.\")\n    \n    if precompute:\n        G = X.T @ X\n    else:\n        G = None\n    \n    coef = np.zeros((n_features, n_targets))\n    n_iters = np.zeros(n_targets, dtype=int)\n    \n    for k in range(n_targets):\n        residual = y[:, k]\n        indices = []\n        coef_path = []\n        \n        for _ in range(n_features):\n            if G is not None:\n                correlations = X.T @ residual\n            else:\n                correlations = X.T @ residual\n            \n            best_index = np.argmax(np.abs(correlations))\n            indices.append(best_index)\n            \n            X_selected = X[:, indices]\n            coef_selected, _, _, _ = lstsq(X_selected, y[:, k], rcond=None)\n            \n            residual = y[:, k] - X_selected @ coef_selected\n            \n            if return_path:\n                full_coef = np.zeros(n_features)\n                full_coef[indices] = coef_selected\n                coef_path.append(full_coef)\n            \n            if tol is not None and norm(residual) < tol:\n                break\n            \n            if n_nonzero_coefs is not None and len(indices) >= n_nonzero_coefs:\n                break\n        \n        coef[indices, k] = coef_selected\n        n_iters[k] = len(indices)\n        \n        if return_path:\n            coef_path = np.array(coef_path)\n    \n    if return_n_iter:\n        return coef, n_iters\n    return coef\n\n# Example usage\nif __name__ == \"__main__\":\n    # Sample data\n    X = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    y = np.array([1, 2, 3])\n\n    # Run OMP\n    coef = orthogonal_mp(X, y, n_nonzero_coefs=2)\n    print(\"Coefficients:\", coef)\n```\n\n### Explanation:\n- **Parameters**:\n  - `X`: The input data matrix.\n  - `y`: The target values.\n  - `n_nonzero_coefs`: The desired number of non-zero coefficients in the solution.\n  - `tol`: The tolerance for the residual norm.\n  - `precompute`: Whether to precompute the Gram matrix.\n  - `copy_X`: Whether to copy the input matrix `X`.\n  - `return_path`: Whether to return the entire path of coefficients.\n  - `return_n_iter`: Whether to return the number of iterations.\n\n- **Returns**:\n  - `coef`: The coefficients of the OMP solution.\n  - `n_iters`: The number of iterations (if `return_n_iter` is `True`).\n\nThis implementation provides a basic framework for the OMP algorithm, allowing for flexibility in terms of stopping criteria and output options.",
    "prompt": "Generate a Python function called orthogonal_mp that implements the Orthogonal Matching Pursuit (OMP) algorithm. The function takes in input parameters X (array-like of shape (n_samples, n_features)) and y (ndarray of shape (n_samples,) or (n_samples, n_targets)), along with optional parameters such as n_nonzero_coefs, tol, precompute, copy_X, return_path, and return_n_iter. \n\nThe function solves n_targets OMP problems by finding the coefficients of the OMP solution based on the input data X and targets y. The OMP problem is defined as finding the coefficients that minimize the residual error subject to constraints on the number of non-zero coefficients or the maximum squared norm of the residual.\n\nThe function returns the coefficients (coef) of the OMP solution as an ndarray of shape (n_features,) or (n_features, n_targets), along with the number of active features across every target (n_iters) if return_n_iter is set to True. Additionally, the function provides options to return the coefficient path and the number of iterations.\n\nThe OMP algorithm is based on the work by Mallat and Zhang in 1993 and Rubinstein, Zibulevsky, and Elad in 2008. The function includes examples demonstrating the usage of orthogonal_mp with sample data.",
    "function_name": "orthogonal_mp",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Table"
}