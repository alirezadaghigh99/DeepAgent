{
    "result": "To create the `compute_sample_weight` function, we need to handle different scenarios for the `class_weight` parameter, compute the sample weights based on class frequencies, and handle optional subsampling using the `indices` parameter. Below is the implementation of the function, including error handling and usage examples:\n\n```python\nimport numpy as np\nfrom collections import Counter\n\ndef compute_sample_weight(class_weight, y, indices=None):\n    \"\"\"\n    Estimate sample weights by class for unbalanced datasets.\n\n    Parameters:\n    - class_weight: dict, list of dicts, \"balanced\", or None\n        Weights associated with classes.\n    - y: array-like, sparse matrix\n        Original class labels per sample.\n    - indices: array-like of shape (n_subsample,), default=None\n        Indices to be used in a subsample.\n\n    Returns:\n    - sample_weight_vect: numpy array of shape (n_samples,)\n        Sample weights as applied to the original y.\n    \"\"\"\n    if indices is not None:\n        y = np.asarray(y)[indices]\n    \n    unique_classes = np.unique(y)\n    class_counts = Counter(y)\n    \n    if class_weight is None:\n        # Default to uniform weights\n        class_weight_dict = {cls: 1.0 for cls in unique_classes}\n    elif class_weight == \"balanced\":\n        # Compute balanced weights\n        total_samples = len(y)\n        class_weight_dict = {\n            cls: total_samples / (len(unique_classes) * class_counts[cls])\n            for cls in unique_classes\n        }\n    elif isinstance(class_weight, dict):\n        # Use provided class weights\n        class_weight_dict = class_weight\n    else:\n        raise ValueError(\"class_weight must be 'balanced', a dict, or None.\")\n    \n    # Create the sample weight vector\n    sample_weight_vect = np.array([class_weight_dict[cls] for cls in y])\n    \n    return sample_weight_vect\n\n# Example usage:\n# Example 1: Using \"balanced\" mode\ny = np.array([0, 0, 1, 1, 1, 2])\nsample_weights_balanced = compute_sample_weight(\"balanced\", y)\nprint(\"Balanced sample weights:\", sample_weights_balanced)\n\n# Example 2: Using a custom class weight dictionary\nclass_weight = {0: 1.0, 1: 0.5, 2: 2.0}\nsample_weights_custom = compute_sample_weight(class_weight, y)\nprint(\"Custom sample weights:\", sample_weights_custom)\n\n# Example 3: Using indices for subsampling\nindices = [0, 2, 4, 5]\nsample_weights_subsample = compute_sample_weight(\"balanced\", y, indices=indices)\nprint(\"Subsampled balanced weights:\", sample_weights_subsample)\n```\n\n### Explanation:\n\n1. **Parameters**:\n   - `class_weight`: Determines how weights are assigned to each class. It can be a dictionary, \"balanced\", or None.\n   - `y`: The array of class labels.\n   - `indices`: Optional parameter to specify a subsample of `y`.\n\n2. **Handling `class_weight`**:\n   - If `None`, all classes are assigned a weight of 1.\n   - If `\"balanced\"`, weights are computed inversely proportional to class frequencies.\n   - If a dictionary, it directly specifies the weight for each class.\n\n3. **Subsampling**:\n   - If `indices` is provided, `y` is filtered to include only the specified indices.\n\n4. **Error Handling**:\n   - Raises a `ValueError` if `class_weight` is not one of the expected types.\n\n5. **Examples**:\n   - Demonstrates usage with \"balanced\" mode, custom weights, and subsampling.\n\nThis function should cover the typical use cases for computing sample weights in unbalanced datasets.",
    "prompt": "Create a Python function called compute_sample_weight that estimates sample weights by class for unbalanced datasets. The function takes in three parameters: class_weight (dict, list of dicts, \"balanced\", or None), y (array-like, sparse matrix), and indices (array-like of shape (n_subsample,), default=None). \n\nThe class_weight parameter represents weights associated with classes, with options for different formats and the \"balanced\" mode for automatic adjustment based on class frequencies. The y parameter is an array of original class labels per sample, and the indices parameter is an array of indices to be used in a subsample.\n\nThe function returns a numpy array called sample_weight_vect of shape (n_samples,) containing the sample weights as applied to the original y. The function includes examples of usage and error handling for different scenarios.",
    "function_name": "compute_sample_weight",
    "ground_truth": "sklearn/utils/class_weight.py",
    "test": "sklearn/utils/tests/test_class_weight.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}