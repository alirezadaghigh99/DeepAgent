{
    "result": "To implement a confusion matrix function without using `sklearn`, you can follow these steps:\n\n1. Validate that the input arrays `true` and `pred` are of the same length.\n2. Determine the unique class labels present in the arrays.\n3. Initialize a square matrix of size `K x K`, where `K` is the number of unique class labels.\n4. Iterate over the `true` and `pred` arrays, incrementing the appropriate cell in the matrix for each pair of true and predicted labels.\n\nHere's a Python function that implements this logic:\n\n```python\nimport numpy as np\n\ndef confusion_matrix(true, pred):\n    # Ensure the input arrays are numpy arrays\n    true = np.asarray(true)\n    pred = np.asarray(pred)\n    \n    # Check if the lengths of the arrays are the same\n    if len(true) != len(pred):\n        raise ValueError(\"The length of true and pred must be the same.\")\n    \n    # Find the unique class labels\n    labels = np.unique(true)\n    \n    # Check if pred contains the same set of labels\n    if not np.array_equal(np.unique(pred), labels):\n        raise ValueError(\"True and pred must contain the same set of distinct labels.\")\n    \n    # Create a confusion matrix of size K x K\n    K = len(labels)\n    conf_matrix = np.zeros((K, K), dtype=int)\n    \n    # Map each label to an index\n    label_to_index = {label: index for index, label in enumerate(labels)}\n    \n    # Populate the confusion matrix\n    for t, p in zip(true, pred):\n        i = label_to_index[t]\n        j = label_to_index[p]\n        conf_matrix[i, j] += 1\n    \n    return conf_matrix\n\n# Example usage:\n# true_labels = np.array([0, 1, 2, 2, 0, 1])\n# pred_labels = np.array([0, 2, 1, 2, 0, 1])\n# print(confusion_matrix(true_labels, pred_labels))\n```\n\n### Explanation:\n- **Input Validation**: The function first checks that the `true` and `pred` arrays are of the same length and contain the same set of unique labels.\n- **Label Mapping**: A dictionary `label_to_index` is used to map each unique label to an index, which helps in populating the confusion matrix.\n- **Matrix Population**: The function iterates over the `true` and `pred` arrays, using the label-to-index mapping to increment the appropriate cell in the confusion matrix.\n\nThis function should provide the same results as `sklearn.metrics.confusion_matrix` for the given constraints.",
    "prompt": "Generate a Python function called confusion_matrix that iImplements a confusion matrix for true labels\n    and predicted labels. true and pred MUST BE the same length\n    and have the same distinct set of class labels represented.\n\n    Results are identical (and similar computation time) to:\n        \"sklearn.metrics.confusion_matrix\"\n\n    However, this function avoids the dependency on sklearn.\n\n    Parameters\n    ----------\n    true : np.ndarray 1d\n      Contains labels.\n      Assumes true and pred contains the same set of distinct labels.\n\n    pred : np.ndarray 1d\n      A discrete vector of noisy labels, i.e. some labels may be erroneous.\n      *Format requirements*: for dataset with K classes, labels must be in {0,1,...,K-1}.\n\n    Returns\n    -------\n    confusion_matrix : np.ndarray (2D)\n      matrix of confusion counts with true on rows and pred on columns",
    "function_name": "confusion_matrix",
    "ground_truth": "cleanlab/internal/util.py",
    "test": "tests/test_util.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}