{
    "result": "To implement the `find_overlapping_classes` function, we need to handle different input scenarios and compute the overlapping classes based on the provided data. The function will return a Pandas DataFrame with the required columns. Here's a possible implementation:\n\n```python\nimport numpy as np\nimport pandas as pd\n\ndef find_overlapping_classes(labels=None, pred_probs=None, asymmetric=False, class_names=None, num_examples=None, joint=None, confident_joint=None):\n    if joint is not None and num_examples is None:\n        raise ValueError(\"If 'joint' is provided, 'num_examples' must also be provided.\")\n    \n    if confident_joint is None:\n        if labels is not None and pred_probs is not None:\n            # Compute the confident joint from labels and pred_probs\n            confident_joint = compute_confident_joint(labels, pred_probs)\n        elif joint is not None:\n            # Use the joint directly if provided\n            confident_joint = joint * num_examples\n        else:\n            raise ValueError(\"You must provide either 'labels' and 'pred_probs', or 'joint' and 'num_examples', or 'confident_joint'.\")\n\n    if num_examples is None:\n        num_examples = np.sum(confident_joint)\n\n    K = confident_joint.shape[0]\n    overlapping_data = []\n\n    for i in range(K):\n        for j in range(i + 1, K):\n            if asymmetric:\n                num_overlap_ij = confident_joint[i, j]\n                num_overlap_ji = confident_joint[j, i]\n                if num_overlap_ij > 0:\n                    overlapping_data.append((i, j, num_overlap_ij, num_overlap_ij / num_examples))\n                if num_overlap_ji > 0:\n                    overlapping_data.append((j, i, num_overlap_ji, num_overlap_ji / num_examples))\n            else:\n                num_overlap = confident_joint[i, j] + confident_joint[j, i]\n                if num_overlap > 0:\n                    overlapping_data.append((i, j, num_overlap, num_overlap / num_examples))\n\n    df = pd.DataFrame(overlapping_data, columns=[\"Class Index A\", \"Class Index B\", \"Num Overlapping Examples\", \"Joint Probability\"])\n    df = df.sort_values(by=\"Joint Probability\", ascending=False).reset_index(drop=True)\n\n    if class_names is not None:\n        df['Class Name A'] = df['Class Index A'].apply(lambda x: class_names[x])\n        df['Class Name B'] = df['Class Index B'].apply(lambda x: class_names[x])\n\n    return df\n\ndef compute_confident_joint(labels, pred_probs):\n    # Placeholder for the actual computation of the confident joint\n    # This function should be implemented based on the specific method used to compute the confident joint\n    # For now, we will return a dummy matrix for demonstration purposes\n    K = pred_probs.shape[1]\n    confident_joint = np.zeros((K, K))\n    # Example logic to fill the confident_joint matrix\n    for i, label in enumerate(labels):\n        predicted_class = np.argmax(pred_probs[i])\n        confident_joint[label, predicted_class] += 1\n    return confident_joint\n```\n\n### Explanation:\n- **Input Handling**: The function checks which inputs are provided and computes the `confident_joint` matrix if necessary.\n- **Confident Joint Calculation**: If `confident_joint` is not provided, it is computed from `labels` and `pred_probs` using a placeholder function `compute_confident_joint`.\n- **Overlapping Calculation**: The function iterates over class pairs to calculate the number of overlapping examples and their joint probability.\n- **Asymmetric Option**: If `asymmetric` is `True`, it considers both directions of class confusion separately.\n- **Output**: The function returns a DataFrame sorted by joint probability, optionally including class names if provided.\n\nThis implementation assumes the existence of a method to compute the confident joint from labels and predicted probabilities, which should be defined based on the specific requirements of your dataset and model.",
    "prompt": "Generate a Python function called find_overlapping_classes that rReturns the pairs of classes that are often mislabeled as one another.\n    Consider merging the top pairs of classes returned by this method each into a single class.\n    If the dataset is labeled by human annotators, consider clearly defining the\n    difference between the classes prior to having annotators label the data.\n    This method provides two scores in the Pandas DataFrame that is returned:\n    * **Num Overlapping Examples**: The number of examples where the two classes overlap\n    * **Joint Probability**: `(num overlapping examples / total number of examples in the dataset`).\n    This method works by providing any one (and only one) of the following inputs:\n    1. ``labels`` and ``pred_probs``, or\n    2. ``joint`` and ``num_examples``, or\n    3. ``confident_joint``\n      Parameters\n    ----------\n    labels : np.ndarray or list, optional\n      An array_like (of length N) of noisy labels for the classification dataset, i.e. some labels may be erroneous.\n      Elements must be integers in the set 0, 1, ..., K-1, where K is the number of classes.\n      All the classes (0, 1, ..., and K-1) should be present in ``labels``, such that\n      ``len(set(labels)) == pred_probs.shape[1]`` for standard multi-class classification with single-labeled data (e.g. ``labels =  [1,0,2,1,1,0...]``).\n      For multi-label classification where each example can belong to multiple classes (e.g. ``labels = [[1,2],[1],[0],[],...]``),\n      your labels should instead satisfy: ``len(set(k for l in labels for k in l)) == pred_probs.shape[1])``.\n\n    pred_probs : np.ndarray, optional\n      An array of shape ``(N, K)`` of model-predicted probabilities,\n      ``P(label=k|x)``. Each row of this matrix corresponds\n      to an example `x` and contains the model-predicted probabilities that\n      `x` belongs to each possible class, for each of the K classes. The\n      columns must be ordered such that these probabilities correspond to\n      class 0, 1, ..., K-1. `pred_probs` should have been computed using 3 (or\n      higher) fold cross-validation.\n\n    asymmetric : bool, optional\n      If ``asymmetric=True``, returns separate estimates for both pairs (class1, class2) and (class2, class1). Use this\n      for finding \"is a\" relationships where for example \"class1 is a class2\".\n      In this case, num overlapping examples counts the number of examples that have been labeled as class1 which should actually have been labeled as class2.\n      If ``asymmetric=False``, the pair (class1, class2) will only be returned once with an arbitrary order.\n      In this case, their estimated score is the sum: ``score(class1, class2) + score(class2, class1))``.\n\n    class_names : Iterable[str]\n        A list or other iterable of the string class names. The list should be in the order that\n        matches the class indices. So if class 0 is 'dog' and class 1 is 'cat', then\n        ``class_names = ['dog', 'cat']``.\n\n    num_examples : int or None, optional\n        The number of examples in the dataset, i.e. ``len(labels)``. You only need to provide this if\n        you use this function with the joint, e.g. ``find_overlapping_classes(joint=joint)``, otherwise\n        this is automatically computed via ``sum(confident_joint)`` or ``len(labels)``.\n\n    joint : np.ndarray, optional\n        An array of shape ``(K, K)``, where K is the number of classes,\n        representing the estimated joint distribution of the noisy labels and\n        true labels. The sum of all entries in this matrix must be 1 (valid\n        probability distribution). Each entry in the matrix captures the co-occurence joint\n        probability of a true label and a noisy label, i.e. ``p(noisy_label=i, true_label=j)``.\n        **Important**. If you input the joint, you must also input `num_examples`.\n\n    confident_joint : np.ndarray, optional\n      An array of shape ``(K, K)`` representing the confident joint, the matrix used for identifying label issues, which\n      estimates a confident subset of the joint distribution of the noisy and true labels, ``P_{noisy label, true label}``.\n      Entry ``(j, k)`` in the matrix is the number of examples confidently counted into the pair of ``(noisy label=j, true label=k)`` classes.\n      The `confident_joint` can be computed using :py:func:`count.compute_confident_joint <cleanlab.count.compute_confident_joint>`.\n      If not provided, it is computed from the given (noisy) `labels` and `pred_probs`.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\" and a description of each below.\n        Each row corresponds to a pair of classes.\n\n        * *Class Index A*: the index of a class in 0, 1, ..., K-1.\n        * *Class Index B*: the index of a different class (from Class A) in 0, 1, ..., K-1.\n        * *Num Overlapping Examples*: estimated number of labels overlapping between the two classes.\n        * *Joint Probability*: the *Num Overlapping Examples* divided by the number of examples in the dataset.\n\n        By default, the DataFrame is ordered by \"Joint Probability\" descending.",
    "function_name": "find_overlapping_classes",
    "ground_truth": "cleanlab/dataset.py",
    "test": "tests/test_dataset.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}