{
    "result": "To estimate the joint distribution of label noise \\( P(\\text{label}=i, \\text{true\\_label}=j) \\), we need to consider both the predicted probabilities and the actual labels. The function `estimate_joint` will handle both multi-class and multi-label classification scenarios. If the `confident_joint` is not provided, the function will compute it based on the input data. For multi-label classification, a helper function `_estimate_joint_multilabel` will be used.\n\nHere's how you can implement the `estimate_joint` function:\n\n```python\nimport numpy as np\n\ndef estimate_joint(labels, pred_probs, confident_joint=None, multi_label=False):\n    \"\"\"\n    Estimate the joint distribution of label noise P(label=i, true_label=j).\n    \n    Parameters:\n    - labels: array-like, shape (n_samples,)\n        Class labels for each example in the dataset.\n    - pred_probs: array-like, shape (n_samples, n_classes)\n        Model-predicted class probabilities for each example in the dataset.\n    - confident_joint: array-like, optional\n        Estimated class label error statistics.\n    - multi_label: bool\n        Indicates whether the dataset is for multi-class or multi-label classification.\n    \n    Returns:\n    - confident_joint_distribution: array\n        An estimate of the true joint distribution of noisy and true labels.\n    \"\"\"\n    labels = np.array(labels)\n    pred_probs = np.array(pred_probs)\n    n_classes = pred_probs.shape[1]\n    \n    if multi_label:\n        return _estimate_joint_multilabel(labels, pred_probs, confident_joint)\n    \n    if confident_joint is None:\n        confident_joint = np.zeros((n_classes, n_classes))\n        for i, label in enumerate(labels):\n            predicted_label = np.argmax(pred_probs[i])\n            confident_joint[label, predicted_label] += 1\n    \n    # Normalize the confident_joint to get a distribution\n    confident_joint_distribution = confident_joint / np.sum(confident_joint)\n    \n    return confident_joint_distribution\n\ndef _estimate_joint_multilabel(labels, pred_probs, confident_joint=None):\n    \"\"\"\n    Estimate the joint distribution for multi-label classification.\n    \n    Parameters:\n    - labels: array-like, shape (n_samples, n_classes)\n        Binary matrix indicating the presence of each class label for each example.\n    - pred_probs: array-like, shape (n_samples, n_classes)\n        Model-predicted class probabilities for each example in the dataset.\n    - confident_joint: array-like, optional\n        Estimated class label error statistics.\n    \n    Returns:\n    - confident_joint_distribution: array, shape (n_classes, 2, 2)\n        An estimate of the true joint distribution of noisy and true labels.\n    \"\"\"\n    labels = np.array(labels)\n    pred_probs = np.array(pred_probs)\n    n_samples, n_classes = labels.shape\n    \n    if confident_joint is None:\n        confident_joint = np.zeros((n_classes, 2, 2))\n        for i in range(n_samples):\n            for j in range(n_classes):\n                true_label = labels[i, j]\n                predicted_label = pred_probs[i, j] >= 0.5\n                confident_joint[j, true_label, predicted_label] += 1\n    \n    # Normalize the confident_joint to get a distribution\n    confident_joint_distribution = confident_joint / np.sum(confident_joint)\n    \n    return confident_joint_distribution\n```\n\n### Explanation:\n\n1. **Input Parameters:**\n   - `labels`: The true labels for each example.\n   - `pred_probs`: The predicted probabilities for each class.\n   - `confident_joint`: An optional parameter that, if not provided, will be computed.\n   - `multi_label`: A boolean indicating if the task is multi-label.\n\n2. **Multi-Class vs. Multi-Label:**\n   - For multi-class, the joint distribution is a \\( K \\times K \\) matrix.\n   - For multi-label, the joint distribution is a \\( K \\times 2 \\times 2 \\) tensor.\n\n3. **Confident Joint Calculation:**\n   - If `confident_joint` is not provided, it is computed by counting occurrences of predicted and true labels.\n\n4. **Normalization:**\n   - The joint distribution is normalized to ensure it sums to 1.\n\n5. **Multi-Label Handling:**\n   - The `_estimate_joint_multilabel` function handles the multi-label case by considering each class independently and using a threshold (0.5) to determine predicted labels.\n\nThis function provides a flexible way to estimate the joint distribution of label noise for both multi-class and multi-label classification tasks.",
    "prompt": "Generate a Python function called estimate_joint that estimates the joint distribution of label noise P(label=i, true_label=j) based on the given inputs. The function takes in the following parameters:\n\n- labels: an array or list of class labels for each example in the dataset\n- pred_probs: an array of model-predicted class probabilities for each example in the dataset\n- confident_joint: an optional array of estimated class label error statistics\n- multi_label: a boolean indicating whether the dataset is for regular (multi-class) classification or multi-label classification\n\nThe function returns confident_joint_distribution, an array representing an estimate of the true joint distribution of noisy and true labels. The shape of the array depends on the value of multi_label - it will be (K, K) if multi_label is False, and (K, 2, 2) if multi_label is True. The function ensures that the sum of the joint distribution is 1 and satisfies certain conditions.\n\nThe function internally computes the confident_joint if it is not provided, and calibrates it based on the input labels and pred_probs. If multi_label is True, the function calls _estimate_joint_multilabel to handle multi-label classification.",
    "function_name": "estimate_joint",
    "ground_truth": "cleanlab/count.py",
    "test": "tests/test_filter_count.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}