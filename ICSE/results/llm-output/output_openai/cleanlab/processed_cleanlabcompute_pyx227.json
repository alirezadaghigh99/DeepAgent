{
    "result": "To compute `pyx := P(true_label=k|x)` from `pred_probs`, `noise_matrix`, and `inverse_noise_matrix`, we can use the following approach. The idea is to adjust the predicted probabilities (`pred_probs`) using the noise matrices to account for label noise. Here's a Python function that implements this:\n\n```python\nimport numpy as np\n\ndef compute_pyx(pred_probs, noise_matrix, inverse_noise_matrix):\n    \"\"\"\n    Compute P(true_label=k|x) from P(label=k|x), noise_matrix, and inverse_noise_matrix.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        P(label=k|x) is a (N x K) matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        pred_probs should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape (K, K)) of the form P(label=k_s|true_label=k_y) containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape (K, K)) of the form P(true_label=k_y|label=k_s) representing\n        the estimated fraction observed examples in each class k_s, that are\n        mislabeled examples from every other class k_y. If None, the\n        inverse_noise_matrix will be computed from pred_probs and labels.\n        Assumes columns of inverse_noise_matrix sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        P(true_label=k|x) is a (N, K) matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        pred_probs should have been computed using 3 (or higher) fold cross-validation.\n    \"\"\"\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )\n\n    # Ensure the noise matrices are square and have the same dimensions\n    K = pred_probs.shape[1]\n    if noise_matrix.shape != (K, K) or inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\"Noise matrices must be square and match the number of classes K.\")\n\n    # Compute the adjusted probabilities\n    # Use the inverse noise matrix to adjust the predicted probabilities\n    pyx = np.dot(pred_probs, inverse_noise_matrix)\n\n    # Normalize the probabilities to ensure they sum to 1 for each example\n    pyx /= pyx.sum(axis=1, keepdims=True)\n\n    return pyx\n```\n\n### Explanation:\n- **Input Validation**: The function first checks if `pred_probs` is a 2D array and if the noise matrices are square and match the number of classes.\n- **Adjustment**: The predicted probabilities are adjusted using the `inverse_noise_matrix`. This step corrects the predictions by accounting for the noise in the labels.\n- **Normalization**: After adjustment, the probabilities are normalized to ensure they sum to 1 for each example.\n\nThis function assumes that the noise matrices are estimated correctly, at least in terms of their diagonals, which are often easier to estimate accurately.",
    "prompt": "\"Write a python function compute_pyx Compute ``pyx := P(true_label=k|x)`` from ``pred_probs := P(label=k|x)``, `noise_matrix` and\n    `inverse_noise_matrix`.\n\n    This method is ROBUST - meaning it works well even when the\n    noise matrices are estimated poorly by only using the diagonals of the\n    matrices which tend to be easy to estimate correctly.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        ``P(label=k|x)`` is a ``(N x K)`` matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of `noise_matrix` sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``)  of the form ``P(true_label=k_y|label=k_s)`` representing\n        the estimated fraction observed examples in each class `k_s`, that are\n        mislabeled examples from every other class `k_y`. If None, the\n        inverse_noise_matrix will be computed from `pred_probs` and `labels`.\n        Assumes columns of `inverse_noise_matrix` sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        ``P(true_label=k|x)`` is a  ``(N, K)`` matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )",
    "function_name": "compute_pyx",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}