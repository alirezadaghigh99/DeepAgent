{
    "result": "To generate the `compute_ps_py_inv_noise_matrix` function, we need to calculate the probabilities `ps` and `py`, and the inverse of the noise matrix. Here's how you can implement this function in Python:\n\n```python\nimport numpy as np\n\ndef compute_ps_py_inv_noise_matrix(labels, noise_matrix):\n    \"\"\"\n    Compute ps := P(labels=k), py := P(true_labels=k), and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n        A discrete vector of noisy labels, i.e. some labels may be erroneous.\n        *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.\n\n    Returns\n    -------\n    ps : np.ndarray\n        The probability distribution of the noisy labels.\n\n    py : np.ndarray\n        The probability distribution of the true labels.\n\n    inv_noise_matrix : np.ndarray\n        The inverse of the noise matrix.\n    \"\"\"\n    # Number of classes\n    K = noise_matrix.shape[0]\n\n    # Compute ps: P(labels=k)\n    label_counts = np.bincount(labels, minlength=K)\n    ps = label_counts / len(labels)\n\n    # Compute py: P(true_labels=k)\n    # Assuming noise_matrix is invertible, we can compute py using the inverse noise matrix\n    inv_noise_matrix = np.linalg.inv(noise_matrix)\n    py = inv_noise_matrix @ ps\n\n    return ps, py, inv_noise_matrix\n\n# Example usage:\n# labels = np.array([0, 1, 1, 2, 2, 2, 0, 1, 0, 2])\n# noise_matrix = np.array([[0.9, 0.05, 0.05],\n#                          [0.1, 0.85, 0.05],\n#                          [0.1, 0.1, 0.8]])\n# ps, py, inv_noise_matrix = compute_ps_py_inv_noise_matrix(labels, noise_matrix)\n# print(\"ps:\", ps)\n# print(\"py:\", py)\n# print(\"Inverse Noise Matrix:\\n\", inv_noise_matrix)\n```\n\n### Explanation:\n\n1. **Compute `ps`:** This is the probability distribution of the noisy labels. We calculate it by counting the occurrences of each label in the `labels` array and normalizing by the total number of labels.\n\n2. **Compute `py`:** This is the probability distribution of the true labels. We assume that the noise matrix is invertible, which allows us to compute `py` by multiplying the inverse of the noise matrix with `ps`.\n\n3. **Inverse Noise Matrix:** We compute the inverse of the noise matrix using `np.linalg.inv()`. This step assumes that the noise matrix is invertible, which is a necessary condition for this computation.\n\nThis function will return the computed `ps`, `py`, and the inverse noise matrix.",
    "prompt": "Generate a Python function called compute_ps_py_inv_noise_matrix that Compute ``ps := P(labels=k), py := P(true_labels=k)``, and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n          A discrete vector of noisy labels, i.e. some labels may be erroneous.\n          *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.",
    "function_name": "compute_ps_py_inv_noise_matrix",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}