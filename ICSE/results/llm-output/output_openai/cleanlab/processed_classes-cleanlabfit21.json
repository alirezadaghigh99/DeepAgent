{
    "result": "To implement the `fit` function for the `CleanLearning` class, we need to follow the steps outlined in your request. Below is a detailed implementation of the `fit` function:\n\n```python\nfrom sklearn.base import BaseEstimator\nimport numpy as np\nimport pandas as pd\n\nclass CleanLearning(BaseEstimator):\n    def __init__(\n        self,\n        clf=None,\n        *,\n        seed=None,\n        cv_n_folds=5,\n        converge_latent_estimates=False,\n        pulearning=None,\n        find_label_issues_kwargs={},\n        label_quality_scores_kwargs={},\n        verbose=False,\n        low_memory=False,\n    ):\n        self.clf = clf\n        self.seed = seed\n        self.cv_n_folds = cv_n_folds\n        self.converge_latent_estimates = converge_latent_estimates\n        self.pulearning = pulearning\n        self.find_label_issues_kwargs = find_label_issues_kwargs\n        self.label_quality_scores_kwargs = label_quality_scores_kwargs\n        self.verbose = verbose\n        self.label_issues_df = None\n        self.label_issues_mask = None\n        self.sample_weight = None\n        self.confident_joint = None\n        self.py = None\n        self.ps = None\n        self.num_classes = None\n        self.noise_matrix = None\n        self.inverse_noise_matrix = None\n        self.clf_kwargs = None\n        self.clf_final_kwargs = None\n        self.low_memory = low_memory\n\n    def fit(self, X, labels=None, y=None, sample_weight=None, label_issues=None):\n        # Step 1: Validate input parameters\n        if (labels is None and y is None) or (labels is not None and y is not None):\n            raise ValueError(\"Either 'labels' or 'y' must be provided, but not both.\")\n        \n        labels = labels if labels is not None else y\n\n        # Step 2: Ensure X is two-dimensional if clf is default\n        if self.clf is None and len(X.shape) != 2:\n            raise ValueError(\"Input data X must be two-dimensional.\")\n\n        # Step 3: Combine keyword arguments for clf.fit\n        clf_kwargs = self.clf_kwargs or {}\n        clf_final_kwargs = self.clf_final_kwargs or {}\n        fit_kwargs = {**clf_kwargs, **clf_final_kwargs}\n\n        # Step 4: Check if sample weights are provided and supported\n        if sample_weight is not None:\n            if not hasattr(self.clf, 'fit'):\n                raise ValueError(\"The classifier does not support sample weights.\")\n            fit_kwargs['sample_weight'] = sample_weight\n\n        # Step 5: Detect label issues if not provided\n        if label_issues is None:\n            label_issues = self.find_label_issues(X, labels, **self.find_label_issues_kwargs)\n\n        # Step 6: Process label_issues\n        if isinstance(label_issues, pd.DataFrame):\n            self.label_issues_df = label_issues\n        else:\n            raise ValueError(\"label_issues must be a pandas DataFrame.\")\n\n        # Step 7: Prune data to exclude examples with label issues\n        self.label_issues_mask = ~self.label_issues_df['has_issue']\n        x_cleaned = X[self.label_issues_mask]\n        labels_cleaned = labels[self.label_issues_mask]\n\n        # Step 8: Assign sample weights if supported\n        if sample_weight is not None:\n            sample_weight_cleaned = sample_weight[self.label_issues_mask]\n            fit_kwargs['sample_weight'] = sample_weight_cleaned\n\n        # Step 9: Fit the classifier on the cleaned data\n        self.clf.fit(x_cleaned, labels_cleaned, **fit_kwargs)\n\n        # Step 10: Store the detected label issues\n        self.label_issues_df = label_issues\n\n    def find_label_issues(self, X, labels, **kwargs):\n        # Placeholder for the actual implementation of finding label issues\n        # This should return a DataFrame with a column 'has_issue' indicating label issues\n        # For demonstration, let's assume all labels are correct\n        return pd.DataFrame({'has_issue': np.zeros(len(labels), dtype=bool)})\n\n# Example usage:\n# clf = SomeClassifier()\n# clean_learning = CleanLearning(clf=clf)\n# clean_learning.fit(X_train, labels=y_train)\n```\n\n### Explanation:\n- **Input Validation**: The function checks that either `labels` or `y` is provided, but not both.\n- **Dimensionality Check**: If the classifier is the default one (i.e., `None`), it ensures that `X` is two-dimensional.\n- **Keyword Arguments**: Combines `clf_kwargs` and `clf_final_kwargs` for the classifier's `fit` method.\n- **Sample Weights**: Checks if sample weights are provided and if the classifier supports them.\n- **Label Issues Detection**: If `label_issues` is not provided, it calls `find_label_issues` to detect them.\n- **Data Pruning**: Excludes examples with label issues to create cleaned datasets.\n- **Model Fitting**: Fits the classifier on the cleaned data.\n- **Storing Results**: Stores the detected label issues in `label_issues_df`.\n\nThis implementation assumes that the `find_label_issues` method is a placeholder and should be replaced with the actual logic for detecting label issues.",
    "prompt": "Generate a Python function `fit` for the class `CleanLearning` that trains a model `clf` with error-prone, noisy labels as if it had been trained on a dataset with perfect labels. The function should handle the following steps: \n\n1. Validate input parameters, ensuring either `labels` or `y` is provided, but not both.\n2. If the classifier `clf` is the default one, ensure the input data `X` is two-dimensional.\n3. Combine keyword arguments for `clf.fit` using `clf_kwargs` and `clf_final_kwargs`.\n4. Check if sample weights are provided and ensure they are supported by the classifier.\n5. If `label_issues` is not provided, call the method `find_label_issues` to detect label issues using cross-validation, predicted probabilities, and optionally, noise matrices.\n6. Process `label_issues` to ensure it is correctly formatted and contains label quality scores if predicted probabilities are available.\n7. Prune the data to exclude examples with label issues and prepare cleaned data `x_cleaned` and `labels_cleaned`.\n8. Assign sample weights if the classifier supports them and include them in the final training step if necessary.\n9. Fit the classifier `clf` on the cleaned data `x_cleaned` with the corresponding labels `labels_cleaned` using the combined keyword arguments.\n10. Store the detected label issues in the class attribute `label_issues_df`.\n\n```python\nclass CleanLearning(BaseEstimator):\n    def __init__(\n        self,\n        clf=None,\n        *,\n        seed=None,\n        cv_n_folds=5,\n        converge_latent_estimates=False,\n        pulearning=None,\n        find_label_issues_kwargs={},\n        label_quality_scores_kwargs={},\n        verbose=False,\n        low_memory=False,\n    ):\n        self.clf = clf\n        self.seed = seed\n        self.cv_n_folds = cv_n_folds\n        self.converge_latent_estimates = converge_latent_estimates\n        self.pulearning = pulearning\n        self.find_label_issues_kwargs = find_label_issues_kwargs\n        self.label_quality_scores_kwargs = label_quality_scores_kwargs\n        self.verbose = verbose\n        self.label_issues_df = None\n        self.label_issues_mask = None\n        self.sample_weight = None\n        self.confident_joint = None\n        self.py = None\n        self.ps = None\n        self.num_classes = None\n        self.noise_matrix = None\n        self.inverse_noise_matrix = None\n        self.clf_kwargs = None\n        self.clf_final_kwargs = None\n        self.low_memory = low_memory\n```",
    "function_name": "fit",
    "ground_truth": "cleanlab/classification.py",
    "test": "tests/test_classification.py",
    "class": "CleanLearning",
    "stage": "",
    "task": "Classification",
    "data": "Training"
}