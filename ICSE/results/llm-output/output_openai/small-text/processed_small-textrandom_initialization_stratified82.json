{
    "result": "To implement the `random_initialization_stratified` function, we need to handle two scenarios: single-label stratification and multi-label stratification. For single-label stratification, we'll use a helper function `stratified_sampling`. For multi-label stratification, we'll use another helper function `multilabel_stratified_subsets_sampling`, but only if the `multilabel_strategy` is 'labelsets'. If the strategy is anything else, we'll raise a `ValueError`.\n\nHere's how you can implement this:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom sklearn.model_selection import train_test_split\n\ndef stratified_sampling(y, n_samples):\n    \"\"\"Perform stratified sampling for single-label data.\"\"\"\n    unique_classes, y_indices = np.unique(y, return_inverse=True)\n    n_classes = len(unique_classes)\n    \n    # Calculate the number of samples per class\n    class_counts = np.bincount(y_indices)\n    class_ratios = class_counts / len(y)\n    samples_per_class = np.round(class_ratios * n_samples).astype(int)\n    \n    # Ensure the total number of samples is correct\n    while samples_per_class.sum() != n_samples:\n        diff = n_samples - samples_per_class.sum()\n        for i in range(abs(diff)):\n            samples_per_class[i % n_classes] += np.sign(diff)\n    \n    indices = []\n    for class_index, n_class_samples in enumerate(samples_per_class):\n        class_indices = np.where(y_indices == class_index)[0]\n        selected_indices = np.random.choice(class_indices, n_class_samples, replace=False)\n        indices.extend(selected_indices)\n    \n    return np.array(indices)\n\ndef multilabel_stratified_subsets_sampling(y, n_samples):\n    \"\"\"Perform stratified sampling for multi-label data using 'labelsets' strategy.\"\"\"\n    # Convert csr_matrix to dense array for processing\n    y_dense = y.toarray()\n    \n    # Create unique labelsets\n    unique_labelsets, labelset_indices = np.unique(y_dense, axis=0, return_inverse=True)\n    n_labelsets = len(unique_labelsets)\n    \n    # Calculate the number of samples per labelset\n    labelset_counts = np.bincount(labelset_indices)\n    labelset_ratios = labelset_counts / len(y_dense)\n    samples_per_labelset = np.round(labelset_ratios * n_samples).astype(int)\n    \n    # Ensure the total number of samples is correct\n    while samples_per_labelset.sum() != n_samples:\n        diff = n_samples - samples_per_labelset.sum()\n        for i in range(abs(diff)):\n            samples_per_labelset[i % n_labelsets] += np.sign(diff)\n    \n    indices = []\n    for labelset_index, n_labelset_samples in enumerate(samples_per_labelset):\n        labelset_indices = np.where(labelset_indices == labelset_index)[0]\n        selected_indices = np.random.choice(labelset_indices, n_labelset_samples, replace=False)\n        indices.extend(selected_indices)\n    \n    return np.array(indices)\n\ndef random_initialization_stratified(y, n_samples=10, multilabel_strategy='labelsets'):\n    if isinstance(y, csr_matrix):\n        if multilabel_strategy == 'labelsets':\n            return multilabel_stratified_subsets_sampling(y, n_samples)\n        else:\n            raise ValueError(f'Invalid multilabel_strategy: {multilabel_strategy}')\n    else:\n        return stratified_sampling(y, n_samples)\n\n# Example usage:\n# y = np.array([0, 1, 0, 1, 2, 2, 1, 0, 2, 1])\n# indices = random_initialization_stratified(y, n_samples=5)\n# print(indices)\n```\n\n### Explanation:\n- **stratified_sampling**: This function handles single-label stratification. It calculates the number of samples needed per class based on the class distribution and randomly selects indices for each class.\n- **multilabel_stratified_subsets_sampling**: This function handles multi-label stratification using the 'labelsets' strategy. It treats each unique combination of labels as a separate class and performs stratified sampling based on these labelsets.\n- **random_initialization_stratified**: This is the main function that decides which stratification method to use based on the type of `y` and the `multilabel_strategy`.\n\nThis implementation ensures that the samples are drawn in a stratified manner, respecting the distribution of classes or labelsets in the input data.",
    "prompt": "Generate a Python function called random_initialization_stratified that randomly draws a subset stratified by class labels. The function takes in parameters y, which is an np.ndarray[int] or csr_matrix representing the labels to be used for stratification, n_samples which is an integer representing the number of samples to draw, and multilabel_strategy which is a string representing the multi-label strategy to be used in case of a multi-label labeling (default is 'labelsets'). \n\nThe function returns indices, which is an np.ndarray[int] representing the indices relative to y. If y is of type csr_matrix, the function uses the multilabel_strategy 'labelsets' to perform multilabel stratified subsets sampling using the function multilabel_stratified_subsets_sampling. If the multilabel_strategy is not 'labelsets', a ValueError is raised : ValueError(f'Invalid multilabel_strategy: {multilabel_strategy}'). If y is not a csr_matrix, the function performs stratified sampling using the function stratified_sampling. for the input the diefault is n_samples=10, multilabel_strategy='labelsets'",
    "function_name": "random_initialization_stratified",
    "ground_truth": "small_text/initialization/strategies.py",
    "test": "tests/unit/small_text/initialization/test_strategies.py::RandomInitializationStratifiedTest",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Text"
}