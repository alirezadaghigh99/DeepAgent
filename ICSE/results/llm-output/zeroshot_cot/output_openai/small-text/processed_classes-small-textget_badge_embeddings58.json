{
    "result": "To implement the `get_badge_embeddings` function for the `BADGE` class, we need to consider both multi-class and binary classification scenarios. The function will scale the embeddings based on the predicted class probabilities. For multi-class problems, each embedding will be expanded and scaled for each class, while for binary problems, the original embeddings will be returned.\n\nHere's a step-by-step breakdown of how to implement this:\n\n1. **Initialize the BADGE class**: The class should store the number of classes as an instance variable.\n\n2. **Define the `get_badge_embeddings` function**: This function will take `embeddings` and `proba` as inputs.\n\n3. **Handle multi-class classification**:\n   - For each sample, compute the gradient embeddings by scaling the original embeddings with the class probabilities.\n   - For the most likely class, scale the embedding by `1 - p` (where `p` is the probability of the most likely class).\n   - For other classes, scale the embedding by `-p`.\n\n4. **Handle binary classification**:\n   - Simply return the original embeddings, as the binary case does not require expansion.\n\n5. **Return the computed badge embeddings**.\n\nHere's the complete implementation:\n\n```python\nimport numpy as np\n\nclass BADGE:\n    def __init__(self, num_classes):\n        self.num_classes = num_classes\n\n    def get_badge_embeddings(self, embeddings, proba):\n        num_samples, embedding_dim = embeddings.shape\n        \n        if self.num_classes > 2:\n            # Multi-class case\n            badge_embeddings = np.zeros((num_samples, embedding_dim * self.num_classes))\n            \n            for i in range(num_samples):\n                for c in range(self.num_classes):\n                    if c == np.argmax(proba[i]):\n                        # Scale by (1 - p) for the most likely class\n                        scale = 1 - proba[i, c]\n                    else:\n                        # Scale by -p for other classes\n                        scale = -proba[i, c]\n                    \n                    # Place the scaled embedding in the appropriate section of the badge_embeddings\n                    badge_embeddings[i, c * embedding_dim:(c + 1) * embedding_dim] = scale * embeddings[i]\n        \n        else:\n            # Binary case\n            badge_embeddings = embeddings\n        \n        return badge_embeddings\n```\n\n### Explanation:\n- **Multi-class**: For each sample, the embedding is expanded to have a separate section for each class. The scaling is done such that the most likely class is scaled by `1 - p`, and all other classes are scaled by `-p`.\n- **Binary**: The original embeddings are returned without modification, as the binary case does not require the expansion of embeddings.\n\nThis implementation ensures that the embeddings are appropriately scaled for use in the BADGE strategy for batch active learning.",
    "prompt": "Write a Python function `get_badge_embeddings` for the `BADGE` class. This function should calculate embeddings scaled by class probabilities, enabling the use of the BADGE strategy for batch active learning. The function takes `embeddings` and `proba` (predicted class probabilities) as input and returns the `badge_embeddings`. For multi-class problems, the embeddings are expanded and scaled for each class; for binary problems, the original embeddings are returned.\n\n```python\nclass BADGE(EmbeddingBasedQueryStrategy):\n    def __init__(self, num_classes):\n        self.num_classes = num_classes\n\n    def get_badge_embeddings(self, embeddings, proba):\n``` \n\nThe `get_badge_embeddings` function should generate an embedding matrix where each original embedding is scaled by the negative class probabilities, except for the most likely class, which is scaled differently. For multi-class classification, this scaling is performed for each class, creating a larger embedding matrix. The output is a 2D numpy array where each row corresponds to an embedding.",
    "function_name": "get_badge_embeddings",
    "ground_truth": "small_text/integrations/pytorch/query_strategies/strategies.py",
    "test": "tests/integration/small_text/integrations/pytorch/query_strategies/test_query_strategies.py::QueryStrategiesTest",
    "class": "BADGE",
    "stage": "Text",
    "task": "Classification",
    "data": "Evaluation/metrics"
}