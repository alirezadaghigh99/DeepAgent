{
    "result": "To create the `so3_exp_map` function, we will follow these steps:\n\n1. **Import Necessary Libraries**: We need to import the `torch` library to handle tensor operations.\n\n2. **Define the Function**: Create the function `so3_exp_map` that takes `log_rot` and an optional `eps` parameter.\n\n3. **Validate Input Shape**: Check if the input `log_rot` has the correct shape `(minibatch, 3)`. If not, raise a `ValueError`.\n\n4. **Compute the Norm**: Calculate the norm of each vector in the batch. This norm represents the angle of rotation.\n\n5. **Handle Singularity**: Clamp the norm to avoid division by zero or very small values, using the `eps` parameter.\n\n6. **Compute the Rotation Matrices**: Use Rodrigues' rotation formula to compute the rotation matrices from the logarithmic representation.\n\n7. **Return the Result**: Return the batch of rotation matrices.\n\nHere's the implementation:\n\n```python\nimport torch\n\ndef so3_exp_map(log_rot: torch.Tensor, eps: float = 0.0001) -> torch.Tensor:\n    # Check if the input has the correct shape\n    if log_rot.ndim != 2 or log_rot.shape[1] != 3:\n        raise ValueError(\"Input log_rot must have shape (minibatch, 3)\")\n\n    # Compute the norm of each vector in the batch\n    theta = torch.norm(log_rot, dim=1, keepdim=True)  # Shape: (minibatch, 1)\n\n    # Clamp the norm to handle the singularity\n    theta_clamped = torch.clamp(theta, min=eps)\n\n    # Compute the unit rotation axis\n    k = log_rot / theta_clamped  # Shape: (minibatch, 3)\n\n    # Compute the sine and cosine of the angles\n    cos_theta = torch.cos(theta)\n    sin_theta = torch.sin(theta)\n\n    # Compute the outer product of k with itself\n    k_outer = k.unsqueeze(2) @ k.unsqueeze(1)  # Shape: (minibatch, 3, 3)\n\n    # Compute the skew-symmetric cross-product matrix of k\n    k_cross = torch.zeros((log_rot.shape[0], 3, 3), device=log_rot.device)\n    k_cross[:, 0, 1] = -k[:, 2]\n    k_cross[:, 0, 2] = k[:, 1]\n    k_cross[:, 1, 0] = k[:, 2]\n    k_cross[:, 1, 2] = -k[:, 0]\n    k_cross[:, 2, 0] = -k[:, 1]\n    k_cross[:, 2, 1] = k[:, 0]\n\n    # Compute the rotation matrices using Rodrigues' formula\n    identity = torch.eye(3, device=log_rot.device).unsqueeze(0)  # Shape: (1, 3, 3)\n    R = cos_theta.unsqueeze(2) * identity + (1 - cos_theta.unsqueeze(2)) * k_outer + sin_theta.unsqueeze(2) * k_cross\n\n    return R\n\n# Example usage:\n# log_rot = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\n# rotation_matrices = so3_exp_map(log_rot)\n# print(rotation_matrices)\n```\n\nThis function uses Rodrigues' rotation formula to convert a batch of logarithmic representations of rotation matrices into actual rotation matrices, handling the singularity at zero by clamping the norm.",
    "prompt": "Create a Python function called so3_exp_map that takes in a torch.Tensor log_rot representing a batch of logarithmic representations of rotation matrices and an optional float eps set to 0.0001. The function converts the logarithmic representations to a batch of 3x3 rotation matrices using the Rodrigues formula. The input log_rot should be a batch of vectors of shape (minibatch, 3) and the output should be a batch of rotation matrices of shape (minibatch, 3, 3). The function handles a singularity around log(R) = 0 by clamping it with the eps argument. If the input log_rot is of incorrect shape, a ValueError is raised. The function returns the batch of rotation matrices after conversion. Reference to Rodrigues' rotation formula is provided for further information.",
    "function_name": "so3_exp_map",
    "ground_truth": "pytorch3d/transforms/so3.py",
    "test": "tests/test_so3.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}