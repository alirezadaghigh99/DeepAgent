{
    "result": "To create the `vert_align` function, we need to follow these steps:\n\n1. **Input Validation**: Ensure that the inputs `feats` and `verts` have the expected shapes and attributes. Raise appropriate errors if they don't.\n\n2. **Feature Sampling**: Use the vertex positions to sample features from the feature map. This involves handling different interpolation modes and padding modes.\n\n3. **Return Format**: Depending on the `return_packed` flag, return the features in the desired format.\n\nLet's break down the implementation step by step:\n\n### Step 1: Input Validation\n\nWe need to check the shapes and attributes of `feats` and `verts`.\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef vert_align(feats, verts, return_packed=False, interp_mode='bilinear', padding_mode='zeros', align_corners=True):\n    # Check if feats is a list or a single tensor\n    if isinstance(feats, list):\n        for f in feats:\n            if not isinstance(f, torch.Tensor) or f.dim() != 4:\n                raise ValueError(\"Each element in feats must be a tensor of shape (N, C, H, W).\")\n    elif isinstance(feats, torch.Tensor):\n        if feats.dim() != 4:\n            raise ValueError(\"feats must be a tensor of shape (N, C, H, W).\")\n    else:\n        raise ValueError(\"feats must be a tensor or a list of tensors.\")\n\n    # Check verts shape or attributes\n    if isinstance(verts, torch.Tensor):\n        if verts.dim() != 3 or verts.size(2) != 3:\n            raise ValueError(\"verts must be a tensor of shape (N, V, 3).\")\n    elif hasattr(verts, 'verts_padded') or hasattr(verts, 'points_padded'):\n        verts = verts.verts_padded if hasattr(verts, 'verts_padded') else verts.points_padded\n        if verts.dim() != 3 or verts.size(2) != 3:\n            raise ValueError(\"verts_padded or points_padded must be of shape (N, V, 3).\")\n    else:\n        raise ValueError(\"verts must be a tensor or an object with verts_padded or points_padded attributes.\")\n\n    # Check batch dimension consistency\n    if isinstance(feats, list):\n        batch_size = feats[0].size(0)\n        for f in feats:\n            if f.size(0) != batch_size:\n                raise ValueError(\"All tensors in feats must have the same batch size.\")\n    else:\n        batch_size = feats.size(0)\n\n    if verts.size(0) != batch_size:\n        raise ValueError(\"Batch size of verts must match batch size of feats.\")\n```\n\n### Step 2: Feature Sampling\n\nWe will use grid sampling to extract features based on vertex positions.\n\n```python\n    # Prepare the grid for sampling\n    grid = verts[..., :2].unsqueeze(2)  # (N, V, 1, 2)\n\n    # Sample features from each feature map\n    sampled_feats = []\n    if isinstance(feats, list):\n        for f in feats:\n            N, C, H, W = f.shape\n            sampled = F.grid_sample(f, grid, mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners)\n            sampled = sampled.squeeze(3).permute(0, 2, 1)  # (N, V, C)\n            sampled_feats.append(sampled)\n    else:\n        N, C, H, W = feats.shape\n        sampled = F.grid_sample(feats, grid, mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners)\n        sampled = sampled.squeeze(3).permute(0, 2, 1)  # (N, V, C)\n        sampled_feats.append(sampled)\n\n    # Concatenate features if feats is a list\n    feats_sampled = torch.cat(sampled_feats, dim=2)  # (N, V, sum(C_n))\n```\n\n### Step 3: Return Format\n\nHandle the `return_packed` flag to return the features in the desired format.\n\n```python\n    # Return packed features if requested\n    if return_packed:\n        feats_sampled = feats_sampled.view(-1, feats_sampled.size(2))  # (sum(V), C)\n\n    return feats_sampled\n```\n\n### Complete Function\n\nHere is the complete `vert_align` function:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef vert_align(feats, verts, return_packed=False, interp_mode='bilinear', padding_mode='zeros', align_corners=True):\n    # Check if feats is a list or a single tensor\n    if isinstance(feats, list):\n        for f in feats:\n            if not isinstance(f, torch.Tensor) or f.dim() != 4:\n                raise ValueError(\"Each element in feats must be a tensor of shape (N, C, H, W).\")\n    elif isinstance(feats, torch.Tensor):\n        if feats.dim() != 4:\n            raise ValueError(\"feats must be a tensor of shape (N, C, H, W).\")\n    else:\n        raise ValueError(\"feats must be a tensor or a list of tensors.\")\n\n    # Check verts shape or attributes\n    if isinstance(verts, torch.Tensor):\n        if verts.dim() != 3 or verts.size(2) != 3:\n            raise ValueError(\"verts must be a tensor of shape (N, V, 3).\")\n    elif hasattr(verts, 'verts_padded') or hasattr(verts, 'points_padded'):\n        verts = verts.verts_padded if hasattr(verts, 'verts_padded') else verts.points_padded\n        if verts.dim() != 3 or verts.size(2) != 3:\n            raise ValueError(\"verts_padded or points_padded must be of shape (N, V, 3).\")\n    else:\n        raise ValueError(\"verts must be a tensor or an object with verts_padded or points_padded attributes.\")\n\n    # Check batch dimension consistency\n    if isinstance(feats, list):\n        batch_size = feats[0].size(0)\n        for f in feats:\n            if f.size(0) != batch_size:\n                raise ValueError(\"All tensors in feats must have the same batch size.\")\n    else:\n        batch_size = feats.size(0)\n\n    if verts.size(0) != batch_size:\n        raise ValueError(\"Batch size of verts must match batch size of feats.\")\n\n    # Prepare the grid for sampling\n    grid = verts[..., :2].unsqueeze(2)  # (N, V, 1, 2)\n\n    # Sample features from each feature map\n    sampled_feats = []\n    if isinstance(feats, list):\n        for f in feats:\n            N, C, H, W = f.shape\n            sampled = F.grid_sample(f, grid, mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners)\n            sampled = sampled.squeeze(3).permute(0, 2, 1)  # (N, V, C)\n            sampled_feats.append(sampled)\n    else:\n        N, C, H, W = feats.shape\n        sampled = F.grid_sample(feats, grid, mode=interp_mode, padding_mode=padding_mode, align_corners=align_corners)\n        sampled = sampled.squeeze(3).permute(0, 2, 1)  # (N, V, C)\n        sampled_feats.append(sampled)\n\n    # Concatenate features if feats is a list\n    feats_sampled = torch.cat(sampled_feats, dim=2)  # (N, V, sum(C_n))\n\n    # Return packed features if requested\n    if return_packed:\n        feats_sampled = feats_sampled.view(-1, feats_sampled.size(2))  # (sum(V), C)\n\n    return feats_sampled\n```\n\nThis function should now correctly perform vertex alignment based on the given parameters and handle various input configurations.",
    "prompt": "Create a Python function vert_align that performs \"vertex alignment\" or \"perceptual feature pooling,\" which samples vertex features from a feature map based on vertex positions. The function takes the following parameters:\n\nfeats: A tensor of shape (N, C, H, W) representing image features from which to sample, or a list of such tensors, each with potentially different C, H, or W dimensions.\nverts: A tensor of shape (N, V, 3) representing the (x, y, z) vertex positions, or an object with verts_padded or points_padded attributes. The (x, y) coordinates should be normalized such that (-1, -1) corresponds to the top-left and (1, 1) to the bottom-right of the feature map.\nreturn_packed: A boolean flag indicating whether to return packed features. Defaults to False.\ninterp_mode: A string specifying the interpolation mode ('bilinear' or 'nearest'). Defaults to 'bilinear'.\npadding_mode: A string specifying how to handle vertices outside the [-1, 1] range ('zeros', 'reflection', or 'border'). Defaults to 'zeros'.\nalign_corners: A boolean indicating whether to align corners geometrically. If True, extrema refer to the center points of corner pixels; if False, they refer to the corner points of the input's corner pixels. Defaults to True.\nReturns:\nfeats_sampled: A tensor of shape (N, V, C) giving sampled features for each vertex. If feats is a list, the function returns concatenated features in shape (N, V, sum(C_n)) where C_n = feats[n].shape[1]. If return_packed = True, the features are transformed to a packed representation of shape (sum(V), C).\nError Handling:\nRaise a ValueError if verts does not have the expected shape or attributes.\nRaise a ValueError if feats does not have the expected shape (N, C, H, W) or if the batch dimensions of feats and verts do not match.",
    "function_name": "vert_align",
    "ground_truth": "pytorch3d/ops/vert_align.py",
    "test": "tests/test_vert_align.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}