{
    "result": "To create the `draw_rectangle` function, we need to handle several tasks, including validating inputs, iterating over the batch of images, and drawing rectangles on each image. We'll use PyTorch for tensor operations and assume that the images are represented as tensors. Let's break down the implementation step by step.\n\n### Step 1: Validate Inputs\n\nFirst, we need to ensure that the input tensors have the correct shapes and that the batch sizes match.\n\n```python\nimport torch\n\ndef draw_rectangle(image, rectangle, color=None, fill=False):\n    # Validate the input shapes\n    B, C, H, W = image.shape\n    B_rect, N, points = rectangle.shape\n    \n    # Check that the batch sizes match\n    assert B == B_rect, \"Batch size of image and rectangle tensors must match.\"\n    \n    # Check that each rectangle is defined by 4 points\n    assert points == 4, \"Each rectangle must be defined by 4 coordinates (x1, y1, x2, y2).\"\n    \n    # Default color handling\n    if color is None:\n        color = torch.tensor([255] * C)  # Default to white for 3-channel images\n    return image\n```\n\n### Step 2: Handle Color Broadcasting\n\nWe need to ensure that the color tensor is correctly broadcasted to match the number of channels in the image.\n\n```python\n    # Handle color broadcasting\n    if color.dim() == 1:\n        color = color.view(1, 1, -1)  # Shape (1, 1, C)\n    elif color.dim() == 2:\n        color = color.view(B, N, -1)  # Shape (B, N, C)\n    elif color.dim() == 3:\n        pass  # Already in shape (B, N, C)\n    else:\n        raise ValueError(\"Color tensor has an invalid shape.\")\n```\n\n### Step 3: Draw Rectangles\n\nNow, we iterate over each image in the batch and draw the rectangles.\n\n```python\n    # Iterate over each image in the batch\n    for b in range(B):\n        for n in range(N):\n            x1, y1, x2, y2 = rectangle[b, n]\n            rect_color = color[min(b, color.size(0) - 1), min(n, color.size(1) - 1)]\n            \n            # Draw the rectangle\n            if fill:\n                image[b, :, y1:y2, x1:x2] = rect_color.view(-1, 1, 1)\n            else:\n                # Draw borders\n                image[b, :, y1, x1:x2] = rect_color.view(-1, 1)\n                image[b, :, y2-1, x1:x2] = rect_color.view(-1, 1)\n                image[b, :, y1:y2, x1] = rect_color.view(-1, 1)\n                image[b, :, y1:y2, x2-1] = rect_color.view(-1, 1)\n    \n    return image\n```\n\n### Final Function\n\nCombining all the steps, the complete function is as follows:\n\n```python\nimport torch\n\ndef draw_rectangle(image, rectangle, color=None, fill=False):\n    # Validate the input shapes\n    B, C, H, W = image.shape\n    B_rect, N, points = rectangle.shape\n    \n    # Check that the batch sizes match\n    assert B == B_rect, \"Batch size of image and rectangle tensors must match.\"\n    \n    # Check that each rectangle is defined by 4 points\n    assert points == 4, \"Each rectangle must be defined by 4 coordinates (x1, y1, x2, y2).\"\n    \n    # Default color handling\n    if color is None:\n        color = torch.tensor([255] * C)  # Default to white for 3-channel images\n    \n    # Handle color broadcasting\n    if color.dim() == 1:\n        color = color.view(1, 1, -1)  # Shape (1, 1, C)\n    elif color.dim() == 2:\n        color = color.view(B, N, -1)  # Shape (B, N, C)\n    elif color.dim() == 3:\n        pass  # Already in shape (B, N, C)\n    else:\n        raise ValueError(\"Color tensor has an invalid shape.\")\n    \n    # Iterate over each image in the batch\n    for b in range(B):\n        for n in range(N):\n            x1, y1, x2, y2 = rectangle[b, n]\n            rect_color = color[min(b, color.size(0) - 1), min(n, color.size(1) - 1)]\n            \n            # Draw the rectangle\n            if fill:\n                image[b, :, y1:y2, x1:x2] = rect_color.view(-1, 1, 1)\n            else:\n                # Draw borders\n                image[b, :, y1, x1:x2] = rect_color.view(-1, 1)\n                image[b, :, y2-1, x1:x2] = rect_color.view(-1, 1)\n                image[b, :, y1:y2, x1] = rect_color.view(-1, 1)\n                image[b, :, y1:y2, x2-1] = rect_color.view(-1, 1)\n    \n    return image\n```\n\nThis function should now correctly draw rectangles on a batch of image tensors, handling various color specifications and the option to fill the rectangles.",
    "prompt": "Create a Python function draw_rectangle that draws one or more rectangles on a batch of image tensors. The function accepts the following parameters:\n\nimage: A tensor of shape (B, C, H, W), where B is the batch size, C is the number of channels, H is the height, and W is the width of the images.\nrectangle: A tensor of shape (B, N, 4), where N is the number of rectangles per image, and each rectangle is defined by four coordinates (x1, y1, x2, y2) corresponding to the top-left and bottom-right corners.\ncolor: An optional tensor specifying the color of the rectangles. It can be of various shapes: (1,), (3,), (B, N, 1), or (B, N, 3). If the image has 3 channels and the color tensor has 1 channel, the color will be broadcasted.\nfill: An optional boolean flag indicating whether to fill the rectangles with color (True) or just draw the borders (False). Defaults to False.\nThe function modifies the input image tensor in place, drawing the specified rectangles according to the provided parameters. It also returns the modified image tensor for convenience.\n\nError Handling:\nRaise an AssertionError if the batch size of the image tensor does not match the batch size of the rectangle tensor.\nRaise an AssertionError if the number of points in the rectangle tensor is not 4.",
    "function_name": "draw_rectangle",
    "ground_truth": "kornia/utils/draw.py",
    "test": "tests/utils/test_draw.py::TestDrawRectangle",
    "class": "",
    "stage": "Inference",
    "task": "Detection",
    "data": "Image"
}