{
    "result": "To create a function that converts a 3x3 rotation matrix to a quaternion, we need to follow these steps:\n\n1. **Validate Input**: Ensure the input is a valid 3x3 rotation matrix.\n2. **Compute the Quaternion**: Use the mathematical relationship between rotation matrices and quaternions to compute the quaternion.\n3. **Handle Edge Cases**: Use a small epsilon value to avoid division by zero.\n4. **Return the Quaternion**: Ensure the output is in the correct format and shape.\n\nLet's start by implementing the function step by step.\n\n### Step 1: Validate Input\n\nFirst, we need to ensure that the input is a valid 3x3 rotation matrix. This involves checking the shape and type of the input.\n\n```python\nimport numpy as np\n\ndef validate_rotation_matrix(matrix):\n    if not isinstance(matrix, np.ndarray):\n        raise TypeError(\"Input must be a numpy array.\")\n    if matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input must be a 3x3 matrix.\")\n    if not np.allclose(np.linalg.det(matrix), 1.0, atol=1e-6):\n        raise ValueError(\"Input matrix must be a valid rotation matrix with determinant 1.\")\n\n# Example usage of validation\ntry:\n    validate_rotation_matrix(np.eye(3))\n    print(\"Validation passed.\")\nexcept Exception as e:\n    print(f\"Validation failed: {e}\")\n```\n\n### Step 2: Compute the Quaternion\n\nNow, let's implement the conversion from a rotation matrix to a quaternion.\n\n```python\ndef rotation_matrix_to_quaternion(matrix, eps=1e-6):\n    validate_rotation_matrix(matrix)\n    \n    # Initialize the quaternion\n    q = np.empty((matrix.shape[0], 4))\n    \n    # Compute the trace of the matrix\n    trace = np.trace(matrix, axis1=-2, axis2=-1)\n    \n    # Compute the quaternion based on the trace\n    for i in range(matrix.shape[0]):\n        if trace[i] > 0:\n            s = 2.0 * np.sqrt(trace[i] + 1.0)\n            q[i, 0] = 0.25 * s\n            q[i, 1] = (matrix[i, 2, 1] - matrix[i, 1, 2]) / s\n            q[i, 2] = (matrix[i, 0, 2] - matrix[i, 2, 0]) / s\n            q[i, 3] = (matrix[i, 1, 0] - matrix[i, 0, 1]) / s\n        else:\n            if matrix[i, 0, 0] > matrix[i, 1, 1] and matrix[i, 0, 0] > matrix[i, 2, 2]:\n                s = 2.0 * np.sqrt(1.0 + matrix[i, 0, 0] - matrix[i, 1, 1] - matrix[i, 2, 2])\n                q[i, 0] = (matrix[i, 2, 1] - matrix[i, 1, 2]) / s\n                q[i, 1] = 0.25 * s\n                q[i, 2] = (matrix[i, 0, 1] + matrix[i, 1, 0]) / s\n                q[i, 3] = (matrix[i, 0, 2] + matrix[i, 2, 0]) / s\n            elif matrix[i, 1, 1] > matrix[i, 2, 2]:\n                s = 2.0 * np.sqrt(1.0 + matrix[i, 1, 1] - matrix[i, 0, 0] - matrix[i, 2, 2])\n                q[i, 0] = (matrix[i, 0, 2] - matrix[i, 2, 0]) / s\n                q[i, 1] = (matrix[i, 0, 1] + matrix[i, 1, 0]) / s\n                q[i, 2] = 0.25 * s\n                q[i, 3] = (matrix[i, 1, 2] + matrix[i, 2, 1]) / s\n            else:\n                s = 2.0 * np.sqrt(1.0 + matrix[i, 2, 2] - matrix[i, 0, 0] - matrix[i, 1, 1])\n                q[i, 0] = (matrix[i, 1, 0] - matrix[i, 0, 1]) / s\n                q[i, 1] = (matrix[i, 0, 2] + matrix[i, 2, 0]) / s\n                q[i, 2] = (matrix[i, 1, 2] + matrix[i, 2, 1]) / s\n                q[i, 3] = 0.25 * s\n    \n    return q\n\n# Example usage\nrotation_matrices = np.array([np.eye(3), np.eye(3)])\nquaternions = rotation_matrix_to_quaternion(rotation_matrices)\nprint(quaternions)\n```\n\n### Step 3: Handle Edge Cases\n\nWe have already included an `eps` parameter to avoid division by zero, but in this implementation, it is not directly used. The logic of the function ensures that division by zero is avoided by checking the trace and the diagonal elements of the matrix.\n\n### Step 4: Return the Quaternion\n\nThe function returns a quaternion tensor with shape `(*, 4)`, where `*` is the batch size of the input rotation matrices.\n\nThis implementation should cover the basic requirements for converting a 3x3 rotation matrix to a quaternion, including input validation and error handling.",
    "prompt": "Generate a Python function called rotation_matrix_to_quaternion that converts a 3x3 rotation matrix to a 4d quaternion vector. The input parameters are a rotation matrix tensor and a small value eps to avoid zero division. The output is a quaternion tensor with components in (w, x, y, z) format. The function returns the quaternion tensor with shape (*, 4). The function includes examples of usage and error handling for input types and sizes.",
    "function_name": "rotation_matrix_to_quaternion",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestRotationMatrixToQuaternion",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}