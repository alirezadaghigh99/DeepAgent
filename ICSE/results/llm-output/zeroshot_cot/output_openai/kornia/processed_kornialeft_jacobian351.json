{
    "result": "To generate the `left_jacobian` function for computing the left Jacobian of SO(3), we need to follow a series of steps. The left Jacobian of SO(3) is a matrix that relates small changes in the Lie algebra to small changes in the Lie group. Here's how you can implement this in Python using PyTorch for tensor operations:\n\n### Step 1: Import Necessary Libraries\n\nFirst, we need to import PyTorch, which will be used for tensor operations.\n\n```python\nimport torch\n```\n\n### Step 2: Define the Skew-Symmetric Matrix Function\n\nThe skew-symmetric matrix is used to represent cross products as matrix multiplications. For a vector \\([x, y, z]\\), the skew-symmetric matrix is:\n\n\\[\n\\text{skew}([x, y, z]) = \\begin{bmatrix} 0 & -z & y \\\\ z & 0 & -x \\\\ -y & x & 0 \\end{bmatrix}\n\\]\n\n```python\ndef skew_symmetric(vec):\n    zero = torch.zeros_like(vec[..., 0])\n    x, y, z = vec[..., 0], vec[..., 1], vec[..., 2]\n    return torch.stack([\n        torch.stack([zero, -z, y], dim=-1),\n        torch.stack([z, zero, -x], dim=-1),\n        torch.stack([-y, x, zero], dim=-1)\n    ], dim=-2)\n```\n\n### Step 3: Define the Left Jacobian Function\n\nThe left Jacobian of SO(3) can be computed using the Rodrigues' rotation formula. For a small rotation vector \\(\\theta\\), the left Jacobian \\(J_l(\\theta)\\) is given by:\n\n\\[\nJ_l(\\theta) = I + \\frac{1 - \\cos(\\theta)}{\\theta^2} \\text{skew}(\\theta) + \\frac{\\theta - \\sin(\\theta)}{\\theta^3} \\text{skew}(\\theta)^2\n\\]\n\nWhere \\(\\theta\\) is the norm of the vector.\n\n```python\ndef left_jacobian(vec):\n    theta = torch.norm(vec, dim=-1, keepdim=True)\n    theta_sq = theta ** 2\n    theta_cube = theta ** 3\n\n    # Handle the case when theta is very small\n    small_angle = theta < 1e-6\n\n    # Compute the skew-symmetric matrix\n    skew_mat = skew_symmetric(vec)\n\n    # Compute the terms\n    I = torch.eye(3, device=vec.device, dtype=vec.dtype).expand(vec.shape[0], 3, 3)\n    A = (1 - torch.cos(theta)) / theta_sq\n    B = (theta - torch.sin(theta)) / theta_cube\n\n    # Compute the left Jacobian\n    J_l = I + A[..., None, None] * skew_mat + B[..., None, None] * torch.matmul(skew_mat, skew_mat)\n\n    # Handle small angles using Taylor expansion\n    if small_angle.any():\n        J_l[small_angle] = I[small_angle] + 0.5 * skew_mat[small_angle] - (1/6) * torch.matmul(skew_mat[small_angle], skew_mat[small_angle])\n\n    return J_l\n```\n\n### Step 4: Test the Function\n\nYou can test the function with a sample input to ensure it works correctly.\n\n```python\n# Example usage\nvec = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=torch.float32)\njacobian = left_jacobian(vec)\nprint(jacobian)\n```\n\nThis code defines a function `left_jacobian` that computes the left Jacobian matrix for a batch of 3D vectors, handling both small and large angles appropriately.",
    "prompt": "Generate a Python function called left_jacobian that computes the left Jacobian of So3. The input is a tensor called vec of shape (B, 3) where B is the batch size. The output is a tensor of shape (B, 3, 3) representing the left Jacobian matrix. The function uses the input tensor to calculate the left Jacobian matrix using specific mathematical operations",
    "function_name": "left_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3::test_left_jacobian",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}