{
    "result": "To create the `rgb_to_grayscale` function, we need to follow these steps:\n\n1. **Validate the Input Shape**: Ensure the input tensor has the shape `(*, 3, H, W)`.\n2. **Determine Default Weights**: Use different default weights based on the data type of the image.\n3. **Validate and Use `rgb_weights`**: If provided, ensure they sum to 1 and have the correct shape.\n4. **Convert to Grayscale**: Apply the weights to convert the RGB image to grayscale.\n5. **Return the Grayscale Image**: Ensure the output has the shape `(*, 1, H, W)`.\n\nLet's implement this step by step:\n\n```python\nimport torch\n\ndef rgb_to_grayscale(image, rgb_weights=None):\n    # Step 1: Validate the input shape\n    if image.ndim < 3 or image.shape[-3] != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    # Step 2: Determine default weights based on data type\n    if image.dtype == torch.uint8:\n        default_weights = torch.tensor([76, 150, 29], dtype=torch.float32) / 255.0\n    elif image.is_floating_point():\n        default_weights = torch.tensor([0.299, 0.587, 0.114], dtype=image.dtype)\n    else:\n        raise TypeError(\"Unsupported image data type. Use uint8 or floating point types.\")\n\n    # Step 3: Validate and use rgb_weights\n    if rgb_weights is not None:\n        rgb_weights = torch.tensor(rgb_weights, dtype=image.dtype)\n        if rgb_weights.shape != (3,):\n            raise ValueError(\"rgb_weights must be a tensor of shape (3,)\")\n        if not torch.isclose(rgb_weights.sum(), torch.tensor(1.0, dtype=image.dtype)):\n            raise ValueError(\"The sum of rgb_weights must be 1\")\n    else:\n        rgb_weights = default_weights\n\n    # Step 4: Convert to grayscale\n    # Reshape rgb_weights to (3, 1, 1) for broadcasting\n    rgb_weights = rgb_weights.view(3, 1, 1)\n    grayscale_image = (image * rgb_weights).sum(dim=-3, keepdim=True)\n\n    # Step 5: Return the grayscale image\n    return grayscale_image\n\n# Example usage:\n# image = torch.rand((2, 3, 256, 256), dtype=torch.float32)  # Example RGB image\n# grayscale_image = rgb_to_grayscale(image)\n# print(grayscale_image.shape)  # Should be (2, 1, 256, 256)\n```\n\n### Explanation:\n\n- **Input Validation**: We check if the input tensor has at least 3 dimensions and the third-to-last dimension is 3, which corresponds to the RGB channels.\n- **Default Weights**: We set default weights based on the data type. For `uint8`, we normalize the weights by dividing by 255.0 to ensure they sum to 1.\n- **Custom Weights**: If `rgb_weights` is provided, we ensure it is a tensor of shape `(3,)` and that its sum is 1.\n- **Grayscale Conversion**: We use broadcasting to apply the weights across the RGB channels and sum them to get the grayscale image.\n- **Output Shape**: The output is reshaped to ensure it has a single channel, maintaining the original batch and spatial dimensions.",
    "prompt": "Create a Python function `rgb_to_grayscale` that converts an RGB image to its grayscale version. The function should:\n\n- Accept an `image` tensor with shape `(*, 3, H, W)` representing the RGB image.\n- Optionally accept `rgb_weights`, a tensor containing weights for the RGB channels. The sum of these weights should be 1.\n- If `rgb_weights` is not provided, default weights based on the image data type should be used: `[76, 150, 29]` for `uint8` images and `[0.299, 0.587, 0.114]` for floating-point images.\n- Validate that the input tensor has the correct shape and raise a `ValueError` if not.\n- Convert the RGB image to grayscale using the provided or default weights.\n- Return the grayscale image with shape `(*, 1, H, W)`.\n\nEnsure that the function handles different image data types correctly and raises a `TypeError` for unsupported types.",
    "function_name": "rgb_to_grayscale",
    "ground_truth": "kornia/color/gray.py",
    "test": "tests/color/test_gray.py::TestRgbToGrayscale",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}