{
    "result": "To implement the `match_fginn` function, we need to follow these steps:\n\n1. **Compute Descriptor Distances**: Calculate the pairwise distances between descriptors in `desc1` and `desc2`.\n\n2. **Find Nearest Neighbors**: For each descriptor in `desc1`, find the nearest neighbor in `desc2` based on the computed distances.\n\n3. **Apply Threshold**: Filter matches based on the descriptor distance threshold `th`.\n\n4. **Spatial Consistency Check**: Use the `lafs1` and `lafs2` to ensure spatial consistency of matches, applying the `spatial_th` threshold.\n\n5. **Mutual Nearest Neighbor Check**: If `mutual` is `True`, ensure that the nearest neighbor relationship is mutual.\n\n6. **Return Matches**: Return the distances and indices of the matching descriptors.\n\nHere's the implementation:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:\n    # Step 1: Compute Descriptor Distances\n    if dm is None:\n        dm = torch.cdist(desc1, desc2, p=2)  # Euclidean distance\n\n    # Step 2: Find Nearest Neighbors\n    min_dist, nn_idx = torch.min(dm, dim=1)\n\n    # Step 3: Apply Descriptor Distance Threshold\n    valid_matches = min_dist < th\n\n    # Step 4: Spatial Consistency Check\n    if spatial_th > 0:\n        # Compute spatial distances between matched LAFs\n        spatial_dist = torch.norm(lafs1[:, :2, 2].unsqueeze(1) - lafs2[nn_idx, :2, 2], dim=2)\n        valid_matches &= (spatial_dist < spatial_th)\n\n    # Step 5: Mutual Nearest Neighbor Check\n    if mutual:\n        # Find nearest neighbors in the opposite direction\n        _, reverse_nn_idx = torch.min(dm.t(), dim=1)\n        mutual_matches = reverse_nn_idx[nn_idx] == torch.arange(len(desc1), device=desc1.device)\n        valid_matches &= mutual_matches\n\n    # Filter matches based on validity\n    matched_indices = torch.nonzero(valid_matches).squeeze(1)\n    matched_desc1_idx = matched_indices\n    matched_desc2_idx = nn_idx[matched_indices]\n    matched_distances = min_dist[matched_indices]\n\n    # Step 6: Return Matches\n    return matched_distances, torch.stack((matched_desc1_idx, matched_desc2_idx), dim=1)\n\n```\n\n### Explanation:\n\n- **Descriptor Distance Calculation**: We use `torch.cdist` to compute the pairwise Euclidean distances between `desc1` and `desc2`.\n\n- **Nearest Neighbor Search**: We find the nearest neighbor for each descriptor in `desc1` by taking the minimum distance along the second dimension.\n\n- **Thresholding**: We apply a threshold to filter out matches with a descriptor distance greater than `th`.\n\n- **Spatial Consistency**: We calculate the spatial distance between the matched keypoints using the LAFs and apply a spatial threshold.\n\n- **Mutual Nearest Neighbor**: If `mutual` is `True`, we ensure that the nearest neighbor relationship is mutual by checking the reverse nearest neighbor condition.\n\n- **Return**: We return the distances and indices of valid matches.",
    "prompt": "Generate a Python function called match_fginn that finds nearest neighbors in desc2 for each vector in desc1. The inputs are Tensors desc1, desc2, lafs1, lafs2, th, spatial_th, mutual, and dm. The function returns a tuple of Tensors containing the descriptor distance of matching descriptors and the long tensor indexes of matching descriptors in desc1 and desc2. The function also performs a mutual nearest neighbor check if specified.\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:",
    "function_name": "match_fginn",
    "ground_truth": "kornia/feature/matching.py",
    "test": "tests/feature/test_matching.py::TestMatchFGINN",
    "class": "",
    "stage": "Inference",
    "task": "Detection",
    "data": "Image"
}