{
    "result": "To generate the `get_rotation_matrix2d` function, we need to follow these steps:\n\n1. **Import Necessary Libraries**: We'll use PyTorch for tensor operations.\n2. **Define the Function**: The function will take three inputs: `center`, `angle`, and `scale`.\n3. **Validate Input Shapes**: Ensure the inputs have the correct shapes.\n4. **Calculate the Rotation Matrix**: Use the center, angle, and scale to compute the affine transformation matrix.\n5. **Return the Result**: The function will return the computed affine matrix.\n6. **Provide an Example Usage**: Demonstrate how to use the function with sample inputs.\n\nLet's implement this step by step:\n\n### Step 1: Import Necessary Libraries\n\n```python\nimport torch\n```\n\n### Step 2: Define the Function\n\n```python\ndef get_rotation_matrix2d(center, angle, scale):\n    \"\"\"\n    Calculate the affine matrix of 2D rotation.\n\n    Parameters:\n    - center: Tensor of shape (B, 2) representing the center of rotation.\n    - angle: Tensor of shape (B,) representing the rotation angle in degrees.\n    - scale: Tensor of shape (B, 2) representing the scale factor for x, y scaling.\n\n    Returns:\n    - Tensor of shape (B, 2, 3) representing the affine transformation matrix.\n    \"\"\"\n```\n\n### Step 3: Validate Input Shapes\n\n```python\n    assert center.shape[1] == 2, \"Center must have shape (B, 2)\"\n    assert angle.dim() == 1, \"Angle must have shape (B,)\"\n    assert scale.shape[1] == 2, \"Scale must have shape (B, 2)\"\n```\n\n### Step 4: Calculate the Rotation Matrix\n\n```python\n    B = center.shape[0]\n    angle_rad = angle * (torch.pi / 180.0)  # Convert angle from degrees to radians\n\n    cos_a = torch.cos(angle_rad)\n    sin_a = torch.sin(angle_rad)\n\n    # Create the rotation matrix\n    rotation_matrix = torch.zeros((B, 2, 3), dtype=center.dtype, device=center.device)\n\n    rotation_matrix[:, 0, 0] = cos_a * scale[:, 0]\n    rotation_matrix[:, 0, 1] = -sin_a * scale[:, 1]\n    rotation_matrix[:, 1, 0] = sin_a * scale[:, 0]\n    rotation_matrix[:, 1, 1] = cos_a * scale[:, 1]\n\n    # Adjust the translation part to keep the center fixed\n    rotation_matrix[:, 0, 2] = center[:, 0] - (rotation_matrix[:, 0, 0] * center[:, 0] + rotation_matrix[:, 0, 1] * center[:, 1])\n    rotation_matrix[:, 1, 2] = center[:, 1] - (rotation_matrix[:, 1, 0] * center[:, 0] + rotation_matrix[:, 1, 1] * center[:, 1])\n```\n\n### Step 5: Return the Result\n\n```python\n    return rotation_matrix\n```\n\n### Step 6: Provide an Example Usage\n\n```python\n# Example usage\nif __name__ == \"__main__\":\n    center = torch.tensor([[50.0, 50.0], [30.0, 30.0]])\n    angle = torch.tensor([45.0, 90.0])\n    scale = torch.tensor([[1.0, 1.0], [0.5, 0.5]])\n\n    rotation_matrices = get_rotation_matrix2d(center, angle, scale)\n    print(rotation_matrices)\n```\n\n### Complete Code\n\n```python\nimport torch\n\ndef get_rotation_matrix2d(center, angle, scale):\n    \"\"\"\n    Calculate the affine matrix of 2D rotation.\n\n    Parameters:\n    - center: Tensor of shape (B, 2) representing the center of rotation.\n    - angle: Tensor of shape (B,) representing the rotation angle in degrees.\n    - scale: Tensor of shape (B, 2) representing the scale factor for x, y scaling.\n\n    Returns:\n    - Tensor of shape (B, 2, 3) representing the affine transformation matrix.\n    \"\"\"\n    assert center.shape[1] == 2, \"Center must have shape (B, 2)\"\n    assert angle.dim() == 1, \"Angle must have shape (B,)\"\n    assert scale.shape[1] == 2, \"Scale must have shape (B, 2)\"\n\n    B = center.shape[0]\n    angle_rad = angle * (torch.pi / 180.0)  # Convert angle from degrees to radians\n\n    cos_a = torch.cos(angle_rad)\n    sin_a = torch.sin(angle_rad)\n\n    # Create the rotation matrix\n    rotation_matrix = torch.zeros((B, 2, 3), dtype=center.dtype, device=center.device)\n\n    rotation_matrix[:, 0, 0] = cos_a * scale[:, 0]\n    rotation_matrix[:, 0, 1] = -sin_a * scale[:, 1]\n    rotation_matrix[:, 1, 0] = sin_a * scale[:, 0]\n    rotation_matrix[:, 1, 1] = cos_a * scale[:, 1]\n\n    # Adjust the translation part to keep the center fixed\n    rotation_matrix[:, 0, 2] = center[:, 0] - (rotation_matrix[:, 0, 0] * center[:, 0] + rotation_matrix[:, 0, 1] * center[:, 1])\n    rotation_matrix[:, 1, 2] = center[:, 1] - (rotation_matrix[:, 1, 0] * center[:, 0] + rotation_matrix[:, 1, 1] * center[:, 1])\n\n    return rotation_matrix\n\n# Example usage\nif __name__ == \"__main__\":\n    center = torch.tensor([[50.0, 50.0], [30.0, 30.0]])\n    angle = torch.tensor([45.0, 90.0])\n    scale = torch.tensor([[1.0, 1.0], [0.5, 0.5]])\n\n    rotation_matrices = get_rotation_matrix2d(center, angle, scale)\n    print(rotation_matrices)\n```\n\nThis code defines the `get_rotation_matrix2d` function, which calculates the affine transformation matrix for 2D rotation based on the given center, angle, and scale. The example usage demonstrates how to use the function with sample inputs.",
    "prompt": "Generate a Python function called get_rotation_matrix2d that calculates an affine matrix of 2D rotation. The function takes three inputs: center (center of the rotation in the source image with shape (B, 2)), angle (rotation angle in degrees with shape (B)), and scale (scale factor for x, y scaling with shape (B, 2)). \n\nThe function returns the affine matrix of 2D rotation with shape (B, 2, 3). The rotation matrix is calculated based on the provided center, angle, and scale values. The transformation maps the rotation center to itself, but adjustments can be made if needed.\n\nEnsure that the inputs are of type Tensor and have the correct shapes before performing the calculations. The function also includes an example usage with sample input values. This function is often used in conjunction with the warp_affine function.",
    "function_name": "get_rotation_matrix2d",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp.py::TestRotationMatrix2d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Image"
}