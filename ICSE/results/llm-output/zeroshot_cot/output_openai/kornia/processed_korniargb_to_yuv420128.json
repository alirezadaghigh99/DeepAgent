{
    "result": "To create the `rgb_to_yuv420` function, we need to follow these steps:\n\n1. **Input Validation and Padding**: Ensure the input tensor has the correct shape and pad it if necessary to make the height and width even.\n2. **RGB to YUV Conversion**: Convert the RGB image to YUV format using the standard conversion formula.\n3. **Subsampling**: Subsample the U and V channels to create the YUV 420 format.\n4. **Return the Result**: Return the Y plane and the subsampled UV planes.\n\nLet's implement this step by step:\n\n### Step 1: Input Validation and Padding\n\nFirst, we need to ensure that the input tensor has the correct shape and pad it if necessary.\n\n```python\nimport torch\nfrom typing import Tuple\n\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    if image.dim() < 4 or image.size(1) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W)\")\n    \n    # Get the height and width\n    _, _, H, W = image.shape\n    \n    # Check if H and W are even, if not, pad the image\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width must be even numbers.\")\n    \n    # No padding needed since we are assuming H and W are even\n    return image\n```\n\n### Step 2: RGB to YUV Conversion\n\nNext, we convert the RGB image to YUV using the standard conversion formula.\n\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    if image.dim() < 4 or image.size(1) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W)\")\n    \n    # Get the height and width\n    _, _, H, W = image.shape\n    \n    # Check if H and W are even, if not, pad the image\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width must be even numbers.\")\n    \n    # Convert RGB to YUV\n    r, g, b = image[:, 0, :, :], image[:, 1, :, :], image[:, 2, :, :]\n    y = 0.299 * r + 0.587 * g + 0.114 * b\n    u = -0.14713 * r - 0.28886 * g + 0.436 * b\n    v = 0.615 * r - 0.51499 * g - 0.10001 * b\n    \n    return y, u, v\n```\n\n### Step 3: Subsampling\n\nSubsample the U and V channels to create the YUV 420 format.\n\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    if image.dim() < 4 or image.size(1) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W)\")\n    \n    # Get the height and width\n    _, _, H, W = image.shape\n    \n    # Check if H and W are even, if not, pad the image\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width must be even numbers.\")\n    \n    # Convert RGB to YUV\n    r, g, b = image[:, 0, :, :], image[:, 1, :, :], image[:, 2, :, :]\n    y = 0.299 * r + 0.587 * g + 0.114 * b\n    u = -0.14713 * r - 0.28886 * g + 0.436 * b\n    v = 0.615 * r - 0.51499 * g - 0.10001 * b\n    \n    # Subsample U and V\n    u_sub = u[:, ::2, ::2]\n    v_sub = v[:, ::2, ::2]\n    \n    # Stack U and V\n    uv = torch.stack((u_sub, v_sub), dim=1)\n    \n    # Add channel dimension to Y\n    y = y.unsqueeze(1)\n    \n    return y, uv\n```\n\n### Step 4: Return the Result\n\nFinally, return the Y plane and the subsampled UV planes.\n\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    if image.dim() < 4 or image.size(1) != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W)\")\n    \n    # Get the height and width\n    _, _, H, W = image.shape\n    \n    # Check if H and W are even, if not, pad the image\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width must be even numbers.\")\n    \n    # Convert RGB to YUV\n    r, g, b = image[:, 0, :, :], image[:, 1, :, :], image[:, 2, :, :]\n    y = 0.299 * r + 0.587 * g + 0.114 * b\n    u = -0.14713 * r - 0.28886 * g + 0.436 * b\n    v = 0.615 * r - 0.51499 * g - 0.10001 * b\n    \n    # Subsample U and V\n    u_sub = u[:, ::2, ::2]\n    v_sub = v[:, ::2, ::2]\n    \n    # Stack U and V\n    uv = torch.stack((u_sub, v_sub), dim=1)\n    \n    # Add channel dimension to Y\n    y = y.unsqueeze(1)\n    \n    return y, uv\n```\n\nThis function will convert an RGB image to YUV 420 format, ensuring that the input dimensions are even and returning the Y plane and subsampled UV planes as specified.",
    "prompt": "Generate a Python function called rgb_to_yuv420 that takes in a torch.Tensor representing an RGB image and returns a tuple of two torch.Tensors. The input image is assumed to be in the range of (0, 1) and needs to be padded to be evenly divisible by 2 horizontally and vertically. The function will output the YUV 420 (subsampled) version of the input image with chroma siting at (0.5, 0.5).\n\nThe function should have the following signature:\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nThe function converts the RGB image to YUV 420 format and returns:\n- A Tensor containing the Y plane with shape (*, 1, H, W)\n- A Tensor containing the UV planes with shape (*, 2, H/2, W/2)\n\nEnsure that the input image has a shape of (*, 3, H, W) where H and W are even numbers. If the input does not meet these requirements, appropriate errors will be raised.\n\nExample usage:\n```python\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```",
    "function_name": "rgb_to_yuv420",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestRgbToYuv420",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}