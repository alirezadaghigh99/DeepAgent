{
    "result": "To generate the `quaternion_exp_to_log` function, we will follow these steps:\n\n1. **Import Necessary Libraries**: We need to import PyTorch since we are dealing with tensors.\n2. **Function Definition**: Define the function `quaternion_exp_to_log` with parameters `quaternion` and `eps`.\n3. **Input Validation**: Check if the input is a tensor and has the correct shape.\n4. **Unpack Quaternion**: Extract the scalar and vector parts from the quaternion.\n5. **Compute Quaternion Norm**: Calculate the norm of the vector part.\n6. **Apply Log Map**: Use the quaternion log map formula to compute the result.\n7. **Return the Result**: Return the computed log map as a tensor.\n\nLet's implement this step by step:\n\n```python\nimport torch\n\ndef quaternion_exp_to_log(quaternion, eps):\n    # Step 3: Input Validation\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    if quaternion.shape[-1] != 4:\n        raise ValueError(\"Input tensor must have shape (*, 4).\")\n    \n    # Step 4: Unpack Quaternion\n    w, x, y, z = quaternion[..., 0], quaternion[..., 1], quaternion[..., 2], quaternion[..., 3]\n    vector_part = quaternion[..., 1:]\n    \n    # Step 5: Compute Quaternion Norm\n    vector_norm = torch.norm(vector_part, dim=-1)\n    \n    # Step 6: Apply Log Map\n    # Clamp the norm to avoid division by zero\n    vector_norm_clamped = torch.clamp(vector_norm, min=eps)\n    theta = torch.acos(torch.clamp(w, min=-1.0, max=1.0))\n    scale = theta / vector_norm_clamped\n    \n    # Handle the case where vector_norm is zero\n    scale = torch.where(vector_norm < eps, torch.zeros_like(scale), scale)\n    \n    log_map = scale.unsqueeze(-1) * vector_part\n    \n    # Step 7: Return the Result\n    return log_map\n\n# Example usage\nquaternion = torch.tensor((1., 0., 0., 0.))\nresult = quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\nprint(result)  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n- **Input Validation**: Ensures the input is a tensor and has the correct shape.\n- **Unpack Quaternion**: Separates the scalar (`w`) and vector (`x, y, z`) parts.\n- **Quaternion Norm**: Computes the norm of the vector part.\n- **Log Map Calculation**: Uses the formula for the quaternion logarithm, handling edge cases where the vector norm is zero by clamping and using conditional logic.\n- **Return**: Outputs the log map as a tensor of shape `(*, 3)`.",
    "prompt": "Generate a Python function called quaternion_exp_to_log that applies the log map to a quaternion. The input is a tensor called quaternion in (w, x, y, z) format and a float called eps for clamping. The output is a tensor of shape (*, 3) representing the quaternion log map. The function checks if the input is a Tensor and has a shape of (*, 4). It then unpacks the quaternion into a vector and scalar, computes the quaternion norm, and applies the log map to calculate the quaternion log. An example usage is provided with a sample quaternion input. >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_exp_to_log",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/epipolar/test_essential.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}