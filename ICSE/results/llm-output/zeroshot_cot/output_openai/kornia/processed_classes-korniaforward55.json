{
    "result": "To implement the `forward` method for the `Rotate` class, we need to perform a rotation transformation on the input tensor. This involves several steps, including calculating the rotation matrix, applying the transformation, and ensuring the output tensor has the same shape as the input. Here's how you can achieve this:\n\n1. **Calculate the Rotation Matrix**: We need to create a rotation matrix that will rotate the image anti-clockwise by a specified angle. The rotation matrix for a 2D rotation is given by:\n\n   \\[\n   R = \\begin{bmatrix}\n   \\cos(\\theta) & -\\sin(\\theta) \\\\\n   \\sin(\\theta) & \\cos(\\theta)\n   \\end{bmatrix}\n   \\]\n\n   where \\(\\theta\\) is the rotation angle in radians.\n\n2. **Determine the Center of Rotation**: If a center is not provided, the default center is the center of the image.\n\n3. **Apply the Transformation**: Use PyTorch's `grid_sample` and `affine_grid` functions to apply the rotation transformation to the input tensor.\n\n4. **Handle Interpolation and Padding**: Use the specified interpolation mode and padding mode to handle how the image is sampled and how the borders are treated.\n\nHere's the complete implementation of the `forward` method:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport math\n\nclass Rotate(nn.Module):\n    def __init__(self, angle, center=None, mode='bilinear', padding_mode='zeros', align_corners=False):\n        super(Rotate, self).__init__()\n        self.angle = angle\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Get the dimensions of the input tensor\n        n, c, h, w = input.size()\n        \n        # Calculate the center of rotation\n        if self.center is None:\n            center = (w / 2, h / 2)\n        else:\n            center = self.center\n        \n        # Convert angle from degrees to radians\n        angle_rad = -self.angle * math.pi / 180  # Negative for anti-clockwise rotation\n        \n        # Calculate the rotation matrix\n        cos_a = math.cos(angle_rad)\n        sin_a = math.sin(angle_rad)\n        rotation_matrix = torch.tensor([\n            [cos_a, -sin_a, 0],\n            [sin_a, cos_a, 0]\n        ], dtype=torch.float32, device=input.device)\n        \n        # Adjust the translation part of the matrix to rotate around the center\n        translation_matrix = torch.tensor([\n            [1, 0, center[0]],\n            [0, 1, center[1]]\n        ], dtype=torch.float32, device=input.device)\n        \n        translation_back_matrix = torch.tensor([\n            [1, 0, -center[0]],\n            [0, 1, -center[1]]\n        ], dtype=torch.float32, device=input.device)\n        \n        # Combine the matrices\n        rotation_matrix = torch.mm(translation_matrix, torch.mm(rotation_matrix, translation_back_matrix))\n        \n        # Create the affine grid\n        grid = F.affine_grid(rotation_matrix.unsqueeze(0), input.size(), align_corners=self.align_corners)\n        \n        # Sample the input tensor using the grid\n        output = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n        \n        return output\n```\n\n### Explanation:\n- **Rotation Matrix**: We calculate the rotation matrix for the given angle and adjust it to rotate around the specified center.\n- **Affine Grid**: We use `affine_grid` to create a grid that represents the transformation.\n- **Grid Sample**: We apply the transformation using `grid_sample`, which interpolates the input tensor based on the grid.\n- **Parameters**: The class constructor allows specifying the angle, center, interpolation mode, padding mode, and alignment flag, providing flexibility in how the rotation is performed.",
    "prompt": "**Task:** Write the `forward` method for the `Rotate` class. This method should rotate the input tensor anti-clockwise around its center. The method should return a tensor of the same shape as the input.\n\n\n**Class Context:**\n```python\nclass Rotate(nn.Module):\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Implement this function\n```\n\n**Requirements:**\n- The method should take the input tensor and rotate it by the specified angle.\n- The rotation should be performed around the provided center, or the center should be calculated if not provided.\n- Use the specified interpolation mode (`'bilinear'` or `'nearest'`), padding mode (`'zeros'`, `'border'`, or `'reflection'`), and alignment flag (`align_corners`).",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestRotate",
    "class": "Rotate",
    "stage": "Image",
    "task": "",
    "data": "Inference"
}