{
    "result": "To generate the `project` function for the `PinholeCamera` class, we need to follow these steps:\n\n1. **Transform the 3D point from world coordinates to camera coordinates** using the extrinsic matrix.\n2. **Project the 3D point in camera coordinates onto the 2D image plane** using the intrinsic matrix.\n3. **Normalize the projected points** to get the final `(u, v)` coordinates.\n\nLet's break down the code step by step:\n\n### Step 1: Transform the 3D point from world coordinates to camera coordinates\n\nThe extrinsic matrix is used to transform points from world coordinates to camera coordinates. The extrinsic matrix is typically a 4x4 matrix that combines rotation and translation. However, since the input `point_3d` is a tensor with shape `(*, 3)`, we need to convert it to homogeneous coordinates by appending a 1 to each point.\n\n```python\nimport torch\n\ndef project(self, point_3d: torch.Tensor) -> torch.Tensor:\n    # Convert point_3d to homogeneous coordinates by appending a 1\n    ones = torch.ones((*point_3d.shape[:-1], 1), device=point_3d.device)\n    point_3d_homogeneous = torch.cat([point_3d, ones], dim=-1)\n    \n    # Transform the 3D point from world coordinates to camera coordinates\n    point_camera = torch.matmul(point_3d_homogeneous, self._extrinsics.T)\n```\n\n### Step 2: Project the 3D point in camera coordinates onto the 2D image plane\n\nThe intrinsic matrix is used to project 3D points in camera coordinates onto the 2D image plane. The intrinsic matrix is typically a 3x3 matrix.\n\n```python\n    # Project the 3D point onto the 2D image plane using the intrinsic matrix\n    point_2d_homogeneous = torch.matmul(point_camera[..., :3], self._intrinsics.T)\n```\n\n### Step 3: Normalize the projected points\n\nTo get the final `(u, v)` coordinates, we need to normalize the projected points by dividing by the third coordinate (z-coordinate).\n\n```python\n    # Normalize the projected points to get (u, v) coordinates\n    u = point_2d_homogeneous[..., 0] / point_2d_homogeneous[..., 2]\n    v = point_2d_homogeneous[..., 1] / point_2d_homogeneous[..., 2]\n    \n    # Stack the (u, v) coordinates into a single tensor\n    uv_coordinates = torch.stack([u, v], dim=-1)\n    \n    return uv_coordinates\n```\n\n### Complete `project` function\n\nHere is the complete `project` function for the `PinholeCamera` class:\n\n```python\nimport torch\n\nclass PinholeCamera:\n    def __init__(self, intrinsics: torch.Tensor, extrinsics: torch.Tensor, height: torch.Tensor, width: torch.Tensor) -> None:\n        self.height: torch.Tensor = height\n        self.width: torch.Tensor = width\n        self._intrinsics: torch.Tensor = intrinsics\n        self._extrinsics: torch.Tensor = extrinsics\n\n    def project(self, point_3d: torch.Tensor) -> torch.Tensor:\n        # Convert point_3d to homogeneous coordinates by appending a 1\n        ones = torch.ones((*point_3d.shape[:-1], 1), device=point_3d.device)\n        point_3d_homogeneous = torch.cat([point_3d, ones], dim=-1)\n        \n        # Transform the 3D point from world coordinates to camera coordinates\n        point_camera = torch.matmul(point_3d_homogeneous, self._extrinsics.T)\n        \n        # Project the 3D point onto the 2D image plane using the intrinsic matrix\n        point_2d_homogeneous = torch.matmul(point_camera[..., :3], self._intrinsics.T)\n        \n        # Normalize the projected points to get (u, v) coordinates\n        u = point_2d_homogeneous[..., 0] / point_2d_homogeneous[..., 2]\n        v = point_2d_homogeneous[..., 1] / point_2d_homogeneous[..., 2]\n        \n        # Stack the (u, v) coordinates into a single tensor\n        uv_coordinates = torch.stack([u, v], dim=-1)\n        \n        return uv_coordinates\n```\n\nThis function will take a 3D point in world coordinates and project it onto the 2D camera plane, returning the `(u, v)` coordinates.",
    "prompt": "\"Generate the `project` function for the following class to project a 3D point in world coordinates onto the 2D camera plane. The input is `self` and a `point_3d` tensor with shape `(*, 3)`, and the output is a tensor of `(u, v)` camera coordinates with shape `(*, 2)`.\n\n```python\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n```\"",
    "function_name": "project",
    "ground_truth": "kornia/geometry/camera/pinhole.py",
    "test": "tests/geometry/camera/test_pinhole.py",
    "class": "PinholeCamera",
    "stage": "Image",
    "task": "",
    "data": "pre-post process"
}