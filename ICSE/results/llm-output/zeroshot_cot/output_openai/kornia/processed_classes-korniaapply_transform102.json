{
    "result": "To generate the `apply_transform` function for the `RandomGamma` class, we need to follow these steps:\n\n1. **Extract Parameters**: Retrieve the `gamma_factor` and `gain_factor` from the `params` dictionary.\n2. **Apply Transformation**: Use these parameters to apply the gamma transformation to the input tensor.\n3. **Return the Transformed Tensor**: Ensure the output is the transformed tensor.\n\nHere's how you can implement the `apply_transform` function:\n\n```python\nimport torch\n\nclass RandomGamma(IntensityAugmentationBase2D):\n    def __init__(\n        self,\n        gamma: Tuple[float, float] = (1.0, 1.0),\n        gain: Tuple[float, float] = (1.0, 1.0),\n        same_on_batch: bool = False,\n        p: float = 1.0,\n        keepdim: bool = False,\n    ) -> None:\n        super().__init__(p=p, same_on_batch=same_on_batch, keepdim=keepdim)\n        self._param_generator = rg.PlainUniformGenerator(\n            (gamma, \"gamma_factor\", None, None), (gain, \"gain_factor\", None, None)\n        )\n\n    def apply_transform(\n        self,\n        input: torch.Tensor,\n        params: dict,\n        flags: dict,\n        transform: Optional[torch.Tensor] = None\n    ) -> torch.Tensor:\n        # Extract gamma and gain factors from params\n        gamma_factor = params.get(\"gamma_factor\", 1.0)\n        gain_factor = params.get(\"gain_factor\", 1.0)\n\n        # Apply the gamma transformation\n        # The formula is: output = gain * input^gamma\n        transformed = gain_factor * torch.pow(input, gamma_factor)\n\n        return transformed\n```\n\n### Explanation:\n\n- **Parameter Extraction**: We use `params.get(\"gamma_factor\", 1.0)` and `params.get(\"gain_factor\", 1.0)` to safely extract the gamma and gain factors, providing default values of `1.0` if they are not present.\n  \n- **Gamma Transformation**: The transformation is applied using the formula `output = gain * input^gamma`. This is done using PyTorch's `torch.pow` function to raise the input tensor to the power of `gamma_factor`, and then multiplying by `gain_factor`.\n\n- **Return**: The transformed tensor is returned as the output of the function.\n\nThis function assumes that the input tensor is already normalized and that the gamma transformation is appropriate for the data type and range of the input tensor.",
    "prompt": "Generate a Python function apply_transform for the RandomGamma class that applies a random gamma transformation to an input tensor image. The input types are input (a tensor), params (a dictionary containing the transformation parameters), flags (a dictionary for additional flags), and an optional transform tensor. The output is the transformed tensor.\n\nclass RandomGamma(IntensityAugmentationBase2D):\n    def __init__(\n        self,\n        gamma: Tuple[float, float] = (1.0, 1.0),\n        gain: Tuple[float, float] = (1.0, 1.0),\n        same_on_batch: bool = False,\n        p: float = 1.0,\n        keepdim: bool = False,\n    ) -> None:\n        super().__init__(p=p, same_on_batch=same_on_batch, keepdim=keepdim)\n        self._param_generator = rg.PlainUniformGenerator(\n            (gamma, \"gamma_factor\", None, None), (gain, \"gain_factor\", None, None)\n        )",
    "function_name": "apply_transform",
    "ground_truth": "kornia/augmentation/_2d/intensity/gamma.py",
    "test": "tests/augmentation/test_augmentation.py::TestRandomGamma",
    "class": "RandomGamma",
    "stage": "Image",
    "task": "",
    "data": "pre-post process"
}