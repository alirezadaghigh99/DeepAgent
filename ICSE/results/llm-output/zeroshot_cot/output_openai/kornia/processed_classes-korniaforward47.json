{
    "result": "To implement the `forward` function for the `Affine` class, we need to construct an affine transformation matrix using the provided parameters (`angle`, `translation`, `scale_factor`, `shear`, and `center`) and apply this transformation to the input tensor. We'll use PyTorch's `torch.nn.functional.affine_grid` and `torch.nn.functional.grid_sample` to perform the transformation. Here's how you can implement this step by step:\n\n1. **Import Necessary Libraries**: Ensure you have the necessary imports for PyTorch and any other required modules.\n\n2. **Initialize the Class**: Define the `__init__` method to store the transformation parameters.\n\n3. **Construct the Affine Transformation Matrix**: Create a function to construct the affine transformation matrix from the given parameters.\n\n4. **Apply the Transformation**: Use the transformation matrix to create a grid and apply it to the input tensor.\n\nHere's the complete implementation:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport math\n\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        super(Affine, self).__init__()\n        self.angle = angle\n        self.translation = translation\n        self.scale_factor = scale_factor\n        self.shear = shear\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        batch_size, channels, height, width = input.size()\n        \n        # Default values for transformations\n        angle = self.angle if self.angle is not None else torch.zeros(batch_size)\n        translation = self.translation if self.translation is not None else torch.zeros(batch_size, 2)\n        scale_factor = self.scale_factor if self.scale_factor is not None else torch.ones(batch_size, 2)\n        shear = self.shear if self.shear is not None else torch.zeros(batch_size, 2)\n        center = self.center if self.center is not None else torch.tensor([width / 2, height / 2]).repeat(batch_size, 1)\n\n        # Convert angle from degrees to radians\n        angle = angle * math.pi / 180.0\n\n        # Construct the affine transformation matrix\n        cos_a = torch.cos(angle)\n        sin_a = torch.sin(angle)\n        sx, sy = scale_factor[:, 0], scale_factor[:, 1]\n        shx, shy = shear[:, 0], shear[:, 1]\n        cx, cy = center[:, 0], center[:, 1]\n        tx, ty = translation[:, 0], translation[:, 1]\n\n        # Affine matrix components\n        a = cos_a / sx\n        b = (sin_a + shx) / sx\n        c = (1 - cos_a) * cx - sin_a * cy + tx\n        d = (-sin_a + shy) / sy\n        e = cos_a / sy\n        f = sin_a * cx + (1 - cos_a) * cy + ty\n\n        # Create the affine transformation matrix\n        affine_matrix = torch.stack([a, b, c, d, e, f], dim=1).view(batch_size, 2, 3)\n\n        # Create the grid for sampling\n        grid = F.affine_grid(affine_matrix, input.size(), align_corners=self.align_corners)\n\n        # Apply the grid to the input tensor\n        output = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\n### Explanation:\n- **Affine Matrix Construction**: The affine matrix is constructed using the provided parameters. The matrix is a combination of rotation, translation, scaling, and shearing transformations.\n- **Grid Sampling**: The `affine_grid` function generates a grid based on the affine matrix, and `grid_sample` applies this grid to the input tensor to produce the transformed output.\n- **Handling Defaults**: If any transformation parameter is not provided, a default value is used (e.g., no rotation, no translation, unit scaling, etc.).\n\nThis implementation allows you to apply complex affine transformations to a batch of images using PyTorch.",
    "prompt": "Write a Python function `forward` for the `Affine` class that applies multiple elementary affine transformations (rotation, translation, scaling, and shearing) to a batch of input tensors. The function takes a 4D tensor with shape `[batch_size, channels, height, width]` as input and returns a transformed tensor of the same shape. The affine transformation is computed using parameters such as `angle`, `translation`, `scale_factor`, `shear`, and `center`, with optional interpolation modes and padding options.\n\n```python\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        # Initialization code...\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n``` \n\nThe `forward` function constructs an affine transformation matrix based on the provided parameters and applies this transformation to the input tensor.",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestAffine2d",
    "class": "Affine",
    "stage": "Image",
    "task": "",
    "data": "Model construction"
}