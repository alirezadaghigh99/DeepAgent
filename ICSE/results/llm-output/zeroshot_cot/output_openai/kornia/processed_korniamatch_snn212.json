{
    "result": "To create the `match_snn` function, we need to follow these steps:\n\n1. **Input Validation**: Ensure that the input tensors `desc1` and `desc2` have valid shapes and that `desc2` has at least two descriptors.\n\n2. **Distance Calculation**: If a precomputed distance matrix `dm` is not provided, compute the pairwise distances between descriptors in `desc1` and `desc2`.\n\n3. **Find Nearest Neighbors**: For each descriptor in `desc1`, find the indices and distances of the two nearest neighbors in `desc2`.\n\n4. **Apply Ratio Test**: Check if the ratio of the distance to the nearest neighbor to the distance to the second nearest neighbor is less than or equal to the threshold `th`.\n\n5. **Return Results**: Collect and return the distances and indices of the descriptors that satisfy the ratio test.\n\nLet's implement this step by step:\n\n```python\nimport torch\n\ndef match_snn(desc1, desc2, th=0.8, dm=None):\n    # Step 1: Input Validation\n    if desc1.ndim != 2 or desc2.ndim != 2:\n        raise ValueError(\"desc1 and desc2 must be 2D tensors.\")\n    \n    if desc2.size(0) < 2:\n        return torch.empty((0, 1)), torch.empty((0, 2), dtype=torch.long)\n    \n    # Step 2: Distance Calculation\n    if dm is None:\n        # Compute the pairwise distance matrix\n        dm = torch.cdist(desc1, desc2, p=2)  # Euclidean distance\n    \n    # Step 3: Find Nearest Neighbors\n    # Sort distances to find the two nearest neighbors\n    sorted_distances, sorted_indices = torch.sort(dm, dim=1)\n    \n    # Get the nearest and second nearest distances and their indices\n    nearest_distances = sorted_distances[:, 0]\n    second_nearest_distances = sorted_distances[:, 1]\n    nearest_indices = sorted_indices[:, 0]\n    second_nearest_indices = sorted_indices[:, 1]\n    \n    # Step 4: Apply Ratio Test\n    ratio = nearest_distances / second_nearest_distances\n    valid_mask = ratio <= th\n    \n    # Step 5: Return Results\n    matching_distances = nearest_distances[valid_mask].unsqueeze(1)\n    matching_indices = torch.stack((torch.arange(desc1.size(0))[valid_mask], nearest_indices[valid_mask]), dim=1)\n    \n    return matching_distances, matching_indices\n\n# Example usage:\n# desc1 = torch.rand(5, 128)  # 5 descriptors of dimension 128\n# desc2 = torch.rand(10, 128) # 10 descriptors of dimension 128\n# distances, indices = match_snn(desc1, desc2)\n```\n\n### Explanation:\n- **Input Validation**: We check that both `desc1` and `desc2` are 2D tensors and that `desc2` has at least two descriptors.\n- **Distance Calculation**: If a distance matrix `dm` is not provided, we compute it using `torch.cdist`, which calculates the pairwise Euclidean distance.\n- **Find Nearest Neighbors**: We sort the distances to find the nearest and second nearest neighbors for each descriptor in `desc1`.\n- **Apply Ratio Test**: We compute the ratio of the nearest to the second nearest distance and apply the threshold.\n- **Return Results**: We return the distances and indices of the descriptors that pass the ratio test. The indices are returned as a long tensor with the shape `(B3, 2)`, where `B3` is the number of matches found.",
    "prompt": "Create a Python function `match_snn` that takes in two tensors, `desc1` and `desc2`, representing batches of descriptors, a threshold `th` = 0.8, and an optional precomputed distance matrix `dm`. The function returns the distances and indices of descriptors from `desc1` that have nearest neighbors in `desc2`, satisfying the condition that the ratio of the first to the second nearest neighbor distance is less than or equal to `th`. If `desc2` has fewer than two descriptors, or if no matches meet the ratio threshold, the function returns an empty result. It checks the validity of the input shapes and then identifies the matching descriptors and their corresponding distances.Return:\n        - Descriptor distance of matching descriptors, shape of :math:`(B3, 1)`.\n        - Long tensor indexes of matching descriptors in desc1 and desc2. Shape: :math:`(B3, 2)`,\n          where 0 <= B3 <= B1.",
    "function_name": "match_snn",
    "ground_truth": "kornia/feature/matching.py#L48",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Detection",
    "data": "Image"
}