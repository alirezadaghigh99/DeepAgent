{
    "result": "To create the `get_projective_transform` function, we need to follow these steps:\n\n1. **Import Necessary Libraries**: We'll use PyTorch for tensor operations.\n2. **Validate Input Shapes and Types**: Ensure that the input tensors have the correct shapes and are on the same device and have the same dtype.\n3. **Convert Angles from Degrees to Radians**: Since trigonometric functions in PyTorch use radians, we'll convert the angles.\n4. **Create Rotation Matrices**: Construct rotation matrices for each axis (x, y, z).\n5. **Combine Rotation Matrices**: Combine the individual rotation matrices into a single rotation matrix.\n6. **Apply Scaling**: Incorporate the scaling factors into the transformation.\n7. **Translate to Center**: Adjust the transformation to account for the center of rotation.\n8. **Return the Projection Matrix**: Construct and return the final projection matrix.\n\nLet's implement this step by step:\n\n```python\nimport torch\n\ndef get_projective_transform(center, angles, scales):\n    # Step 1: Validate input shapes\n    assert center.shape[-1] == 3, \"Center must have shape (B, 3)\"\n    assert angles.shape[-1] == 3, \"Angles must have shape (B, 3)\"\n    assert scales.shape[-1] == 3, \"Scales must have shape (B, 3)\"\n    \n    # Step 2: Validate input types and devices\n    assert center.device == angles.device == scales.device, \"All inputs must be on the same device\"\n    assert center.dtype == angles.dtype == scales.dtype, \"All inputs must have the same dtype\"\n    \n    # Step 3: Convert angles from degrees to radians\n    angles_rad = angles * (torch.pi / 180.0)\n    \n    # Step 4: Create rotation matrices\n    cos = torch.cos\n    sin = torch.sin\n    \n    cx, cy, cz = cos(angles_rad[:, 0]), cos(angles_rad[:, 1]), cos(angles_rad[:, 2])\n    sx, sy, sz = sin(angles_rad[:, 0]), sin(angles_rad[:, 1]), sin(angles_rad[:, 2])\n    \n    # Rotation matrix around x-axis\n    Rx = torch.stack([\n        torch.stack([torch.ones_like(cx), torch.zeros_like(cx), torch.zeros_like(cx)], dim=-1),\n        torch.stack([torch.zeros_like(cx), cx, -sx], dim=-1),\n        torch.stack([torch.zeros_like(cx), sx, cx], dim=-1)\n    ], dim=-2)\n    \n    # Rotation matrix around y-axis\n    Ry = torch.stack([\n        torch.stack([cy, torch.zeros_like(cy), sy], dim=-1),\n        torch.stack([torch.zeros_like(cy), torch.ones_like(cy), torch.zeros_like(cy)], dim=-1),\n        torch.stack([-sy, torch.zeros_like(cy), cy], dim=-1)\n    ], dim=-2)\n    \n    # Rotation matrix around z-axis\n    Rz = torch.stack([\n        torch.stack([cz, -sz, torch.zeros_like(cz)], dim=-1),\n        torch.stack([sz, cz, torch.zeros_like(cz)], dim=-1),\n        torch.stack([torch.zeros_like(cz), torch.zeros_like(cz), torch.ones_like(cz)], dim=-1)\n    ], dim=-2)\n    \n    # Step 5: Combine rotation matrices\n    R = torch.matmul(Rz, torch.matmul(Ry, Rx))\n    \n    # Step 6: Apply scaling\n    S = torch.diag_embed(scales)\n    RS = torch.matmul(R, S)\n    \n    # Step 7: Translate to center\n    T = torch.eye(4, device=center.device, dtype=center.dtype).unsqueeze(0).repeat(center.shape[0], 1, 1)\n    T[:, :3, 3] = center\n    \n    # Step 8: Construct the final projection matrix\n    P = torch.cat([RS, torch.zeros(center.shape[0], 3, 1, device=center.device, dtype=center.dtype)], dim=-1)\n    P = torch.matmul(T, torch.cat([P, torch.tensor([[[0, 0, 0, 1]]], device=center.device, dtype=center.dtype).repeat(center.shape[0], 1, 1)], dim=-2))\n    \n    return P[:, :3, :]\n\n# Example usage:\n# center = torch.tensor([[0.0, 0.0, 0.0]])\n# angles = torch.tensor([[45.0, 45.0, 45.0]])\n# scales = torch.tensor([[1.0, 1.0, 1.0]])\n# projection_matrix = get_projective_transform(center, angles, scales)\n# print(projection_matrix)\n```\n\nThis function will compute the projection matrix for a 3D rotation, taking into account the specified center, rotation angles, and scales.",
    "prompt": "Create a Python function get_projective_transform that calculates the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function takes the following parameters:\n\ncenter: A tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\nangles: A tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\nscales: A tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\nThe function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.Raise an AssertionError if center or angles do not have the expected shape.\nRaise an AssertionError if center and angles do not share the same device and dtype.",
    "function_name": "get_projective_transform",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp3d.py::TestGetRotationMatrix3d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}