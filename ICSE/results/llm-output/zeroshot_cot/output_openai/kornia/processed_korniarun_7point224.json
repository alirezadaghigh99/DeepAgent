{
    "result": "To implement the `run_7point` function, we need to follow several steps. Let's break it down:\n\n1. **Input Validation**: Ensure the input shapes are correct.\n2. **Normalization**: Normalize the input points to improve numerical stability.\n3. **Construct Linear System**: Use the normalized points to construct a linear system.\n4. **Solve with SVD**: Use Singular Value Decomposition (SVD) to solve the linear system and obtain candidate fundamental matrices.\n5. **Cubic Polynomial**: Form a cubic polynomial from the candidate matrices and solve for its roots.\n6. **Compute Fundamental Matrices**: Use the roots to compute up to three potential fundamental matrices.\n7. **Return Results**: Ensure the results are returned in the correct shape.\n\nLet's implement this step by step:\n\n### Step 1: Input Validation\n\n```python\nimport numpy as np\n\ndef run_7point(points1, points2):\n    # Check input shapes\n    assert points1.shape == points2.shape, \"Input point sets must have the same shape.\"\n    B, N, D = points1.shape\n    assert N == 7 and D == 2, \"Each set of points must have shape (B, 7, 2).\"\n    \n    # Proceed with normalization and other steps\n```\n\n### Step 2: Normalization\n\nNormalization involves translating and scaling the points so that their centroid is at the origin and their average distance from the origin is \u221a2.\n\n```python\ndef normalize_points(points):\n    B, N, D = points.shape\n    mean = np.mean(points, axis=1, keepdims=True)\n    std = np.std(points, axis=1, keepdims=True)\n    scale = np.sqrt(2) / std\n    T = np.zeros((B, 3, 3))\n    T[:, 0, 0] = scale[:, 0, 0]\n    T[:, 1, 1] = scale[:, 0, 1]\n    T[:, 0, 2] = -scale[:, 0, 0] * mean[:, 0, 0]\n    T[:, 1, 2] = -scale[:, 0, 1] * mean[:, 0, 1]\n    T[:, 2, 2] = 1\n    points_h = np.concatenate([points, np.ones((B, N, 1))], axis=-1)\n    normalized_points = np.einsum('bij,bkj->bki', T, points_h)\n    return normalized_points, T\n\n# Normalize the points\npoints1_normalized, T1 = normalize_points(points1)\npoints2_normalized, T2 = normalize_points(points2)\n```\n\n### Step 3: Construct Linear System\n\nConstruct the matrix A for the linear system `Af = 0`.\n\n```python\ndef construct_matrix_A(points1, points2):\n    B, N, _ = points1.shape\n    A = np.zeros((B, N, 9))\n    for i in range(N):\n        x1, y1 = points1[:, i, 0], points1[:, i, 1]\n        x2, y2 = points2[:, i, 0], points2[:, i, 1]\n        A[:, i] = np.stack([x2*x1, x2*y1, x2, y2*x1, y2*y1, y2, x1, y1, np.ones_like(x1)], axis=-1)\n    return A\n\n# Construct the matrix A\nA = construct_matrix_A(points1_normalized, points2_normalized)\n```\n\n### Step 4: Solve with SVD\n\nUse SVD to solve the linear system and obtain candidate fundamental matrices.\n\n```python\ndef solve_svd(A):\n    B = A.shape[0]\n    F1 = np.zeros((B, 3, 3))\n    F2 = np.zeros((B, 3, 3))\n    for i in range(B):\n        _, _, Vt = np.linalg.svd(A[i])\n        F1[i] = Vt[-1].reshape(3, 3)\n        F2[i] = Vt[-2].reshape(3, 3)\n    return F1, F2\n\n# Solve using SVD\nF1, F2 = solve_svd(A)\n```\n\n### Step 5: Cubic Polynomial\n\nForm a cubic polynomial from the candidate matrices and solve for its roots.\n\n```python\ndef solve_cubic_polynomial(F1, F2):\n    B = F1.shape[0]\n    fundamental_matrices = []\n    for i in range(B):\n        # Form the polynomial coefficients\n        a0 = np.linalg.det(F1[i])\n        a1 = np.linalg.det(F2[i])\n        a2 = np.linalg.det(F1[i] + F2[i])\n        a3 = np.linalg.det(F1[i] - F2[i])\n        \n        # Solve the cubic polynomial\n        roots = np.roots([a3, a2, a1, a0])\n        \n        # Compute the fundamental matrices\n        for root in roots:\n            if np.isreal(root):\n                F = F1[i] + root.real * F2[i]\n                fundamental_matrices.append(F)\n    return fundamental_matrices\n\n# Solve the cubic polynomial\nfundamental_matrices = solve_cubic_polynomial(F1, F2)\n```\n\n### Step 6: Compute Fundamental Matrices\n\nCompute the fundamental matrices using the roots obtained.\n\n```python\ndef compute_fundamental_matrices(F1, F2, roots):\n    F_matrices = []\n    for root in roots:\n        if np.isreal(root):\n            F = F1 + root.real * F2\n            F_matrices.append(F)\n    return F_matrices\n\n# Compute the fundamental matrices\nfundamental_matrices = []\nfor i in range(B):\n    roots = np.roots([np.linalg.det(F1[i] - F2[i]), np.linalg.det(F1[i] + F2[i]), np.linalg.det(F2[i]), np.linalg.det(F1[i])])\n    F_matrices = compute_fundamental_matrices(F1[i], F2[i], roots)\n    fundamental_matrices.extend(F_matrices)\n```\n\n### Step 7: Return Results\n\nEnsure the results are returned in the correct shape.\n\n```python\ndef run_7point(points1, points2):\n    # Check input shapes\n    assert points1.shape == points2.shape, \"Input point sets must have the same shape.\"\n    B, N, D = points1.shape\n    assert N == 7 and D == 2, \"Each set of points must have shape (B, 7, 2).\"\n    \n    # Normalize the points\n    points1_normalized, T1 = normalize_points(points1)\n    points2_normalized, T2 = normalize_points(points2)\n    \n    # Construct the matrix A\n    A = construct_matrix_A(points1_normalized, points2_normalized)\n    \n    # Solve using SVD\n    F1, F2 = solve_svd(A)\n    \n    # Compute the fundamental matrices\n    fundamental_matrices = []\n    for i in range(B):\n        roots = np.roots([np.linalg.det(F1[i] - F2[i]), np.linalg.det(F1[i] + F2[i]), np.linalg.det(F2[i]), np.linalg.det(F1[i])])\n        F_matrices = compute_fundamental_matrices(F1[i], F2[i], roots)\n        for F in F_matrices:\n            # Denormalize the fundamental matrix\n            F = np.dot(T2[i].T, np.dot(F, T1[i]))\n            fundamental_matrices.append(F)\n    \n    # Reshape the result\n    m = len(fundamental_matrices) // B\n    result = np.array(fundamental_matrices).reshape(B, m, 3, 3)\n    return result\n\n# Example usage\n# points1 and points2 should be numpy arrays of shape (B, 7, 2)\n# result = run_7point(points1, points2)\n```\n\nThis code provides a complete implementation of the 7-point algorithm for computing the fundamental matrix. It includes input validation, normalization, construction of the linear system, solving with SVD, forming and solving the cubic polynomial, and returning the computed fundamental matrices.",
    "prompt": "Create a Python function `run_7point` that computes the fundamental matrix using the 7-point algorithm. The function should:\n\n- Accept two sets of points (`points1`, `points2`) as input, each of shape `(B, N, 2)`, where `B` is the batch size, and `N` is the number of points (exactly 7).\n- Normalize the points, construct a linear system, and solve it using SVD to obtain two fundamental matrices.\n- Use these matrices to form a cubic polynomial, solve for its roots, and compute up to three potential fundamental matrices.\n- Handle edge cases where matrices might be non-invertible and ensure numerical stability.\n- Return the computed fundamental matrices in the shape `(B, 3*m, 3)`, where `m` can be 1, 2, or 3.\n\nErrors:\n- The function should raise `AssertionError` if the input tensors do not have the expected shapes.\n- Handle cases where matrix inversion is problematic, ensuring robust solutions are returned.",
    "function_name": "run_7point",
    "ground_truth": "kornia/geometry/epipolar/fundamental.py#L76",
    "test": "tests/geometry/epipolar/test_fundamental.py::TestFindFundamental",
    "class": "",
    "stage": "Model Construction",
    "task": "Detection",
    "data": "Image"
}