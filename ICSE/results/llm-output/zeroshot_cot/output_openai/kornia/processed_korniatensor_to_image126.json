{
    "result": "To create the `tensor_to_image` function, we need to handle several tasks: checking the input type and dimensions, moving the tensor to CPU if necessary, making it contiguous if required, and finally converting it to a NumPy array with the appropriate shape. Let's break down the steps and implement the function:\n\n1. **Check Input Type**: Ensure the input is a PyTorch tensor.\n2. **Check Tensor Dimensions**: Validate that the tensor has 2, 3, or 4 dimensions.\n3. **Move to CPU**: If the tensor is on a GPU, move it to the CPU.\n4. **Make Contiguous**: If `force_contiguous` is `True`, ensure the tensor is contiguous.\n5. **Convert to NumPy**: Convert the tensor to a NumPy array.\n6. **Adjust Shape**: Adjust the shape of the NumPy array based on the input dimensions and the `keepdim` flag.\n\nHere's the implementation:\n\n```python\nimport torch\nimport numpy as np\n\ndef tensor_to_image(tensor, keepdim=True, force_contiguous=False):\n    # Check if the input is a PyTorch tensor\n    if not isinstance(tensor, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n    \n    # Check the number of dimensions\n    if tensor.ndimension() not in {2, 3, 4}:\n        raise ValueError(\"Input tensor must have 2, 3, or 4 dimensions.\")\n    \n    # Move tensor to CPU if it's on GPU\n    if tensor.is_cuda:\n        tensor = tensor.cpu()\n    \n    # Make tensor contiguous if required\n    if force_contiguous:\n        tensor = tensor.contiguous()\n    \n    # Convert tensor to NumPy array\n    array = tensor.numpy()\n    \n    # Adjust the shape of the array\n    if tensor.ndimension() == 2:\n        # (H, W) -> (H, W)\n        return array\n    elif tensor.ndimension() == 3:\n        # (C, H, W) -> (H, W, C)\n        array = np.transpose(array, (1, 2, 0))\n        return array\n    elif tensor.ndimension() == 4:\n        # (B, C, H, W) -> (B, H, W, C)\n        array = np.transpose(array, (0, 2, 3, 1))\n        if not keepdim:\n            # Remove the batch dimension if keepdim is False\n            array = np.squeeze(array, axis=0)\n        return array\n\n# Example usage:\n# tensor = torch.randn(3, 224, 224)  # Example tensor\n# image = tensor_to_image(tensor, keepdim=False, force_contiguous=True)\n```\n\n### Explanation:\n- **Type and Dimension Checks**: We first ensure the input is a tensor and has valid dimensions.\n- **Device Handling**: We move the tensor to the CPU if it's on a GPU.\n- **Contiguity**: We make the tensor contiguous if `force_contiguous` is `True`.\n- **Conversion and Reshaping**: We convert the tensor to a NumPy array and adjust its shape based on its original dimensions and the `keepdim` flag. For 3D tensors, we transpose the channels to the last dimension. For 4D tensors, we handle the batch dimension accordingly.",
    "prompt": "Create a Python function `tensor_to_image` that converts a PyTorch tensor image to a NumPy array image. The function should:\n\n- Accept a tensor as input, which can have one of the following shapes: `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- Convert the tensor to a NumPy array, handling cases where the tensor is in GPU memory by copying it back to CPU.\n- Optionally, squeeze the dimensions if `keepdim` is `False`.\n- Ensure the tensor is contiguous if `force_contiguous` is `True`.\n- Return the converted image with the appropriate shape: `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nInput types:\n- `tensor`: A PyTorch tensor of shape `(H, W)`, `(C, H, W)`, or `(B, C, H, W)`.\n- `keepdim`: A boolean indicating whether to retain the batch dimension.\n- `force_contiguous`: A boolean indicating whether to make the tensor contiguous.\n\nOutput:\n- Returns a NumPy array representing the image with the shape `(H, W)`, `(H, W, C)`, or `(B, H, W, C)`.\n\nErrors:\n- Raise a `TypeError` if the input is not a Tensor.\n- Raise a `ValueError` if the input tensor's dimensions are not 2, 3, or 4.",
    "function_name": "tensor_to_image",
    "ground_truth": "kornia/utils/image.py",
    "test": "tests/utils/test_image_utils.py::test_tensor_to_image",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}