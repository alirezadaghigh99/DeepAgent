{
    "result": "To create the `depth_from_point` function, we need to apply a rigid transformation to the 3D points and then compute the depth of each transformed point. The depth of a point in this context is typically the z-coordinate of the point after transformation. Let's break down the steps:\n\n1. **Apply the Rigid Transformation**: A rigid transformation consists of a rotation followed by a translation. For a point \\( X \\), the transformed point \\( X' \\) is given by:\n   \\[\n   X' = R \\cdot X + t\n   \\]\n   where \\( R \\) is the rotation matrix and \\( t \\) is the translation vector.\n\n2. **Extract the Depth**: The depth of the transformed point is the z-coordinate of \\( X' \\).\n\nLet's implement this in the `depth_from_point` function:\n\n```python\nimport numpy as np\n\ndef depth_from_point(R, t, X):\n    \"\"\"\n    Return the depth of a point transformed by a rigid transform.\n\n    Args:\n       R: The rotation matrix with shape (*, 3, 3).\n       t: The translation vector with shape (*, 3, 1).\n       X: The 3d points with shape (*, 3).\n\n    Returns:\n       The depth value per point with shape (*, 1).\n    \"\"\"\n    # Ensure X is a column vector\n    X = X[..., np.newaxis]  # Shape becomes (*, 3, 1)\n\n    # Apply the rigid transformation\n    X_transformed = np.matmul(R, X) + t  # Shape (*, 3, 1)\n\n    # Extract the z-coordinate (depth) from the transformed points\n    depth = X_transformed[..., 2, :]  # Shape (*, 1)\n\n    return depth\n\n# Example usage:\n# R = np.array([[[1, 0, 0], [0, 1, 0], [0, 0, 1]]])  # Identity rotation\n# t = np.array([[[0], [0], [1]]])  # Translation along z-axis\n# X = np.array([[1, 2, 3]])  # A single 3D point\n# print(depth_from_point(R, t, X))  # Should output [[4]]\n```\n\n### Explanation:\n- **Input Shapes**: The function expects `R` to be a rotation matrix of shape `(*, 3, 3)`, `t` to be a translation vector of shape `(*, 3, 1)`, and `X` to be 3D points of shape `(*, 3)`.\n- **Transformation**: We first convert `X` to a column vector to facilitate matrix multiplication. We then apply the transformation using matrix multiplication and addition.\n- **Depth Extraction**: The depth is extracted as the z-coordinate of the transformed point, which is the third element in the last dimension of `X_transformed`.\n\nThis function should work for batches of points and transformations, as indicated by the use of the `*` in the shapes, which allows for broadcasting over additional dimensions.",
    "prompt": "Write a python function depth_from_point that Return the depth of a point transformed by a rigid transform.\n\n    Args:\n       R: The rotation matrix with shape :math:`(*, 3, 3)`.\n       t: The translation vector with shape :math:`(*, 3, 1)`.\n       X: The 3d points with shape :math:`(*, 3)`.\n\n    Returns:\n       The depth value per point with shape :math:`(*, 1)`.",
    "function_name": "depth_from_point",
    "ground_truth": "kornia/geometry/epipolar/projection.py#L151",
    "test": "tests/geometry/epipolar/test_essential.py::TestMotionFromEssentialChooseSolution",
    "class": "",
    "stage": "Inference",
    "task": "Prediction",
    "data": "Image"
}