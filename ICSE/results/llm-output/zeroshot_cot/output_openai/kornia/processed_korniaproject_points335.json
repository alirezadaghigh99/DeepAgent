{
    "result": "To create the `project_points` function, we need to follow these steps:\n\n1. **Import Necessary Libraries**: We'll use PyTorch for tensor operations.\n2. **Define the Function**: The function will take two arguments: a 3D point tensor and a camera matrix tensor.\n3. **Perform the Projection**: Use matrix multiplication to project the 3D points onto the 2D plane.\n4. **Normalize the Coordinates**: Convert the homogeneous coordinates to 2D coordinates.\n5. **Return the Result**: The function will return the 2D coordinates.\n\nLet's implement this step by step:\n\n### Step 1: Import Necessary Libraries\n\n```python\nimport torch\n```\n\n### Step 2: Define the Function\n\n```python\ndef project_points(points_3d, camera_matrix):\n    \"\"\"\n    Projects 3D points onto a 2D camera plane using the camera matrix.\n\n    Args:\n        points_3d (torch.Tensor): A tensor of shape (*, 3) representing 3D points.\n        camera_matrix (torch.Tensor): A tensor of shape (*, 3, 3) representing the camera matrix.\n\n    Returns:\n        torch.Tensor: A tensor of shape (*, 2) representing the projected 2D points.\n    \"\"\"\n```\n\n### Step 3: Perform the Projection\n\n```python\n    # Add a dimension to points_3d to make it compatible for matrix multiplication\n    points_3d_homogeneous = torch.cat((points_3d, torch.ones(points_3d.shape[:-1] + (1,))), dim=-1)\n    \n    # Perform matrix multiplication\n    projected_points_homogeneous = torch.matmul(points_3d_homogeneous.unsqueeze(-2), camera_matrix).squeeze(-2)\n```\n\n### Step 4: Normalize the Coordinates\n\n```python\n    # Normalize to get 2D coordinates\n    u = projected_points_homogeneous[..., 0] / projected_points_homogeneous[..., 2]\n    v = projected_points_homogeneous[..., 1] / projected_points_homogeneous[..., 2]\n    \n    # Stack the u and v coordinates\n    projected_points_2d = torch.stack((u, v), dim=-1)\n```\n\n### Step 5: Return the Result\n\n```python\n    return projected_points_2d\n```\n\n### Complete Function\n\nHere's the complete function:\n\n```python\nimport torch\n\ndef project_points(points_3d, camera_matrix):\n    \"\"\"\n    Projects 3D points onto a 2D camera plane using the camera matrix.\n\n    Args:\n        points_3d (torch.Tensor): A tensor of shape (*, 3) representing 3D points.\n        camera_matrix (torch.Tensor): A tensor of shape (*, 3, 3) representing the camera matrix.\n\n    Returns:\n        torch.Tensor: A tensor of shape (*, 2) representing the projected 2D points.\n    \"\"\"\n    # Add a dimension to points_3d to make it compatible for matrix multiplication\n    points_3d_homogeneous = torch.cat((points_3d, torch.ones(points_3d.shape[:-1] + (1,))), dim=-1)\n    \n    # Perform matrix multiplication\n    projected_points_homogeneous = torch.matmul(points_3d_homogeneous.unsqueeze(-2), camera_matrix).squeeze(-2)\n    \n    # Normalize to get 2D coordinates\n    u = projected_points_homogeneous[..., 0] / projected_points_homogeneous[..., 2]\n    v = projected_points_homogeneous[..., 1] / projected_points_homogeneous[..., 2]\n    \n    # Stack the u and v coordinates\n    projected_points_2d = torch.stack((u, v), dim=-1)\n    \n    return projected_points_2d\n```\n\n### Example Usage\n\n```python\n# Example usage\npoints_3d = torch.rand((1, 3))  # Random 3D point\ncamera_matrix = torch.eye(3).unsqueeze(0)  # Identity matrix as camera matrix\n\nprojected_points = project_points(points_3d, camera_matrix)\nprint(projected_points)\n```\n\nThis function will project the 3D points onto the 2D camera plane using the provided camera matrix. The example usage demonstrates how to use the function with a random 3D point and an identity matrix as the camera matrix.",
    "prompt": "Generate a Python function called project_points that takes in a 3D point tensor and a camera matrix tensor as input. The function projects the 3D point onto the 2D camera plane using the camera matrix. The input tensor for the 3D point should have shape (*, 3) and the camera matrix tensor should have shape (*, 3, 3). The function returns a tensor of (u, v) camera coordinates with shape (*, 2). An example usage of the function is provided where a random 3D point and an identity matrix as the camera matrix are used to project the point onto the camera plane, resulting in a tensor of camera coordinates.",
    "function_name": "project_points",
    "ground_truth": "kornia/geometry/camera/perspective.py",
    "test": "tests/geometry/camera/test_projections.py::TestProjectionZ1",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}