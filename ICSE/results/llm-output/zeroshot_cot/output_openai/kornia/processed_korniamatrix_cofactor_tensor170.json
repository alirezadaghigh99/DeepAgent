{
    "result": "To create the `matrix_cofactor_tensor` function, we need to follow these steps:\n\n1. **Import Necessary Libraries**: We'll use NumPy for matrix operations.\n2. **Define the Function**: The function will take a tensor of matrices as input.\n3. **Check Matrix Shape**: Ensure the input tensor has the correct shape `(*, 3, 3)`.\n4. **Compute Determinants**: Calculate the determinant of each 3x3 matrix.\n5. **Check for Singular Matrices**: Raise an exception if all matrices are singular.\n6. **Compute Cofactor Matrices**: For each matrix, compute the cofactor matrix.\n7. **Return the Result**: Return a tensor of cofactor matrices.\n\nLet's implement this step by step:\n\n### Step 1: Import Necessary Libraries\n\n```python\nimport numpy as np\n```\n\n### Step 2: Define the Function\n\n```python\ndef matrix_cofactor_tensor(matrix):\n    # Step 3: Check Matrix Shape\n    if matrix.ndim < 2 or matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input tensor must have shape (*, 3, 3).\")\n    \n    # Step 4: Compute Determinants\n    determinants = np.linalg.det(matrix)\n    \n    # Step 5: Check for Singular Matrices\n    if np.all(determinants == 0):\n        raise Exception(\"All input matrices are singular.\")\n    \n    # Step 6: Compute Cofactor Matrices\n    cofactor_matrices = np.empty_like(matrix)\n    for index in np.ndindex(matrix.shape[:-2]):\n        mat = matrix[index]\n        cofactor = np.empty((3, 3))\n        \n        # Calculate the cofactor matrix\n        for i in range(3):\n            for j in range(3):\n                minor = np.delete(np.delete(mat, i, axis=0), j, axis=1)\n                cofactor[i, j] = ((-1) ** (i + j)) * np.linalg.det(minor)\n        \n        cofactor_matrices[index] = cofactor\n    \n    # Step 7: Return the Result\n    return cofactor_matrices\n```\n\n### Explanation\n\n- **Shape Check**: We ensure the input tensor has the last two dimensions as 3x3.\n- **Determinant Calculation**: We use `np.linalg.det` to compute determinants.\n- **Singular Check**: We raise an exception if all determinants are zero.\n- **Cofactor Calculation**: For each matrix, we compute the cofactor matrix by iterating over each element, calculating the minor, and applying the cofactor formula.\n- **Return**: The function returns a tensor of cofactor matrices.\n\nThis function should work for any tensor of 3x3 matrices, efficiently computing the cofactor matrices while handling singular matrices appropriately.",
    "prompt": "Create a Python function `matrix_cofactor_tensor` that:\n\n- Computes the cofactor matrix for a given tensor of matrices with shape `(*, 3, 3)`.\n- Accepts a single parameter:\n  - `matrix`: A tensor of shape `(*, 3, 3)` representing the input matrices.\n- Returns a tensor containing the cofactor matrices of the input matrices.\n\nErrors:\n- Raises an `Exception` if all input matrices are singular (i.e., their determinants are zero).",
    "function_name": "matrix_cofactor_tensor",
    "ground_truth": "kornia/geometry/epipolar/numeric.py#L31",
    "test": "tests/geometry/epipolar/test_essential.py::TestDecomposeEssentialMatrixNoSVD",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}