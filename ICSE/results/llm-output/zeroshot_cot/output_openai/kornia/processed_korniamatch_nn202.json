{
    "result": "To create the `match_nn` function, we will follow these steps:\n\n1. **Check Input Shapes**: Ensure that `desc1` and `desc2` have the correct shapes `(B1, D)` and `(B2, D)` respectively.\n\n2. **Handle Empty Descriptors**: If either `desc1` or `desc2` is empty, return a placeholder output using a helper function `_no_match`.\n\n3. **Compute Distance Matrix**: If the distance matrix `dm` is not provided, compute it using `torch.cdist`.\n\n4. **Find Nearest Neighbors**: For each descriptor in `desc1`, find the nearest neighbor in `desc2` by identifying the minimum distance and its index.\n\n5. **Construct Output Tensors**: Return the distances and indices of the nearest neighbors.\n\nLet's implement this step by step:\n\n```python\nimport torch\n\ndef _no_match(B1):\n    # Returns placeholder outputs when there are no matches\n    return torch.full((B1, 1), float('inf')), torch.full((B1, 2), -1, dtype=torch.long)\n\ndef match_nn(desc1, desc2, dm=None):\n    # Check if desc1 and desc2 have the correct shapes\n    if desc1.dim() != 2 or desc2.dim() != 2:\n        raise ValueError(\"Input descriptors must be 2D tensors.\")\n    \n    B1, D1 = desc1.shape\n    B2, D2 = desc2.shape\n    \n    if D1 != D2:\n        raise ValueError(\"Descriptor dimensions must match.\")\n    \n    # Handle empty descriptors\n    if B1 == 0 or B2 == 0:\n        return _no_match(B1)\n    \n    # Compute distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n    \n    # Find nearest neighbors\n    min_distances, min_indices = torch.min(dm, dim=1)\n    \n    # Construct the indices tensor\n    indices = torch.stack((torch.arange(B1), min_indices), dim=1)\n    \n    return min_distances.unsqueeze(1), indices\n\n# Example usage:\n# desc1 = torch.rand(5, 128)  # Example descriptor batch 1\n# desc2 = torch.rand(10, 128) # Example descriptor batch 2\n# distances, indices = match_nn(desc1, desc2)\n# print(distances)\n# print(indices)\n```\n\n### Explanation:\n\n- **_no_match Function**: This helper function returns placeholder tensors when there are no matches. It returns a tensor of infinite distances and a tensor of indices filled with `-1`.\n\n- **Input Validation**: The function checks if the input tensors are 2D and have matching descriptor dimensions.\n\n- **Distance Matrix Calculation**: If `dm` is not provided, it is computed using `torch.cdist`, which calculates pairwise distances between two sets of vectors.\n\n- **Nearest Neighbor Search**: The function uses `torch.min` to find the minimum distance and its index for each descriptor in `desc1`.\n\n- **Output Construction**: The function returns the minimum distances and the corresponding indices in a structured format.\n\nThis implementation assumes that the input tensors are compatible and does not include explicit error handling for incompatible inputs beyond basic shape checks.",
    "prompt": "Create a Python function `match_nn` that:\n\n- Takes three parameters:\n  - `desc1`: A tensor containing a batch of descriptors with shape `(B1, D)`.\n  - `desc2`: A tensor containing another batch of descriptors with shape `(B2, D)`.\n  - `dm`: An optional precomputed distance matrix tensor of shape `(B1, B2)`. If not provided, the function computes the distance matrix using `torch.cdist`.\n\n- The function finds the nearest neighbors in `desc2` for each vector in `desc1`:\n  - Checks if the input descriptors have the correct shapes.\n  - If either `desc1` or `desc2` is empty, it returns a placeholder output using `_no_match`.\n  - If `dm` is not provided, it calculates the distance matrix between `desc1` and `desc2`.\n  - Finds the minimum distances and their corresponding indices in `desc2` for each vector in `desc1`.\n  - Constructs a tensor containing the indices of matching descriptors in `desc1` and `desc2`.\n\n- Returns:\n  - A tensor of matching descriptor distances with shape `(B1, 1)`.\n  - A tensor of long indices of matching descriptors in `desc1` and `desc2` with shape `(B1, 2)`.\n\nErrors:\n- The function assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs.",
    "function_name": "match_nn",
    "ground_truth": "kornia/feature/matching.py#L60",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}