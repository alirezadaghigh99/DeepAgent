{
    "result": "To create the `rotate_laf` function, we need to follow these steps:\n\n1. **Validate Input Shape**: Ensure that the input `LAF` tensor has the correct shape `(B, N, 2, 3)`. If not, raise an error.\n\n2. **Convert Angles from Degrees to Radians**: Since trigonometric functions in most libraries use radians, convert the input angles from degrees to radians.\n\n3. **Create Rotation Matrices**: For each angle, create a 2x2 rotation matrix.\n\n4. **Apply Rotation to LAF**: Multiply the rotation matrix with the 2x2 part of each LAF to apply the rotation.\n\n5. **Return the Rotated LAF**: Ensure the output has the same shape as the input.\n\nLet's implement this step by step:\n\n### Step 1: Validate Input Shape\n\n```python\nimport torch\n\ndef rotate_laf(LAF, angles_degrees):\n    # Check if LAF has the correct shape\n    if LAF.ndim != 4 or LAF.shape[2:] != (2, 3):\n        raise ValueError(\"Input LAF must have shape (B, N, 2, 3)\")\n    \n    # Check if angles_degrees has the correct shape\n    if angles_degrees.ndim != 3 or angles_degrees.shape[2] != 1:\n        raise ValueError(\"Input angles_degrees must have shape (B, N, 1)\")\n    \n    # Proceed with the function implementation\n```\n\n### Step 2: Convert Angles from Degrees to Radians\n\n```python\n    # Convert angles from degrees to radians\n    angles_radians = angles_degrees * (torch.pi / 180.0)\n```\n\n### Step 3: Create Rotation Matrices\n\n```python\n    # Compute cosine and sine of angles\n    cos_theta = torch.cos(angles_radians)\n    sin_theta = torch.sin(angles_radians)\n    \n    # Create rotation matrices\n    rotation_matrices = torch.zeros((LAF.shape[0], LAF.shape[1], 2, 2), device=LAF.device)\n    rotation_matrices[:, :, 0, 0] = cos_theta.squeeze(-1)\n    rotation_matrices[:, :, 0, 1] = -sin_theta.squeeze(-1)\n    rotation_matrices[:, :, 1, 0] = sin_theta.squeeze(-1)\n    rotation_matrices[:, :, 1, 1] = cos_theta.squeeze(-1)\n```\n\n### Step 4: Apply Rotation to LAF\n\n```python\n    # Apply rotation to the 2x2 part of each LAF\n    rotated_LAF = LAF.clone()\n    rotated_LAF[:, :, :2, :2] = torch.matmul(rotation_matrices, LAF[:, :, :2, :2])\n```\n\n### Step 5: Return the Rotated LAF\n\n```python\n    return rotated_LAF\n```\n\n### Complete Function\n\nHere is the complete `rotate_laf` function:\n\n```python\nimport torch\n\ndef rotate_laf(LAF, angles_degrees):\n    # Check if LAF has the correct shape\n    if LAF.ndim != 4 or LAF.shape[2:] != (2, 3):\n        raise ValueError(\"Input LAF must have shape (B, N, 2, 3)\")\n    \n    # Check if angles_degrees has the correct shape\n    if angles_degrees.ndim != 3 or angles_degrees.shape[2] != 1:\n        raise ValueError(\"Input angles_degrees must have shape (B, N, 1)\")\n    \n    # Convert angles from degrees to radians\n    angles_radians = angles_degrees * (torch.pi / 180.0)\n    \n    # Compute cosine and sine of angles\n    cos_theta = torch.cos(angles_radians)\n    sin_theta = torch.sin(angles_radians)\n    \n    # Create rotation matrices\n    rotation_matrices = torch.zeros((LAF.shape[0], LAF.shape[1], 2, 2), device=LAF.device)\n    rotation_matrices[:, :, 0, 0] = cos_theta.squeeze(-1)\n    rotation_matrices[:, :, 0, 1] = -sin_theta.squeeze(-1)\n    rotation_matrices[:, :, 1, 0] = sin_theta.squeeze(-1)\n    rotation_matrices[:, :, 1, 1] = cos_theta.squeeze(-1)\n    \n    # Apply rotation to the 2x2 part of each LAF\n    rotated_LAF = LAF.clone()\n    rotated_LAF[:, :, :2, :2] = torch.matmul(rotation_matrices, LAF[:, :, :2, :2])\n    \n    return rotated_LAF\n```\n\nThis function will rotate each Local Affine Frame by the specified angles and return the rotated frames.",
    "prompt": "Create a function `rotate_laf` that applies an additional rotation to a Local Affine Frame (LAF). The function takes in a tensor `LAF` of shape `(B, N, 2, 3)` and a tensor `angles_degrees` of shape `(B, N, 1)` representing rotation angles in degrees. It returns the rotated LAF with the same shape. The function raises an error if the input LAF is not properly structured.",
    "function_name": "rotate_laf",
    "ground_truth": "kornia/feature/laf.py#L70",
    "test": "tests/feature/test_laf.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}