{
    "result": "To create the `chi2` function that computes the chi-squared statistics between each non-negative feature and class, we will follow these steps:\n\n1. **Import Necessary Libraries**: We need to import NumPy for numerical operations and `LabelBinarizer` from `sklearn.preprocessing` to handle the class labels.\n\n2. **Binarize the Class Labels**: Use `LabelBinarizer` to convert the class labels into a binary matrix representation.\n\n3. **Calculate Observed and Expected Frequencies**: For each feature, calculate the observed and expected frequencies needed for the chi-squared test.\n\n4. **Compute Chi-Squared Statistics and p-values**: Use the chi-squared formula to compute the statistics and p-values for each feature.\n\n5. **Return the Results**: Return the chi-squared statistics and p-values as NumPy arrays.\n\nLet's implement this step by step:\n\n```python\nimport numpy as np\nfrom sklearn.preprocessing import LabelBinarizer\nfrom scipy.stats import chi2 as chi2_dist\n\ndef chi2(X, y):\n    # Step 1: Binarize the class labels\n    lb = LabelBinarizer()\n    Y = lb.fit_transform(y)\n    \n    # If Y is a binary class, it will have only one column, we need to handle this case\n    if Y.shape[1] == 1:\n        Y = np.hstack([1 - Y, Y])\n    \n    # Step 2: Initialize arrays to store chi-squared statistics and p-values\n    n_features = X.shape[1]\n    chi2_stats = np.zeros(n_features)\n    p_values = np.zeros(n_features)\n    \n    # Step 3: Calculate observed and expected frequencies\n    observed = np.dot(Y.T, X)  # shape (n_classes, n_features)\n    feature_sums = X.sum(axis=0)\n    class_sums = Y.sum(axis=0)\n    total_sum = feature_sums.sum()\n    \n    expected = np.outer(class_sums, feature_sums) / total_sum\n    \n    # Step 4: Compute chi-squared statistics and p-values\n    chi2_stats = ((observed - expected) ** 2 / expected).sum(axis=0)\n    p_values = chi2_dist.sf(chi2_stats, df=Y.shape[1] - 1)\n    \n    # Step 5: Return the results\n    return chi2_stats, p_values\n```\n\n### Explanation:\n\n- **LabelBinarizer**: Converts the class labels into a binary matrix, where each column represents a class.\n- **Observed Frequencies**: Calculated as the dot product of the transposed binary class matrix and the feature matrix.\n- **Expected Frequencies**: Calculated using the outer product of class sums and feature sums, normalized by the total sum.\n- **Chi-Squared Statistics**: Computed using the formula \\((O - E)^2 / E\\), where \\(O\\) is the observed frequency and \\(E\\) is the expected frequency.\n- **p-values**: Calculated using the survival function (`sf`) of the chi-squared distribution, which gives the probability of observing a chi-squared statistic as extreme as the one calculated.\n\nThis function efficiently computes the chi-squared statistics and p-values for each feature with a complexity of \\(O(n_{\\text{classes}} \\times n_{\\text{features}})\\).",
    "prompt": "Generate a Python function called chi2 that computes chi-squared statistics between each non-negative feature and class. The function takes two parameters: X, an array-like or sparse matrix of shape (n_samples, n_features) representing sample vectors, and y, an array-like of shape (n_samples,) representing target vector (class labels). The function returns two arrays: chi2, an ndarray of shape (n_features,) containing Chi2 statistics for each feature, and p_values, an ndarray of shape (n_features,) containing p-values for each feature. The complexity of the algorithm is O(n_classes * n_features). The function uses the LabelBinarizer to handle sparse representation for Y and performs calculations to determine observed and expected values before calling the _chisquare function.",
    "function_name": "chi2",
    "ground_truth": "sklearn/feature_selection/_univariate_selection.py",
    "test": "sklearn/feature_selection/tests/test_chi2.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}