{
    "result": "To generate the `contingency_matrix` function step by step, we'll break down the process into manageable parts. We'll start by defining the function signature and then implement each part of the functionality.\n\n### Step 1: Define the Function Signature\n\nFirst, we'll define the function signature with the required parameters and optional parameters.\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,)\n        Ground truth class labels.\n    - labels_pred: array-like of shape (n_samples,)\n        Cluster labels.\n    - eps: float, optional\n        If not None, a small value added to each cell for smoothing.\n    - sparse: bool, optional\n        If True, return a sparse CSR matrix.\n    - dtype: numeric type, optional\n        Desired data type of the output matrix.\n\n    Returns:\n    - C: ndarray or sparse matrix of shape (n_classes_true, n_classes_pred)\n        Contingency matrix.\n    \n    Example:\n    >>> labels_true = [0, 0, 1, 1, 2, 2]\n    >>> labels_pred = [0, 0, 1, 1, 0, 2]\n    >>> contingency_matrix(labels_true, labels_pred)\n    array([[2, 0, 0],\n           [0, 2, 0],\n           [1, 0, 1]])\n    \"\"\"\n```\n\n### Step 2: Validate Inputs and Determine Unique Classes\n\nNext, we need to validate the inputs and determine the unique classes in both `labels_true` and `labels_pred`.\n\n```python\n    labels_true = np.asarray(labels_true)\n    labels_pred = np.asarray(labels_pred)\n\n    if labels_true.shape != labels_pred.shape:\n        raise ValueError(\"labels_true and labels_pred must have the same shape.\")\n\n    classes_true = np.unique(labels_true)\n    classes_pred = np.unique(labels_pred)\n\n    n_classes_true = classes_true.size\n    n_classes_pred = classes_pred.size\n```\n\n### Step 3: Initialize the Contingency Matrix\n\nWe'll initialize the contingency matrix with zeros. The dtype will be determined based on the `eps` and `dtype` parameters.\n\n```python\n    if eps is not None:\n        dtype = float\n    elif dtype is None:\n        dtype = int\n\n    if sparse:\n        C = csr_matrix((n_classes_true, n_classes_pred), dtype=dtype)\n    else:\n        C = np.zeros((n_classes_true, n_classes_pred), dtype=dtype)\n```\n\n### Step 4: Populate the Contingency Matrix\n\nWe'll iterate over the samples and populate the contingency matrix.\n\n```python\n    for i in range(labels_true.size):\n        true_index = np.where(classes_true == labels_true[i])[0][0]\n        pred_index = np.where(classes_pred == labels_pred[i])[0][0]\n        C[true_index, pred_index] += 1\n```\n\n### Step 5: Apply Epsilon Smoothing (if applicable)\n\nIf `eps` is provided, we'll add it to each element of the matrix.\n\n```python\n    if eps is not None:\n        if sparse:\n            C.data += eps\n        else:\n            C += eps\n```\n\n### Step 6: Return the Contingency Matrix\n\nFinally, we'll return the contingency matrix.\n\n```python\n    return C\n```\n\n### Complete Function\n\nHere is the complete `contingency_matrix` function:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,)\n        Ground truth class labels.\n    - labels_pred: array-like of shape (n_samples,)\n        Cluster labels.\n    - eps: float, optional\n        If not None, a small value added to each cell for smoothing.\n    - sparse: bool, optional\n        If True, return a sparse CSR matrix.\n    - dtype: numeric type, optional\n        Desired data type of the output matrix.\n\n    Returns:\n    - C: ndarray or sparse matrix of shape (n_classes_true, n_classes_pred)\n        Contingency matrix.\n    \n    Example:\n    >>> labels_true = [0, 0, 1, 1, 2, 2]\n    >>> labels_pred = [0, 0, 1, 1, 0, 2]\n    >>> contingency_matrix(labels_true, labels_pred)\n    array([[2, 0, 0],\n           [0, 2, 0],\n           [1, 0, 1]])\n    \"\"\"\n    labels_true = np.asarray(labels_true)\n    labels_pred = np.asarray(labels_pred)\n\n    if labels_true.shape != labels_pred.shape:\n        raise ValueError(\"labels_true and labels_pred must have the same shape.\")\n\n    classes_true = np.unique(labels_true)\n    classes_pred = np.unique(labels_pred)\n\n    n_classes_true = classes_true.size\n    n_classes_pred = classes_pred.size\n\n    if eps is not None:\n        dtype = float\n    elif dtype is None:\n        dtype = int\n\n    if sparse:\n        C = csr_matrix((n_classes_true, n_classes_pred), dtype=dtype)\n    else:\n        C = np.zeros((n_classes_true, n_classes_pred), dtype=dtype)\n\n    for i in range(labels_true.size):\n        true_index = np.where(classes_true == labels_true[i])[0][0]\n        pred_index = np.where(classes_pred == labels_pred[i])[0][0]\n        C[true_index, pred_index] += 1\n\n    if eps is not None:\n        if sparse:\n            C.data += eps\n        else:\n            C += eps\n\n    return C\n```\n\nThis function should now correctly compute the contingency matrix based on the provided labels and options.",
    "prompt": "Generate a Python function called contingency_matrix that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function takes in two array-like inputs: labels_true (ground truth class labels) and labels_pred (cluster labels). Additionally, it has optional parameters eps (float), sparse (bool), and dtype (numeric type). \n\nThe function returns a contingency matrix of shape [n_classes_true, n_classes_pred], where each element C[i, j] represents the number of samples in true class i and predicted class j. If eps is not None, the dtype of the output array will be float; otherwise, it will be an integer unless specified with the dtype argument. If sparse is True, a sparse CSR matrix will be returned. \n\nAn example usage of the function is provided in the docstring, where labels_true and labels_pred are given as input, and the resulting contingency matrix is shown.",
    "function_name": "contingency_matrix",
    "ground_truth": "sklearn/metrics/cluster/_supervised.py",
    "test": "sklearn/metrics/cluster/tests/test_supervised.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}