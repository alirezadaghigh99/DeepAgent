{
    "result": "To create the `calibration_curve` function, we will follow these steps:\n\n1. **Import Necessary Libraries**: We'll need NumPy for numerical operations and potentially some functions from scikit-learn for binning and handling the data.\n\n2. **Define the Function Signature**: We'll define the function with the specified parameters.\n\n3. **Validate Inputs**: Ensure that `y_true` and `y_prob` are of the same length and handle the `pos_label` parameter.\n\n4. **Binning Strategy**: Implement the binning strategy based on the `strategy` parameter.\n\n5. **Compute Probabilities**: Calculate the true and predicted probabilities for each bin.\n\n6. **Return the Results**: Return the computed arrays.\n\n7. **Provide Usage Examples**: Demonstrate how to use the function with sample data.\n\nLet's implement this step by step.\n\n### Step 1: Import Necessary Libraries\n\n```python\nimport numpy as np\nfrom sklearn.utils import column_or_1d\nfrom sklearn.preprocessing import label_binarize\n```\n\n### Step 2: Define the Function Signature\n\n```python\ndef calibration_curve(y_true, y_prob, pos_label=None, n_bins=5, strategy='uniform'):\n```\n\n### Step 3: Validate Inputs\n\n```python\n    y_true = column_or_1d(y_true)\n    y_prob = column_or_1d(y_prob)\n    \n    if len(y_true) != len(y_prob):\n        raise ValueError(\"y_true and y_prob must be of the same length.\")\n    \n    if pos_label is None:\n        pos_label = 1\n    \n    y_true = label_binarize(y_true, classes=[pos_label, 1 - pos_label]).ravel()\n```\n\n### Step 4: Binning Strategy\n\n```python\n    if strategy not in ['uniform', 'quantile']:\n        raise ValueError(\"strategy must be either 'uniform' or 'quantile'.\")\n    \n    if strategy == 'uniform':\n        bins = np.linspace(0., 1., n_bins + 1)\n    elif strategy == 'quantile':\n        bins = np.percentile(y_prob, np.linspace(0, 100, n_bins + 1))\n```\n\n### Step 5: Compute Probabilities\n\n```python\n    binids = np.digitize(y_prob, bins) - 1\n    prob_true = np.zeros(n_bins)\n    prob_pred = np.zeros(n_bins)\n    \n    for i in range(n_bins):\n        mask = binids == i\n        if np.any(mask):\n            prob_true[i] = np.mean(y_true[mask])\n            prob_pred[i] = np.mean(y_prob[mask])\n```\n\n### Step 6: Return the Results\n\n```python\n    return prob_true, prob_pred\n```\n\n### Step 7: Provide Usage Examples\n\n```python\n# Example usage\nif __name__ == \"__main__\":\n    y_true = [0, 0, 1, 1]\n    y_prob = [0.1, 0.4, 0.35, 0.8]\n    \n    prob_true, prob_pred = calibration_curve(y_true, y_prob, pos_label=1, n_bins=2, strategy='uniform')\n    print(\"True probabilities:\", prob_true)\n    print(\"Predicted probabilities:\", prob_pred)\n```\n\n### Full Function Code\n\n```python\nimport numpy as np\nfrom sklearn.utils import column_or_1d\nfrom sklearn.preprocessing import label_binarize\n\ndef calibration_curve(y_true, y_prob, pos_label=None, n_bins=5, strategy='uniform'):\n    y_true = column_or_1d(y_true)\n    y_prob = column_or_1d(y_prob)\n    \n    if len(y_true) != len(y_prob):\n        raise ValueError(\"y_true and y_prob must be of the same length.\")\n    \n    if pos_label is None:\n        pos_label = 1\n    \n    y_true = label_binarize(y_true, classes=[pos_label, 1 - pos_label]).ravel()\n    \n    if strategy not in ['uniform', 'quantile']:\n        raise ValueError(\"strategy must be either 'uniform' or 'quantile'.\")\n    \n    if strategy == 'uniform':\n        bins = np.linspace(0., 1., n_bins + 1)\n    elif strategy == 'quantile':\n        bins = np.percentile(y_prob, np.linspace(0, 100, n_bins + 1))\n    \n    binids = np.digitize(y_prob, bins) - 1\n    prob_true = np.zeros(n_bins)\n    prob_pred = np.zeros(n_bins)\n    \n    for i in range(n_bins):\n        mask = binids == i\n        if np.any(mask):\n            prob_true[i] = np.mean(y_true[mask])\n            prob_pred[i] = np.mean(y_prob[mask])\n    \n    return prob_true, prob_pred\n\n# Example usage\nif __name__ == \"__main__\":\n    y_true = [0, 0, 1, 1]\n    y_prob = [0.1, 0.4, 0.35, 0.8]\n    \n    prob_true, prob_pred = calibration_curve(y_true, y_prob, pos_label=1, n_bins=2, strategy='uniform')\n    print(\"True probabilities:\", prob_true)\n    print(\"Predicted probabilities:\", prob_pred)\n```\n\nThis code provides a complete implementation of the `calibration_curve` function, including input validation, binning strategies, and example usage.",
    "prompt": "Generate a Python function called calibration_curve that computes true and predicted probabilities for a calibration curve. The function takes in the following parameters:\n\n- y_true: array-like of shape (n_samples), representing the true targets.\n- y_prob: array-like of shape (n_samples), representing the probabilities of the positive class.\n- pos_label: int, float, bool, or str, default=None, indicating the label of the positive class.\n- n_bins: int, default=5, specifying the number of bins to discretize the [0, 1] interval.\n- strategy: {'uniform', 'quantile'}, default='uniform', determining the strategy used to define the widths of the bins.\n\nThe function returns two arrays:\n- prob_true: ndarray of shape (n_bins,) or smaller, representing the proportion of samples whose class is the positive class in each bin (fraction of positives).\n- prob_pred: ndarray of shape (n_bins,) or smaller, representing the mean predicted probability in each bin.\n\nThe function also includes examples demonstrating how to use it with sample data.",
    "function_name": "calibration_curve",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py::test_calibration_display_pos_label",
    "class": "",
    "stage": "Inference",
    "task": "Classification",
    "data": "Table"
}