{
    "result": "To create the `extract_patches_2d` function, we will follow these steps:\n\n1. **Define the function signature**: The function will take parameters for the image data, patch size, maximum number of patches, and random state.\n\n2. **Validate inputs**: Ensure that the inputs are valid, such as checking the dimensions of the image and the patch size.\n\n3. **Calculate the number of possible patches**: Determine how many patches can be extracted from the image based on the patch size.\n\n4. **Randomly select patches**: Use the random state to select a specified number of patches.\n\n5. **Extract patches**: Extract the patches from the image and store them in an array.\n\n6. **Return the patches**: Return the array of extracted patches.\n\nLet's implement this step by step:\n\n### Step 1: Define the function signature\n\n```python\nimport numpy as np\n\ndef extract_patches_2d(image, patch_size, max_patches=None, random_state=None):\n    \"\"\"\n    Extracts patches from a 2D image.\n\n    Parameters:\n    - image: np.ndarray, the original image data.\n    - patch_size: tuple of two integers, the size of the patches (patch_height, patch_width).\n    - max_patches: int, optional, the maximum number of patches to extract.\n    - random_state: int or np.random.RandomState, optional, the random state for sampling.\n\n    Returns:\n    - patches: np.ndarray, the extracted patches.\n    \"\"\"\n    pass\n```\n\n### Step 2: Validate inputs\n\n```python\ndef extract_patches_2d(image, patch_size, max_patches=None, random_state=None):\n    if not isinstance(image, np.ndarray) or image.ndim != 3:\n        raise ValueError(\"Image must be a 3D numpy array (height, width, channels).\")\n    \n    if len(patch_size) != 2:\n        raise ValueError(\"Patch size must be a tuple of two integers (patch_height, patch_width).\")\n    \n    patch_height, patch_width = patch_size\n    image_height, image_width, _ = image.shape\n    \n    if patch_height > image_height or patch_width > image_width:\n        raise ValueError(\"Patch size must be smaller than the image size.\")\n```\n\n### Step 3: Calculate the number of possible patches\n\n```python\n    n_patches_height = image_height - patch_height + 1\n    n_patches_width = image_width - patch_width + 1\n    total_patches = n_patches_height * n_patches_width\n```\n\n### Step 4: Randomly select patches\n\n```python\n    if max_patches is None:\n        max_patches = total_patches\n    \n    if random_state is None:\n        rng = np.random.default_rng()\n    elif isinstance(random_state, int):\n        rng = np.random.default_rng(random_state)\n    else:\n        rng = random_state\n    \n    selected_patches_indices = rng.choice(total_patches, size=min(max_patches, total_patches), replace=False)\n```\n\n### Step 5: Extract patches\n\n```python\n    patches = []\n    for idx in selected_patches_indices:\n        i = idx // n_patches_width\n        j = idx % n_patches_width\n        patch = image[i:i + patch_height, j:j + patch_width, :]\n        patches.append(patch)\n    \n    patches = np.array(patches)\n```\n\n### Step 6: Return the patches\n\n```python\n    return patches\n```\n\n### Complete Function\n\n```python\nimport numpy as np\n\ndef extract_patches_2d(image, patch_size, max_patches=None, random_state=None):\n    if not isinstance(image, np.ndarray) or image.ndim != 3:\n        raise ValueError(\"Image must be a 3D numpy array (height, width, channels).\")\n    \n    if len(patch_size) != 2:\n        raise ValueError(\"Patch size must be a tuple of two integers (patch_height, patch_width).\")\n    \n    patch_height, patch_width = patch_size\n    image_height, image_width, _ = image.shape\n    \n    if patch_height > image_height or patch_width > image_width:\n        raise ValueError(\"Patch size must be smaller than the image size.\")\n    \n    n_patches_height = image_height - patch_height + 1\n    n_patches_width = image_width - patch_width + 1\n    total_patches = n_patches_height * n_patches_width\n    \n    if max_patches is None:\n        max_patches = total_patches\n    \n    if random_state is None:\n        rng = np.random.default_rng()\n    elif isinstance(random_state, int):\n        rng = np.random.default_rng(random_state)\n    else:\n        rng = random_state\n    \n    selected_patches_indices = rng.choice(total_patches, size=min(max_patches, total_patches), replace=False)\n    \n    patches = []\n    for idx in selected_patches_indices:\n        i = idx // n_patches_width\n        j = idx % n_patches_width\n        patch = image[i:i + patch_height, j:j + patch_width, :]\n        patches.append(patch)\n    \n    patches = np.array(patches)\n    return patches\n```\n\n### Example Usage\n\n```python\n# Example usage\nif __name__ == \"__main__\":\n    # Create a sample image (8x8 pixels with 3 channels)\n    sample_image = np.random.rand(8, 8, 3)\n    \n    # Extract patches\n    patches = extract_patches_2d(sample_image, patch_size=(3, 3), max_patches=5, random_state=42)\n    \n    print(\"Extracted patches shape:\", patches.shape)\n    print(\"Extracted patches:\", patches)\n```\n\nThis function will extract patches from a given 2D image, allowing you to specify the patch size, the maximum number of patches, and a random state for reproducibility.",
    "prompt": "Generate a Python function called extract_patches_2d that reshapes a 2D image into a collection of patches. The function takes in parameters including the original image data, patch size, maximum number of patches to extract, and random state for sampling. It returns an array of patches extracted from the image, with the shape of the patches specified by the patch height, patch width, and number of channels in the image. The function also includes examples demonstrating how to use it with sample image data.",
    "function_name": "extract_patches_2d",
    "ground_truth": "sklearn/feature_extraction/image.py",
    "test": "sklearn/feature_extraction/tests/test_image.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}