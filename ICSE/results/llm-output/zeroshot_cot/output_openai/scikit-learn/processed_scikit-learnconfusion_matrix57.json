{
    "result": "To create a `confusion_matrix` function in Python, we can follow these steps:\n\n1. **Import Necessary Libraries**: We'll need NumPy for array manipulations.\n2. **Define the Function**: The function will take the parameters as described.\n3. **Determine Labels**: If labels are not provided, determine them from `y_true` and `y_pred`.\n4. **Initialize the Confusion Matrix**: Create a matrix of zeros with dimensions based on the number of labels.\n5. **Populate the Confusion Matrix**: Iterate over `y_true` and `y_pred` to fill in the matrix.\n6. **Apply Sample Weights**: If sample weights are provided, apply them to the matrix.\n7. **Normalize the Matrix**: If normalization is requested, normalize the matrix accordingly.\n8. **Return the Matrix**: Finally, return the confusion matrix.\n\nHere's the implementation:\n\n```python\nimport numpy as np\n\ndef confusion_matrix(y_true, y_pred, labels=None, sample_weight=None, normalize=None):\n    # Determine the labels\n    if labels is None:\n        labels = np.unique(np.concatenate((y_true, y_pred)))\n    else:\n        labels = np.asarray(labels)\n    \n    # Create a mapping from label to index\n    label_to_index = {label: index for index, label in enumerate(labels)}\n    \n    # Initialize the confusion matrix\n    n_labels = len(labels)\n    cm = np.zeros((n_labels, n_labels), dtype=np.float64)\n    \n    # Populate the confusion matrix\n    for true, pred in zip(y_true, y_pred):\n        true_index = label_to_index[true]\n        pred_index = label_to_index[pred]\n        cm[true_index, pred_index] += 1\n    \n    # Apply sample weights if provided\n    if sample_weight is not None:\n        sample_weight = np.asarray(sample_weight)\n        for i, (true, pred) in enumerate(zip(y_true, y_pred)):\n            true_index = label_to_index[true]\n            pred_index = label_to_index[pred]\n            cm[true_index, pred_index] += sample_weight[i] - 1\n    \n    # Normalize the confusion matrix if requested\n    if normalize is not None:\n        with np.errstate(all='ignore'):\n            if normalize == 'true':\n                cm = cm / cm.sum(axis=1, keepdims=True)\n            elif normalize == 'pred':\n                cm = cm / cm.sum(axis=0, keepdims=True)\n            elif normalize == 'all':\n                cm = cm / cm.sum()\n            else:\n                raise ValueError(\"normalize must be one of {'true', 'pred', 'all', None}\")\n    \n    return cm\n```\n\n### Explanation:\n\n- **Labels**: If not provided, they are determined from the unique values in `y_true` and `y_pred`.\n- **Confusion Matrix Initialization**: A zero matrix of size `(n_labels, n_labels)` is created.\n- **Population**: For each pair of true and predicted labels, the corresponding cell in the matrix is incremented.\n- **Sample Weights**: If provided, they adjust the counts in the matrix.\n- **Normalization**: The matrix can be normalized by rows, columns, or overall, depending on the `normalize` parameter.\n\nThis function should cover the basic requirements for computing a confusion matrix with optional normalization and sample weighting.",
    "prompt": "Generate a Python function called confusion_matrix that Compute confusion matrix to evaluate the accuracy of a classification.\n\n    By definition a confusion matrix :math:`C` is such that :math:`C_{i, j}`\n    is equal to the number of observations known to be in group :math:`i` and\n    predicted to be in group :math:`j`.\n\n    Thus in binary classification, the count of true negatives is\n    :math:`C_{0,0}`, false negatives is :math:`C_{1,0}`, true positives is\n    :math:`C_{1,1}` and false positives is :math:`C_{0,1}`.\n\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples,)\n        Ground truth (correct) target values.\n\n    y_pred : array-like of shape (n_samples,)\n        Estimated targets as returned by a classifier.\n\n    labels : array-like of shape (n_classes), default=None\n        List of labels to index the matrix. This may be used to reorder\n        or select a subset of labels.\n        If ``None`` is given, those that appear at least once\n        in ``y_true`` or ``y_pred`` are used in sorted order.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights.\n\n        .. versionadded:: 0.18\n\n    normalize : {'true', 'pred', 'all'}, default=None\n        Normalizes confusion matrix over the true (rows), predicted (columns)\n        conditions or all the population. If None, confusion matrix will not be\n        normalized.\n\n    Returns\n    -------\n    C : ndarray of shape (n_classes, n_classes)\n        Confusion matrix whose i-th row and j-th\n        column entry indicates the number of\n        samples with true label being i-th class\n        and predicted label being j-th class.",
    "function_name": "confusion_matrix",
    "ground_truth": "sklearn/metrics/_classification.py",
    "test": "sklearn/metrics/tests/test_classification.py::test_zero_division_nan_no_warning",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": ""
}