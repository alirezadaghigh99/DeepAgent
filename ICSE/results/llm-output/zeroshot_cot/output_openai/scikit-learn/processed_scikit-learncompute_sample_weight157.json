{
    "result": "To create the `compute_sample_weight` function, we'll break down the task into several steps. We'll handle different types of `class_weight` inputs, calculate class frequencies, and compute sample weights accordingly. Let's start by outlining the function and handling the \"balanced\" mode.\n\n### Step 1: Function Definition and Basic Setup\n\nWe'll define the function and handle the input parameters. We'll also import necessary libraries.\n\n```python\nimport numpy as np\nfrom collections import Counter\n\ndef compute_sample_weight(class_weight, y, indices=None):\n    \"\"\"\n    Estimate sample weights by class for unbalanced datasets.\n\n    Parameters:\n    - class_weight: dict, list of dicts, \"balanced\", or None\n        Weights associated with classes.\n    - y: array-like, sparse matrix\n        Original class labels per sample.\n    - indices: array-like of shape (n_subsample,), default=None\n        Indices to be used in a subsample.\n\n    Returns:\n    - sample_weight_vect: numpy array of shape (n_samples,)\n        Sample weights as applied to the original y.\n    \"\"\"\n    # Convert y to a numpy array if it's not already\n    y = np.asarray(y)\n    \n    # If indices are provided, use them to create a subsample of y\n    if indices is not None:\n        y = y[indices]\n    \n    # Initialize sample_weight_vect with ones\n    sample_weight_vect = np.ones(y.shape[0], dtype=np.float64)\n    \n    # Calculate class frequencies\n    class_counts = Counter(y)\n    n_samples = len(y)\n    \n    # Handle the \"balanced\" mode\n    if class_weight == \"balanced\":\n        for cls in class_counts:\n            class_weight = n_samples / (len(class_counts) * class_counts[cls])\n            sample_weight_vect[y == cls] = class_weight\n    \n    return sample_weight_vect\n```\n\n### Step 2: Handling Different `class_weight` Inputs\n\nNext, we'll handle the case where `class_weight` is a dictionary or a list of dictionaries.\n\n```python\n    # Handle dictionary or list of dictionaries for class_weight\n    if isinstance(class_weight, dict):\n        for cls, weight in class_weight.items():\n            sample_weight_vect[y == cls] = weight\n    elif isinstance(class_weight, list):\n        for cw in class_weight:\n            if isinstance(cw, dict):\n                for cls, weight in cw.items():\n                    sample_weight_vect[y == cls] = weight\n```\n\n### Step 3: Error Handling\n\nWe'll add error handling for unsupported `class_weight` types.\n\n```python\n    # Error handling for unsupported class_weight types\n    elif class_weight is not None:\n        raise ValueError(\"class_weight must be 'balanced', a dict, a list of dicts, or None.\")\n```\n\n### Step 4: Usage Examples\n\nFinally, let's add some usage examples to demonstrate how the function can be used.\n\n```python\n# Example usage\nif __name__ == \"__main__\":\n    y = np.array([0, 1, 0, 1, 1, 2, 2, 2, 2])\n    indices = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])\n\n    # Using \"balanced\" mode\n    print(\"Balanced mode:\", compute_sample_weight(\"balanced\", y))\n\n    # Using a dictionary for class weights\n    class_weight_dict = {0: 1.0, 1: 2.0, 2: 0.5}\n    print(\"Class weight dict:\", compute_sample_weight(class_weight_dict, y))\n\n    # Using a list of dictionaries for class weights\n    class_weight_list = [{0: 1.0, 1: 2.0}, {2: 0.5}]\n    print(\"Class weight list:\", compute_sample_weight(class_weight_list, y))\n```\n\nThis function should now handle different scenarios for computing sample weights in unbalanced datasets. It includes error handling and examples for clarity.",
    "prompt": "Create a Python function called compute_sample_weight that estimates sample weights by class for unbalanced datasets. The function takes in three parameters: class_weight (dict, list of dicts, \"balanced\", or None), y (array-like, sparse matrix), and indices (array-like of shape (n_subsample,), default=None). \n\nThe class_weight parameter represents weights associated with classes, with options for different formats and the \"balanced\" mode for automatic adjustment based on class frequencies. The y parameter is an array of original class labels per sample, and the indices parameter is an array of indices to be used in a subsample.\n\nThe function returns a numpy array called sample_weight_vect of shape (n_samples,) containing the sample weights as applied to the original y. The function includes examples of usage and error handling for different scenarios.",
    "function_name": "compute_sample_weight",
    "ground_truth": "sklearn/utils/class_weight.py",
    "test": "sklearn/utils/tests/test_class_weight.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}