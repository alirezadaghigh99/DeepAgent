{
    "result": "To create a function `from_estimator` that plots a calibration curve using a binary classifier and data, we can break down the task into several steps. We'll use libraries such as `matplotlib` for plotting and `sklearn` for calibration curve computation. Here's how you can implement this function step by step:\n\n### Step 1: Import Necessary Libraries\n\nFirst, we need to import the necessary libraries.\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.utils import check_matplotlib_support\nfrom sklearn.base import is_classifier\nfrom sklearn.exceptions import NotFittedError\n```\n\n### Step 2: Define the Function Signature\n\nDefine the function signature with the required parameters.\n\n```python\ndef from_estimator(estimator, X, y, n_bins=10, strategy='uniform', pos_label=None, name=None, ref_line=True, ax=None, **kwargs):\n```\n\n### Step 3: Validate the Estimator\n\nEnsure that the estimator is a fitted classifier.\n\n```python\n    if not is_classifier(estimator):\n        raise ValueError(\"The provided estimator is not a classifier.\")\n    \n    try:\n        y_prob = estimator.predict_proba(X)[:, 1]\n    except NotFittedError:\n        raise ValueError(\"The provided estimator is not fitted yet.\")\n```\n\n### Step 4: Compute the Calibration Curve\n\nUse `calibration_curve` from `sklearn` to compute the calibration curve.\n\n```python\n    prob_true, prob_pred = calibration_curve(y, y_prob, n_bins=n_bins, strategy=strategy, pos_label=pos_label)\n```\n\n### Step 5: Plot the Calibration Curve\n\nPlot the calibration curve using `matplotlib`.\n\n```python\n    check_matplotlib_support('from_estimator')\n    \n    if ax is None:\n        fig, ax = plt.subplots()\n    \n    line_label = name if name is not None else estimator.__class__.__name__\n    ax.plot(prob_pred, prob_true, marker='o', label=line_label, **kwargs)\n    \n    if ref_line:\n        ax.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly calibrated')\n    \n    ax.set_xlabel('Mean predicted probability')\n    ax.set_ylabel('Fraction of positives')\n    ax.set_title('Calibration plot (reliability curve)')\n    ax.legend(loc='best')\n```\n\n### Step 6: Create a CalibrationDisplay Object\n\nCreate a `CalibrationDisplay` object to store the computed values.\n\n```python\n    class CalibrationDisplay:\n        def __init__(self, prob_true, prob_pred, estimator_name):\n            self.prob_true = prob_true\n            self.prob_pred = prob_pred\n            self.estimator_name = estimator_name\n        \n        def plot(self, ax=None, **kwargs):\n            if ax is None:\n                fig, ax = plt.subplots()\n            ax.plot(self.prob_pred, self.prob_true, marker='o', label=self.estimator_name, **kwargs)\n            ax.set_xlabel('Mean predicted probability')\n            ax.set_ylabel('Fraction of positives')\n            ax.set_title('Calibration plot (reliability curve)')\n            ax.legend(loc='best')\n    \n    return CalibrationDisplay(prob_true, prob_pred, line_label)\n```\n\n### Full Function Code\n\nHere is the complete function code:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.utils import check_matplotlib_support\nfrom sklearn.base import is_classifier\nfrom sklearn.exceptions import NotFittedError\n\ndef from_estimator(estimator, X, y, n_bins=10, strategy='uniform', pos_label=None, name=None, ref_line=True, ax=None, **kwargs):\n    if not is_classifier(estimator):\n        raise ValueError(\"The provided estimator is not a classifier.\")\n    \n    try:\n        y_prob = estimator.predict_proba(X)[:, 1]\n    except NotFittedError:\n        raise ValueError(\"The provided estimator is not fitted yet.\")\n    \n    prob_true, prob_pred = calibration_curve(y, y_prob, n_bins=n_bins, strategy=strategy, pos_label=pos_label)\n    \n    check_matplotlib_support('from_estimator')\n    \n    if ax is None:\n        fig, ax = plt.subplots()\n    \n    line_label = name if name is not None else estimator.__class__.__name__\n    ax.plot(prob_pred, prob_true, marker='o', label=line_label, **kwargs)\n    \n    if ref_line:\n        ax.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly calibrated')\n    \n    ax.set_xlabel('Mean predicted probability')\n    ax.set_ylabel('Fraction of positives')\n    ax.set_title('Calibration plot (reliability curve)')\n    ax.legend(loc='best')\n    \n    class CalibrationDisplay:\n        def __init__(self, prob_true, prob_pred, estimator_name):\n            self.prob_true = prob_true\n            self.prob_pred = prob_pred\n            self.estimator_name = estimator_name\n        \n        def plot(self, ax=None, **kwargs):\n            if ax is None:\n                fig, ax = plt.subplots()\n            ax.plot(self.prob_pred, self.prob_true, marker='o', label=self.estimator_name, **kwargs)\n            ax.set_xlabel('Mean predicted probability')\n            ax.set_ylabel('Fraction of positives')\n            ax.set_title('Calibration plot (reliability curve)')\n            ax.legend(loc='best')\n    \n    return CalibrationDisplay(prob_true, prob_pred, line_label)\n```\n\nThis function will plot a calibration curve for a given binary classifier and dataset, and return a `CalibrationDisplay` object that can be used to further manipulate or display the plot.",
    "prompt": "Generate a Python function called from_estimator that plots a calibration curve using a binary classifier and data. The function takes in parameters such as estimator (fitted classifier), X (input values), y (binary target values), n_bins (number of bins for discretization), strategy (bin width strategy), pos_label (positive class label), name (label for curve), ref_line (whether to plot a reference line), ax (matplotlib axes), and additional keyword arguments. The function returns a CalibrationDisplay object that stores computed values.",
    "function_name": "from_estimator",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}