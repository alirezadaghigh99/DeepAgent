{
    "result": "To create the `johnson_lindenstrauss_min_dim` function, we need to understand the Johnson-Lindenstrauss (JL) lemma. The JL lemma states that a small set of points in a high-dimensional space can be embedded into a lower-dimensional space such that the distances between the points are nearly preserved. The lemma provides a bound on the number of dimensions required to achieve this embedding with a given distortion rate.\n\nThe formula to calculate the minimum number of dimensions \\( k \\) required is:\n\n\\[ k \\geq \\frac{4 \\ln(n)}{\\epsilon^2 / 2 - \\epsilon^3 / 3} \\]\n\nwhere:\n- \\( n \\) is the number of samples.\n- \\( \\epsilon \\) is the maximum distortion rate.\n\nLet's start by implementing the function step by step.\n\n### Step 1: Import Necessary Libraries\n\nWe'll need the `numpy` library to handle array-like inputs and mathematical operations.\n\n```python\nimport numpy as np\n```\n\n### Step 2: Define the Function\n\nWe'll define the function `johnson_lindenstrauss_min_dim` with parameters for the number of samples and the distortion rate.\n\n```python\ndef johnson_lindenstrauss_min_dim(n_samples, eps):\n    \"\"\"\n    Calculate the minimum number of components required for a random projection\n    to ensure an eps-embedding with good probability, according to the\n    Johnson-Lindenstrauss lemma.\n\n    Parameters:\n    n_samples (int or array-like): The number of samples.\n    eps (float or array-like): The maximum distortion rate.\n\n    Returns:\n    int or np.ndarray: The minimal number of components required.\n    \"\"\"\n```\n\n### Step 3: Handle Array-like Inputs\n\nWe'll ensure that the inputs can be handled as arrays, which allows the function to process multiple values at once.\n\n```python\n    n_samples = np.atleast_1d(n_samples)\n    eps = np.atleast_1d(eps)\n```\n\n### Step 4: Calculate the Minimum Number of Dimensions\n\nWe'll use the formula provided by the JL lemma to calculate the minimum number of dimensions.\n\n```python\n    if np.any(eps <= 0) or np.any(eps >= 1):\n        raise ValueError(\"eps must be between 0 and 1 (exclusive).\")\n    \n    min_dim = (4 * np.log(n_samples)) / (eps**2 / 2 - eps**3 / 3)\n    return np.ceil(min_dim).astype(int)\n```\n\n### Step 5: Provide Usage Examples\n\nFinally, let's add some examples of how to use the function.\n\n```python\n# Example usage:\n# Calculate the minimum number of dimensions for 1000 samples with a distortion rate of 0.1\nprint(johnson_lindenstrauss_min_dim(1000, 0.1))\n\n# Calculate for multiple samples and distortion rates\nprint(johnson_lindenstrauss_min_dim([100, 1000, 10000], [0.1, 0.2, 0.3]))\n```\n\n### Complete Function\n\nHere's the complete function with all the steps combined:\n\n```python\nimport numpy as np\n\ndef johnson_lindenstrauss_min_dim(n_samples, eps):\n    \"\"\"\n    Calculate the minimum number of components required for a random projection\n    to ensure an eps-embedding with good probability, according to the\n    Johnson-Lindenstrauss lemma.\n\n    Parameters:\n    n_samples (int or array-like): The number of samples.\n    eps (float or array-like): The maximum distortion rate.\n\n    Returns:\n    int or np.ndarray: The minimal number of components required.\n    \"\"\"\n    n_samples = np.atleast_1d(n_samples)\n    eps = np.atleast_1d(eps)\n    \n    if np.any(eps <= 0) or np.any(eps >= 1):\n        raise ValueError(\"eps must be between 0 and 1 (exclusive).\")\n    \n    min_dim = (4 * np.log(n_samples)) / (eps**2 / 2 - eps**3 / 3)\n    return np.ceil(min_dim).astype(int)\n\n# Example usage:\nprint(johnson_lindenstrauss_min_dim(1000, 0.1))\nprint(johnson_lindenstrauss_min_dim([100, 1000, 10000], [0.1, 0.2, 0.3]))\n```\n\nThis function calculates the minimum number of dimensions required for a random projection to ensure an eps-embedding with good probability, based on the Johnson-Lindenstrauss lemma.",
    "prompt": "Generate a Python function called johnson_lindenstrauss_min_dim that calculates the minimum number of components needed to guarantee a distortion rate within a specified range for a random projection. The function takes in the number of samples (n_samples) as an integer or array-like input and the maximum distortion rate (eps) as a float or array-like input. It returns the minimal number of components required to ensure an eps-embedding with good probability for the given number of samples. The function also includes references to the Johnson-Lindenstrauss lemma and provides examples of usage.",
    "function_name": "johnson_lindenstrauss_min_dim",
    "ground_truth": "sklearn/random_projection.py",
    "test": "sklearn/tests/test_random_projection.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Table"
}