{
    "result": "To implement the `orthogonal_mp_gram` function, we will follow these steps:\n\n1. **Input Validation and Initialization**: Validate the inputs and initialize necessary variables.\n2. **Precompute the Gram Matrix**: If `precompute` is enabled, compute the Gram matrix.\n3. **Orthogonal Matching Pursuit Algorithm**: Implement the OMP algorithm to iteratively select features and update the solution.\n4. **Return Results**: Return the coefficients and optionally the number of iterations and the coefficient path.\n\nLet's go through each step in detail:\n\n### Step 1: Input Validation and Initialization\n\nFirst, we need to validate the inputs and initialize variables. This includes checking the dimensions of `X` and `y`, setting default values for `n_nonzero_coefs`, and handling the `copy_X` parameter.\n\n```python\nimport numpy as np\n\ndef orthogonal_mp_gram(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):\n    X = np.array(X, copy=copy_X)\n    y = np.array(y)\n    \n    n_samples, n_features = X.shape\n    \n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    \n    n_targets = y.shape[1]\n    \n    if n_nonzero_coefs is None:\n        n_nonzero_coefs = max(1, int(0.1 * n_features))\n    \n    if n_nonzero_coefs > n_features:\n        raise ValueError(\"Number of non-zero coefficients cannot exceed the number of features.\")\n    \n    if tol is not None:\n        n_nonzero_coefs = n_features  # Allow full iteration if tol is specified\n    \n    if precompute == 'auto':\n        precompute = n_samples > n_features\n    \n    coef_path = [] if return_path else None\n```\n\n### Step 2: Precompute the Gram Matrix\n\nIf `precompute` is enabled, compute the Gram matrix `G = X^T X` and the target projections `X^T y`.\n\n```python\n    if precompute:\n        G = np.dot(X.T, X)\n        Xy = np.dot(X.T, y)\n    else:\n        G = None\n        Xy = None\n```\n\n### Step 3: Orthogonal Matching Pursuit Algorithm\n\nImplement the OMP algorithm to iteratively select features and update the solution.\n\n```python\n    coef = np.zeros((n_features, n_targets))\n    residual = y.copy()\n    indices = []\n    n_iter = 0\n    \n    for _ in range(n_nonzero_coefs):\n        if tol is not None and np.sum(residual ** 2) <= tol:\n            break\n        \n        if precompute:\n            correlations = np.dot(G, coef) - Xy\n        else:\n            correlations = np.dot(X.T, residual)\n        \n        # Select the feature with the maximum correlation\n        new_idx = np.argmax(np.sum(correlations ** 2, axis=1))\n        indices.append(new_idx)\n        \n        # Update the coefficients\n        A = X[:, indices]\n        coef_active, _, _, _ = np.linalg.lstsq(A, y, rcond=None)\n        residual = y - np.dot(A, coef_active)\n        \n        # Store the coefficients\n        coef[indices, :] = coef_active\n        \n        if return_path:\n            coef_path.append(coef.copy())\n        \n        n_iter += 1\n```\n\n### Step 4: Return Results\n\nFinally, return the coefficients and optionally the number of iterations and the coefficient path.\n\n```python\n    if return_path:\n        coef_path = np.array(coef_path)\n    \n    if return_n_iter:\n        return coef.squeeze(), n_iter, coef_path if return_path else None\n    else:\n        return coef.squeeze(), coef_path if return_path else None\n```\n\n### Complete Function\n\nHere is the complete `orthogonal_mp_gram` function:\n\n```python\nimport numpy as np\n\ndef orthogonal_mp_gram(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):\n    X = np.array(X, copy=copy_X)\n    y = np.array(y)\n    \n    n_samples, n_features = X.shape\n    \n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    \n    n_targets = y.shape[1]\n    \n    if n_nonzero_coefs is None:\n        n_nonzero_coefs = max(1, int(0.1 * n_features))\n    \n    if n_nonzero_coefs > n_features:\n        raise ValueError(\"Number of non-zero coefficients cannot exceed the number of features.\")\n    \n    if tol is not None:\n        n_nonzero_coefs = n_features  # Allow full iteration if tol is specified\n    \n    if precompute == 'auto':\n        precompute = n_samples > n_features\n    \n    coef_path = [] if return_path else None\n    \n    if precompute:\n        G = np.dot(X.T, X)\n        Xy = np.dot(X.T, y)\n    else:\n        G = None\n        Xy = None\n    \n    coef = np.zeros((n_features, n_targets))\n    residual = y.copy()\n    indices = []\n    n_iter = 0\n    \n    for _ in range(n_nonzero_coefs):\n        if tol is not None and np.sum(residual ** 2) <= tol:\n            break\n        \n        if precompute:\n            correlations = np.dot(G, coef) - Xy\n        else:\n            correlations = np.dot(X.T, residual)\n        \n        # Select the feature with the maximum correlation\n        new_idx = np.argmax(np.sum(correlations ** 2, axis=1))\n        indices.append(new_idx)\n        \n        # Update the coefficients\n        A = X[:, indices]\n        coef_active, _, _, _ = np.linalg.lstsq(A, y, rcond=None)\n        residual = y - np.dot(A, coef_active)\n        \n        # Store the coefficients\n        coef[indices, :] = coef_active\n        \n        if return_path:\n            coef_path.append(coef.copy())\n        \n        n_iter += 1\n    \n    if return_path:\n        coef_path = np.array(coef_path)\n    \n    if return_n_iter:\n        return coef.squeeze(), n_iter, coef_path if return_path else None\n    else:\n        return coef.squeeze(), coef_path if return_path else None\n```\n\nThis function implements the Orthogonal Matching Pursuit algorithm with options for precomputing the Gram matrix, returning the coefficient path, and returning the number of iterations.",
    "prompt": "Create a Python function `orthogonal_mp_gram` that implements the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems. The function should accept the following parameters:\n- `X`: A 2D array-like of shape `(n_samples, n_features)` representing the input data. Columns should be assumed to have unit norm.\n- `y`: A 1D or 2D array-like of shape `(n_samples,)` or `(n_samples, n_targets)` representing the target values.\n- `n_nonzero_coefs`: An integer specifying the desired number of non-zero coefficients in the solution. If `None`, this defaults to 10% of the number of features.\n- `tol`: A float specifying the maximum squared norm of the residual. If provided, this overrides `n_nonzero_coefs`.\n- `precompute`: A boolean or the string `'auto'` indicating whether to precompute the Gram matrix for faster computation when `n_targets` or `n_samples` is large.\n- `copy_X`: A boolean indicating whether to copy the input matrix `X` (default is `True`).\n- `return_path`: A boolean indicating whether to return the entire coefficient path for each iteration.\n- `return_n_iter`: A boolean indicating whether to return the number of iterations taken for convergence.\n\nThe function should return the coefficients of the OMP solution as a 1D or 2D NumPy array, depending on the input, with an option to return the number of iterations if `return_n_iter` is `True`. Handle edge cases such as when the number of non-zero coefficients exceeds the number of features by raising a `ValueError`. The function should use efficient computation techniques, including the option to precompute the Gram matrix if `precompute` is enabled.",
    "function_name": "orthogonal_mp_gram",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Classification",
    "data": "Table"
}