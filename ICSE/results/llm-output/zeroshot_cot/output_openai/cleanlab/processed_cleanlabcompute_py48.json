{
    "result": "To create the `compute_py` function, we will break down the task into several steps. We'll start by defining the function signature and then implement the logic for each method (`cnt`, `eqn`, `marginal`, `marginal_ps`) to compute the prior probabilities. We'll also include error handling for invalid input shapes and missing parameters. Finally, we'll ensure the output is clipped between 0 and 1.\n\n### Step 1: Define the Function Signature and Basic Structure\n\nFirst, let's define the function signature and basic structure, including input validation.\n\n```python\nimport numpy as np\n\ndef compute_py(ps, noise_matrix, inverse_noise_matrix, py_method, true_labels_class_counts):\n    \"\"\"\n    Computes the prior probability of true class labels based on observed noisy labels.\n\n    Parameters:\n    - ps: Array-like, shape (K,) or (1, K), observed noisy label probabilities.\n    - noise_matrix: Array-like, shape (K, K), noise matrix.\n    - inverse_noise_matrix: Array-like, shape (K, K), inverse of the noise matrix.\n    - py_method: String, method to compute prior probabilities ('cnt', 'eqn', 'marginal', 'marginal_ps').\n    - true_labels_class_counts: Array-like, shape (K,), counts of true class labels.\n\n    Returns:\n    - py: Array, shape (K,) or (1, K), prior probability of each true class label.\n    \"\"\"\n    # Convert inputs to numpy arrays for easier manipulation\n    ps = np.asarray(ps)\n    noise_matrix = np.asarray(noise_matrix)\n    inverse_noise_matrix = np.asarray(inverse_noise_matrix)\n    true_labels_class_counts = np.asarray(true_labels_class_counts)\n\n    # Validate input shapes\n    K = ps.shape[-1]\n    if noise_matrix.shape != (K, K) or inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\"Noise matrices must be of shape (K, K).\")\n    if true_labels_class_counts.shape != (K,):\n        raise ValueError(\"true_labels_class_counts must be of shape (K,).\")\n\n    # Initialize py\n    py = np.zeros(K)\n\n    # Compute py based on the specified method\n    if py_method == 'cnt':\n        # Method: cnt\n        py = true_labels_class_counts / np.sum(true_labels_class_counts)\n    elif py_method == 'eqn':\n        # Method: eqn\n        py = np.dot(inverse_noise_matrix, ps)\n    elif py_method == 'marginal':\n        # Method: marginal\n        py = np.dot(ps, noise_matrix)\n    elif py_method == 'marginal_ps':\n        # Method: marginal_ps\n        py = np.dot(ps, noise_matrix) / np.sum(np.dot(ps, noise_matrix))\n    else:\n        raise ValueError(\"Invalid py_method. Choose from 'cnt', 'eqn', 'marginal', 'marginal_ps'.\")\n\n    # Clip py to ensure values are between 0 and 1\n    py = np.clip(py, 0, 1)\n\n    return py\n```\n\n### Step 2: Explanation of Each Method\n\n- **`cnt`**: This method calculates the prior probabilities directly from the counts of true class labels. It normalizes the counts to sum to 1.\n- **`eqn`**: This method uses the inverse noise matrix to estimate the prior probabilities from the observed noisy label probabilities.\n- **`marginal`**: This method computes the marginal probabilities by multiplying the observed probabilities with the noise matrix.\n- **`marginal_ps`**: Similar to `marginal`, but it normalizes the result to ensure it sums to 1.\n\n### Step 3: Error Handling\n\nThe function includes error handling for:\n- Invalid shapes of the noise matrices and true label counts.\n- Invalid `py_method` values.\n\n### Step 4: Clipping the Output\n\nThe output `py` is clipped to ensure all values are between 0 and 1, which is a common practice to handle numerical stability issues.\n\nThis function should now be ready to use for computing prior probabilities based on the specified method.",
    "prompt": "Generate a Python function called compute_py that computes the prior probability of true class labels based on observed noisy labels, noise matrices, and inverse noise matrices. The function takes in parameters ps, noise_matrix, inverse_noise_matrix, py_method, and true_labels_class_counts. The function returns an array py of shape (K,) or (1, K) containing the prior probability of each true class label. The function includes error handling for invalid input shapes and missing parameters, and uses different methods (cnt, eqn, marginal, marginal_ps) to compute the prior probabilities based on the specified py_method. The output array py is clipped to ensure values are between 0 and 1.",
    "function_name": "compute_py",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}