{
    "result": "To create a confusion matrix function in Python without using `sklearn`, we can follow these steps:\n\n1. **Validate Input**: Ensure that the `true` and `pred` arrays are of the same length and contain the same set of distinct labels.\n\n2. **Determine Unique Classes**: Identify the unique class labels present in the `true` and `pred` arrays.\n\n3. **Initialize the Confusion Matrix**: Create a square matrix of size `K x K`, where `K` is the number of unique classes.\n\n4. **Populate the Confusion Matrix**: Iterate over the `true` and `pred` arrays, incrementing the appropriate cell in the matrix for each pair of true and predicted labels.\n\n5. **Return the Confusion Matrix**: Output the populated confusion matrix.\n\nLet's implement this step by step:\n\n### Step 1: Validate Input\n\nFirst, we need to ensure that the input arrays are valid.\n\n```python\nimport numpy as np\n\ndef confusion_matrix(true, pred):\n    # Check if the input arrays are of the same length\n    if len(true) != len(pred):\n        raise ValueError(\"The length of true and pred must be the same.\")\n    \n    # Check if both arrays contain the same set of distinct labels\n    unique_true = np.unique(true)\n    unique_pred = np.unique(pred)\n    \n    if not np.array_equal(unique_true, unique_pred):\n        raise ValueError(\"True and pred must contain the same set of distinct labels.\")\n    \n    # Proceed to the next step\n```\n\n### Step 2: Determine Unique Classes\n\nIdentify the unique class labels.\n\n```python\n    # Determine the unique classes\n    classes = unique_true  # or unique_pred, since they are the same\n    num_classes = len(classes)\n```\n\n### Step 3: Initialize the Confusion Matrix\n\nCreate a zero-initialized matrix of size `K x K`.\n\n```python\n    # Initialize the confusion matrix\n    conf_matrix = np.zeros((num_classes, num_classes), dtype=int)\n```\n\n### Step 4: Populate the Confusion Matrix\n\nIterate over the `true` and `pred` arrays to fill the matrix.\n\n```python\n    # Create a mapping from class label to index\n    class_to_index = {label: index for index, label in enumerate(classes)}\n    \n    # Populate the confusion matrix\n    for t, p in zip(true, pred):\n        true_index = class_to_index[t]\n        pred_index = class_to_index[p]\n        conf_matrix[true_index, pred_index] += 1\n```\n\n### Step 5: Return the Confusion Matrix\n\nFinally, return the populated confusion matrix.\n\n```python\n    return conf_matrix\n```\n\n### Complete Function\n\nHere is the complete function:\n\n```python\nimport numpy as np\n\ndef confusion_matrix(true, pred):\n    # Check if the input arrays are of the same length\n    if len(true) != len(pred):\n        raise ValueError(\"The length of true and pred must be the same.\")\n    \n    # Check if both arrays contain the same set of distinct labels\n    unique_true = np.unique(true)\n    unique_pred = np.unique(pred)\n    \n    if not np.array_equal(unique_true, unique_pred):\n        raise ValueError(\"True and pred must contain the same set of distinct labels.\")\n    \n    # Determine the unique classes\n    classes = unique_true  # or unique_pred, since they are the same\n    num_classes = len(classes)\n    \n    # Initialize the confusion matrix\n    conf_matrix = np.zeros((num_classes, num_classes), dtype=int)\n    \n    # Create a mapping from class label to index\n    class_to_index = {label: index for index, label in enumerate(classes)}\n    \n    # Populate the confusion matrix\n    for t, p in zip(true, pred):\n        true_index = class_to_index[t]\n        pred_index = class_to_index[p]\n        conf_matrix[true_index, pred_index] += 1\n    \n    return conf_matrix\n```\n\nThis function should now correctly compute the confusion matrix for the given true and predicted labels without relying on `sklearn`.",
    "prompt": "Generate a Python function called confusion_matrix that iImplements a confusion matrix for true labels\n    and predicted labels. true and pred MUST BE the same length\n    and have the same distinct set of class labels represented.\n\n    Results are identical (and similar computation time) to:\n        \"sklearn.metrics.confusion_matrix\"\n\n    However, this function avoids the dependency on sklearn.\n\n    Parameters\n    ----------\n    true : np.ndarray 1d\n      Contains labels.\n      Assumes true and pred contains the same set of distinct labels.\n\n    pred : np.ndarray 1d\n      A discrete vector of noisy labels, i.e. some labels may be erroneous.\n      *Format requirements*: for dataset with K classes, labels must be in {0,1,...,K-1}.\n\n    Returns\n    -------\n    confusion_matrix : np.ndarray (2D)\n      matrix of confusion counts with true on rows and pred on columns",
    "function_name": "confusion_matrix",
    "ground_truth": "cleanlab/internal/util.py",
    "test": "tests/test_util.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}