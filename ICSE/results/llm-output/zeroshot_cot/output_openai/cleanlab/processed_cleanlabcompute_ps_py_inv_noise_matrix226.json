{
    "result": "To generate the `compute_ps_py_inv_noise_matrix` function, we need to break down the task into smaller steps. We'll start by understanding the requirements and then implement each part of the function.\n\n### Step 1: Compute `ps` and `py`\n\n- `ps` is the empirical distribution of the noisy labels, i.e., `P(labels=k)`.\n- `py` is the empirical distribution of the true labels, i.e., `P(true_labels=k)`.\n\nTo compute `ps`, we can count the occurrences of each label in the `labels` array and normalize by the total number of labels. For `py`, we will use the noise matrix to estimate the distribution of true labels.\n\n### Step 2: Compute the Inverse Noise Matrix\n\nThe inverse noise matrix is the inverse of the given noise matrix. This matrix is used to estimate the true label distribution from the noisy label distribution.\n\n### Step 3: Implement the Function\n\nLet's implement the function step by step.\n\n```python\nimport numpy as np\n\ndef compute_ps_py_inv_noise_matrix(labels, noise_matrix):\n    \"\"\"\n    Compute ps := P(labels=k), py := P(true_labels=k), and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n        A discrete vector of noisy labels, i.e. some labels may be erroneous.\n        *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.\n\n    Returns\n    -------\n    ps : np.ndarray\n        The empirical distribution of the noisy labels.\n\n    py : np.ndarray\n        The estimated distribution of the true labels.\n\n    inv_noise_matrix : np.ndarray\n        The inverse of the noise matrix.\n    \"\"\"\n    # Step 1: Compute ps\n    K = noise_matrix.shape[0]\n    label_counts = np.bincount(labels, minlength=K)\n    ps = label_counts / len(labels)\n\n    # Step 2: Compute the inverse noise matrix\n    inv_noise_matrix = np.linalg.inv(noise_matrix)\n\n    # Step 3: Compute py\n    py = inv_noise_matrix @ ps\n\n    return ps, py, inv_noise_matrix\n\n# Example usage:\n# labels = np.array([0, 1, 1, 2, 2, 2])\n# noise_matrix = np.array([[0.9, 0.1, 0.0],\n#                          [0.1, 0.8, 0.1],\n#                          [0.0, 0.2, 0.8]])\n# ps, py, inv_noise_matrix = compute_ps_py_inv_noise_matrix(labels, noise_matrix)\n```\n\n### Explanation\n\n- **`ps` Calculation**: We use `np.bincount` to count occurrences of each label and normalize by the total number of labels.\n- **Inverse Noise Matrix**: We use `np.linalg.inv` to compute the inverse of the noise matrix.\n- **`py` Calculation**: We multiply the inverse noise matrix by `ps` to estimate the true label distribution.\n\nThis function assumes that the noise matrix is invertible. If the noise matrix is not invertible, the function will raise an error.",
    "prompt": "Generate a Python function called compute_ps_py_inv_noise_matrix that Compute ``ps := P(labels=k), py := P(true_labels=k)``, and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n          A discrete vector of noisy labels, i.e. some labels may be erroneous.\n          *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.",
    "function_name": "compute_ps_py_inv_noise_matrix",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}