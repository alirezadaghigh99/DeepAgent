{
    "result": "To compute `pyx := P(true_label=k|x)` from `pred_probs := P(label=k|x)`, `noise_matrix`, and `inverse_noise_matrix`, we need to follow these steps:\n\n1. **Validate Input Shapes**: Ensure that `pred_probs` is a 2D array and that `noise_matrix` and `inverse_noise_matrix` are square matrices with the same number of classes as the number of columns in `pred_probs`.\n\n2. **Compute `pyx`**: Use the relationship between the predicted probabilities, noise matrix, and inverse noise matrix to compute the true label probabilities. The relationship can be expressed as:\n   \\[\n   P(\\text{true\\_label}=k|x) = \\text{inverse\\_noise\\_matrix} \\times P(\\text{label}=k|x)\n   \\]\n   This involves a matrix multiplication of the inverse noise matrix with the predicted probabilities.\n\n3. **Normalize `pyx`**: Ensure that the resulting probabilities for each example sum to 1.\n\nHere's the Python function implementing these steps:\n\n```python\nimport numpy as np\n\ndef compute_pyx(pred_probs, noise_matrix, inverse_noise_matrix):\n    # Validate input shapes\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )\n    \n    N, K = pred_probs.shape\n    \n    if noise_matrix.shape != (K, K):\n        raise ValueError(\n            \"Input parameter np.ndarray 'noise_matrix' has shape \"\n            + str(noise_matrix.shape)\n            + \", but shape should be (K, K)\"\n        )\n    \n    if inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\n            \"Input parameter np.ndarray 'inverse_noise_matrix' has shape \"\n            + str(inverse_noise_matrix.shape)\n            + \", but shape should be (K, K)\"\n        )\n    \n    # Compute pyx using the inverse noise matrix\n    pyx = np.dot(pred_probs, inverse_noise_matrix)\n    \n    # Normalize pyx to ensure each row sums to 1\n    pyx /= pyx.sum(axis=1, keepdims=True)\n    \n    return pyx\n```\n\n### Explanation:\n- **Input Validation**: We check that `pred_probs` is a 2D array and that both `noise_matrix` and `inverse_noise_matrix` are square matrices with dimensions `(K, K)`.\n- **Matrix Multiplication**: We compute `pyx` by multiplying `pred_probs` with `inverse_noise_matrix`.\n- **Normalization**: We ensure that each row of `pyx` sums to 1, which is a requirement for probability distributions.\n\nThis function assumes that the `inverse_noise_matrix` is provided. If it is not, you would need additional logic to compute it from `pred_probs` and `labels`, which is not covered in this function.",
    "prompt": "\"Write a python function compute_pyx Compute ``pyx := P(true_label=k|x)`` from ``pred_probs := P(label=k|x)``, `noise_matrix` and\n    `inverse_noise_matrix`.\n\n    This method is ROBUST - meaning it works well even when the\n    noise matrices are estimated poorly by only using the diagonals of the\n    matrices which tend to be easy to estimate correctly.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        ``P(label=k|x)`` is a ``(N x K)`` matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of `noise_matrix` sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``)  of the form ``P(true_label=k_y|label=k_s)`` representing\n        the estimated fraction observed examples in each class `k_s`, that are\n        mislabeled examples from every other class `k_y`. If None, the\n        inverse_noise_matrix will be computed from `pred_probs` and `labels`.\n        Assumes columns of `inverse_noise_matrix` sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        ``P(true_label=k|x)`` is a  ``(N, K)`` matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )",
    "function_name": "compute_pyx",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}