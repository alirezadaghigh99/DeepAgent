{
    "result": "To create the `find_overlapping_classes` function, we'll break down the task into several steps. We'll start by defining the function signature and then implement the logic to handle the different input scenarios. Finally, we'll compute the overlapping classes and return the results in a Pandas DataFrame.\n\n### Step 1: Define the Function Signature\n\nWe'll start by defining the function signature with the parameters as described in the prompt.\n\n```python\nimport numpy as np\nimport pandas as pd\n\ndef find_overlapping_classes(labels=None, pred_probs=None, asymmetric=False, class_names=None, num_examples=None, joint=None, confident_joint=None):\n    \"\"\"\n    Finds pairs of classes that are often mislabeled as one another.\n    \n    Parameters\n    ----------\n    labels : np.ndarray or list, optional\n        An array_like of noisy labels for the classification dataset.\n    pred_probs : np.ndarray, optional\n        An array of shape (N, K) of model-predicted probabilities.\n    asymmetric : bool, optional\n        If True, returns separate estimates for both pairs (class1, class2) and (class2, class1).\n    class_names : Iterable[str], optional\n        A list or other iterable of the string class names.\n    num_examples : int or None, optional\n        The number of examples in the dataset.\n    joint : np.ndarray, optional\n        An array of shape (K, K) representing the estimated joint distribution.\n    confident_joint : np.ndarray, optional\n        An array of shape (K, K) representing the confident joint.\n    \n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\".\n    \"\"\"\n    # Implementation will go here\n```\n\n### Step 2: Handle Input Scenarios\n\nWe'll implement logic to handle the different input scenarios. We'll compute the `confident_joint` if it's not provided and use the `joint` if available.\n\n```python\n    if joint is not None:\n        if num_examples is None:\n            raise ValueError(\"num_examples must be provided if joint is used.\")\n        confident_joint = joint * num_examples\n    elif confident_joint is None:\n        if labels is None or pred_probs is None:\n            raise ValueError(\"Either joint, confident_joint, or both labels and pred_probs must be provided.\")\n        # Compute the confident_joint from labels and pred_probs\n        # This is a placeholder for the actual computation\n        confident_joint = compute_confident_joint(labels, pred_probs)\n        num_examples = len(labels)\n    else:\n        num_examples = np.sum(confident_joint)\n```\n\n### Step 3: Compute Overlapping Classes\n\nWe'll compute the overlapping classes based on the `confident_joint` matrix.\n\n```python\n    K = confident_joint.shape[0]\n    overlapping_data = []\n\n    for i in range(K):\n        for j in range(i + 1, K):\n            num_overlapping = confident_joint[i, j] + confident_joint[j, i]\n            joint_prob = num_overlapping / num_examples\n            overlapping_data.append((i, j, num_overlapping, joint_prob))\n\n    if asymmetric:\n        overlapping_data = []\n        for i in range(K):\n            for j in range(K):\n                if i != j:\n                    num_overlapping = confident_joint[i, j]\n                    joint_prob = num_overlapping / num_examples\n                    overlapping_data.append((i, j, num_overlapping, joint_prob))\n```\n\n### Step 4: Create and Return the DataFrame\n\nFinally, we'll create a Pandas DataFrame from the computed data and return it.\n\n```python\n    df = pd.DataFrame(overlapping_data, columns=[\"Class Index A\", \"Class Index B\", \"Num Overlapping Examples\", \"Joint Probability\"])\n    df = df.sort_values(by=\"Joint Probability\", ascending=False).reset_index(drop=True)\n    \n    return df\n```\n\n### Step 5: Complete Function\n\nHere's the complete function:\n\n```python\nimport numpy as np\nimport pandas as pd\n\ndef find_overlapping_classes(labels=None, pred_probs=None, asymmetric=False, class_names=None, num_examples=None, joint=None, confident_joint=None):\n    if joint is not None:\n        if num_examples is None:\n            raise ValueError(\"num_examples must be provided if joint is used.\")\n        confident_joint = joint * num_examples\n    elif confident_joint is None:\n        if labels is None or pred_probs is None:\n            raise ValueError(\"Either joint, confident_joint, or both labels and pred_probs must be provided.\")\n        # Compute the confident_joint from labels and pred_probs\n        # This is a placeholder for the actual computation\n        confident_joint = compute_confident_joint(labels, pred_probs)\n        num_examples = len(labels)\n    else:\n        num_examples = np.sum(confident_joint)\n\n    K = confident_joint.shape[0]\n    overlapping_data = []\n\n    for i in range(K):\n        for j in range(i + 1, K):\n            num_overlapping = confident_joint[i, j] + confident_joint[j, i]\n            joint_prob = num_overlapping / num_examples\n            overlapping_data.append((i, j, num_overlapping, joint_prob))\n\n    if asymmetric:\n        overlapping_data = []\n        for i in range(K):\n            for j in range(K):\n                if i != j:\n                    num_overlapping = confident_joint[i, j]\n                    joint_prob = num_overlapping / num_examples\n                    overlapping_data.append((i, j, num_overlapping, joint_prob))\n\n    df = pd.DataFrame(overlapping_data, columns=[\"Class Index A\", \"Class Index B\", \"Num Overlapping Examples\", \"Joint Probability\"])\n    df = df.sort_values(by=\"Joint Probability\", ascending=False).reset_index(drop=True)\n    \n    return df\n```\n\nThis function should now be able to handle the different input scenarios and return the pairs of classes that are often mislabeled as one another. Note that the `compute_confident_joint` function is a placeholder and should be implemented or replaced with an appropriate method to compute the confident joint from `labels` and `pred_probs`.",
    "prompt": "Generate a Python function called find_overlapping_classes that rReturns the pairs of classes that are often mislabeled as one another.\n    Consider merging the top pairs of classes returned by this method each into a single class.\n    If the dataset is labeled by human annotators, consider clearly defining the\n    difference between the classes prior to having annotators label the data.\n    This method provides two scores in the Pandas DataFrame that is returned:\n    * **Num Overlapping Examples**: The number of examples where the two classes overlap\n    * **Joint Probability**: `(num overlapping examples / total number of examples in the dataset`).\n    This method works by providing any one (and only one) of the following inputs:\n    1. ``labels`` and ``pred_probs``, or\n    2. ``joint`` and ``num_examples``, or\n    3. ``confident_joint``\n      Parameters\n    ----------\n    labels : np.ndarray or list, optional\n      An array_like (of length N) of noisy labels for the classification dataset, i.e. some labels may be erroneous.\n      Elements must be integers in the set 0, 1, ..., K-1, where K is the number of classes.\n      All the classes (0, 1, ..., and K-1) should be present in ``labels``, such that\n      ``len(set(labels)) == pred_probs.shape[1]`` for standard multi-class classification with single-labeled data (e.g. ``labels =  [1,0,2,1,1,0...]``).\n      For multi-label classification where each example can belong to multiple classes (e.g. ``labels = [[1,2],[1],[0],[],...]``),\n      your labels should instead satisfy: ``len(set(k for l in labels for k in l)) == pred_probs.shape[1])``.\n\n    pred_probs : np.ndarray, optional\n      An array of shape ``(N, K)`` of model-predicted probabilities,\n      ``P(label=k|x)``. Each row of this matrix corresponds\n      to an example `x` and contains the model-predicted probabilities that\n      `x` belongs to each possible class, for each of the K classes. The\n      columns must be ordered such that these probabilities correspond to\n      class 0, 1, ..., K-1. `pred_probs` should have been computed using 3 (or\n      higher) fold cross-validation.\n\n    asymmetric : bool, optional\n      If ``asymmetric=True``, returns separate estimates for both pairs (class1, class2) and (class2, class1). Use this\n      for finding \"is a\" relationships where for example \"class1 is a class2\".\n      In this case, num overlapping examples counts the number of examples that have been labeled as class1 which should actually have been labeled as class2.\n      If ``asymmetric=False``, the pair (class1, class2) will only be returned once with an arbitrary order.\n      In this case, their estimated score is the sum: ``score(class1, class2) + score(class2, class1))``.\n\n    class_names : Iterable[str]\n        A list or other iterable of the string class names. The list should be in the order that\n        matches the class indices. So if class 0 is 'dog' and class 1 is 'cat', then\n        ``class_names = ['dog', 'cat']``.\n\n    num_examples : int or None, optional\n        The number of examples in the dataset, i.e. ``len(labels)``. You only need to provide this if\n        you use this function with the joint, e.g. ``find_overlapping_classes(joint=joint)``, otherwise\n        this is automatically computed via ``sum(confident_joint)`` or ``len(labels)``.\n\n    joint : np.ndarray, optional\n        An array of shape ``(K, K)``, where K is the number of classes,\n        representing the estimated joint distribution of the noisy labels and\n        true labels. The sum of all entries in this matrix must be 1 (valid\n        probability distribution). Each entry in the matrix captures the co-occurence joint\n        probability of a true label and a noisy label, i.e. ``p(noisy_label=i, true_label=j)``.\n        **Important**. If you input the joint, you must also input `num_examples`.\n\n    confident_joint : np.ndarray, optional\n      An array of shape ``(K, K)`` representing the confident joint, the matrix used for identifying label issues, which\n      estimates a confident subset of the joint distribution of the noisy and true labels, ``P_{noisy label, true label}``.\n      Entry ``(j, k)`` in the matrix is the number of examples confidently counted into the pair of ``(noisy label=j, true label=k)`` classes.\n      The `confident_joint` can be computed using :py:func:`count.compute_confident_joint <cleanlab.count.compute_confident_joint>`.\n      If not provided, it is computed from the given (noisy) `labels` and `pred_probs`.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\" and a description of each below.\n        Each row corresponds to a pair of classes.\n\n        * *Class Index A*: the index of a class in 0, 1, ..., K-1.\n        * *Class Index B*: the index of a different class (from Class A) in 0, 1, ..., K-1.\n        * *Num Overlapping Examples*: estimated number of labels overlapping between the two classes.\n        * *Joint Probability*: the *Num Overlapping Examples* divided by the number of examples in the dataset.\n\n        By default, the DataFrame is ordered by \"Joint Probability\" descending.",
    "function_name": "find_overlapping_classes",
    "ground_truth": "cleanlab/dataset.py",
    "test": "tests/test_dataset.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}