{
    "result": "To create the `encode_jpeg` function, we will break down the task into several steps. We'll use the Python Imaging Library (PIL) to handle image encoding. Here's how we can approach this:\n\n1. **Import Necessary Libraries**: We'll need PIL for image processing and potentially NumPy to handle tensor operations.\n\n2. **Define the Function Signature**: The function will take an input tensor or list of tensors and a quality parameter.\n\n3. **Validate Inputs**: Check if the quality is between 1 and 100 and if the input is not an empty list.\n\n4. **Process Each Image**: Convert each tensor to a PIL Image, then encode it to JPEG format.\n\n5. **Return the Encoded Images**: Collect the encoded JPEG bytes and return them.\n\nLet's implement this step by step:\n\n### Step 1: Import Necessary Libraries\n\n```python\nfrom PIL import Image\nimport numpy as np\nimport io\n```\n\n### Step 2: Define the Function Signature\n\n```python\ndef encode_jpeg(images, quality):\n```\n\n### Step 3: Validate Inputs\n\n```python\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n    \n    if isinstance(images, list) and len(images) == 0:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    if not isinstance(images, list):\n        images = [images]\n```\n\n### Step 4: Process Each Image\n\n```python\n    encoded_images = []\n    \n    for img in images:\n        if isinstance(img, np.ndarray):\n            # Convert CHW to HWC\n            img = np.transpose(img, (1, 2, 0))\n            # Convert to PIL Image\n            pil_img = Image.fromarray(img)\n        else:\n            raise TypeError(\"Each image must be a NumPy array.\")\n        \n        # Encode to JPEG\n        with io.BytesIO() as output:\n            pil_img.save(output, format=\"JPEG\", quality=quality)\n            jpeg_bytes = output.getvalue()\n            encoded_images.append(jpeg_bytes)\n```\n\n### Step 5: Return the Encoded Images\n\n```python\n    return encoded_images if len(encoded_images) > 1 else encoded_images[0]\n```\n\n### Complete Function\n\nHere is the complete function:\n\n```python\nfrom PIL import Image\nimport numpy as np\nimport io\n\ndef encode_jpeg(images, quality):\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n    \n    if isinstance(images, list) and len(images) == 0:\n        raise ValueError(\"Input list cannot be empty.\")\n    \n    if not isinstance(images, list):\n        images = [images]\n    \n    encoded_images = []\n    \n    for img in images:\n        if isinstance(img, np.ndarray):\n            # Convert CHW to HWC\n            img = np.transpose(img, (1, 2, 0))\n            # Convert to PIL Image\n            pil_img = Image.fromarray(img)\n        else:\n            raise TypeError(\"Each image must be a NumPy array.\")\n        \n        # Encode to JPEG\n        with io.BytesIO() as output:\n            pil_img.save(output, format=\"JPEG\", quality=quality)\n            jpeg_bytes = output.getvalue()\n            encoded_images.append(jpeg_bytes)\n    \n    return encoded_images if len(encoded_images) > 1 else encoded_images[0]\n```\n\nThis function should now correctly encode a tensor or list of tensors into JPEG format, handling the specified quality and input validation.",
    "prompt": "Create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format. The function accepts images in CHW layout and a quality parameter between 1 and 100 to control the output JPEG quality. The output is a tensor or list of tensors containing the raw bytes of the JPEG file(s). The function raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is passed as input.",
    "function_name": "encode_jpeg",
    "ground_truth": "torchvision/io/image.py",
    "test": "test/test_image.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}