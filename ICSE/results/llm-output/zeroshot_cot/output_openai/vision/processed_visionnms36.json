{
    "result": "To implement the `nms` function using PyTorch and its `torchvision` library, we will follow these steps:\n\n1. **Import Necessary Libraries**: We'll need PyTorch and torchvision for tensor operations and the NMS function.\n2. **Define the Function Signature**: The function will take three parameters: `boxes`, `scores`, and `iou_threshold`.\n3. **Check for Required Operations**: Ensure that the necessary operations are available in the environment.\n4. **Perform Non-Maximum Suppression**: Use torchvision's built-in NMS function to perform the suppression.\n5. **Return the Indices**: Return the indices of the boxes that are kept after NMS, sorted by scores.\n\nLet's implement this step by step:\n\n### Step 1: Import Necessary Libraries\n\n```python\nimport torch\nfrom torchvision.ops import nms as torchvision_nms\n```\n\n### Step 2: Define the Function Signature\n\n```python\ndef nms(boxes: torch.Tensor, scores: torch.Tensor, iou_threshold: float) -> torch.Tensor:\n```\n\n### Step 3: Check for Required Operations\n\nBefore performing NMS, we should ensure that the necessary operations are available. However, since we are using PyTorch and torchvision, these operations should be available if the libraries are correctly installed.\n\n### Step 4: Perform Non-Maximum Suppression\n\nUse the `torchvision.ops.nms` function to perform NMS. This function takes the boxes, scores, and IoU threshold as input and returns the indices of the boxes to keep.\n\n```python\n    # Ensure the inputs are on the same device\n    if boxes.device != scores.device:\n        raise ValueError(\"Boxes and scores must be on the same device\")\n\n    # Perform NMS using torchvision's built-in function\n    keep_indices = torchvision_nms(boxes, scores, iou_threshold)\n```\n\n### Step 5: Return the Indices\n\nReturn the indices of the boxes that are kept after NMS, sorted by scores.\n\n```python\n    # Sort the kept indices by scores in descending order\n    sorted_indices = keep_indices[scores[keep_indices].argsort(descending=True)]\n    return sorted_indices\n```\n\n### Complete Function\n\nHere is the complete `nms` function:\n\n```python\nimport torch\nfrom torchvision.ops import nms as torchvision_nms\n\ndef nms(boxes: torch.Tensor, scores: torch.Tensor, iou_threshold: float) -> torch.Tensor:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on a set of bounding boxes.\n\n    Args:\n        boxes (torch.Tensor): Tensor of shape [N, 4] representing bounding box coordinates in (x1, y1, x2, y2) format.\n        scores (torch.Tensor): Tensor of shape [N] containing scores for each box.\n        iou_threshold (float): IoU threshold for suppression.\n\n    Returns:\n        torch.Tensor: Indices of the boxes that have been kept after NMS, sorted in decreasing order of scores.\n    \"\"\"\n    # Ensure the inputs are on the same device\n    if boxes.device != scores.device:\n        raise ValueError(\"Boxes and scores must be on the same device\")\n\n    # Perform NMS using torchvision's built-in function\n    keep_indices = torchvision_nms(boxes, scores, iou_threshold)\n\n    # Sort the kept indices by scores in descending order\n    sorted_indices = keep_indices[scores[keep_indices].argsort(descending=True)]\n    return sorted_indices\n```\n\nThis function will perform non-maximum suppression on the input bounding boxes and return the indices of the boxes that are kept, sorted by their scores in descending order.",
    "prompt": "Generate a Python function called nms that performs non-maximum suppression (NMS) on a set of bounding boxes based on their intersection-over-union (IoU) values. The function takes three inputs: boxes (a Tensor of shape [N, 4] representing bounding box coordinates in (x1, y1, x2, y2) format), scores (a Tensor of shape [N] containing scores for each box), and iou_threshold (a float value specifying the IoU threshold for suppression).\n\nThe function iteratively removes lower scoring boxes that have an IoU greater than the specified threshold with another higher scoring box. The output is an int64 Tensor containing the indices of the boxes that have been kept after NMS, sorted in decreasing order of scores. Additionally, the function logs API usage and ensures that necessary operations are available before performing NMS using PyTorch's torchvision library.",
    "function_name": "nms",
    "ground_truth": "torchvision/ops/boxes.py",
    "test": "test/test_ops.py::TestNMS",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}