{
    "result": "To create the `gaussian_noise_image` function, we will follow these steps:\n\n1. **Check Input Conditions**: Ensure the input image tensor is of a floating-point dtype and that the `sigma` value is non-negative. If these conditions are not met, raise a `ValueError`.\n\n2. **Generate Gaussian Noise**: Create a noise tensor with the same shape as the input image, using the specified `mean` and `sigma`.\n\n3. **Add Noise to Image**: Add the generated noise to the input image tensor.\n\n4. **Clip Values**: If the `clip` parameter is `True`, clip the resulting noisy image tensor to the range [0, 1].\n\n5. **Return the Noisy Image**: Return the modified image tensor.\n\nHere's the implementation of the `gaussian_noise_image` function:\n\n```python\nimport torch\n\ndef gaussian_noise_image(image, mean=0.0, sigma=0.1, clip=True):\n    # Check if the input image is a floating-point tensor\n    if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n    \n    # Check if sigma is non-negative\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")\n    \n    # Generate Gaussian noise\n    noise = torch.normal(mean=mean, std=sigma, size=image.size(), dtype=image.dtype, device=image.device)\n    \n    # Add noise to the image\n    noisy_image = image + noise\n    \n    # Clip the values to the range [0, 1] if clip is True\n    if clip:\n        noisy_image = torch.clamp(noisy_image, 0.0, 1.0)\n    \n    return noisy_image\n```\n\n### Explanation:\n\n- **Input Validation**: We first check if the input image tensor is of a floating-point type using `image.is_floating_point()`. If not, a `ValueError` is raised. Similarly, we check if `sigma` is non-negative.\n\n- **Noise Generation**: We use `torch.normal` to generate Gaussian noise with the specified `mean` and `sigma`. The noise tensor is created with the same shape, dtype, and device as the input image.\n\n- **Adding Noise**: The generated noise is added to the input image tensor.\n\n- **Clipping**: If `clip` is `True`, we use `torch.clamp` to ensure all values in the noisy image are within the [0, 1] range.\n\n- **Return**: Finally, the function returns the noisy image tensor.",
    "prompt": "Write a Python function `gaussian_noise_image` that adds Gaussian noise to an input image tensor. The function should accept the following parameters: `image` (a float tensor), `mean` (mean of the Gaussian noise, defaulting to 0.0), `sigma` (standard deviation of the Gaussian noise, defaulting to 0.1), and `clip` (a boolean indicating whether to clip the output values to the [0, 1] range, defaulting to `True`). The function should return the noisy image tensor. Ensure that the input tensor is of a floating-point dtype and that `sigma` is non-negative, raising a `ValueError` if these conditions are not met.  if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")",
    "function_name": "gaussian_noise_image",
    "ground_truth": "torchvision/transforms/v2/functional/_misc.py",
    "test": "test/test_transforms_v2.py::TestGaussianNoise",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}