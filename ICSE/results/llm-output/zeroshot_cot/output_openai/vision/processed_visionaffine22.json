{
    "result": "To create the `affine` function that applies an affine transformation to an image while keeping the image center invariant, we can use the `torchvision.transforms.functional` module if the input is a Tensor, or the `PIL.Image` module if the input is a PIL Image. Here's how you can implement this function step by step:\n\n### Step 1: Import Necessary Libraries\n\nFirst, we need to import the necessary libraries. We'll use `PIL` for image manipulation and `torchvision` for handling Tensors.\n\n```python\nfrom PIL import Image\nimport torchvision.transforms.functional as F\nimport torch\n```\n\n### Step 2: Define the `affine` Function\n\nNow, let's define the `affine` function with the specified parameters.\n\n```python\ndef affine(img, angle, translate, scale, shear, interpolation=Image.BILINEAR, fill=0, center=None):\n    \"\"\"\n    Apply an affine transformation on an image while keeping the image center invariant.\n\n    Parameters:\n    - img: PIL Image or Tensor\n    - angle: Rotation angle in degrees\n    - translate: Tuple of horizontal and vertical translations\n    - scale: Overall scale\n    - shear: Shear angle values\n    - interpolation: Desired interpolation mode\n    - fill: Pixel fill value for areas outside the transformed image\n    - center: Optional center of rotation\n\n    Returns:\n    - Transformed image as a PIL Image or Tensor\n    \"\"\"\n```\n\n### Step 3: Handle Different Image Types\n\nWe need to check if the input image is a PIL Image or a Tensor and handle each case accordingly.\n\n```python\n    if isinstance(img, Image.Image):\n        # Handle PIL Image\n        width, height = img.size\n    elif isinstance(img, torch.Tensor):\n        # Handle Tensor\n        _, height, width = img.shape\n    else:\n        raise TypeError(\"img should be PIL Image or Tensor\")\n```\n\n### Step 4: Calculate the Center of Rotation\n\nIf the center is not provided, we should calculate it as the center of the image.\n\n```python\n    if center is None:\n        center = (width * 0.5, height * 0.5)\n```\n\n### Step 5: Apply the Affine Transformation\n\nNow, apply the affine transformation using the appropriate method for the image type.\n\n```python\n    if isinstance(img, Image.Image):\n        # Apply affine transformation for PIL Image\n        return img.transform(\n            (width, height),\n            Image.AFFINE,\n            (scale * cos(angle), -scale * sin(angle), translate[0],\n             scale * sin(angle), scale * cos(angle), translate[1]),\n            resample=interpolation,\n            fillcolor=fill\n        )\n    elif isinstance(img, torch.Tensor):\n        # Apply affine transformation for Tensor\n        return F.affine(\n            img, angle, translate, scale, shear, interpolation=interpolation, fill=fill, center=center\n        )\n```\n\n### Step 6: Complete the Function\n\nFinally, return the transformed image.\n\n```python\n    return img\n```\n\n### Full Function Code\n\nHere's the complete `affine` function:\n\n```python\nfrom PIL import Image\nimport torchvision.transforms.functional as F\nimport torch\nimport math\n\ndef affine(img, angle, translate, scale, shear, interpolation=Image.BILINEAR, fill=0, center=None):\n    \"\"\"\n    Apply an affine transformation on an image while keeping the image center invariant.\n\n    Parameters:\n    - img: PIL Image or Tensor\n    - angle: Rotation angle in degrees\n    - translate: Tuple of horizontal and vertical translations\n    - scale: Overall scale\n    - shear: Shear angle values\n    - interpolation: Desired interpolation mode\n    - fill: Pixel fill value for areas outside the transformed image\n    - center: Optional center of rotation\n\n    Returns:\n    - Transformed image as a PIL Image or Tensor\n    \"\"\"\n    if isinstance(img, Image.Image):\n        # Handle PIL Image\n        width, height = img.size\n    elif isinstance(img, torch.Tensor):\n        # Handle Tensor\n        _, height, width = img.shape\n    else:\n        raise TypeError(\"img should be PIL Image or Tensor\")\n\n    if center is None:\n        center = (width * 0.5, height * 0.5)\n\n    if isinstance(img, Image.Image):\n        # Convert angle and shear to radians\n        angle_rad = math.radians(angle)\n        shear_rad = [math.radians(s) for s in shear]\n\n        # Calculate the affine matrix\n        affine_matrix = (\n            scale * math.cos(angle_rad), -scale * math.sin(angle_rad + shear_rad[0]), translate[0],\n            scale * math.sin(angle_rad), scale * math.cos(angle_rad + shear_rad[1]), translate[1]\n        )\n\n        return img.transform(\n            (width, height),\n            Image.AFFINE,\n            affine_matrix,\n            resample=interpolation,\n            fillcolor=fill\n        )\n    elif isinstance(img, torch.Tensor):\n        # Apply affine transformation for Tensor\n        return F.affine(\n            img, angle, translate, scale, shear, interpolation=interpolation, fill=fill, center=center\n        )\n\n    return img\n```\n\nThis function should now correctly apply an affine transformation to both PIL Images and Tensors, keeping the image center invariant.",
    "prompt": "Create a Python function called affine that applies an affine transformation on an image while keeping the image center invariant. The function takes in parameters such as img (PIL Image or Tensor), angle (rotation angle in degrees), translate (horizontal and vertical translations), scale (overall scale), shear (shear angle values), interpolation (desired interpolation mode), fill (pixel fill value for areas outside the transformed image), and center (optional center of rotation). The function returns the transformed image as a PIL Image or Tensor.",
    "function_name": "affine",
    "ground_truth": "torchvision/transforms/_functional_pil.py",
    "test": "test/test_transforms_tensor.py::test_random_affine_shear",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}