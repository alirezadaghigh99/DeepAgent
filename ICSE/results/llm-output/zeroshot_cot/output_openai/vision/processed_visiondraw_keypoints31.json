{
    "result": "To create the `draw_keypoints` function, we will break down the task into several steps. We'll start by validating the inputs, then proceed to draw the keypoints and connections on the image. Finally, we'll return the modified image. Let's go through each step:\n\n### Step 1: Validate Inputs\n\nWe'll first ensure that the inputs are of the correct type and shape. This includes checking the image tensor, keypoints tensor, and optionally the visibility tensor.\n\n```python\nimport torch\nimport numpy as np\nimport cv2\n\ndef validate_inputs(image, keypoints, connectivity, colors, radius, width, visibility):\n    # Check if image is a tensor\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"The input image must be a tensor.\")\n    \n    # Check image dtype\n    if image.dtype not in [torch.uint8, torch.float32, torch.float64]:\n        raise ValueError(\"The image dtype must be uint8 or float.\")\n    \n    # Check image shape\n    if image.ndim != 3 or image.shape[0] != 3:\n        raise ValueError(\"The image must have shape (3, H, W).\")\n    \n    # Check keypoints shape\n    if keypoints.ndim != 3 or keypoints.shape[2] != 2:\n        raise ValueError(\"Keypoints must have shape (num_instances, K, 2).\")\n    \n    # Check visibility shape\n    if visibility is not None and visibility.shape != keypoints.shape[:2]:\n        raise ValueError(\"Visibility tensor must match the shape of keypoints tensor.\")\n```\n\n### Step 2: Draw Keypoints and Connections\n\nNext, we'll draw the keypoints and connections on the image. We'll use OpenCV for drawing, which requires converting the image tensor to a NumPy array.\n\n```python\ndef draw_keypoints(image, keypoints, connectivity=None, colors=(0, 255, 0), radius=3, width=1, visibility=None):\n    # Validate inputs\n    validate_inputs(image, keypoints, connectivity, colors, radius, width, visibility)\n    \n    # Convert image to NumPy array for OpenCV\n    if image.dtype == torch.float32 or image.dtype == torch.float64:\n        image = (image * 255).byte()\n    image_np = image.permute(1, 2, 0).cpu().numpy()\n    \n    # Convert color to BGR for OpenCV\n    if isinstance(colors, str):\n        colors = cv2.cvtColor(np.uint8([[cv2.COLOR_BGR2RGB]]), cv2.COLOR_RGB2BGR)[0][0]\n    elif isinstance(colors, tuple) and len(colors) == 3:\n        colors = (int(colors[2]), int(colors[1]), int(colors[0]))  # Convert RGB to BGR\n    \n    # Draw keypoints\n    for i, instance in enumerate(keypoints):\n        for j, (x, y) in enumerate(instance):\n            if visibility is None or visibility[i, j]:\n                cv2.circle(image_np, (int(x), int(y)), radius, colors, -1)\n    \n    # Draw connections\n    if connectivity is not None:\n        for i, instance in enumerate(keypoints):\n            for (start, end) in connectivity:\n                if visibility is None or (visibility[i, start] and visibility[i, end]):\n                    pt1 = tuple(map(int, instance[start]))\n                    pt2 = tuple(map(int, instance[end]))\n                    cv2.line(image_np, pt1, pt2, colors, width)\n    \n    # Convert back to tensor\n    image_tensor = torch.from_numpy(image_np).permute(2, 0, 1)\n    return image_tensor\n```\n\n### Explanation\n\n- **Input Validation**: We ensure the image is a tensor with the correct dtype and shape. We also check the keypoints and visibility tensors.\n- **Color Conversion**: OpenCV uses BGR format, so we convert the RGB color if necessary.\n- **Drawing**: We use OpenCV's `circle` and `line` functions to draw keypoints and connections.\n- **Output**: The modified image is converted back to a tensor and returned.\n\nThis function should now correctly overlay keypoints and connections on the given image tensor, handling visibility and connectivity as specified.",
    "prompt": "Create a Python function draw_keypoints that overlays keypoints on a given RGB image tensor. The function should accept the following parameters:\n\nimage: A tensor of shape (3, H, W) and dtype uint8 or float, representing the image.\nkeypoints: A tensor of shape (num_instances, K, 2), where K denotes the number of keypoints per instance, and each keypoint is represented by its (x, y) coordinates.\nconnectivity: An optional list of tuples, where each tuple contains two integers representing keypoints that should be connected with a line.\ncolors: An optional string or tuple specifying the color for the keypoints and lines. The color can be a string (e.g., \"red\") or an RGB tuple.\nradius: An integer specifying the radius of each keypoint.\nwidth: An integer specifying the width of the lines connecting the keypoints.\nvisibility: An optional tensor of shape (num_instances, K) that indicates whether each keypoint is visible (True) or not (False).\nThe function should validate the input tensors and ensure the image is in the correct format. It should draw each visible keypoint on the image, and if connectivity is provided, draw lines connecting the keypoints based on their visibility. The resulting image tensor should be returned with the keypoints and connections drawn.\n\nError Handling:\nRaise a TypeError if the input image is not a tensor.\nRaise a ValueError if the image dtype is not uint8 or float, if the image shape is incorrect, or if the keypoints tensor has an incorrect shape.\nRaise a ValueError if the visibility tensor does not match the shape of the keypoints tensor.",
    "function_name": "draw_keypoints",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py::test_draw_keypoints_visibility",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}