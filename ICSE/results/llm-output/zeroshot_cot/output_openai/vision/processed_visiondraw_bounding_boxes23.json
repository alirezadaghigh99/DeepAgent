{
    "result": "To create the `draw_bounding_boxes` function, we will break down the task into several steps. We'll start by setting up the function signature and handling the input validation. Then, we'll proceed to draw the bounding boxes and labels on the image. Finally, we'll return the modified image tensor.\n\n### Step 1: Function Signature and Input Validation\n\nFirst, we need to define the function signature and handle input validation, including checking the types and shapes of the inputs.\n\n```python\nimport torch\nimport warnings\nfrom torchvision.utils import draw_bounding_boxes\nfrom torchvision.transforms.functional import to_pil_image, to_tensor\n\ndef draw_bounding_boxes(image, boxes, labels=None, colors=None, fill=False, box_width=1, font=None, font_size=10):\n    # Check if the input image is a tensor\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"The input image must be a PyTorch tensor.\")\n    \n    # Check the image dimensions\n    if image.ndim != 3 or image.shape[0] not in [1, 3]:\n        raise ValueError(\"The image tensor must have shape (C, H, W) with C being 1 or 3.\")\n    \n    # Check the image dtype\n    if image.dtype not in [torch.uint8, torch.float32, torch.float64]:\n        raise ValueError(\"The image dtype must be uint8 or float.\")\n    \n    # Check the bounding boxes\n    if not isinstance(boxes, torch.Tensor) or boxes.ndim != 2 or boxes.shape[1] != 4:\n        raise ValueError(\"Bounding boxes must be a tensor of shape (N, 4) in (xmin, ymin, xmax, ymax) format.\")\n    \n    # Warn if no bounding boxes are provided\n    if boxes.size(0) == 0:\n        warnings.warn(\"No bounding boxes provided.\")\n    \n    # Warn if the number of labels does not match the number of boxes\n    if labels is not None and len(labels) != boxes.size(0):\n        warnings.warn(\"The number of labels does not match the number of bounding boxes.\")\n    \n    # Default color\n    if colors is None:\n        colors = [\"red\"] * boxes.size(0)\n    \n    return image, boxes, labels, colors, fill, box_width, font, font_size\n```\n\n### Step 2: Drawing Bounding Boxes\n\nNext, we will use the `draw_bounding_boxes` function from `torchvision.utils` to draw the bounding boxes on the image. This function supports drawing boxes with specified colors and labels.\n\n```python\ndef draw_bounding_boxes(image, boxes, labels=None, colors=None, fill=False, box_width=1, font=None, font_size=10):\n    # ... (input validation code)\n\n    # Convert image to uint8 if it's in float format\n    if image.dtype in [torch.float32, torch.float64]:\n        image = (image * 255).to(torch.uint8)\n    \n    # Draw bounding boxes\n    image_with_boxes = draw_bounding_boxes(\n        image=image,\n        boxes=boxes,\n        labels=labels,\n        colors=colors,\n        width=box_width,\n        fill=fill,\n        font=font,\n        font_size=font_size\n    )\n    \n    return image_with_boxes\n```\n\n### Step 3: Finalizing the Function\n\nFinally, we ensure that the function returns the modified image tensor with the bounding boxes drawn.\n\n```python\ndef draw_bounding_boxes(image, boxes, labels=None, colors=None, fill=False, box_width=1, font=None, font_size=10):\n    # ... (input validation code)\n\n    # Convert image to uint8 if it's in float format\n    if image.dtype in [torch.float32, torch.float64]:\n        image = (image * 255).to(torch.uint8)\n    \n    # Draw bounding boxes\n    image_with_boxes = draw_bounding_boxes(\n        image=image,\n        boxes=boxes,\n        labels=labels,\n        colors=colors,\n        width=box_width,\n        fill=fill,\n        font=font,\n        font_size=font_size\n    )\n    \n    return image_with_boxes\n```\n\nThis function should now be able to handle drawing bounding boxes on both RGB and grayscale images, with options for customization such as colors, labels, and box width. Make sure to have `torchvision` installed to use the `draw_bounding_boxes` function.",
    "prompt": "Create a Python function `draw_bounding_boxes` that draws bounding boxes on a given RGB or grayscale image represented as a PyTorch tensor. The function should accept an image tensor (`image`) of shape `(C, H, W)` and dtype `uint8` or float, a tensor of bounding boxes (`boxes`) in `(xmin, ymin, xmax, ymax)` format, and optional parameters such as labels, colors, fill option, box width, font, and font size. The function should return the image tensor with the bounding boxes drawn on it.\n\n### Error Handling:\n- Raise a `TypeError` if the input `image` is not a tensor.\n- Raise a `ValueError` if the image dtype is not `uint8` or float, if the image dimensions are incorrect, or if the bounding boxes are not in the correct format.\n- Warn if no bounding boxes are provided or if the number of labels does not match the number of boxes.\n\nThe function should support options like filling the bounding boxes with a color, specifying the width of the bounding box edges, and adding labels with custom fonts. The output should be a tensor with the bounding boxes applied, suitable for further processing or visualization.",
    "function_name": "draw_bounding_boxes",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}