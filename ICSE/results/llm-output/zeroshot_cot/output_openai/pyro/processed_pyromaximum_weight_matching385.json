{
    "result": "To create a Python function `maximum_weight_matching` that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching, we can follow these steps:\n\n1. **Import Necessary Libraries**: We'll need libraries like `torch` for tensor operations and potentially `scipy` for solving the maximum-weight matching problem.\n\n2. **Define the Function**: Create a function `maximum_weight_matching` that accepts a tensor of logits.\n\n3. **Convert Logits to a Suitable Format**: The logits tensor should be converted into a format suitable for the matching algorithm. This typically involves converting it to a numpy array and possibly negating it if using a minimum-weight matching algorithm.\n\n4. **Use a Matching Algorithm**: Use a library like `scipy.optimize` to perform the maximum-weight matching. The `linear_sum_assignment` function can be used for this purpose.\n\n5. **Return the Result**: Convert the result back to a tensor and return it.\n\nHere's how you can implement this:\n\n```python\nimport torch\nfrom scipy.optimize import linear_sum_assignment\n\ndef maximum_weight_matching(logits: torch.Tensor) -> torch.Tensor:\n    # Convert logits to a numpy array\n    cost_matrix = logits.detach().cpu().numpy()\n    \n    # Since linear_sum_assignment finds the minimum cost, we negate the cost matrix\n    # to find the maximum weight matching\n    cost_matrix = -cost_matrix\n    \n    # Use the linear_sum_assignment function to find the optimal assignment\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    \n    # Create a tensor to store the optimal assignments\n    assignment = torch.zeros_like(logits, dtype=torch.int)\n    \n    # Set the optimal assignments\n    assignment[row_ind, col_ind] = 1\n    \n    return assignment\n\n# Example usage:\n# logits = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\n# optimal_assignment = maximum_weight_matching(logits)\n# print(optimal_assignment)\n```\n\n### Explanation:\n\n- **Importing Libraries**: We import `torch` for tensor operations and `linear_sum_assignment` from `scipy.optimize` for solving the assignment problem.\n\n- **Function Definition**: The function `maximum_weight_matching` takes a tensor `logits` as input.\n\n- **Cost Matrix Conversion**: We convert the logits tensor to a numpy array and negate it because `linear_sum_assignment` solves a minimum cost problem, and we want to maximize the weights.\n\n- **Optimal Assignment**: We use `linear_sum_assignment` to find the optimal assignment indices.\n\n- **Result Construction**: We create a tensor of zeros with the same shape as `logits` and set the positions of the optimal assignments to 1.\n\n- **Return**: The function returns the tensor representing the optimal assignments.\n\nThis function does not compute gradients, as required, because it uses the `detach()` method to ensure the logits are not part of the computational graph.",
    "prompt": "Generate a Python function maximum_weight_matching that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching. The function performs a matching process and returns the best assignment for each element in the input without computing gradients.",
    "function_name": "maximum_weight_matching",
    "ground_truth": "pyro/distributions/one_two_matching.py",
    "test": "tests/distributions/test_one_two_matching.py::test_mode_phylo",
    "class": "",
    "stage": "Inference",
    "task": "prediction",
    "data": "Table"
}