{
    "result": "To create a function called `from_estimator` that plots a calibration curve using a binary classifier and data, we can follow a step-by-step approach similar to the examples provided. This function will utilize the `calibration_curve` function from `sklearn.calibration` to compute the calibration curve and then plot it using `matplotlib`. Here's how you can implement it:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.calibration import calibration_curve\nfrom sklearn.base import is_classifier\nfrom sklearn.utils import check_consistent_length\nfrom sklearn.utils.validation import check_is_fitted\nfrom sklearn.calibration import CalibrationDisplay\n\ndef from_estimator(\n    estimator,\n    X,\n    y,\n    *,\n    n_bins=10,\n    strategy='uniform',\n    pos_label=None,\n    name=None,\n    ref_line=True,\n    ax=None,\n    **kwargs\n):\n    \"\"\"\n    Plot a calibration curve using a binary classifier and data.\n\n    Parameters:\n    - estimator: Fitted classifier.\n    - X: Input values.\n    - y: Binary target values.\n    - n_bins: Number of bins for discretization.\n    - strategy: Bin width strategy ('uniform' or 'quantile').\n    - pos_label: Positive class label.\n    - name: Label for the curve.\n    - ref_line: Whether to plot a reference line.\n    - ax: Matplotlib axes.\n    - **kwargs: Additional keyword arguments for plotting.\n\n    Returns:\n    - CalibrationDisplay: Object that stores computed values.\n    \"\"\"\n    # 1. Check if the estimator is a classifier and is fitted\n    if not is_classifier(estimator):\n        raise ValueError(\"The estimator should be a fitted classifier.\")\n    check_is_fitted(estimator)\n\n    # 2. Check that X and y have consistent lengths\n    check_consistent_length(X, y)\n\n    # 3. Predict probabilities for the positive class\n    if pos_label is None:\n        pos_label = estimator.classes_[1]\n    y_prob = estimator.predict_proba(X)[:, estimator.classes_ == pos_label].ravel()\n\n    # 4. Compute the calibration curve\n    prob_true, prob_pred = calibration_curve(y, y_prob, n_bins=n_bins, strategy=strategy)\n\n    # 5. Create a plot if no axes are provided\n    if ax is None:\n        fig, ax = plt.subplots()\n\n    # 6. Plot the calibration curve\n    ax.plot(prob_pred, prob_true, marker='o', label=name, **kwargs)\n\n    # 7. Optionally plot the reference line\n    if ref_line:\n        ax.plot([0, 1], [0, 1], linestyle='--', color='gray', label='Perfectly calibrated')\n\n    # 8. Set plot labels and title\n    ax.set_xlabel('Mean predicted probability')\n    ax.set_ylabel('Fraction of positives')\n    ax.set_title('Calibration plot')\n    if name or ref_line:\n        ax.legend()\n\n    # 9. Return a CalibrationDisplay object\n    return CalibrationDisplay(prob_true=prob_true, prob_pred=prob_pred, estimator_name=name, pos_label=pos_label)\n\n```\n\n### Explanation:\n\n1. **Check Estimator**: Ensure the estimator is a classifier and is fitted.\n2. **Check Data Consistency**: Verify that `X` and `y` have consistent lengths.\n3. **Predict Probabilities**: Use the classifier to predict probabilities for the positive class.\n4. **Compute Calibration Curve**: Use `calibration_curve` to compute the true and predicted probabilities.\n5. **Plotting**: Create a plot if no axes are provided, and plot the calibration curve.\n6. **Reference Line**: Optionally plot a reference line for perfect calibration.\n7. **Labels and Title**: Set the labels and title for the plot.\n8. **Return**: Return a `CalibrationDisplay` object containing the computed values.\n\nThis function provides a flexible way to visualize the calibration of a binary classifier, allowing for customization through various parameters and keyword arguments.",
    "prompt": "Generate a Python function called from_estimator that plots a calibration curve using a binary classifier and data. The function takes in parameters such as estimator (fitted classifier), X (input values), y (binary target values), n_bins (number of bins for discretization), strategy (bin width strategy), pos_label (positive class label), name (label for curve), ref_line (whether to plot a reference line), ax (matplotlib axes), and additional keyword arguments. The function returns a CalibrationDisplay object that stores computed values.",
    "function_name": "from_estimator",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}