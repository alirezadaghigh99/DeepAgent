{
    "result": "To implement the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems, we can follow a structured approach similar to the examples you provided. Here's a step-by-step implementation of the `orthogonal_mp_gram` function:\n\n```python\nimport numpy as np\nfrom numpy.linalg import norm\n\ndef orthogonal_mp_gram(X, y, n_nonzero_coefs=None, tol=None, precompute='auto', copy_X=True, return_path=False, return_n_iter=False):\n    \"\"\"\n    Orthogonal Matching Pursuit (OMP) algorithm for sparse linear regression.\n\n    Parameters:\n    - X: 2D array-like of shape (n_samples, n_features) with unit norm columns.\n    - y: 1D or 2D array-like of shape (n_samples,) or (n_samples, n_targets).\n    - n_nonzero_coefs: Desired number of non-zero coefficients. Defaults to 10% of n_features.\n    - tol: Maximum squared norm of the residual. Overrides n_nonzero_coefs if provided.\n    - precompute: Whether to precompute the Gram matrix. Can be 'auto', True, or False.\n    - copy_X: Whether to copy the input matrix X. Default is True.\n    - return_path: Whether to return the entire coefficient path.\n    - return_n_iter: Whether to return the number of iterations taken for convergence.\n\n    Returns:\n    - coef: Coefficients of the OMP solution.\n    - (Optional) n_iter: Number of iterations taken for convergence.\n    \"\"\"\n    # 1. Validate input dimensions and types\n    X = np.array(X, copy=copy_X)\n    y = np.array(y)\n    n_samples, n_features = X.shape\n\n    if y.ndim == 1:\n        y = y[:, np.newaxis]\n    n_targets = y.shape[1]\n\n    # 2. Set default number of non-zero coefficients if not provided\n    if n_nonzero_coefs is None:\n        n_nonzero_coefs = max(1, int(0.1 * n_features))\n\n    # 3. Raise error if n_nonzero_coefs exceeds number of features\n    if n_nonzero_coefs > n_features:\n        raise ValueError(\"Number of non-zero coefficients cannot exceed number of features.\")\n\n    # 4. Precompute Gram matrix if required\n    if precompute == 'auto':\n        precompute = n_samples > n_features\n\n    if precompute:\n        Gram = X.T @ X\n    else:\n        Gram = None\n\n    # 5. Initialize variables\n    coef = np.zeros((n_features, n_targets))\n    residual = y.copy()\n    index_set = []\n    path = []\n\n    # 6. Iteratively select features and update coefficients\n    for n_iter in range(n_nonzero_coefs):\n        # 6.1 Compute correlations\n        if precompute:\n            correlations = X.T @ residual\n        else:\n            correlations = X.T @ residual\n\n        # 6.2 Select the feature with the highest correlation\n        new_idx = np.argmax(norm(correlations, axis=1))\n        index_set.append(new_idx)\n\n        # 6.3 Solve the least squares problem\n        X_selected = X[:, index_set]\n        coef_selected, _, _, _ = np.linalg.lstsq(X_selected, y, rcond=None)\n\n        # 6.4 Update coefficients and residual\n        coef[index_set] = coef_selected\n        residual = y - X_selected @ coef_selected\n\n        # 6.5 Store the path if required\n        if return_path:\n            path.append(coef.copy())\n\n        # 6.6 Check for convergence based on tolerance\n        if tol is not None and norm(residual) ** 2 <= tol:\n            break\n\n    # 7. Return results\n    if return_path:\n        return (coef, path, n_iter + 1) if return_n_iter else (coef, path)\n    else:\n        return (coef, n_iter + 1) if return_n_iter else coef\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first ensures that the input data `X` and `y` are in the correct format and dimensions. It also sets default values for `n_nonzero_coefs` if not provided.\n\n2. **Precomputation**: Depending on the `precompute` flag, the Gram matrix \\( X^T X \\) is computed to speed up the correlation calculations.\n\n3. **Iteration**: The algorithm iteratively selects the feature with the highest correlation to the residual, updates the coefficients using least squares, and checks for convergence based on the tolerance `tol`.\n\n4. **Output**: The function returns the coefficients, and optionally the path of coefficients and the number of iterations, based on the flags `return_path` and `return_n_iter`.\n\nThis implementation efficiently handles the OMP algorithm with options for precomputation and convergence checks, making it suitable for various use cases in sparse linear regression.",
    "prompt": "Create a Python function `orthogonal_mp_gram` that implements the Orthogonal Matching Pursuit (OMP) algorithm for solving sparse linear regression problems. The function should accept the following parameters:\n- `X`: A 2D array-like of shape `(n_samples, n_features)` representing the input data. Columns should be assumed to have unit norm.\n- `y`: A 1D or 2D array-like of shape `(n_samples,)` or `(n_samples, n_targets)` representing the target values.\n- `n_nonzero_coefs`: An integer specifying the desired number of non-zero coefficients in the solution. If `None`, this defaults to 10% of the number of features.\n- `tol`: A float specifying the maximum squared norm of the residual. If provided, this overrides `n_nonzero_coefs`.\n- `precompute`: A boolean or the string `'auto'` indicating whether to precompute the Gram matrix for faster computation when `n_targets` or `n_samples` is large.\n- `copy_X`: A boolean indicating whether to copy the input matrix `X` (default is `True`).\n- `return_path`: A boolean indicating whether to return the entire coefficient path for each iteration.\n- `return_n_iter`: A boolean indicating whether to return the number of iterations taken for convergence.\n\nThe function should return the coefficients of the OMP solution as a 1D or 2D NumPy array, depending on the input, with an option to return the number of iterations if `return_n_iter` is `True`. Handle edge cases such as when the number of non-zero coefficients exceeds the number of features by raising a `ValueError`. The function should use efficient computation techniques, including the option to precompute the Gram matrix if `precompute` is enabled.",
    "function_name": "orthogonal_mp_gram",
    "ground_truth": "sklearn/linear_model/_omp.py",
    "test": "sklearn/linear_model/tests/test_omp.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Classification",
    "data": "Table"
}