{
    "result": "To create a function called `coverage_error` that calculates the coverage error measure, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom sklearn.utils import check_array, column_or_1d\n\ndef coverage_error(y_true, y_score, sample_weight=None):\n    \"\"\"\n    Calculate the coverage error measure.\n\n    The coverage error is the average number of labels that need to be included\n    in the prediction to cover all true labels. It is calculated by determining\n    how far we need to go through the ranked scores to cover all true labels.\n\n    Parameters:\n    - y_true: array-like of shape (n_samples, n_labels)\n      True binary labels in binary indicator format.\n    - y_score: array-like of shape (n_samples, n_labels)\n      Target scores.\n    - sample_weight: array-like of shape (n_samples,), default=None\n      Sample weights.\n\n    Returns:\n    - coverage_error: float\n      The coverage error.\n\n    Examples:\n    >>> y_true = np.array([[1, 0, 1], [0, 1, 0]])\n    >>> y_score = np.array([[0.2, 0.3, 0.5], [0.1, 0.4, 0.2]])\n    >>> coverage_error(y_true, y_score)\n    2.0\n    \"\"\"\n    # 1. Validate input arrays\n    y_true = check_array(y_true, ensure_2d=True)\n    y_score = check_array(y_score, ensure_2d=True)\n    if sample_weight is not None:\n        sample_weight = column_or_1d(sample_weight)\n\n    # 2. Ensure y_true and y_score have the same shape\n    if y_true.shape != y_score.shape:\n        raise ValueError(\"y_true and y_score must have the same shape.\")\n\n    # 3. Determine the number of samples and labels\n    n_samples, n_labels = y_true.shape\n\n    # 4. Initialize coverage error\n    coverage_error = 0.0\n\n    # 5. Iterate over each sample\n    for i in range(n_samples):\n        # 6. Get the indices of true labels for the current sample\n        true_indices = np.where(y_true[i])[0]\n\n        # 7. Sort scores in descending order and get the rank of true labels\n        sorted_indices = np.argsort(-y_score[i])\n        rank_of_true_labels = np.max([np.where(sorted_indices == idx)[0][0] for idx in true_indices])\n\n        # 8. Update coverage error with the rank of the last true label\n        coverage_error += rank_of_true_labels + 1\n\n    # 9. Average the coverage error over all samples, considering sample weights\n    if sample_weight is not None:\n        coverage_error = np.average(coverage_error, weights=sample_weight)\n    else:\n        coverage_error /= n_samples\n\n    # 10. Return the coverage error\n    return coverage_error\n```\n\n### Explanation:\n\n1. **Input Validation**: We use `check_array` to ensure that `y_true` and `y_score` are 2D arrays. If `sample_weight` is provided, it is converted to a 1D array.\n\n2. **Shape Check**: We ensure that `y_true` and `y_score` have the same shape.\n\n3. **Coverage Error Calculation**: For each sample, we determine the indices of the true labels and sort the scores in descending order. We find the rank of the last true label and update the coverage error.\n\n4. **Average Coverage Error**: We average the coverage error over all samples, considering sample weights if provided.\n\n5. **Return Value**: The function returns the coverage error as a float.\n\nThis function provides a way to calculate the coverage error, which is useful in evaluating multi-label classification models.",
    "prompt": "Generate a Python function called coverage_error that calculates the coverage error measure. The function takes in three parameters: y_true, y_score, and an optional parameter sample_weight. \n\nThe y_true parameter is an array-like object containing true binary labels in binary indicator format. The y_score parameter is an array-like object containing target scores. The sample_weight parameter is an array-like object containing sample weights.\n\nThe function calculates how far we need to go through the ranked scores to cover all true labels. It handles ties in y_scores by giving the maximal rank that would have been assigned to all tied values. The function returns the coverage error as a float value.\n\nMake sure to read more about coverage error in the User Guide provided in the code. The function also includes examples of how to use it with sample inputs and expected outputs.",
    "function_name": "coverage_error",
    "ground_truth": "sklearn/metrics/_ranking.py",
    "test": "sklearn/metrics/tests/test_ranking.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}