{
    "result": "To create the `estimate_bandwidth` function, we can follow a step-by-step approach similar to the examples provided. This function will estimate the bandwidth for the mean-shift algorithm using the `NearestNeighbors` class from `sklearn.neighbors`. Here's how you can implement it:\n\n```python\nimport numpy as np\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.utils import check_random_state\n\ndef estimate_bandwidth(X, quantile=0.3, n_samples=None, random_state=0, n_jobs=None):\n    \"\"\"\n    Estimate the bandwidth to use with the mean-shift algorithm.\n\n    Parameters:\n    - X: array-like of shape (n_samples, n_features)\n        Input points.\n    - quantile: float, default=0.3\n        Quantile used to compute the bandwidth.\n    - n_samples: int, default=None\n        Number of samples to use. If None, all samples are used.\n    - random_state: int, RandomState instance, default=0\n        Determines random number generation for subsampling.\n    - n_jobs: int, default=None\n        The number of parallel jobs to run for neighbors search.\n\n    Returns:\n    - bandwidth: float\n        The estimated bandwidth parameter.\n    \"\"\"\n    # 1. Convert random_state into a RandomState instance\n    rs = check_random_state(random_state)\n\n    # 2. If n_samples is specified, randomly sample from X\n    if n_samples is not None:\n        indices = rs.choice(X.shape[0], n_samples, replace=False)\n        X = X[indices]\n\n    # 3. Fit NearestNeighbors to the data\n    nbrs = NearestNeighbors(n_neighbors=int(X.shape[0] * quantile), n_jobs=n_jobs)\n    nbrs.fit(X)\n\n    # 4. Compute the distances to the nearest neighbors\n    distances, _ = nbrs.kneighbors(X)\n\n    # 5. Use the quantile of the distances as the bandwidth\n    bandwidth = np.median(distances[:, -1])\n\n    # 6. Return the estimated bandwidth\n    return bandwidth\n\n# Example usage:\n# import numpy as np\n# from sklearn.cluster import MeanShift\n# X = np.random.rand(100, 2)  # Example data\n# bandwidth = estimate_bandwidth(X, quantile=0.2)\n# ms = MeanShift(bandwidth=bandwidth)\n# ms.fit(X)\n```\n\n### Explanation:\n\n1. **Random State Handling**: We use `check_random_state` to ensure that the random state is handled consistently, which is important for reproducibility when subsampling.\n\n2. **Subsampling**: If `n_samples` is specified, we randomly select a subset of the data to speed up the bandwidth estimation process.\n\n3. **Nearest Neighbors**: We use `NearestNeighbors` to find the nearest neighbors for each point in the dataset. The number of neighbors is determined by the `quantile` parameter.\n\n4. **Distance Calculation**: We calculate the distances to the nearest neighbors and use the median of these distances as the bandwidth. This approach is robust to outliers.\n\n5. **Return Bandwidth**: Finally, we return the estimated bandwidth, which can be used in the mean-shift algorithm.\n\nThis function provides a flexible and efficient way to estimate the bandwidth for mean-shift clustering, with options for subsampling and parallel computation.",
    "prompt": "Generate a Python function called estimate_bandwidth that estimates the bandwidth to use with the mean-shift algorithm. The function takes input points X as an array-like of shape (n_samples, n_features), with optional parameters quantile (default=0.3), n_samples (default=None), random_state (default=0), and n_jobs (default=None). The function returns the bandwidth parameter as a float. The function utilizes the NearestNeighbors class to calculate the bandwidth based on the input data. The function also includes examples of usage with numpy and sklearn.cluster.",
    "function_name": "estimate_bandwidth",
    "ground_truth": "sklearn/cluster/_mean_shift.py",
    "test": "sklearn/cluster/tests/",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Table"
}