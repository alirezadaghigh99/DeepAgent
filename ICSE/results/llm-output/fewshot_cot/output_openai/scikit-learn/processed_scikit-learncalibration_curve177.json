{
    "result": "To create a function called `calibration_curve` that computes true and predicted probabilities for a calibration curve, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom sklearn.utils import column_or_1d\nfrom sklearn.utils.validation import _check_sample_weight\n\ndef calibration_curve(y_true, y_prob, pos_label=None, n_bins=5, strategy='uniform'):\n    \"\"\"\n    Compute true and predicted probabilities for a calibration curve.\n\n    Parameters:\n    - y_true: array-like of shape (n_samples), true targets.\n    - y_prob: array-like of shape (n_samples), probabilities of the positive class.\n    - pos_label: int, float, bool, or str, default=None, label of the positive class.\n    - n_bins: int, default=5, number of bins to discretize the [0, 1] interval.\n    - strategy: {'uniform', 'quantile'}, default='uniform', strategy to define bin widths.\n\n    Returns:\n    - prob_true: ndarray of shape (n_bins,) or smaller, fraction of positives in each bin.\n    - prob_pred: ndarray of shape (n_bins,) or smaller, mean predicted probability in each bin.\n    \"\"\"\n    # 1. Ensure y_true and y_prob are 1-dimensional arrays\n    y_true = column_or_1d(y_true)\n    y_prob = column_or_1d(y_prob)\n\n    # 2. Determine the positive class label if not provided\n    if pos_label is None:\n        pos_label = 1\n\n    # 3. Convert y_true to a binary array where the positive class is 1\n    y_true = (y_true == pos_label).astype(int)\n\n    # 4. Define bin edges based on the chosen strategy\n    if strategy == 'uniform':\n        bin_edges = np.linspace(0.0, 1.0, n_bins + 1)\n    elif strategy == 'quantile':\n        bin_edges = np.percentile(y_prob, np.linspace(0, 100, n_bins + 1))\n    else:\n        raise ValueError(\"Invalid strategy: choose 'uniform' or 'quantile'.\")\n\n    # 5. Initialize arrays to store the true and predicted probabilities\n    prob_true = np.zeros(n_bins)\n    prob_pred = np.zeros(n_bins)\n\n    # 6. Loop over each bin to compute the true and predicted probabilities\n    for i in range(n_bins):\n        # Find indices of samples in the current bin\n        bin_mask = (y_prob >= bin_edges[i]) & (y_prob < bin_edges[i + 1])\n        \n        # Compute the fraction of positives and mean predicted probability in the bin\n        if np.any(bin_mask):\n            prob_true[i] = np.mean(y_true[bin_mask])\n            prob_pred[i] = np.mean(y_prob[bin_mask])\n\n    return prob_true, prob_pred\n\n# Example usage\nif __name__ == \"__main__\":\n    y_true = np.array([0, 0, 1, 1])\n    y_prob = np.array([0.1, 0.4, 0.35, 0.8])\n    prob_true, prob_pred = calibration_curve(y_true, y_prob, n_bins=2, strategy='uniform')\n    print(\"True probabilities:\", prob_true)\n    print(\"Predicted probabilities:\", prob_pred)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first ensures that `y_true` and `y_prob` are 1-dimensional arrays.\n\n2. **Positive Class Label**: If `pos_label` is not provided, it defaults to `1`. The function then converts `y_true` to a binary array where the positive class is represented by `1`.\n\n3. **Bin Edges**: Depending on the `strategy`, the function calculates the bin edges. For 'uniform', it uses equally spaced intervals, and for 'quantile', it uses percentiles of `y_prob`.\n\n4. **Probability Calculation**: The function iterates over each bin, calculates the fraction of positive samples (`prob_true`), and the mean predicted probability (`prob_pred`) for samples in that bin.\n\n5. **Return Values**: The function returns the arrays `prob_true` and `prob_pred`, which represent the calibration curve.\n\n6. **Example Usage**: The example demonstrates how to use the function with sample data.",
    "prompt": "Generate a Python function called calibration_curve that computes true and predicted probabilities for a calibration curve. The function takes in the following parameters:\n\n- y_true: array-like of shape (n_samples), representing the true targets.\n- y_prob: array-like of shape (n_samples), representing the probabilities of the positive class.\n- pos_label: int, float, bool, or str, default=None, indicating the label of the positive class.\n- n_bins: int, default=5, specifying the number of bins to discretize the [0, 1] interval.\n- strategy: {'uniform', 'quantile'}, default='uniform', determining the strategy used to define the widths of the bins.\n\nThe function returns two arrays:\n- prob_true: ndarray of shape (n_bins,) or smaller, representing the proportion of samples whose class is the positive class in each bin (fraction of positives).\n- prob_pred: ndarray of shape (n_bins,) or smaller, representing the mean predicted probability in each bin.\n\nThe function also includes examples demonstrating how to use it with sample data.",
    "function_name": "calibration_curve",
    "ground_truth": "sklearn/calibration.py",
    "test": "sklearn/tests/test_calibration.py::test_calibration_display_pos_label",
    "class": "",
    "stage": "Inference",
    "task": "Classification",
    "data": "Table"
}