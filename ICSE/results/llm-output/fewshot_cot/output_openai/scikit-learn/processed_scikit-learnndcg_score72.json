{
    "result": "To implement the `ndcg_score` function, we need to follow a series of steps to compute the Normalized Discounted Cumulative Gain (NDCG). Here's a step-by-step breakdown of how you can implement this function:\n\n```python\nimport numpy as np\n\ndef dcg_score(y_true, y_score, k=None, ignore_ties=False):\n    \"\"\"\n    Compute the Discounted Cumulative Gain (DCG) score.\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_labels,)\n        True scores of entities to be ranked.\n\n    y_score : array-like of shape (n_labels,)\n        Predicted scores.\n\n    k : int, default=None\n        Only consider the highest k scores in the ranking. If `None`, use all outputs.\n\n    ignore_ties : bool, default=False\n        Assume that there are no ties in y_score for efficiency gains.\n\n    Returns\n    -------\n    dcg : float\n        The DCG score.\n    \"\"\"\n    order = np.argsort(y_score)[::-1]\n    y_true = np.take(y_true, order[:k])\n\n    if ignore_ties:\n        gains = y_true\n    else:\n        gains = 2 ** y_true - 1\n\n    discounts = np.log2(np.arange(len(y_true)) + 2)\n    return np.sum(gains / discounts)\n\ndef ndcg_score(y_true, y_score, k=None, sample_weight=None, ignore_ties=False):\n    \"\"\"\n    Compute Normalized Discounted Cumulative Gain (NDCG) score.\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples, n_labels)\n        True targets of multilabel classification, or true scores of entities to be ranked.\n\n    y_score : array-like of shape (n_samples, n_labels)\n        Target scores.\n\n    k : int, default=None\n        Only consider the highest k scores in the ranking. If `None`, use all outputs.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights. If `None`, all samples are given the same weight.\n\n    ignore_ties : bool, default=False\n        Assume that there are no ties in y_score for efficiency gains.\n\n    Returns\n    -------\n    normalized_discounted_cumulative_gain : float in [0., 1.]\n        The averaged NDCG scores for all samples.\n    \"\"\"\n    y_true = np.asarray(y_true)\n    y_score = np.asarray(y_score)\n\n    if sample_weight is None:\n        sample_weight = np.ones(y_true.shape[0])\n\n    scores = []\n    for true, score, weight in zip(y_true, y_score, sample_weight):\n        best_dcg = dcg_score(true, true, k, ignore_ties)\n        actual_dcg = dcg_score(true, score, k, ignore_ties)\n        if best_dcg == 0:\n            scores.append(0.0)\n        else:\n            scores.append(weight * (actual_dcg / best_dcg))\n\n    return np.sum(scores) / np.sum(sample_weight)\n\n```\n\n### Explanation:\n\n1. **DCG Calculation**: The `dcg_score` function computes the Discounted Cumulative Gain for a single sample. It sorts the true scores based on the predicted scores, applies a logarithmic discount, and sums the results.\n\n2. **NDCG Calculation**: The `ndcg_score` function computes the NDCG for each sample by dividing the actual DCG by the ideal DCG (best possible DCG). It averages these scores across all samples, weighted by `sample_weight`.\n\n3. **Parameters**:\n   - `y_true` and `y_score` are the true and predicted scores, respectively.\n   - `k` limits the number of top scores considered.\n   - `sample_weight` allows weighting of samples.\n   - `ignore_ties` can be used to assume no ties in `y_score` for efficiency.\n\nThis implementation assumes that `y_true` and `y_score` are 2D arrays where each row corresponds to a sample and each column corresponds to a label or entity to be ranked.",
    "prompt": "Generate a Python function called ndcg_score that Compute Normalized Discounted Cumulative Gain.\n\n    Sum the true scores ranked in the order induced by the predicted scores,\n    after applying a logarithmic discount. Then divide by the best possible\n    score (Ideal DCG, obtained for a perfect ranking) to obtain a score between\n    0 and 1.\n\n    This ranking metric returns a high value if true labels are ranked high by\n    ``y_score``.\n\n    Parameters\n    ----------\n    y_true : array-like of shape (n_samples, n_labels)\n        True targets of multilabel classification, or true scores of entities\n        to be ranked. Negative values in `y_true` may result in an output\n        that is not between 0 and 1.\n\n    y_score : array-like of shape (n_samples, n_labels)\n        Target scores, can either be probability estimates, confidence values,\n        or non-thresholded measure of decisions (as returned by\n        \"decision_function\" on some classifiers).\n\n    k : int, default=None\n        Only consider the highest k scores in the ranking. If `None`, use all\n        outputs.\n\n    sample_weight : array-like of shape (n_samples,), default=None\n        Sample weights. If `None`, all samples are given the same weight.\n\n    ignore_ties : bool, default=False\n        Assume that there are no ties in y_score (which is likely to be the\n        case if y_score is continuous) for efficiency gains.\n\n    Returns\n    -------\n    normalized_discounted_cumulative_gain : float in [0., 1.]\n        The averaged NDCG scores for all samples.",
    "function_name": "ndcg_score",
    "ground_truth": "sklearn/metrics/_ranking.py",
    "test": "sklearn/metrics/tests/test_ranking.py:test_ndcg_toy_examples",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}