{
    "result": "To create a Python function called `hinge_loss` that calculates the average hinge loss for binary or multiclass classification tasks, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef hinge_loss(y_true, pred_decision, labels=None, sample_weight=None):\n    \"\"\"\n    Calculate the average hinge loss for binary or multiclass classification tasks.\n\n    Args:\n        y_true (array-like): True target values, encoded as integers (+1 and -1 for binary classification).\n        pred_decision (array-like): Predicted decision values.\n        labels (array-like, optional): All labels for multiclass hinge loss.\n        sample_weight (array-like, optional): Sample weights.\n\n    Returns:\n        float: The average hinge loss.\n    \"\"\"\n    # 1. Convert inputs to NumPy arrays for consistent handling\n    y_true = np.asarray(y_true)\n    pred_decision = np.asarray(pred_decision)\n\n    # 2. Handle sample weights, defaulting to 1 if not provided\n    if sample_weight is None:\n        sample_weight = np.ones_like(y_true, dtype=float)\n    else:\n        sample_weight = np.asarray(sample_weight)\n\n    # 3. Determine if the task is binary or multiclass based on unique labels\n    unique_labels = np.unique(y_true)\n    if labels is None:\n        labels = unique_labels\n\n    # 4. Check if the task is binary classification\n    if len(labels) == 2:\n        # Binary classification hinge loss\n        # Ensure labels are +1 and -1\n        if set(labels) != {1, -1}:\n            raise ValueError(\"For binary classification, labels must be +1 and -1.\")\n\n        # 5. Calculate the hinge loss for binary classification\n        loss = np.maximum(0, 1 - y_true * pred_decision)\n\n    else:\n        # Multiclass classification hinge loss\n        # 6. Ensure pred_decision is 2D for multiclass\n        if pred_decision.ndim == 1:\n            raise ValueError(\"For multiclass classification, pred_decision must be 2D.\")\n\n        # 7. Calculate the hinge loss for each class\n        num_classes = len(labels)\n        loss = np.zeros_like(y_true, dtype=float)\n        for i, true_label in enumerate(y_true):\n            true_index = np.where(labels == true_label)[0][0]\n            true_decision = pred_decision[i, true_index]\n            margins = pred_decision[i] - true_decision + 1\n            margins[true_index] = 0  # Ignore the true class\n            loss[i] = np.sum(np.maximum(0, margins))\n\n    # 8. Apply sample weights to the loss\n    weighted_loss = sample_weight * loss\n\n    # 9. Calculate the average hinge loss\n    average_loss = np.mean(weighted_loss)\n\n    # 10. Return the average hinge loss\n    return average_loss\n```\n\n### Explanation:\n\n1. **Input Conversion**: Convert `y_true` and `pred_decision` to NumPy arrays for consistent handling.\n2. **Sample Weights**: Handle `sample_weight`, defaulting to an array of ones if not provided.\n3. **Label Determination**: Determine if the task is binary or multiclass based on unique labels.\n4. **Binary Classification**: For binary classification, ensure labels are +1 and -1, and calculate the hinge loss.\n5. **Multiclass Classification**: For multiclass, ensure `pred_decision` is 2D, calculate the hinge loss for each class, and sum the losses.\n6. **Weighted Loss**: Apply sample weights to the calculated loss.\n7. **Average Loss**: Compute the average hinge loss and return it.\n\nThis function handles both binary and multiclass classification tasks, applying different calculations based on the number of unique labels present in the target values. It also includes error handling for different scenarios and utilizes NumPy functions for efficient computation.",
    "prompt": "Create a Python function called hinge_loss that calculates the average hinge loss for binary or multiclass classification tasks. The function takes in the following parameters:\n\n- y_true: an array-like object containing the true target values, encoded as integers (+1 and -1 for binary classification).\n- pred_decision: an array-like object containing the predicted decision values.\n- labels: an optional array-like object containing all the labels for multiclass hinge loss.\n- sample_weight: an optional array-like object containing sample weights.\n\nThe function returns the average hinge loss as a float value. The hinge loss is calculated based on the margin between the true and predicted values, and it serves as an upper bound for the number of classification mistakes made by the classifier.\n\nThe function handles both binary and multiclass cases, applying different calculations based on the number of unique labels present in the target values. The implementation includes error handling for different scenarios and utilizes NumPy functions for efficient computation.",
    "function_name": "hinge_loss",
    "ground_truth": "sklearn/metrics/_classification.py",
    "test": "sklearn/metrics/tests/test_classification.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classificatoin",
    "data": "Table"
}