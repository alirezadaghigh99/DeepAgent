{
    "result": "To create a function called `contingency_matrix` that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom sklearn.utils import check_array\n\ndef contingency_matrix(labels_true, labels_pred, eps=None, sparse=False, dtype=None):\n    \"\"\"\n    Build a contingency matrix describing the relationship between ground truth class labels and cluster labels.\n\n    Parameters:\n    - labels_true: array-like of shape (n_samples,)\n        Ground truth class labels.\n    - labels_pred: array-like of shape (n_samples,)\n        Cluster labels.\n    - eps: float, optional\n        If not None, a small value added to all entries of the contingency matrix to avoid zero entries.\n    - sparse: bool, optional\n        If True, return a sparse CSR matrix.\n    - dtype: numeric type, optional\n        Desired data type of the output matrix.\n\n    Returns:\n    - C: ndarray or sparse matrix of shape (n_classes_true, n_classes_pred)\n        Contingency matrix.\n\n    Example:\n    >>> labels_true = [0, 0, 1, 1, 2, 2]\n    >>> labels_pred = [0, 0, 1, 1, 0, 2]\n    >>> contingency_matrix(labels_true, labels_pred)\n    array([[2, 0, 0],\n           [0, 2, 0],\n           [1, 0, 1]])\n    \"\"\"\n    # 1. Ensure input arrays are 1D and have the same length\n    labels_true = check_array(labels_true, ensure_2d=False, dtype=None)\n    labels_pred = check_array(labels_pred, ensure_2d=False, dtype=None)\n    if labels_true.shape != labels_pred.shape:\n        raise ValueError(\"labels_true and labels_pred must have the same size.\")\n\n    # 2. Determine the unique classes and clusters\n    classes, class_idx = np.unique(labels_true, return_inverse=True)\n    clusters, cluster_idx = np.unique(labels_pred, return_inverse=True)\n\n    # 3. Initialize the contingency matrix with zeros\n    n_classes = classes.size\n    n_clusters = clusters.size\n    if dtype is None:\n        dtype = np.float64 if eps is not None else np.int64\n    C = np.zeros((n_classes, n_clusters), dtype=dtype)\n\n    # 4. Populate the contingency matrix\n    np.add.at(C, (class_idx, cluster_idx), 1)\n\n    # 5. Add eps to all entries if specified\n    if eps is not None:\n        C = C.astype(np.float64)\n        C += eps\n\n    # 6. Convert to sparse matrix if requested\n    if sparse:\n        C = csr_matrix(C)\n\n    # 7. Return the contingency matrix\n    return C\n```\n\n### Explanation:\n\n1. **Input Validation**: We use `check_array` from `sklearn.utils` to ensure that the input arrays are 1D and have the same length.\n\n2. **Unique Classes and Clusters**: We determine the unique classes and clusters using `np.unique`, which also provides indices to map each label to its corresponding class or cluster.\n\n3. **Contingency Matrix Initialization**: We initialize a zero matrix of shape `(n_classes, n_clusters)`.\n\n4. **Matrix Population**: We use `np.add.at` to efficiently populate the contingency matrix by incrementing the appropriate indices.\n\n5. **Epsilon Adjustment**: If `eps` is provided, we convert the matrix to `float64` and add `eps` to all entries to avoid zero entries.\n\n6. **Sparse Matrix Conversion**: If `sparse` is `True`, we convert the matrix to a sparse CSR format using `csr_matrix`.\n\n7. **Return**: Finally, we return the contingency matrix, either as a dense or sparse matrix based on the `sparse` parameter.",
    "prompt": "Generate a Python function called contingency_matrix that builds a contingency matrix describing the relationship between ground truth class labels and cluster labels. The function takes in two array-like inputs: labels_true (ground truth class labels) and labels_pred (cluster labels). Additionally, it has optional parameters eps (float), sparse (bool), and dtype (numeric type). \n\nThe function returns a contingency matrix of shape [n_classes_true, n_classes_pred], where each element C[i, j] represents the number of samples in true class i and predicted class j. If eps is not None, the dtype of the output array will be float; otherwise, it will be an integer unless specified with the dtype argument. If sparse is True, a sparse CSR matrix will be returned. \n\nAn example usage of the function is provided in the docstring, where labels_true and labels_pred are given as input, and the resulting contingency matrix is shown.",
    "function_name": "contingency_matrix",
    "ground_truth": "sklearn/metrics/cluster/_supervised.py",
    "test": "sklearn/metrics/cluster/tests/test_supervised.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}