{
    "result": "To create a function `make_multilabel_classification` that generates a random multilabel classification problem, we can follow a structured approach similar to the examples provided. This function will generate synthetic data for multilabel classification tasks, allowing for customization of various parameters. Here's a step-by-step implementation:\n\n```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom sklearn.utils import check_random_state\n\ndef make_multilabel_classification(n_samples=100, n_features=20, n_classes=5, n_labels=2,\n                                   length=50, allow_unlabeled=False, sparse=False,\n                                   return_distributions=False, random_state=None):\n    \"\"\"\n    Generate a random multilabel classification problem.\n\n    Parameters:\n    - n_samples: int, default=100\n        Number of samples.\n    - n_features: int, default=20\n        Number of features.\n    - n_classes: int, default=5\n        Number of classes.\n    - n_labels: int, default=2\n        Average number of labels per instance.\n    - length: int, default=50\n        Average length of the document (number of non-zero features).\n    - allow_unlabeled: bool, default=False\n        If True, some instances might not have any labels.\n    - sparse: bool, default=False\n        If True, return X and Y as sparse matrices.\n    - return_distributions: bool, default=False\n        If True, return the class and feature distributions.\n    - random_state: int, RandomState instance or None, default=None\n        Determines random number generation for dataset creation.\n\n    Returns:\n    - X: ndarray or sparse matrix of shape (n_samples, n_features)\n        The generated samples.\n    - Y: ndarray or sparse matrix of shape (n_samples, n_classes)\n        The label sets.\n    - p_c: ndarray of shape (n_classes,), optional\n        Prior class probability.\n    - p_w_c: ndarray of shape (n_features, n_classes), optional\n        Conditional probabilities of features given classes.\n    \"\"\"\n    # 1. Initialize random state\n    rng = check_random_state(random_state)\n\n    # 2. Generate class prior probabilities\n    p_c = rng.rand(n_classes)\n    p_c /= p_c.sum()\n\n    # 3. Generate conditional probabilities of features given classes\n    p_w_c = rng.rand(n_features, n_classes)\n    p_w_c /= p_w_c.sum(axis=0)\n\n    # 4. Initialize X and Y\n    X = np.zeros((n_samples, n_features))\n    Y = np.zeros((n_samples, n_classes))\n\n    # 5. Generate samples\n    for i in range(n_samples):\n        # 5.1. Sample number of labels for this instance\n        if allow_unlabeled:\n            n_labels_i = rng.poisson(n_labels)\n        else:\n            n_labels_i = max(1, rng.poisson(n_labels))\n\n        # 5.2. Sample labels\n        labels = rng.choice(n_classes, size=n_labels_i, replace=False, p=p_c)\n        Y[i, labels] = 1\n\n        # 5.3. Sample features\n        for label in labels:\n            features = rng.choice(n_features, size=length, replace=False, p=p_w_c[:, label])\n            X[i, features] = 1\n\n    # 6. Convert to sparse matrices if requested\n    if sparse:\n        X = csr_matrix(X)\n        Y = csr_matrix(Y)\n\n    # 7. Return results\n    if return_distributions:\n        return X, Y, p_c, p_w_c\n    else:\n        return X, Y\n\n# Example usage\nX, Y = make_multilabel_classification(n_samples=100, n_features=20, n_classes=5, n_labels=2)\n```\n\n### Explanation:\n\n1. **Random State Initialization**: We use `check_random_state` to handle the random state, ensuring reproducibility.\n\n2. **Class and Feature Probabilities**: We generate prior class probabilities (`p_c`) and conditional probabilities of features given classes (`p_w_c`).\n\n3. **Sample Generation**: For each sample, we determine the number of labels and select them based on the class probabilities. We then select features based on the conditional probabilities for each label.\n\n4. **Sparse Option**: If `sparse=True`, the function converts the feature and label matrices to sparse format.\n\n5. **Return Options**: The function can optionally return the class and feature distributions if `return_distributions=True`.\n\nThis function provides a flexible way to generate synthetic multilabel classification data, useful for testing and experimentation.",
    "prompt": "Generate a Python function called make_multilabel_classification that generates a random multilabel classification problem. The function takes in parameters such as the number of samples, number of features, number of classes, number of labels, document length, and other optional parameters. It returns generated samples X as an ndarray of shape (n_samples, n_features), label sets Y as an ndarray or sparse matrix of shape (n_samples, n_classes), and optionally prior class probability p_c and conditional probabilities of features given classes p_w_c. The function utilizes rejection sampling to ensure valid sample generation. Refer to the User Guide for more information.",
    "function_name": "make_multilabel_classification",
    "ground_truth": "sklearn/datasets/_samples_generator.py",
    "test": "sklearn/datasets/tests/test_samples_generator.py",
    "class": "",
    "stage": "Model Construction",
    "task": "Classification",
    "data": ""
}