{
    "result": "To create a function called `compute_sample_weight` that estimates sample weights for unbalanced datasets, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom collections import Counter\n\ndef compute_sample_weight(class_weight, y, indices=None):\n    \"\"\"\n    Estimate sample weights by class for unbalanced datasets.\n\n    Parameters:\n    - class_weight: dict, list of dicts, \"balanced\", or None\n        Weights associated with classes. If \"balanced\", weights are adjusted based on class frequencies.\n    - y: array-like, sparse matrix\n        Original class labels per sample.\n    - indices: array-like of shape (n_subsample,), default=None\n        Indices to be used in a subsample.\n\n    Returns:\n    - sample_weight_vect: numpy array of shape (n_samples,)\n        Sample weights as applied to the original y.\n    \"\"\"\n    # 1. If indices are provided, use them to create a subsample of y\n    if indices is not None:\n        y = np.asarray(y)[indices]\n\n    # 2. Determine the unique classes and their frequencies in y\n    unique_classes, class_counts = np.unique(y, return_counts=True)\n    class_freq = dict(zip(unique_classes, class_counts))\n\n    # 3. Initialize sample weights to 1 for all samples\n    sample_weight_vect = np.ones_like(y, dtype=float)\n\n    # 4. Handle different types of class_weight input\n    if class_weight is None:\n        # No weighting, return the default sample weights\n        return sample_weight_vect\n\n    elif class_weight == \"balanced\":\n        # Calculate balanced weights: n_samples / (n_classes * class_count)\n        n_samples = len(y)\n        n_classes = len(unique_classes)\n        class_weight = {cls: n_samples / (n_classes * count) for cls, count in class_freq.items()}\n\n    elif isinstance(class_weight, dict):\n        # Use the provided class_weight dictionary\n        pass  # class_weight is already a dictionary\n\n    else:\n        raise ValueError(\"class_weight must be 'balanced', a dict, or None\")\n\n    # 5. Apply the class weights to the sample weights\n    for cls, weight in class_weight.items():\n        sample_weight_vect[y == cls] = weight\n\n    # 6. Return the computed sample weights\n    return sample_weight_vect\n\n# Example usage:\n# y = np.array([0, 1, 0, 1, 1, 2])\n# class_weight = \"balanced\"\n# sample_weights = compute_sample_weight(class_weight, y)\n# print(sample_weights)\n```\n\n### Explanation:\n\n1. **Indices Handling**: If `indices` are provided, the function uses them to create a subsample of `y`.\n\n2. **Class Frequency Calculation**: The function calculates the frequency of each class in `y`.\n\n3. **Sample Weight Initialization**: It initializes a sample weight vector with ones.\n\n4. **Class Weight Handling**: The function handles different types of `class_weight` inputs:\n   - If `None`, it returns the default weights.\n   - If `\"balanced\"`, it calculates weights inversely proportional to class frequencies.\n   - If a dictionary, it uses the provided weights.\n\n5. **Weight Application**: It applies the calculated or provided class weights to the sample weight vector.\n\n6. **Return**: Finally, it returns the computed sample weights.\n\nThis function provides flexibility in handling different scenarios for class weighting and can be used to address class imbalance in datasets.",
    "prompt": "Create a Python function called compute_sample_weight that estimates sample weights by class for unbalanced datasets. The function takes in three parameters: class_weight (dict, list of dicts, \"balanced\", or None), y (array-like, sparse matrix), and indices (array-like of shape (n_subsample,), default=None). \n\nThe class_weight parameter represents weights associated with classes, with options for different formats and the \"balanced\" mode for automatic adjustment based on class frequencies. The y parameter is an array of original class labels per sample, and the indices parameter is an array of indices to be used in a subsample.\n\nThe function returns a numpy array called sample_weight_vect of shape (n_samples,) containing the sample weights as applied to the original y. The function includes examples of usage and error handling for different scenarios.",
    "function_name": "compute_sample_weight",
    "ground_truth": "sklearn/utils/class_weight.py",
    "test": "sklearn/utils/tests/test_class_weight.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}