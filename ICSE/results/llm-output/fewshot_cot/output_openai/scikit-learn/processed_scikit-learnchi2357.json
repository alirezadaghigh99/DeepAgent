{
    "result": "To create a function that computes chi-squared statistics between each non-negative feature and class, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement the `chi2` function:\n\n```python\nimport numpy as np\nfrom scipy.sparse import issparse\nfrom sklearn.preprocessing import LabelBinarizer\nfrom scipy.stats import chi2 as chi2_distribution\n\ndef chi2(X, y):\n    \"\"\"\n    Compute chi-squared statistics between each non-negative feature and class.\n\n    Parameters:\n    X : array-like or sparse matrix, shape (n_samples, n_features)\n        Sample vectors.\n    y : array-like, shape (n_samples,)\n        Target vector (class labels).\n\n    Returns:\n    chi2 : ndarray, shape (n_features,)\n        Chi2 statistics for each feature.\n    p_values : ndarray, shape (n_features,)\n        p-values for each feature.\n    \"\"\"\n    # 1. Ensure X is a dense array if it's sparse\n    if issparse(X):\n        X = X.toarray()\n\n    # 2. Binarize the class labels\n    lb = LabelBinarizer()\n    Y = lb.fit_transform(y)\n\n    # 3. If Y is a binary class, ensure it has two columns\n    if Y.shape[1] == 1:\n        Y = np.hstack([1 - Y, Y])\n\n    # 4. Compute observed frequencies\n    observed = np.dot(Y.T, X)\n\n    # 5. Compute expected frequencies\n    feature_count = X.sum(axis=0)\n    class_prob = Y.mean(axis=0)\n    expected = np.outer(class_prob, feature_count)\n\n    # 6. Compute chi-squared statistics\n    chi2_stat = (observed - expected) ** 2 / expected\n    chi2_stat = chi2_stat.sum(axis=0)\n\n    # 7. Compute p-values\n    p_values = chi2_distribution.sf(chi2_stat, df=Y.shape[1] - 1)\n\n    # 8. Return the chi-squared statistics and p-values\n    return chi2_stat, p_values\n```\n\n### Explanation of the Steps:\n\n1. **Ensure Dense Array**: If `X` is a sparse matrix, convert it to a dense array for easier manipulation.\n\n2. **Binarize Class Labels**: Use `LabelBinarizer` to convert class labels into a binary matrix representation. This helps in calculating observed frequencies for each class.\n\n3. **Handle Binary Classes**: If the target is binary, ensure the resulting matrix has two columns to represent both classes.\n\n4. **Compute Observed Frequencies**: Calculate the observed frequency of each feature for each class by multiplying the transposed binary class matrix with `X`.\n\n5. **Compute Expected Frequencies**: Calculate the expected frequency of each feature for each class based on the class probabilities and total feature counts.\n\n6. **Compute Chi-Squared Statistics**: Use the formula for chi-squared statistics to compute the value for each feature.\n\n7. **Compute p-values**: Calculate the p-values using the chi-squared distribution's survival function.\n\n8. **Return Results**: Return the chi-squared statistics and p-values for each feature.",
    "prompt": "Generate a Python function called chi2 that computes chi-squared statistics between each non-negative feature and class. The function takes two parameters: X, an array-like or sparse matrix of shape (n_samples, n_features) representing sample vectors, and y, an array-like of shape (n_samples,) representing target vector (class labels). The function returns two arrays: chi2, an ndarray of shape (n_features,) containing Chi2 statistics for each feature, and p_values, an ndarray of shape (n_features,) containing p-values for each feature. The complexity of the algorithm is O(n_classes * n_features). The function uses the LabelBinarizer to handle sparse representation for Y and performs calculations to determine observed and expected values before calling the _chisquare function.",
    "function_name": "chi2",
    "ground_truth": "sklearn/feature_selection/_univariate_selection.py",
    "test": "sklearn/feature_selection/tests/test_chi2.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}