{
    "result": "To create a function called `det_curve` that computes error rates for different probability thresholds in a binary classification task, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\nfrom sklearn.utils import check_consistent_length, column_or_1d\nfrom sklearn.utils.multiclass import type_of_target\n\ndef det_curve(y_true, y_score, pos_label=None, sample_weight=None):\n    \"\"\"\n    Compute error rates for different probability thresholds in a binary classification task.\n\n    Parameters:\n    - y_true: ndarray of shape (n_samples), true binary labels.\n    - y_score: ndarray of shape (n_samples), target scores.\n    - pos_label: int, float, bool, or str, default=None, label of the positive class.\n    - sample_weight: array-like of shape (n_samples), default=None, sample weights.\n\n    Returns:\n    - fpr: ndarray of shape (n_thresholds), false positive rate.\n    - fnr: ndarray of shape (n_thresholds), false negative rate.\n    - thresholds: ndarray of shape (n_thresholds), decreasing score values.\n    \"\"\"\n    # 1. Ensure y_true and y_score have consistent lengths\n    y_true = column_or_1d(y_true)\n    y_score = column_or_1d(y_score)\n    check_consistent_length(y_true, y_score, sample_weight)\n\n    # 2. Determine the positive label if not provided\n    if pos_label is None:\n        pos_label = 1.0 if type_of_target(y_true) == 'binary' else y_true.max()\n\n    # 3. Sort scores and corresponding true labels and weights\n    desc_score_indices = np.argsort(y_score, kind=\"mergesort\")[::-1]\n    y_score = y_score[desc_score_indices]\n    y_true = y_true[desc_score_indices]\n    if sample_weight is not None:\n        sample_weight = sample_weight[desc_score_indices]\n\n    # 4. Compute true positive and false positive counts\n    distinct_value_indices = np.where(np.diff(y_score))[0]\n    threshold_idxs = np.r_[distinct_value_indices, y_true.size - 1]\n\n    tps = np.cumsum((y_true == pos_label) * (sample_weight if sample_weight is not None else 1))\n    fps = np.cumsum((y_true != pos_label) * (sample_weight if sample_weight is not None else 1))\n\n    # 5. Calculate false positive rate (fpr) and false negative rate (fnr)\n    tps = tps[threshold_idxs]\n    fps = fps[threshold_idxs]\n\n    if sample_weight is not None:\n        P = np.sum((y_true == pos_label) * sample_weight)\n        N = np.sum((y_true != pos_label) * sample_weight)\n    else:\n        P = np.sum(y_true == pos_label)\n        N = np.sum(y_true != pos_label)\n\n    fpr = fps / N\n    fnr = 1 - tps / P\n\n    # 6. Extract thresholds\n    thresholds = y_score[threshold_idxs]\n\n    # 7. Return the false positive rate, false negative rate, and thresholds\n    return fpr, fnr, thresholds\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first ensures that `y_true` and `y_score` are one-dimensional arrays and have consistent lengths. It also checks the sample weights if provided.\n\n2. **Positive Label Determination**: If `pos_label` is not specified, it defaults to `1.0` for binary targets or the maximum value in `y_true`.\n\n3. **Sorting**: The scores and corresponding true labels (and weights) are sorted in descending order of `y_score`.\n\n4. **Cumulative Sums**: Cumulative sums of true positives and false positives are computed to determine the number of positive and negative samples at each threshold.\n\n5. **Error Rates Calculation**: The false positive rate (FPR) and false negative rate (FNR) are calculated based on the cumulative sums.\n\n6. **Thresholds Extraction**: The function extracts the thresholds corresponding to distinct score values.\n\n7. **Return Values**: The function returns the FPR, FNR, and thresholds, which can be used to evaluate the performance of a binary classifier.",
    "prompt": "Generate a Python function called det_curve that computes error rates for different probability thresholds in a binary classification task. The function takes in the following parameters:\n\n- y_true: ndarray of shape (n_samples), representing the true binary labels.\n- y_score: ndarray of shape (n_samples), representing target scores.\n- pos_label: int, float, bool, or str, default=None, indicating the label of the positive class.\n- sample_weight: array-like of shape (n_samples), default=None, representing sample weights.\n\nThe function returns the following outputs:\n\n- fpr: ndarray of shape (n_thresholds), representing the false positive rate.\n- fnr: ndarray of shape (n_thresholds), representing the false negative rate.\n- thresholds: ndarray of shape (n_thresholds), representing decreasing score values.\n\nThe det_curve function is used for evaluating ranking and error tradeoffs in binary classification tasks. It is recommended to read more about it in the User Guide. Additionally, the function provides examples on how to use it with sample data.",
    "function_name": "det_curve",
    "ground_truth": "sklearn/metrics/_ranking.py",
    "test": "sklearn/metrics/tests/test_ranking.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": ""
}