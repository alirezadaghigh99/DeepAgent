{
    "result": "To implement the `get_badge_embeddings` function for the `BADGE` class, we need to consider both multi-class and binary classification scenarios. The function will scale the embeddings based on the predicted class probabilities. For multi-class problems, each embedding is expanded and scaled for each class, while for binary problems, the original embeddings are returned.\n\nHere's a step-by-step implementation of the `get_badge_embeddings` function:\n\n```python\nimport numpy as np\n\nclass BADGE(EmbeddingBasedQueryStrategy):\n    def __init__(self, num_classes):\n        self.num_classes = num_classes\n\n    def get_badge_embeddings(self, embeddings, proba):\n        \"\"\"\n        Calculate badge embeddings scaled by class probabilities.\n\n        Args:\n            embeddings (np.ndarray): Original embeddings of shape (n_samples, embedding_dim).\n            proba (np.ndarray): Predicted class probabilities of shape (n_samples, num_classes).\n\n        Returns:\n            np.ndarray: Badge embeddings of shape (n_samples, embedding_dim * num_classes) for multi-class,\n                        or (n_samples, embedding_dim) for binary classification.\n        \"\"\"\n        n_samples, embedding_dim = embeddings.shape\n\n        if self.num_classes > 2:\n            # Multi-class case\n            # Initialize an array to hold the expanded and scaled embeddings\n            badge_embeddings = np.zeros((n_samples, embedding_dim * self.num_classes))\n\n            for i in range(n_samples):\n                for c in range(self.num_classes):\n                    # Calculate the scaling factor for each class\n                    scaling_factor = proba[i, c] - (1 if c == np.argmax(proba[i]) else 0)\n                    # Scale the original embedding and place it in the correct position\n                    badge_embeddings[i, c * embedding_dim:(c + 1) * embedding_dim] = embeddings[i] * scaling_factor\n\n        else:\n            # Binary classification case\n            # Simply return the original embeddings\n            badge_embeddings = embeddings\n\n        return badge_embeddings\n```\n\n### Explanation:\n\n1. **Initialization**: The function starts by determining the number of samples and the dimension of the embeddings.\n\n2. **Multi-class Case**:\n   - For each sample, the function iterates over each class.\n   - It calculates a scaling factor for each class. The scaling factor is the class probability minus 1 for the most likely class (i.e., the class with the highest probability).\n   - The original embedding is scaled by this factor and placed in the appropriate position in the `badge_embeddings` array.\n\n3. **Binary Classification Case**:\n   - If the problem is binary, the function simply returns the original embeddings without modification.\n\nThis implementation ensures that the embeddings are appropriately scaled for use in the BADGE strategy for batch active learning.",
    "prompt": "Write a Python function `get_badge_embeddings` for the `BADGE` class. This function should calculate embeddings scaled by class probabilities, enabling the use of the BADGE strategy for batch active learning. The function takes `embeddings` and `proba` (predicted class probabilities) as input and returns the `badge_embeddings`. For multi-class problems, the embeddings are expanded and scaled for each class; for binary problems, the original embeddings are returned.\n\n```python\nclass BADGE(EmbeddingBasedQueryStrategy):\n    def __init__(self, num_classes):\n        self.num_classes = num_classes\n\n    def get_badge_embeddings(self, embeddings, proba):\n``` \n\nThe `get_badge_embeddings` function should generate an embedding matrix where each original embedding is scaled by the negative class probabilities, except for the most likely class, which is scaled differently. For multi-class classification, this scaling is performed for each class, creating a larger embedding matrix. The output is a 2D numpy array where each row corresponds to an embedding.",
    "function_name": "get_badge_embeddings",
    "ground_truth": "small_text/integrations/pytorch/query_strategies/strategies.py",
    "test": "tests/integration/small_text/integrations/pytorch/query_strategies/test_query_strategies.py::QueryStrategiesTest",
    "class": "BADGE",
    "stage": "Text",
    "task": "Classification",
    "data": "Evaluation/metrics"
}