{
    "result": "To create a Python class called `EncodeImages` with the specified `encode_images` method, we can follow a structured approach similar to the examples you provided. This class will generate hashes for images in a directory, optionally using multiprocessing for efficiency. Here's how you can implement it:\n\n```python\nimport os\nfrom typing import Optional, Dict\nfrom multiprocessing import cpu_count, Pool\nfrom imagededup.methods import PHash  # Assuming PHash is the hash method you want to use\n\nclass EncodeImages:\n    def __init__(self, hash_method=None):\n        # Initialize with a hash method, defaulting to PHash if none is provided\n        self.hash_method = hash_method or PHash()\n\n    def _generate_hash(self, image_path: str) -> str:\n        # Generate a hash for a single image\n        return self.hash_method.encode_image(image_file=image_path)\n\n    def encode_images(self, image_dir: Optional[str] = None, recursive: bool = False, num_enc_workers: int = cpu_count()) -> Dict[str, str]:\n        \"\"\"\n        Generate hashes for all images in a given directory.\n\n        Args:\n            image_dir (str, optional): Path to the image directory.\n            recursive (bool): Find images recursively in nested directories. Defaults to False.\n            num_enc_workers (int): Number of CPU cores to use for multiprocessing. Defaults to all available CPUs.\n\n        Returns:\n            Dict[str, str]: Mapping of filenames to 64-character hash strings.\n        \"\"\"\n        if image_dir is None:\n            raise ValueError(\"image_dir must be specified.\")\n\n        # 1. Collect all image file paths\n        image_paths = []\n        for root, _, files in os.walk(image_dir):\n            for file in files:\n                if file.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif', '.tiff')):\n                    image_paths.append(os.path.join(root, file))\n            if not recursive:\n                break\n\n        # 2. Generate hashes using multiprocessing if num_enc_workers > 0\n        if num_enc_workers > 0:\n            with Pool(processes=num_enc_workers) as pool:\n                hashes = pool.map(self._generate_hash, image_paths)\n        else:\n            # Single-threaded processing\n            hashes = [self._generate_hash(path) for path in image_paths]\n\n        # 3. Create a dictionary mapping filenames to their hashes\n        hash_mapping = {os.path.basename(path): hash_str for path, hash_str in zip(image_paths, hashes)}\n\n        return hash_mapping\n\n# Example usage:\n# from imagededup.methods import PHash\n# myencoder = EncodeImages(PHash())\n# mapping = myencoder.encode_images('path/to/directory')\n```\n\n### Explanation:\n\n1. **Initialization**: The class is initialized with a hash method, defaulting to `PHash` if none is provided.\n\n2. **_generate_hash Method**: This private method generates a hash for a single image using the specified hash method.\n\n3. **encode_images Method**:\n   - **Image Collection**: It collects all image file paths from the specified directory, optionally searching recursively.\n   - **Hash Generation**: It uses multiprocessing to generate hashes if `num_enc_workers` is greater than 0. Otherwise, it processes images in a single-threaded manner.\n   - **Result Mapping**: It returns a dictionary mapping filenames to their corresponding hash strings.\n\nThis implementation provides a flexible and efficient way to generate image hashes, leveraging multiprocessing for performance when needed.",
    "prompt": "Generate a Python class called encode_images with the following methods:\n- encode_images(self, image_dir=None, recursive: bool = False, num_enc_workers: int = cpu_count())\n\nThe encode_images method generates hashes for all images in a given directory of images. It takes three arguments:\n- image_dir: Path to the image directory.\n- recursive: Optional, find images recursively in a nested image directory structure, set to False by default.\n- num_enc_workers: Optional, number of CPU cores to use for multiprocessing encoding generation, set to the number of CPUs in the system by default. 0 disables multiprocessing.\n\nThe method returns a dictionary that contains a mapping of filenames and corresponding 64-character hash strings, such as {'Image1.jpg': 'hash_string1', 'Image2.jpg': 'hash_string2', ...}\n\nExample usage:\n```\nfrom imagededup.methods import <hash-method>\nmyencoder = <hash-method>()\nmapping = myencoder.encode_images('path/to/directory')\n```",
    "function_name": "encode_images",
    "ground_truth": "imagededup/methods/hashing.py",
    "test": "tests/test_hashing.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": ""
}