{
    "result": "To create a function `yuv420_to_rgb` that converts a YUV420 image to RGB, we need to follow a series of steps. This involves checking the input tensor shapes, upsampling the chroma components, and then converting the YUV444 format to RGB. Here's a step-by-step implementation:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef yuv_to_rgb(yuv):\n    \"\"\"\n    Convert a YUV444 image to RGB.\n    \n    Args:\n        yuv (torch.Tensor): Tensor of shape (*, 3, H, W) in YUV format.\n        \n    Returns:\n        torch.Tensor: Tensor of shape (*, 3, H, W) in RGB format.\n    \"\"\"\n    # Define the conversion matrix from YUV to RGB\n    conversion_matrix = torch.tensor([\n        [1.0, 0.0, 1.402],\n        [1.0, -0.344136, -0.714136],\n        [1.0, 1.772, 0.0]\n    ], dtype=yuv.dtype, device=yuv.device)\n    \n    # Reshape the YUV tensor for matrix multiplication\n    yuv = yuv.permute(0, 2, 3, 1)  # Move channel to the last dimension\n    rgb = torch.matmul(yuv, conversion_matrix.T)\n    rgb = rgb.permute(0, 3, 1, 2)  # Move channel back to the second dimension\n    \n    return rgb\n\ndef yuv420_to_rgb(imagey, imageuv):\n    \"\"\"\n    Convert a YUV420 image to RGB.\n    \n    Args:\n        imagey (torch.Tensor): Tensor of shape (*, 1, H, W) for the Y plane.\n        imageuv (torch.Tensor): Tensor of shape (*, 2, H/2, W/2) for the UV planes.\n        \n    Returns:\n        torch.Tensor: Tensor of shape (*, 3, H, W) in RGB format.\n    \"\"\"\n    # Check input types and shapes\n    if not isinstance(imagey, torch.Tensor) or not isinstance(imageuv, torch.Tensor):\n        raise TypeError(\"Inputs must be torch Tensors.\")\n    \n    if imagey.shape[1] != 1 or imageuv.shape[1] != 2:\n        raise ValueError(\"imagey must have shape (*, 1, H, W) and imageuv must have shape (*, 2, H/2, W/2).\")\n    \n    # Get the dimensions\n    _, _, H, W = imagey.shape\n    _, _, H_uv, W_uv = imageuv.shape\n    \n    if H_uv * 2 != H or W_uv * 2 != W:\n        raise ValueError(\"imageuv dimensions must be half of imagey dimensions.\")\n    \n    # Upsample the UV planes to match the Y plane dimensions\n    imageuv_upsampled = F.interpolate(imageuv, size=(H, W), mode='bilinear', align_corners=False)\n    \n    # Concatenate the Y and upsampled UV planes to form a YUV444 image\n    yuv444 = torch.cat((imagey, imageuv_upsampled), dim=1)\n    \n    # Convert YUV444 to RGB\n    rgb = yuv_to_rgb(yuv444)\n    \n    return rgb\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if the inputs are torch Tensors and if they have the correct shapes. The Y plane should have a shape of `(*, 1, H, W)`, and the UV planes should have a shape of `(*, 2, H/2, W/2)`.\n\n2. **Upsampling**: The UV planes are upsampled using bilinear interpolation to match the dimensions of the Y plane. This is necessary because YUV420 format has chroma subsampling.\n\n3. **Concatenation**: The upsampled UV planes are concatenated with the Y plane to form a YUV444 image.\n\n4. **Conversion**: The `yuv_to_rgb` function is used to convert the YUV444 image to RGB. This function uses a conversion matrix to transform the YUV values to RGB.\n\n5. **Output**: The function returns the RGB image with the shape `(*, 3, H, W)`.",
    "prompt": "Create a Python function called yuv420_to_rgb that converts a YUV420 image to RGB. The function takes two torch Tensors as input: imagey for the Y (luma) image plane with shape (*, 1, H, W) and imageuv for the UV (chroma) image planes with shape (*, 2, H/2, W/2). The output is the RGB version of the image with shape (*, 3, H, W). The function assumes that the image data is in the range of (0, 1) for luma and (-0.5, 0.5) for chroma, and that the input needs to be padded to be evenly divisible by 2 horizontally and vertically. The chroma siting is assumed to be (0.5, 0.5).\n\nEnsure that the input imagey and imageuv are torch Tensors, have the correct shapes, and meet the specified requirements. The function first upsamples the input images and then converts the YUV444 tensor to RGB using a separate function called yuv_to_rgb.",
    "function_name": "yuv420_to_rgb",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestYuv420ToRgb",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}