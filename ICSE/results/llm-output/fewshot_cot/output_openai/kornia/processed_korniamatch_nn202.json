{
    "result": "To create the `match_nn` function as described, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement the function:\n\n```python\nimport torch\n\ndef _no_match(b1):\n    \"\"\"\n    Returns placeholder outputs when there are no matches.\n    \"\"\"\n    # Create a tensor of zeros for distances and a tensor of -1 for indices\n    distances = torch.zeros((b1, 1))\n    indices = torch.full((b1, 2), -1, dtype=torch.long)\n    return distances, indices\n\ndef match_nn(desc1, desc2, dm=None):\n    \"\"\"\n    Finds the nearest neighbors in desc2 for each vector in desc1.\n\n    Args:\n        desc1 (Tensor): A tensor of shape (B1, D) containing descriptors.\n        desc2 (Tensor): A tensor of shape (B2, D) containing descriptors.\n        dm (Tensor, optional): A precomputed distance matrix of shape (B1, B2).\n\n    Returns:\n        distances (Tensor): A tensor of shape (B1, 1) with matching descriptor distances.\n        indices (Tensor): A tensor of shape (B1, 2) with indices of matching descriptors.\n    \"\"\"\n    # 1. Check if desc1 or desc2 is empty and return placeholder if so\n    if desc1.size(0) == 0 or desc2.size(0) == 0:\n        return _no_match(desc1.size(0))\n\n    # 2. Compute the distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n\n    # 3. Find the minimum distances and their indices in desc2 for each vector in desc1\n    min_distances, min_indices = torch.min(dm, dim=1)\n\n    # 4. Construct the indices tensor for matching descriptors\n    indices = torch.stack((torch.arange(desc1.size(0)), min_indices), dim=1)\n\n    # 5. Reshape the distances to have shape (B1, 1)\n    distances = min_distances.unsqueeze(1)\n\n    # 6. Return the distances and indices tensors\n    return distances, indices\n```\n\n### Explanation:\n\n1. **Placeholder Output**: The `_no_match` function returns placeholder tensors when either `desc1` or `desc2` is empty. It returns a tensor of zeros for distances and a tensor of -1 for indices.\n\n2. **Distance Matrix Calculation**: If the distance matrix `dm` is not provided, it is computed using `torch.cdist`, which calculates the pairwise distances between the descriptors in `desc1` and `desc2`.\n\n3. **Finding Nearest Neighbors**: The function uses `torch.min` to find the minimum distances and their corresponding indices in `desc2` for each descriptor in `desc1`.\n\n4. **Constructing Indices Tensor**: The indices tensor is constructed by stacking the indices of `desc1` and the corresponding nearest neighbor indices from `desc2`.\n\n5. **Output**: The function returns the distances and indices tensors, with distances reshaped to have shape `(B1, 1)`.\n\nThis implementation assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs, as specified in the requirements.",
    "prompt": "Create a Python function `match_nn` that:\n\n- Takes three parameters:\n  - `desc1`: A tensor containing a batch of descriptors with shape `(B1, D)`.\n  - `desc2`: A tensor containing another batch of descriptors with shape `(B2, D)`.\n  - `dm`: An optional precomputed distance matrix tensor of shape `(B1, B2)`. If not provided, the function computes the distance matrix using `torch.cdist`.\n\n- The function finds the nearest neighbors in `desc2` for each vector in `desc1`:\n  - Checks if the input descriptors have the correct shapes.\n  - If either `desc1` or `desc2` is empty, it returns a placeholder output using `_no_match`.\n  - If `dm` is not provided, it calculates the distance matrix between `desc1` and `desc2`.\n  - Finds the minimum distances and their corresponding indices in `desc2` for each vector in `desc1`.\n  - Constructs a tensor containing the indices of matching descriptors in `desc1` and `desc2`.\n\n- Returns:\n  - A tensor of matching descriptor distances with shape `(B1, 1)`.\n  - A tensor of long indices of matching descriptors in `desc1` and `desc2` with shape `(B1, 2)`.\n\nErrors:\n- The function assumes that the input tensors have compatible shapes and does not include explicit error handling for incompatible inputs.",
    "function_name": "match_nn",
    "ground_truth": "kornia/feature/matching.py#L60",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}