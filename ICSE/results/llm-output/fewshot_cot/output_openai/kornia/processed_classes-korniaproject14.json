{
    "result": "To generate the `project` function for the `PinholeCamera` class, we need to follow a series of steps to transform a 3D point in world coordinates into 2D camera coordinates. This involves using the camera's intrinsic and extrinsic matrices to perform the necessary transformations. Here's a step-by-step implementation:\n\n```python\nimport torch\nfrom torch import Tensor\n\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n\n    def project(self, point_3d: Tensor) -> Tensor:\n        \"\"\"\n        Project a 3D point in world coordinates onto the 2D camera plane.\n\n        Args:\n            point_3d (Tensor): A tensor of shape (*, 3) representing 3D points.\n\n        Returns:\n            Tensor: A tensor of shape (*, 2) representing 2D camera coordinates (u, v).\n        \"\"\"\n        # 1. Convert the 3D point to homogeneous coordinates by adding a 1.\n        ones = torch.ones((*point_3d.shape[:-1], 1), dtype=point_3d.dtype, device=point_3d.device)\n        point_3d_homogeneous = torch.cat((point_3d, ones), dim=-1)\n\n        # 2. Apply the extrinsic transformation to convert world coordinates to camera coordinates.\n        point_camera = torch.matmul(point_3d_homogeneous, self._extrinsics.T)\n\n        # 3. Apply the intrinsic transformation to project the 3D camera coordinates to 2D.\n        point_2d_homogeneous = torch.matmul(point_camera, self._intrinsics.T)\n\n        # 4. Normalize the homogeneous coordinates to get the (u, v) coordinates.\n        u = point_2d_homogeneous[..., 0] / point_2d_homogeneous[..., 2]\n        v = point_2d_homogeneous[..., 1] / point_2d_homogeneous[..., 2]\n\n        # 5. Stack the (u, v) coordinates to form the final output tensor.\n        uv_coordinates = torch.stack((u, v), dim=-1)\n\n        return uv_coordinates\n```\n\n### Explanation:\n\n1. **Homogeneous Coordinates**: We start by converting the 3D point into homogeneous coordinates by appending a 1. This is necessary for matrix multiplication with the extrinsic matrix.\n\n2. **Extrinsic Transformation**: The extrinsic matrix transforms the 3D point from world coordinates to camera coordinates. This involves a matrix multiplication with the transposed extrinsic matrix.\n\n3. **Intrinsic Transformation**: The intrinsic matrix projects the 3D camera coordinates onto the 2D image plane. Again, this is done via matrix multiplication with the transposed intrinsic matrix.\n\n4. **Normalization**: The resulting 2D coordinates are in homogeneous form, so we divide by the third coordinate to get the actual (u, v) coordinates.\n\n5. **Output**: Finally, we stack the u and v coordinates to form the output tensor of shape `(*, 2)`.",
    "prompt": "\"Generate the `project` function for the following class to project a 3D point in world coordinates onto the 2D camera plane. The input is `self` and a `point_3d` tensor with shape `(*, 3)`, and the output is a tensor of `(u, v)` camera coordinates with shape `(*, 2)`.\n\n```python\nclass PinholeCamera:\n    def __init__(self, intrinsics: Tensor, extrinsics: Tensor, height: Tensor, width: Tensor) -> None:\n        self.height: Tensor = height\n        self.width: Tensor = width\n        self._intrinsics: Tensor = intrinsics\n        self._extrinsics: Tensor = extrinsics\n```\"",
    "function_name": "project",
    "ground_truth": "kornia/geometry/camera/pinhole.py",
    "test": "tests/geometry/camera/test_pinhole.py",
    "class": "PinholeCamera",
    "stage": "Image",
    "task": "",
    "data": "pre-post process"
}