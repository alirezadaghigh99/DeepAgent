{
    "result": "To create the `match_fginn` function, we can follow a step-by-step approach similar to the examples provided. This function will find the nearest neighbors in `desc2` for each vector in `desc1`, perform a mutual nearest neighbor check if specified, and return the descriptor distances and indices of matching descriptors. Here's how you can implement it:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:\n    \"\"\"\n    Finds nearest neighbors in desc2 for each vector in desc1.\n\n    Args:\n        desc1 (Tensor): Descriptors from the first set, shape (N1, D).\n        desc2 (Tensor): Descriptors from the second set, shape (N2, D).\n        lafs1 (Tensor): Local affine frames for desc1, shape (N1, 2, 3).\n        lafs2 (Tensor): Local affine frames for desc2, shape (N2, 2, 3).\n        th (float): Distance threshold for matching.\n        spatial_th (float): Spatial distance threshold for matching.\n        mutual (bool): If True, perform mutual nearest neighbor check.\n        dm (Optional[Tensor]): Precomputed distance matrix, shape (N1, N2).\n\n    Returns:\n        Tuple[Tensor, Tensor]: Descriptor distances and indices of matches.\n    \"\"\"\n    # 1. Compute the distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n\n    # 2. Find the nearest neighbor in desc2 for each descriptor in desc1\n    min_dist, min_idx = torch.min(dm, dim=1)\n\n    # 3. Apply the distance threshold\n    valid_matches = min_dist < th\n\n    # 4. Check spatial consistency using lafs\n    if spatial_th > 0:\n        spatial_dist = torch.norm(lafs1[:, :2, 2].unsqueeze(1) - lafs2[:, :2, 2], dim=2)\n        valid_matches &= (spatial_dist.min(dim=1).values < spatial_th)\n\n    # 5. Perform mutual nearest neighbor check if specified\n    if mutual:\n        reverse_min_dist, reverse_min_idx = torch.min(dm, dim=0)\n        mutual_matches = (reverse_min_idx[min_idx] == torch.arange(len(desc1), device=desc1.device))\n        valid_matches &= mutual_matches\n\n    # 6. Filter matches based on validity\n    matched_indices = torch.nonzero(valid_matches).squeeze(1)\n    matched_distances = min_dist[matched_indices]\n    matched_desc1_indices = matched_indices\n    matched_desc2_indices = min_idx[matched_indices]\n\n    # 7. Return the distances and indices of matching descriptors\n    return matched_distances, torch.stack((matched_desc1_indices, matched_desc2_indices), dim=1)\n```\n\n### Explanation:\n\n1. **Distance Matrix Calculation**: If a precomputed distance matrix (`dm`) is not provided, compute it using `torch.cdist`, which calculates the pairwise distances between `desc1` and `desc2`.\n\n2. **Nearest Neighbor Search**: For each descriptor in `desc1`, find the nearest neighbor in `desc2` by finding the minimum distance in each row of the distance matrix.\n\n3. **Distance Threshold**: Apply a threshold to filter out matches with distances greater than `th`.\n\n4. **Spatial Consistency Check**: Use the local affine frames (`lafs1` and `lafs2`) to ensure spatial consistency by checking if the spatial distance is below `spatial_th`.\n\n5. **Mutual Nearest Neighbor Check**: If `mutual` is `True`, ensure that the nearest neighbor relationship is mutual by checking if the nearest neighbor in `desc2` also points back to the original descriptor in `desc1`.\n\n6. **Filter Matches**: Use the validity mask to filter out invalid matches and gather the indices and distances of valid matches.\n\n7. **Return Results**: Return the distances and indices of the matching descriptors as a tuple.",
    "prompt": "Generate a Python function called match_fginn that finds nearest neighbors in desc2 for each vector in desc1. The inputs are Tensors desc1, desc2, lafs1, lafs2, th, spatial_th, mutual, and dm. The function returns a tuple of Tensors containing the descriptor distance of matching descriptors and the long tensor indexes of matching descriptors in desc1 and desc2. The function also performs a mutual nearest neighbor check if specified.\ndef match_fginn(\n    desc1: Tensor,\n    desc2: Tensor,\n    lafs1: Tensor,\n    lafs2: Tensor,\n    th: float = 0.8,\n    spatial_th: float = 10.0,\n    mutual: bool = False,\n    dm: Optional[Tensor] = None,\n) -> Tuple[Tensor, Tensor]:",
    "function_name": "match_fginn",
    "ground_truth": "kornia/feature/matching.py",
    "test": "tests/feature/test_matching.py::TestMatchFGINN",
    "class": "",
    "stage": "Inference",
    "task": "Detection",
    "data": "Image"
}