{
    "result": "To create a function called `spatial_gradient` that computes the first-order image derivative using a Sobel operator, we can follow a structured approach similar to the examples provided. Here's a step-by-step implementation:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef spatial_gradient(image: torch.Tensor, mode: str = 'sobel', order: int = 1, normalized: bool = False) -> torch.Tensor:\n    \"\"\"\n    Computes the first-order image derivative in both x and y directions using a Sobel operator or simple difference.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (B, C, H, W).\n        mode (str): Derivatives modality, either 'sobel' or 'diff'. Defaults to 'sobel'.\n        order (int): Order of the derivatives. Currently, only first-order is supported. Defaults to 1.\n        normalized (bool): Whether to normalize the output. Defaults to False.\n\n    Returns:\n        torch.Tensor: Derivatives of the input feature map with shape (B, C, 2, H, W).\n    \"\"\"\n    # 1. Validate the input parameters\n    if mode not in ['sobel', 'diff']:\n        raise ValueError(\"Mode must be either 'sobel' or 'diff'.\")\n    if order != 1:\n        raise ValueError(\"Currently, only first-order derivatives are supported.\")\n\n    # 2. Define Sobel kernels for x and y directions\n    sobel_kernel_x = torch.tensor([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=image.dtype, device=image.device).view(1, 1, 3, 3)\n    sobel_kernel_y = torch.tensor([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=image.dtype, device=image.device).view(1, 1, 3, 3)\n\n    # 3. Define simple difference kernels for x and y directions\n    diff_kernel_x = torch.tensor([[-1, 0, 1]], dtype=image.dtype, device=image.device).view(1, 1, 1, 3)\n    diff_kernel_y = torch.tensor([[-1], [0], [1]], dtype=image.dtype, device=image.device).view(1, 1, 3, 1)\n\n    # 4. Select the appropriate kernels based on the mode\n    if mode == 'sobel':\n        kernel_x, kernel_y = sobel_kernel_x, sobel_kernel_y\n    else:\n        kernel_x, kernel_y = diff_kernel_x, diff_kernel_y\n\n    # 5. Apply the kernels to compute derivatives\n    B, C, H, W = image.shape\n    grad_x = F.conv2d(image.view(B * C, 1, H, W), kernel_x, padding=1, groups=1)\n    grad_y = F.conv2d(image.view(B * C, 1, H, W), kernel_y, padding=1, groups=1)\n\n    # 6. Reshape the gradients to the desired output shape\n    grad_x = grad_x.view(B, C, H, W)\n    grad_y = grad_y.view(B, C, H, W)\n    gradients = torch.stack((grad_x, grad_y), dim=2)  # Shape: (B, C, 2, H, W)\n\n    # 7. Normalize the gradients if required\n    if normalized:\n        gradients = gradients / gradients.abs().max(dim=(2, 3, 4), keepdim=True)[0]\n\n    # 8. Return the computed gradients\n    return gradients\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Create a random image tensor with shape (B, C, H, W)\n    image = torch.rand(1, 1, 5, 5)\n\n    # Compute the spatial gradient using the Sobel operator\n    sobel_gradients = spatial_gradient(image, mode='sobel', normalized=True)\n    print(\"Sobel Gradients:\\n\", sobel_gradients)\n\n    # Compute the spatial gradient using simple difference\n    diff_gradients = spatial_gradient(image, mode='diff', normalized=True)\n    print(\"Difference Gradients:\\n\", diff_gradients)\n```\n\n### Explanation:\n1. **Input Validation**: The function checks if the `mode` is either 'sobel' or 'diff' and if the `order` is 1.\n2. **Kernel Definition**: Sobel and simple difference kernels are defined for both x and y directions.\n3. **Kernel Selection**: Based on the `mode`, the appropriate kernels are selected.\n4. **Convolution**: The kernels are applied to the input image using `torch.nn.functional.conv2d` to compute the gradients.\n5. **Reshape and Stack**: The gradients are reshaped and stacked to form the output tensor with shape (B, C, 2, H, W).\n6. **Normalization**: If `normalized` is True, the gradients are normalized.\n7. **Return**: The function returns the computed gradients.",
    "prompt": "Generate a Python function called spatial_gradient that computes the first-order image derivative in both x and y using a Sobel operator. The function takes in an input image tensor with shape (B, C, H, W), a mode parameter specifying the derivatives modality (either 'sobel' or 'diff'), an order parameter indicating the order of the derivatives, and a normalized parameter determining whether the output is normalized. The function returns the derivatives of the input feature map with shape (B, C, 2, H, W). The function also includes examples demonstrating its usage.",
    "function_name": "spatial_gradient",
    "ground_truth": "kornia/filters/sobel.py",
    "test": "tests/filters/test_sobel.py::TestSpatialGradient",
    "class": "",
    "stage": "Training",
    "task": "",
    "data": "Image"
}