{
    "result": "To create the `make_upright` function that rectifies an affine matrix to make it upright, we can follow a step-by-step approach similar to the examples you provided. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef make_upright(laf: torch.Tensor, eps: float = 1e-6) -> torch.Tensor:\n    \"\"\"\n    Rectifies an affine matrix to make it upright.\n\n    Args:\n        laf (torch.Tensor): Input tensor of shape (B, N, 2, 3) representing affine matrices.\n        eps (float, optional): Small value for safe division. Defaults to 1e-6.\n\n    Returns:\n        torch.Tensor: Rectified affine matrix of the same shape (B, N, 2, 3).\n    \"\"\"\n    # 1. Check the validity of the input affine matrix\n    KORNIA_CHECK_LAF(laf)\n\n    # 2. Extract the 2x2 affine part of the matrix\n    A = laf[..., :2, :2]\n\n    # 3. Compute the determinant of the 2x2 matrix\n    det = torch.det(A)\n\n    # 4. Perform operations equivalent to a 2x2 SVD\n    #    Normalize the columns of A to get the rotation matrix\n    U, _, Vt = torch.linalg.svd(A)\n    R = torch.matmul(U, Vt)\n\n    # 5. Set the rotation matrix to an identity matrix\n    #    This step ensures the matrix is upright\n    R = torch.eye(2, device=laf.device).expand_as(R)\n\n    # 6. Scale the identity matrix by the original determinant\n    S = torch.diag_embed(det.sqrt().unsqueeze(-1).expand(-1, -1, 2))\n\n    # 7. Construct the rectified affine matrix\n    rectified_A = torch.matmul(R, S)\n\n    # 8. Replace the original 2x2 part with the rectified matrix\n    rectified_laf = laf.clone()\n    rectified_laf[..., :2, :2] = rectified_A\n\n    # 9. Return the rectified affine matrix\n    return rectified_laf\n\ndef KORNIA_CHECK_LAF(laf: torch.Tensor):\n    \"\"\"\n    Checks the validity of the input affine matrix.\n\n    Args:\n        laf (torch.Tensor): Input tensor of shape (B, N, 2, 3).\n\n    Raises:\n        ValueError: If the input tensor does not have the correct shape.\n    \"\"\"\n    if laf.ndim != 4 or laf.shape[-2:] != (2, 3):\n        raise ValueError(\"Input tensor must have shape (B, N, 2, 3)\")\n\n# Example usage\nlaf = torch.tensor([[[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]]], dtype=torch.float32)\nrectified_laf = make_upright(laf)\nprint(rectified_laf)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function starts by checking the validity of the input affine matrix using a helper function `KORNIA_CHECK_LAF`.\n\n2. **Extracting the Affine Part**: The 2x2 part of the affine matrix is extracted for further processing.\n\n3. **Determinant Calculation**: The determinant of the 2x2 matrix is calculated to understand the scaling factor.\n\n4. **SVD and Rectification**: The function performs operations equivalent to a 2x2 Singular Value Decomposition (SVD) to obtain the rotation matrix. The rotation matrix is then set to an identity matrix to ensure the matrix is upright.\n\n5. **Scaling**: The identity matrix is scaled by the square root of the determinant to maintain the original scaling.\n\n6. **Reconstruction**: The rectified affine matrix is reconstructed by replacing the original 2x2 part with the rectified matrix.\n\n7. **Return**: The rectified affine matrix is returned.\n\nThis function assumes that the input tensor `laf` is a batch of affine matrices, and it processes each matrix to make it upright while preserving the original scaling.",
    "prompt": "Generate a Python function called make_upright that rectifies an affine matrix to make it upright. The function takes in a tensor laf of shape (B, N, 2, 3) and an optional float eps for safe division. It returns the rectified affine matrix laf of the same shape (B, N, 2, 3). The function first checks the validity of the input affine matrix using KORNIA_CHECK_LAF. It then calculates the determinant of the affine matrix and uses it to rectify the matrix by resetting the rotation matrix to an identity. The function performs operations equivalent to a 2x2 SVD and sets the rotation matrix to an identity. The rectified affine matrix is then scaled using the original determinant and returned. An example usage of the function is provided using torch tensors.",
    "function_name": "make_upright",
    "ground_truth": "kornia/feature/laf.py",
    "test": "tests/feature/test_laf.py::TestMakeUpright",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}