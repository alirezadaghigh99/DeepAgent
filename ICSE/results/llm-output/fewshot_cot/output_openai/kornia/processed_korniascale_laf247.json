{
    "result": "To create the `scale_laf` function, we need to focus on scaling the region part of a Local Affine Frame (LAF) while keeping the center, shape, and orientation unchanged. The LAF is represented as a tensor of shape `(B, N, 2, 3)`, where `B` is the batch size, `N` is the number of LAFs, and the `2x3` matrix represents the affine transformation. The region part of the LAF is typically the `2x2` submatrix of the `2x3` matrix.\n\nHere's a step-by-step implementation of the `scale_laf` function:\n\n```python\nimport torch\n\ndef scale_laf(laf: torch.Tensor, scale_coef) -> torch.Tensor:\n    \"\"\"\n    Scales the region part of a Local Affine Frame (LAF) by a scale coefficient.\n\n    Args:\n        laf (torch.Tensor): Tensor of shape (B, N, 2, 3) representing the LAFs.\n        scale_coef (Union[float, torch.Tensor]): Scaling coefficient. Can be a float or a tensor.\n\n    Returns:\n        torch.Tensor: Scaled LAF of the same shape as the input.\n\n    Raises:\n        TypeError: If scale_coef is neither a float nor a tensor.\n    \"\"\"\n    # 1. Check if scale_coef is a valid type (float or tensor)\n    if not isinstance(scale_coef, (float, torch.Tensor)):\n        raise TypeError(\"scale_coef must be either a float or a torch.Tensor\")\n\n    # 2. Extract the region part (2x2 submatrix) of the LAF\n    region = laf[..., :2, :2]\n\n    # 3. Scale the region part by the scale_coef\n    scaled_region = region * scale_coef\n\n    # 4. Create a new LAF tensor to hold the scaled LAFs\n    scaled_laf = laf.clone()\n\n    # 5. Replace the original region part with the scaled region\n    scaled_laf[..., :2, :2] = scaled_region\n\n    # 6. Return the scaled LAF tensor\n    return scaled_laf\n```\n\n### Explanation:\n\n1. **Type Checking**: We first check if `scale_coef` is either a float or a tensor. If not, a `TypeError` is raised.\n\n2. **Extracting the Region Part**: The region part of the LAF is the `2x2` submatrix, which is extracted using `laf[..., :2, :2]`.\n\n3. **Scaling the Region**: The region is scaled by multiplying it with `scale_coef`. This operation scales the area of the region while keeping the center, shape, and orientation unchanged.\n\n4. **Creating a New LAF Tensor**: We create a copy of the original LAF tensor to hold the scaled LAFs.\n\n5. **Replacing the Region Part**: The original region part in the LAF is replaced with the scaled region.\n\n6. **Returning the Scaled LAF**: Finally, the function returns the scaled LAF tensor, which has the same shape as the input LAF.",
    "prompt": "Create a function `scale_laf` that multiplies the region part of a Local Affine Frame (LAF) by a `scale_coef`, keeping the center, shape, and orientation unchanged but altering the region area. The function accepts a tensor `laf` of shape `(B, N, 2, 3)` and a `scale_coef`, which can be either a float or a tensor. It returns the scaled LAF of the same shape. A `TypeError` is raised if `scale_coef` is neither a float nor a tensor.",
    "function_name": "scale_laf",
    "ground_truth": "kornia/feature/laf.py#L133",
    "test": "tests/feature/test_laf.py::TestScaleLAF",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}