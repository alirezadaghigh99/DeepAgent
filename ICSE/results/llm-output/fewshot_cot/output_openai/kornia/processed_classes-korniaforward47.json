{
    "result": "To implement the `forward` method for the `Affine` class, we need to construct an affine transformation matrix using the provided parameters (`angle`, `translation`, `scale_factor`, `shear`, and `center`) and apply this transformation to the input tensor. We'll use PyTorch's `torch.nn.functional` module to perform the affine transformation. Here's a step-by-step implementation:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom typing import Optional\n\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        super(Affine, self).__init__()\n        self.angle = angle\n        self.translation = translation\n        self.scale_factor = scale_factor\n        self.shear = shear\n        self.center = center\n        self.mode = mode\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # 1. Get the batch size and device\n        batch_size, _, height, width = input.size()\n        device = input.device\n\n        # 2. Initialize transformation matrices\n        transform_matrices = torch.eye(3, device=device).unsqueeze(0).repeat(batch_size, 1, 1)\n\n        # 3. Compute rotation matrix\n        if self.angle is not None:\n            angle_rad = self.angle * torch.pi / 180.0\n            cos_a = torch.cos(angle_rad)\n            sin_a = torch.sin(angle_rad)\n            rotation_matrix = torch.stack([\n                cos_a, -sin_a, torch.zeros_like(cos_a),\n                sin_a, cos_a, torch.zeros_like(sin_a),\n                torch.zeros_like(cos_a), torch.zeros_like(cos_a), torch.ones_like(cos_a)\n            ], dim=-1).view(batch_size, 3, 3)\n            transform_matrices = torch.bmm(transform_matrices, rotation_matrix)\n\n        # 4. Compute translation matrix\n        if self.translation is not None:\n            translation_matrix = torch.eye(3, device=device).unsqueeze(0).repeat(batch_size, 1, 1)\n            translation_matrix[:, 0, 2] = self.translation[:, 0]\n            translation_matrix[:, 1, 2] = self.translation[:, 1]\n            transform_matrices = torch.bmm(transform_matrices, translation_matrix)\n\n        # 5. Compute scaling matrix\n        if self.scale_factor is not None:\n            scale_matrix = torch.eye(3, device=device).unsqueeze(0).repeat(batch_size, 1, 1)\n            scale_matrix[:, 0, 0] = self.scale_factor[:, 0]\n            scale_matrix[:, 1, 1] = self.scale_factor[:, 1]\n            transform_matrices = torch.bmm(transform_matrices, scale_matrix)\n\n        # 6. Compute shearing matrix\n        if self.shear is not None:\n            shear_matrix = torch.eye(3, device=device).unsqueeze(0).repeat(batch_size, 1, 1)\n            shear_matrix[:, 0, 1] = self.shear[:, 0]\n            shear_matrix[:, 1, 0] = self.shear[:, 1]\n            transform_matrices = torch.bmm(transform_matrices, shear_matrix)\n\n        # 7. Compute center translation matrix\n        if self.center is not None:\n            center_matrix = torch.eye(3, device=device).unsqueeze(0).repeat(batch_size, 1, 1)\n            center_matrix[:, 0, 2] = self.center[:, 0]\n            center_matrix[:, 1, 2] = self.center[:, 1]\n            transform_matrices = torch.bmm(center_matrix, transform_matrices)\n            center_matrix[:, 0, 2] = -self.center[:, 0]\n            center_matrix[:, 1, 2] = -self.center[:, 1]\n            transform_matrices = torch.bmm(transform_matrices, center_matrix)\n\n        # 8. Extract the 2x3 part of the transformation matrix\n        affine_matrices = transform_matrices[:, :2, :]\n\n        # 9. Apply the affine transformation\n        grid = F.affine_grid(affine_matrices, input.size(), align_corners=self.align_corners)\n        output = F.grid_sample(input, grid, mode=self.mode, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\n### Explanation:\n1. **Initialization**: The `Affine` class is initialized with optional parameters for rotation, translation, scaling, shearing, and centering. It also takes parameters for interpolation mode, padding mode, and alignment of corners.\n\n2. **Transformation Matrix Construction**: The `forward` method constructs a 3x3 transformation matrix for each image in the batch. It sequentially applies rotation, translation, scaling, shearing, and centering transformations.\n\n3. **Affine Transformation**: The 2x3 affine transformation matrix is extracted from the 3x3 matrix, and `torch.nn.functional.affine_grid` and `torch.nn.functional.grid_sample` are used to apply the transformation to the input tensor.\n\n4. **Return**: The transformed tensor is returned, maintaining the same shape as the input tensor.",
    "prompt": "Write a Python function `forward` for the `Affine` class that applies multiple elementary affine transformations (rotation, translation, scaling, and shearing) to a batch of input tensors. The function takes a 4D tensor with shape `[batch_size, channels, height, width]` as input and returns a transformed tensor of the same shape. The affine transformation is computed using parameters such as `angle`, `translation`, `scale_factor`, `shear`, and `center`, with optional interpolation modes and padding options.\n\n```python\nclass Affine(nn.Module):\n    def __init__(\n        self,\n        angle: Optional[torch.Tensor] = None,\n        translation: Optional[torch.Tensor] = None,\n        scale_factor: Optional[torch.Tensor] = None,\n        shear: Optional[torch.Tensor] = None,\n        center: Optional[torch.Tensor] = None,\n        mode: str = \"bilinear\",\n        padding_mode: str = \"zeros\",\n        align_corners: bool = True,\n    ) -> None:\n        # Initialization code...\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n``` \n\nThe `forward` function constructs an affine transformation matrix based on the provided parameters and applies this transformation to the input tensor.",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestAffine2d",
    "class": "Affine",
    "stage": "Image",
    "task": "",
    "data": "Model construction"
}