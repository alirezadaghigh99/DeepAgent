{
    "result": "To create the `get_projective_transform` function, we need to calculate the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function will involve several steps, including validating inputs, converting angles to radians, creating rotation matrices for each axis, and combining these with scaling and translation to form the final projection matrix. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef get_projective_transform(center: torch.Tensor, angles: torch.Tensor, scales: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Calculate the projection matrix for a 3D rotation given the center, rotation angles, and scales.\n\n    Args:\n        center (torch.Tensor): Tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\n        angles (torch.Tensor): Tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\n        scales (torch.Tensor): Tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\n\n    Returns:\n        torch.Tensor: A tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.\n    \"\"\"\n    # 1. Validate input shapes\n    assert center.shape[1] == 3, \"Center must have shape (B, 3)\"\n    assert angles.shape[1] == 3, \"Angles must have shape (B, 3)\"\n    assert scales.shape[1] == 3, \"Scales must have shape (B, 3)\"\n    \n    # 2. Validate input devices and dtypes\n    assert center.device == angles.device == scales.device, \"Center, angles, and scales must be on the same device\"\n    assert center.dtype == angles.dtype == scales.dtype, \"Center, angles, and scales must have the same dtype\"\n\n    # 3. Convert angles from degrees to radians\n    angles_rad = torch.deg2rad(angles)\n\n    # 4. Compute rotation matrices for each axis\n    cos = torch.cos(angles_rad)\n    sin = torch.sin(angles_rad)\n\n    # Rotation matrix around x-axis\n    Rx = torch.stack([\n        torch.ones_like(cos[:, 0]), torch.zeros_like(cos[:, 0]), torch.zeros_like(cos[:, 0]),\n        torch.zeros_like(cos[:, 0]), cos[:, 0], -sin[:, 0],\n        torch.zeros_like(cos[:, 0]), sin[:, 0], cos[:, 0]\n    ], dim=-1).reshape(-1, 3, 3)\n\n    # Rotation matrix around y-axis\n    Ry = torch.stack([\n        cos[:, 1], torch.zeros_like(cos[:, 1]), sin[:, 1],\n        torch.zeros_like(cos[:, 1]), torch.ones_like(cos[:, 1]), torch.zeros_like(cos[:, 1]),\n        -sin[:, 1], torch.zeros_like(cos[:, 1]), cos[:, 1]\n    ], dim=-1).reshape(-1, 3, 3)\n\n    # Rotation matrix around z-axis\n    Rz = torch.stack([\n        cos[:, 2], -sin[:, 2], torch.zeros_like(cos[:, 2]),\n        sin[:, 2], cos[:, 2], torch.zeros_like(cos[:, 2]),\n        torch.zeros_like(cos[:, 2]), torch.zeros_like(cos[:, 2]), torch.ones_like(cos[:, 2])\n    ], dim=-1).reshape(-1, 3, 3)\n\n    # 5. Combine rotation matrices\n    R = Rz @ Ry @ Rx\n\n    # 6. Apply scaling\n    S = torch.diag_embed(scales)\n\n    # 7. Combine rotation and scaling\n    RS = R @ S\n\n    # 8. Create translation matrix\n    T = torch.eye(4, device=center.device, dtype=center.dtype).unsqueeze(0).repeat(center.shape[0], 1, 1)\n    T[:, :3, 3] = center\n\n    # 9. Combine RS and T to form the final projection matrix\n    P = torch.cat([RS, center.unsqueeze(-1)], dim=-1)\n\n    return P\n```\n\n### Explanation:\n\n1. **Input Validation**: We first check that the input tensors have the correct shapes and are on the same device and have the same dtype.\n\n2. **Angle Conversion**: Convert the rotation angles from degrees to radians since trigonometric functions in PyTorch expect radians.\n\n3. **Rotation Matrices**: Compute the rotation matrices for each axis (x, y, z) using the cosine and sine of the angles.\n\n4. **Combine Rotations**: Multiply the rotation matrices to get the combined rotation matrix.\n\n5. **Scaling**: Create a scaling matrix and multiply it with the rotation matrix.\n\n6. **Translation**: Create a translation matrix using the center coordinates.\n\n7. **Projection Matrix**: Combine the rotation, scaling, and translation matrices to form the final projection matrix.\n\nThis function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.",
    "prompt": "Create a Python function get_projective_transform that calculates the projection matrix for a 3D rotation given the center, rotation angles, and scales. The function takes the following parameters:\n\ncenter: A tensor of shape (B, 3) representing the center of the rotation in the source coordinates (x, y, z).\nangles: A tensor of shape (B, 3) containing the rotation angles in degrees for the x, y, and z axes.\nscales: A tensor of shape (B, 3) representing the scale factors for the x, y, and z directions.\nThe function returns a tensor of shape (B, 3, 4) representing the projection matrix for the 3D rotation.Raise an AssertionError if center or angles do not have the expected shape.\nRaise an AssertionError if center and angles do not share the same device and dtype.",
    "function_name": "get_projective_transform",
    "ground_truth": "kornia/geometry/transform/imgwarp.py",
    "test": "tests/geometry/transform/test_imgwarp3d.py::TestGetRotationMatrix3d",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}