{
    "result": "To create the `match_snn` function, we will follow a step-by-step approach similar to the examples provided. This function will identify matching descriptors between two sets based on a nearest neighbor distance ratio test. Here's how you can implement it:\n\n```python\nimport torch\n\ndef match_snn(desc1: torch.Tensor, desc2: torch.Tensor, th: float = 0.8, dm: Optional[torch.Tensor] = None):\n    \"\"\"\n    Match descriptors from desc1 to desc2 using the SNN ratio test.\n\n    Args:\n        desc1 (torch.Tensor): Tensor of shape (B1, D) representing descriptors.\n        desc2 (torch.Tensor): Tensor of shape (B2, D) representing descriptors.\n        th (float): Threshold for the ratio test. Defaults to 0.8.\n        dm (torch.Tensor, optional): Precomputed distance matrix of shape (B1, B2). Defaults to None.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: \n            - Distances of matching descriptors, shape (B3, 1).\n            - Long tensor indexes of matching descriptors in desc1 and desc2, shape (B3, 2).\n    \"\"\"\n    # 1. Check if desc2 has fewer than two descriptors\n    if desc2.size(0) < 2:\n        return torch.empty((0, 1)), torch.empty((0, 2), dtype=torch.long)\n\n    # 2. Compute the distance matrix if not provided\n    if dm is None:\n        dm = torch.cdist(desc1, desc2)\n\n    # 3. Sort distances to find the nearest and second nearest neighbors\n    sorted_distances, sorted_indices = torch.sort(dm, dim=1)\n\n    # 4. Calculate the ratio of the nearest to the second nearest distance\n    ratio = sorted_distances[:, 0] / sorted_distances[:, 1]\n\n    # 5. Find indices where the ratio is less than or equal to the threshold\n    valid_indices = torch.nonzero(ratio <= th).squeeze()\n\n    # 6. Extract the distances and indices of valid matches\n    if valid_indices.numel() == 0:\n        return torch.empty((0, 1)), torch.empty((0, 2), dtype=torch.long)\n\n    matching_distances = sorted_distances[valid_indices, 0].unsqueeze(1)\n    matching_indices = torch.stack((valid_indices, sorted_indices[valid_indices, 0]), dim=1)\n\n    # 7. Return the distances and indices of matching descriptors\n    return matching_distances, matching_indices\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if `desc2` has fewer than two descriptors. If so, it returns empty tensors because a valid match requires at least two neighbors for the ratio test.\n\n2. **Distance Matrix Calculation**: If a precomputed distance matrix `dm` is not provided, it calculates the pairwise Euclidean distances between `desc1` and `desc2` using `torch.cdist`.\n\n3. **Sorting Distances**: The distances are sorted to identify the nearest and second nearest neighbors for each descriptor in `desc1`.\n\n4. **Ratio Test**: The ratio of the nearest to the second nearest distance is computed. Descriptors that satisfy the ratio test (i.e., the ratio is less than or equal to `th`) are considered valid matches.\n\n5. **Extracting Matches**: The function extracts the distances and indices of descriptors that pass the ratio test. If no matches are found, it returns empty tensors.\n\n6. **Return Values**: The function returns the distances of the matching descriptors and their indices in `desc1` and `desc2`.",
    "prompt": "Create a Python function `match_snn` that takes in two tensors, `desc1` and `desc2`, representing batches of descriptors, a threshold `th` = 0.8, and an optional precomputed distance matrix `dm`. The function returns the distances and indices of descriptors from `desc1` that have nearest neighbors in `desc2`, satisfying the condition that the ratio of the first to the second nearest neighbor distance is less than or equal to `th`. If `desc2` has fewer than two descriptors, or if no matches meet the ratio threshold, the function returns an empty result. It checks the validity of the input shapes and then identifies the matching descriptors and their corresponding distances.Return:\n        - Descriptor distance of matching descriptors, shape of :math:`(B3, 1)`.\n        - Long tensor indexes of matching descriptors in desc1 and desc2. Shape: :math:`(B3, 2)`,\n          where 0 <= B3 <= B1.",
    "function_name": "match_snn",
    "ground_truth": "kornia/feature/matching.py#L48",
    "test": "tests/feature/test_matching.py::TestMatchSNN",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Detection",
    "data": "Image"
}