{
    "result": "To create a function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor, we need to follow a series of steps. This involves calculating the covariance matrix, performing eigen decomposition, and constructing the ZCA matrix. Here's a step-by-step implementation:\n\n```python\nimport torch\nfrom torch import Tensor\nfrom typing import Tuple, Optional\n\ndef zca_mean(\n    inp: Tensor,\n    dim: int = 0,\n    unbiased: bool = True,\n    eps: float = 1e-5,\n    return_inverse: bool = False\n) -> Tuple[Tensor, Tensor, Optional[Tensor]]:\n    \"\"\"\n    Compute the ZCA whitening matrix and mean vector for a given input tensor.\n\n    Args:\n        inp (Tensor): Input tensor of shape (..., N, ...), where N is the number of samples.\n        dim (int): Dimension along which the samples are located.\n        unbiased (bool): Whether to use the unbiased estimate of the covariance matrix.\n        eps (float): Small value for numerical stability.\n        return_inverse (bool): Whether to return the inverse ZCA transform.\n\n    Returns:\n        Tuple[Tensor, Tensor, Optional[Tensor]]: ZCA matrix, mean vector, and optionally the inverse ZCA matrix.\n    \"\"\"\n    # 1. Validate input tensor\n    if not isinstance(inp, Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    if inp.dim() < 2:\n        raise ValueError(\"Input tensor must have at least 2 dimensions.\")\n\n    # 2. Move the sample dimension to the first axis for easier manipulation\n    inp = inp.transpose(0, dim)\n\n    # 3. Compute the mean vector along the sample dimension\n    mean_vector = inp.mean(dim=0, keepdim=True)\n\n    # 4. Center the input data by subtracting the mean\n    centered_inp = inp - mean_vector\n\n    # 5. Compute the covariance matrix\n    N = centered_inp.size(0)\n    cov_matrix = centered_inp.t().matmul(centered_inp) / (N - 1 if unbiased else N)\n\n    # 6. Perform eigen decomposition of the covariance matrix\n    eigenvalues, eigenvectors = torch.linalg.eigh(cov_matrix)\n\n    # 7. Compute the ZCA matrix\n    sqrt_eigenvalues = torch.sqrt(eigenvalues + eps)\n    zca_matrix = eigenvectors @ torch.diag(1.0 / sqrt_eigenvalues) @ eigenvectors.t()\n\n    # 8. Optionally compute the inverse ZCA matrix\n    inverse_zca_matrix = None\n    if return_inverse:\n        inverse_zca_matrix = eigenvectors @ torch.diag(sqrt_eigenvalues) @ eigenvectors.t()\n\n    # 9. Return the ZCA matrix, mean vector, and optionally the inverse ZCA matrix\n    return zca_matrix, mean_vector.squeeze(dim=0), inverse_zca_matrix\n\n```\n\n### Explanation:\n\n1. **Input Validation**: We first check if the input is a tensor and has at least two dimensions.\n\n2. **Dimension Handling**: We transpose the input tensor to bring the sample dimension to the front, making it easier to compute the mean and covariance.\n\n3. **Mean Calculation**: We compute the mean vector along the sample dimension and center the data by subtracting this mean.\n\n4. **Covariance Matrix**: The covariance matrix is computed using the centered data. The unbiased flag determines whether to use `N-1` or `N` in the denominator.\n\n5. **Eigen Decomposition**: We perform eigen decomposition on the covariance matrix to obtain eigenvalues and eigenvectors.\n\n6. **ZCA Matrix**: The ZCA whitening matrix is computed using the eigenvectors and the inverse of the square root of the eigenvalues, with a small epsilon added for numerical stability.\n\n7. **Inverse ZCA Matrix**: If requested, we compute the inverse ZCA matrix using the square root of the eigenvalues.\n\n8. **Return Values**: The function returns the ZCA matrix, mean vector, and optionally the inverse ZCA matrix.",
    "prompt": "Generate a Python function `zca_mean` that computes the ZCA whitening matrix and mean vector for a given input tensor. The function should take as input a tensor `inp`, the dimension `dim` along which the samples are located, a boolean `unbiased` to decide whether to use the unbiased estimate of the covariance matrix, a small value `eps` for numerical stability, and a boolean `return_inverse` to decide whether to return the inverse ZCA transform. The function should return a tuple containing the ZCA matrix, the mean vector, and optionally the inverse ZCA matrix. The tensor shapes should be validated, and appropriate exceptions should be raised if inputs are of incorrect types or dimensions. Include the necessary imports and tensor operations to perform the ZCA whitening process.",
    "function_name": "zca_mean",
    "ground_truth": "kornia/enhance/zca.py",
    "test": "tests/enhance/test_zca.py::TestZCA",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}