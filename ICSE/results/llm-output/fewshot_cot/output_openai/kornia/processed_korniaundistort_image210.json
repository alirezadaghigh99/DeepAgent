{
    "result": "To create a function `undistort_image` that compensates for lens distortion, we need to follow a series of steps. This involves using the intrinsic camera matrix and distortion coefficients to correct the image. Here's a step-by-step guide to implementing this function:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef undistort_image(image: torch.Tensor, K: torch.Tensor, dist: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Compensates an image for lens distortion using the intrinsic camera matrix and distortion coefficients.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, C, H, W).\n        K (torch.Tensor): Intrinsic camera matrix with shape (*, 3, 3).\n        dist (torch.Tensor): Distortion coefficients with shape (*, n).\n\n    Returns:\n        torch.Tensor: Undistorted image with the same shape as the input image (*, C, H, W).\n    \"\"\"\n    # 1. Validate input dimensions\n    assert image.dim() >= 3, \"Image tensor must have at least 3 dimensions (C, H, W).\"\n    assert K.shape[-2:] == (3, 3), \"Intrinsic matrix K must have shape (*, 3, 3).\"\n    assert dist.shape[-1] >= 4, \"Distortion coefficients must have at least 4 elements.\"\n\n    # 2. Extract image dimensions\n    *batch_dims, C, H, W = image.shape\n\n    # 3. Create a meshgrid of pixel coordinates\n    y, x = torch.meshgrid(torch.arange(H, dtype=torch.float32), torch.arange(W, dtype=torch.float32))\n    x, y = x.to(image.device), y.to(image.device)\n\n    # 4. Normalize pixel coordinates using the intrinsic matrix K\n    fx, fy = K[..., 0, 0], K[..., 1, 1]\n    cx, cy = K[..., 0, 2], K[..., 1, 2]\n    x_normalized = (x - cx) / fx\n    y_normalized = (y - cy) / fy\n\n    # 5. Compute radial and tangential distortion\n    r2 = x_normalized**2 + y_normalized**2\n    k1, k2, p1, p2 = dist[..., 0], dist[..., 1], dist[..., 2], dist[..., 3]\n    radial_distortion = 1 + k1 * r2 + k2 * r2**2\n    x_distorted = x_normalized * radial_distortion + 2 * p1 * x_normalized * y_normalized + p2 * (r2 + 2 * x_normalized**2)\n    y_distorted = y_normalized * radial_distortion + p1 * (r2 + 2 * y_normalized**2) + 2 * p2 * x_normalized * y_normalized\n\n    # 6. Convert distorted coordinates back to pixel coordinates\n    x_undistorted = x_distorted * fx + cx\n    y_undistorted = y_distorted * fy + cy\n\n    # 7. Stack and reshape coordinates for grid_sample\n    grid = torch.stack((x_undistorted, y_undistorted), dim=-1)\n    grid = grid.unsqueeze(0).expand(*batch_dims, H, W, 2)\n\n    # 8. Use grid_sample to remap the input image to undistorted coordinates\n    undistorted_image = F.grid_sample(image, grid, align_corners=True)\n\n    # 9. Return the undistorted image\n    return undistorted_image\n\n# Example usage\nimg = torch.rand(1, 3, 5, 5)\nK = torch.eye(3)[None]\ndist_coeff = torch.rand(1, 4)\nout = undistort_image(img, K, dist_coeff)\nprint(out.shape)  # Output: torch.Size([1, 3, 5, 5])\n```\n\n### Explanation:\n1. **Input Validation**: Ensure the input tensors have the correct dimensions.\n2. **Meshgrid Creation**: Generate a grid of pixel coordinates.\n3. **Normalization**: Normalize these coordinates using the intrinsic camera matrix.\n4. **Distortion Calculation**: Apply radial and tangential distortion models.\n5. **Coordinate Conversion**: Convert distorted coordinates back to pixel space.\n6. **Remapping**: Use `grid_sample` to map the input image to the undistorted coordinates.\n7. **Output**: Return the undistorted image with the same shape as the input.",
    "prompt": "Generate a Python function called undistort_image that compensates an image for lens distortion. The function takes in three inputs: image (a torch.Tensor representing the input image with shape (*, C, H, W)), K (a torch.Tensor representing the intrinsic camera matrix with shape (*, 3, 3)), and dist (a torch.Tensor representing the distortion coefficients with shape (*, n)). The distortion coefficients include radial, tangential, thin prism, and tilt distortion models.\n\nThe function returns an undistorted image with the same shape as the input image (*, C, H, W). \n\nFor example:\n```python\nimg = torch.rand(1, 3, 5, 5)\nK = torch.eye(3)[None]\ndist_coeff = torch.rand(1, 4)\nout = undistort_image(img, K, dist_coeff)\nout.shape\n```\n\nThe output shape of the undistorted image will be torch.Size([1, 3, 5, 5).",
    "function_name": "undistort_image",
    "ground_truth": "kornia/geometry/calibration/undistort.py",
    "test": "tests/geometry/calibration/test_undistort.py::TestUndistortImage",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}