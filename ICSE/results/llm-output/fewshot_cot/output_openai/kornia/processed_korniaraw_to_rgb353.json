{
    "result": "To create a function `raw_to_rgb` that converts a raw Bayer image to an RGB image, we need to handle the conversion based on the Color Filter Array (CFA) pattern and perform bilinear interpolation. Below is a step-by-step implementation of the function:\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ndef raw_to_rgb(image: torch.Tensor, cfa: str) -> torch.Tensor:\n    \"\"\"\n    Convert a raw Bayer image to an RGB image using bilinear interpolation.\n\n    Args:\n        image (torch.Tensor): Input raw image tensor with shape (*, 1, H, W).\n        cfa (str): CFA configuration, one of 'BG', 'GB', 'RG', 'GR'.\n\n    Returns:\n        torch.Tensor: RGB image tensor with shape (*, 3, H, W).\n\n    Raises:\n        TypeError: If the input is not a torch.Tensor.\n        ValueError: If the input shape is not (*, 1, H, W) or H/W is not divisible by 2.\n    \"\"\"\n    # 1. Validate input type\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(f\"Input type is not a torch.Tensor. Got {type(image)}.\")\n\n    # 2. Validate input shape\n    if image.ndim < 3 or image.shape[-3] != 1:\n        raise ValueError(f\"Input size must have a shape of (*, 1, H, W). Got {image.shape}.\")\n    \n    # 3. Validate divisibility of H and W by 2\n    if image.shape[-2] % 2 != 0 or image.shape[-1] % 2 != 0:\n        raise ValueError(f\"Input H&W must be evenly divisible by 2. Got {image.shape}.\")\n\n    # 4. Extract dimensions\n    *batch_dims, _, H, W = image.shape\n\n    # 5. Prepare padding for bilinear interpolation\n    pad = (1, 1, 1, 1)  # (left, right, top, bottom)\n    padded_image = F.pad(image, pad, mode='reflect')\n\n    # 6. Initialize RGB channels\n    R = torch.zeros_like(image)\n    G = torch.zeros_like(image)\n    B = torch.zeros_like(image)\n\n    # 7. Define interpolation kernels\n    kernel_RB = torch.tensor([[0.25, 0.5, 0.25],\n                              [0.5, 1.0, 0.5],\n                              [0.25, 0.5, 0.25]], device=image.device, dtype=image.dtype) / 4.0\n\n    kernel_G = torch.tensor([[0, 0.25, 0],\n                             [0.25, 1.0, 0.25],\n                             [0, 0.25, 0]], device=image.device, dtype=image.dtype) / 2.0\n\n    # 8. Perform interpolation based on CFA pattern\n    if cfa == 'BG':\n        B = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0))\n        G = F.conv2d(padded_image, kernel_G.unsqueeze(0).unsqueeze(0))\n        R = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0), stride=1, padding=0, dilation=1, groups=1, bias=None)\n    elif cfa == 'GB':\n        G = F.conv2d(padded_image, kernel_G.unsqueeze(0).unsqueeze(0))\n        B = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0))\n        R = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0), stride=1, padding=0, dilation=1, groups=1, bias=None)\n    elif cfa == 'RG':\n        R = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0))\n        G = F.conv2d(padded_image, kernel_G.unsqueeze(0).unsqueeze(0))\n        B = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0), stride=1, padding=0, dilation=1, groups=1, bias=None)\n    elif cfa == 'GR':\n        G = F.conv2d(padded_image, kernel_G.unsqueeze(0).unsqueeze(0))\n        R = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0))\n        B = F.conv2d(padded_image, kernel_RB.unsqueeze(0).unsqueeze(0), stride=1, padding=0, dilation=1, groups=1, bias=None)\n    else:\n        raise ValueError(f\"Unsupported CFA pattern: {cfa}\")\n\n    # 9. Concatenate RGB channels\n    rgb_image = torch.cat([R, G, B], dim=-3)\n\n    # 10. Return the RGB image\n    return rgb_image\n```\n\n### Explanation:\n1. **Input Validation**: The function checks if the input is a `torch.Tensor` and if its shape is valid. It also checks if the height and width are divisible by 2.\n2. **Padding**: The input image is padded to handle edge cases during interpolation.\n3. **Kernel Definition**: Two kernels are defined for bilinear interpolation: one for red/blue channels and another for the green channel.\n4. **Interpolation**: Based on the CFA pattern, the function applies the appropriate interpolation to each channel.\n5. **Concatenation**: The interpolated channels are concatenated to form the final RGB image.\n\nThis function assumes that the input image is in the range (0, 1) and handles different CFA configurations by applying the appropriate interpolation strategy.",
    "prompt": "Generate a Python function called raw_to_rgb that converts a raw Bayer image to an RGB version of the image. The function takes in a torch.Tensor called image and a CFA configuration called cfa. It returns the RGB version of the image with shape (*,3,H,W). The function assumes a CFA with 2 green, 1 red, and 1 blue, using bilinear interpolation for R/G and a fixed convolution for the green pixels. The input image data is expected to be in the range of (0, 1) and the Height/Width to be evenly divisible by 2. The function handles different CFA configurations (BG, GB, RG, GR) and performs necessary padding and interpolation to convert the raw image to RGB. If the input is not type of tensor, raise type error Input type is not a torch.Tensor. Got {type(image)}. if dimension is not correct, raise value error (f\"Input size must have a shape of (*, 1, H, W). Got {image.shape}.\"). else if shape is not correct, raise value error Input H&W must be evenly disible by 2. Got {image.shape}",
    "function_name": "raw_to_rgb",
    "ground_truth": "kornia/color/raw.py",
    "test": "tests/color/test_raw.py::TestRawToRgb",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}