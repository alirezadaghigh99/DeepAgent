{
    "result": "To create the `rgb_to_grayscale` function, we will follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef rgb_to_grayscale(image: torch.Tensor, rgb_weights: Optional[torch.Tensor] = None) -> torch.Tensor:\n    \"\"\"\n    Convert an RGB image to its grayscale version.\n\n    Args:\n        image (Tensor): Input image tensor with shape (*, 3, H, W).\n        rgb_weights (Tensor, optional): Weights for the RGB channels. The sum should be 1.\n\n    Returns:\n        Tensor: Grayscale image with shape (*, 1, H, W).\n    \"\"\"\n    # 1. Validate the input tensor shape\n    if image.ndim < 3 or image.shape[-3] != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    # 2. Determine the default weights based on the image data type\n    if rgb_weights is None:\n        if image.dtype == torch.uint8:\n            rgb_weights = torch.tensor([76, 150, 29], dtype=torch.float32) / 255\n        elif image.dtype.is_floating_point:\n            rgb_weights = torch.tensor([0.299, 0.587, 0.114], dtype=image.dtype)\n        else:\n            raise TypeError(\"Unsupported image data type. Use uint8 or floating-point.\")\n\n    # 3. Validate that the sum of the weights is 1\n    if not torch.isclose(rgb_weights.sum(), torch.tensor(1.0, dtype=rgb_weights.dtype)):\n        raise ValueError(\"The sum of rgb_weights must be 1.\")\n\n    # 4. Convert the RGB image to grayscale using the weights\n    #    Use broadcasting to apply weights across the image dimensions\n    grayscale_image = (image * rgb_weights.view(1, 3, 1, 1)).sum(dim=-3, keepdim=True)\n\n    # 5. Return the grayscale image with shape (*, 1, H, W)\n    return grayscale_image\n```\n\n### Explanation:\n\n1. **Input Validation**: We first check if the input tensor has the correct shape, ensuring it has at least three dimensions and the third-to-last dimension has size 3 (representing the RGB channels).\n\n2. **Default Weights**: If `rgb_weights` is not provided, we set default weights based on the data type of the image. For `uint8` images, we use weights `[76, 150, 29]` scaled by 255. For floating-point images, we use weights `[0.299, 0.587, 0.114]`.\n\n3. **Weights Validation**: We ensure that the sum of the provided or default weights is 1. This is crucial for maintaining the correct intensity in the grayscale image.\n\n4. **Grayscale Conversion**: We apply the weights to the RGB channels using broadcasting and sum along the channel dimension to get the grayscale image.\n\n5. **Return**: The function returns the grayscale image with the shape `(*, 1, H, W)`, maintaining the batch and spatial dimensions of the input.",
    "prompt": "Create a Python function `rgb_to_grayscale` that converts an RGB image to its grayscale version. The function should:\n\n- Accept an `image` tensor with shape `(*, 3, H, W)` representing the RGB image.\n- Optionally accept `rgb_weights`, a tensor containing weights for the RGB channels. The sum of these weights should be 1.\n- If `rgb_weights` is not provided, default weights based on the image data type should be used: `[76, 150, 29]` for `uint8` images and `[0.299, 0.587, 0.114]` for floating-point images.\n- Validate that the input tensor has the correct shape and raise a `ValueError` if not.\n- Convert the RGB image to grayscale using the provided or default weights.\n- Return the grayscale image with shape `(*, 1, H, W)`.\n\nEnsure that the function handles different image data types correctly and raises a `TypeError` for unsupported types.",
    "function_name": "rgb_to_grayscale",
    "ground_truth": "kornia/color/gray.py",
    "test": "tests/color/test_gray.py::TestRgbToGrayscale",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}