{
    "result": "To implement the function `sample_is_valid_for_homography`, we need to follow a series of steps to ensure that the input tensors are processed correctly and the oriented constraint check is applied. Here's a step-by-step breakdown of how you can implement this function:\n\n```python\nimport torch\n\ndef sample_is_valid_for_homography(points1: torch.Tensor, points2: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Check if the minimal sample is valid for homography estimation using the oriented constraint.\n\n    Args:\n        points1 (torch.Tensor): Tensor of shape (B, 4, 2) representing points from the first image.\n        points2 (torch.Tensor): Tensor of shape (B, 4, 2) representing points from the second image.\n\n    Returns:\n        torch.Tensor: A mask of shape (B,) indicating the validity of each sample for homography estimation.\n    \"\"\"\n    # 1. Check if the shapes of points1 and points2 are equal\n    if points1.shape != points2.shape:\n        raise ValueError(\"The shapes of points1 and points2 must be equal.\")\n\n    # 2. Convert points to homogeneous coordinates by adding a third coordinate with value 1\n    def to_homogeneous(points):\n        ones = torch.ones((points.shape[0], points.shape[1], 1), dtype=points.dtype, device=points.device)\n        return torch.cat([points, ones], dim=-1)\n\n    points1_homogeneous = to_homogeneous(points1)\n    points2_homogeneous = to_homogeneous(points2)\n\n    # 3. Compute the cross product of the first two points in each set to get the line equation\n    def cross_product(p1, p2):\n        return torch.cross(p1, p2, dim=-1)\n\n    line1 = cross_product(points1_homogeneous[:, 0], points1_homogeneous[:, 1])\n    line2 = cross_product(points2_homogeneous[:, 0], points2_homogeneous[:, 1])\n\n    # 4. Compute the oriented constraint for each batch\n    def oriented_constraint(line, point):\n        return torch.sum(line * point, dim=-1)\n\n    # Check the oriented constraint for the third and fourth points\n    valid1 = oriented_constraint(line1, points1_homogeneous[:, 2]) * oriented_constraint(line1, points1_homogeneous[:, 3]) < 0\n    valid2 = oriented_constraint(line2, points2_homogeneous[:, 2]) * oriented_constraint(line2, points2_homogeneous[:, 3]) < 0\n\n    # 5. Combine the validity checks for both sets of points\n    valid_mask = valid1 & valid2\n\n    # 6. Return the validity mask\n    return valid_mask\n\n```\n\n### Explanation:\n\n1. **Shape Check**: We first ensure that `points1` and `points2` have the same shape, as they should correspond to matching points in two images.\n\n2. **Homogeneous Coordinates**: We convert the 2D points to homogeneous coordinates by appending a 1 to each point. This is necessary for performing cross products and other geometric operations.\n\n3. **Cross Product**: We compute the cross product of the first two points in each set to derive the line equation in homogeneous coordinates.\n\n4. **Oriented Constraint**: We apply the oriented constraint by checking the sign of the product of the oriented constraints for the third and fourth points. This ensures that the points are in a valid configuration for homography estimation.\n\n5. **Validity Mask**: We combine the validity checks for both sets of points to produce a final mask indicating which samples are valid for homography estimation.\n\nThis function will return a boolean tensor indicating the validity of each sample in the batch for homography estimation.",
    "prompt": "Generate a Python function called sample_is_valid_for_homography that implements the oriented constraint check from Marquez-Neila2015. The function takes two input tensors, points1 and points2, each with a shape of (B, 4, 2), where B is the batch size. The function returns a mask with the minimal sample that is good for homography estimation, with a shape of (B, 3, 3). The function first checks if the shapes of points1 and points2 are equal, then converts the points to homogeneous coordinates. and finally determines if the sample is valid for homography estimation. The output is a tensor representing the validity of the sample for each batch.",
    "function_name": "sample_is_valid_for_homography",
    "ground_truth": "kornia/geometry/homography.py",
    "test": "tests/geometry/test_homography.py::TestSampleValidation",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}