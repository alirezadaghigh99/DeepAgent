{
    "result": "To create the `rgb_to_yuv420` function, we need to follow a series of steps to convert an RGB image to the YUV 420 format. This involves converting the RGB values to YUV, subsampling the U and V channels, and ensuring the input dimensions are even. Here's a step-by-step implementation:\n\n```python\nimport torch\nfrom typing import Tuple\n\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Convert an RGB image to YUV 420 format.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, 3, H, W) and values in range (0, 1).\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: \n            - Y plane with shape (*, 1, H, W)\n            - UV planes with shape (*, 2, H/2, W/2)\n    \"\"\"\n    # 1. Check input dimensions\n    if image.dim() < 3 or image.size(-3) != 3:\n        raise ValueError(\"Input image must have shape (*, 3, H, W)\")\n\n    # 2. Ensure H and W are even\n    _, _, H, W = image.shape\n    if H % 2 != 0 or W % 2 != 0:\n        raise ValueError(\"Height and width of the image must be even numbers\")\n\n    # 3. Define the RGB to YUV conversion matrix\n    rgb_to_yuv_matrix = torch.tensor([\n        [0.299, 0.587, 0.114],\n        [-0.14713, -0.28886, 0.436],\n        [0.615, -0.51499, -0.10001]\n    ], dtype=image.dtype, device=image.device)\n\n    # 4. Reshape image for matrix multiplication\n    original_shape = image.shape\n    image = image.view(-1, 3, H, W)\n\n    # 5. Convert RGB to YUV\n    yuv = torch.tensordot(image, rgb_to_yuv_matrix, dims=([1], [1]))\n    yuv = yuv.permute(0, 3, 1, 2)  # Reorder to (*, H, W, 3)\n\n    # 6. Extract Y, U, V channels\n    Y = yuv[..., 0:1]  # Shape: (*, H, W, 1)\n    U = yuv[..., 1:2]  # Shape: (*, H, W, 1)\n    V = yuv[..., 2:3]  # Shape: (*, H, W, 1)\n\n    # 7. Subsample U and V channels\n    U_subsampled = U[..., ::2, ::2]  # Shape: (*, H/2, W/2, 1)\n    V_subsampled = V[..., ::2, ::2]  # Shape: (*, H/2, W/2, 1)\n\n    # 8. Concatenate U and V channels\n    UV = torch.cat((U_subsampled, V_subsampled), dim=-1)  # Shape: (*, H/2, W/2, 2)\n\n    # 9. Reshape Y and UV to match the expected output format\n    Y = Y.permute(0, 3, 1, 2).reshape(original_shape[:-3] + (1, H, W))  # Shape: (*, 1, H, W)\n    UV = UV.permute(0, 3, 1, 2).reshape(original_shape[:-3] + (2, H // 2, W // 2))  # Shape: (*, 2, H/2, W/2)\n\n    # 10. Return the Y and UV planes\n    return Y, UV\n\n# Example usage\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```\n\n### Explanation:\n1. **Input Validation**: The function checks if the input tensor has the correct shape and if the height and width are even.\n2. **RGB to YUV Conversion**: The conversion is done using a matrix multiplication with the RGB to YUV conversion matrix.\n3. **Subsampling**: The U and V channels are subsampled by taking every second pixel in both dimensions.\n4. **Output**: The function returns the Y channel and the subsampled UV channels in the specified format.",
    "prompt": "Generate a Python function called rgb_to_yuv420 that takes in a torch.Tensor representing an RGB image and returns a tuple of two torch.Tensors. The input image is assumed to be in the range of (0, 1) and needs to be padded to be evenly divisible by 2 horizontally and vertically. The function will output the YUV 420 (subsampled) version of the input image with chroma siting at (0.5, 0.5).\n\nThe function should have the following signature:\n```python\ndef rgb_to_yuv420(image: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nThe function converts the RGB image to YUV 420 format and returns:\n- A Tensor containing the Y plane with shape (*, 1, H, W)\n- A Tensor containing the UV planes with shape (*, 2, H/2, W/2)\n\nEnsure that the input image has a shape of (*, 3, H, W) where H and W are even numbers. If the input does not meet these requirements, appropriate errors will be raised.\n\nExample usage:\n```python\ninput = torch.rand(2, 3, 4, 6)\noutput = rgb_to_yuv420(input)  # (2x1x4x6, 2x2x2x3)\n```",
    "function_name": "rgb_to_yuv420",
    "ground_truth": "kornia/color/yuv.py",
    "test": "tests/color/test_yuv.py::TestRgbToYuv420",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}