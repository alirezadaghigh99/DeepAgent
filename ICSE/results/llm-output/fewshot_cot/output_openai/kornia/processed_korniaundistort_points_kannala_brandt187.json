{
    "result": "To create a function that undistorts points using the Kannala-Brandt model and the Gauss-Newton optimization algorithm, we can follow a structured approach similar to the examples you provided. Here's a step-by-step implementation:\n\n```python\nimport torch\n\ndef undistort_points_kannala_brandt(distorted_points_in_camera: torch.Tensor, params: torch.Tensor, max_iterations: int = 10, tolerance: float = 1e-6) -> torch.Tensor:\n    \"\"\"\n    Undistorts points from the camera frame into the canonical z=1 plane using the Kannala-Brandt model.\n\n    Args:\n        distorted_points_in_camera (Tensor): Tensor of shape (..., 2) representing the distorted points.\n        params (Tensor): Tensor of shape (..., 8) representing the parameters of the Kannala-Brandt model.\n        max_iterations (int): Maximum number of iterations for the Gauss-Newton optimization. Defaults to 10.\n        tolerance (float): Tolerance for convergence. Defaults to 1e-6.\n\n    Returns:\n        Tensor: Undistorted points with shape (..., 2).\n    \"\"\"\n    # 1. Initialize undistorted points as a copy of the distorted points\n    undistorted_points = distorted_points_in_camera.clone()\n\n    # 2. Extract parameters for the Kannala-Brandt model\n    k1, k2, k3, k4, p1, p2, s1, s2 = params.unbind(-1)\n\n    # 3. Define a function to compute the distortion\n    def compute_distortion(x, y):\n        r = torch.sqrt(x**2 + y**2)\n        theta = torch.atan(r)\n        theta_d = theta * (1 + k1 * theta**2 + k2 * theta**4 + k3 * theta**6 + k4 * theta**8)\n        scale = torch.where(r > 0, theta_d / r, torch.tensor(1.0, dtype=r.dtype, device=r.device))\n        return scale * x, scale * y\n\n    # 4. Iteratively apply the Gauss-Newton optimization\n    for _ in range(max_iterations):\n        # 4.1 Compute the current distortion\n        x, y = undistorted_points.unbind(-1)\n        x_distorted, y_distorted = compute_distortion(x, y)\n\n        # 4.2 Compute the error between distorted and undistorted points\n        error_x = distorted_points_in_camera[..., 0] - x_distorted\n        error_y = distorted_points_in_camera[..., 1] - y_distorted\n        error = torch.stack((error_x, error_y), dim=-1)\n\n        # 4.3 Check for convergence\n        if torch.max(torch.abs(error)) < tolerance:\n            break\n\n        # 4.4 Compute the Jacobian matrix\n        r = torch.sqrt(x**2 + y**2)\n        theta = torch.atan(r)\n        theta_d = theta * (1 + k1 * theta**2 + k2 * theta**4 + k3 * theta**6 + k4 * theta**8)\n        dtheta_d_dtheta = 1 + 3 * k1 * theta**2 + 5 * k2 * theta**4 + 7 * k3 * theta**6 + 9 * k4 * theta**8\n        scale = torch.where(r > 0, theta_d / r, torch.tensor(1.0, dtype=r.dtype, device=r.device))\n        dscale_dr = torch.where(r > 0, (dtheta_d_dtheta - theta_d / r) / r, torch.tensor(0.0, dtype=r.dtype, device=r.device))\n\n        jacobian = torch.stack([\n            scale + x**2 * dscale_dr / r, x * y * dscale_dr / r,\n            x * y * dscale_dr / r, scale + y**2 * dscale_dr / r\n        ], dim=-1).reshape(*x.shape, 2, 2)\n\n        # 4.5 Update the undistorted points using the Gauss-Newton step\n        delta = torch.linalg.solve(jacobian, error.unsqueeze(-1)).squeeze(-1)\n        undistorted_points = undistorted_points + delta\n\n    # 5. Return the undistorted points\n    return undistorted_points\n```\n\n### Explanation:\n\n1. **Initialization**: We start by copying the distorted points to initialize the undistorted points.\n\n2. **Parameter Extraction**: The parameters of the Kannala-Brandt model are extracted for use in the distortion computation.\n\n3. **Distortion Function**: A helper function computes the distortion based on the current estimate of the undistorted points.\n\n4. **Gauss-Newton Optimization**: We iteratively refine the undistorted points:\n   - Compute the current distortion and error.\n   - Check for convergence based on the error magnitude.\n   - Compute the Jacobian matrix for the distortion function.\n   - Update the undistorted points using the Gauss-Newton step.\n\n5. **Return**: The final undistorted points are returned after the optimization loop.",
    "prompt": "Generate a Python function called undistort_points_kannala_brandt that undistorts one or more points from the camera frame into the canonical z=1 plane using the Kannala-Brandt model. The function takes two input parameters: distorted_points_in_camera, a Tensor representing the points to undistort with shape (..., 2), and params, a Tensor representing the parameters of the Kannala-Brandt distortion model with shape (..., 8). The function returns a Tensor representing the undistorted points with shape (..., 2). The function implements the Gauss-Newton optimization algorithm to iteratively undistort the points.",
    "function_name": "undistort_points_kannala_brandt",
    "ground_truth": "kornia/geometry/camera/distortion_kannala_brandt.py",
    "test": "tests/geometry/camera/test_distortion.py::TestDistortionKannalaBrandt",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}