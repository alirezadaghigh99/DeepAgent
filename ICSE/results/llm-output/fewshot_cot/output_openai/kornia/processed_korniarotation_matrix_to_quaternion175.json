{
    "result": "To create a function that converts a 3x3 rotation matrix to a 4D quaternion vector, we can follow a structured approach similar to the examples provided. Here's a step-by-step implementation:\n\n```python\nimport torch\n\ndef rotation_matrix_to_quaternion(rotation_matrix: torch.Tensor, eps: float = 1e-6) -> torch.Tensor:\n    \"\"\"\n    Converts a 3x3 rotation matrix to a 4D quaternion vector.\n\n    Args:\n        rotation_matrix (torch.Tensor): A tensor of shape (..., 3, 3) representing the rotation matrix.\n        eps (float): A small value to avoid division by zero. Defaults to 1e-6.\n\n    Returns:\n        torch.Tensor: A tensor of shape (..., 4) representing the quaternion in (w, x, y, z) format.\n\n    Raises:\n        ValueError: If the input is not a 3x3 matrix or if the input tensor has an incorrect shape.\n    \"\"\"\n    # 1. Check the input tensor shape\n    if rotation_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"Input must be a tensor of shape (..., 3, 3)\")\n\n    # 2. Initialize the quaternion tensor\n    q = torch.empty(rotation_matrix.shape[:-2] + (4,), dtype=rotation_matrix.dtype, device=rotation_matrix.device)\n\n    # 3. Compute the trace of the rotation matrix\n    trace = rotation_matrix[..., 0, 0] + rotation_matrix[..., 1, 1] + rotation_matrix[..., 2, 2]\n\n    # 4. Compute quaternion components based on the trace\n    #    Use different formulas depending on the trace value to ensure numerical stability\n    def compute_quaternion(r, t):\n        if t > 0:\n            s = torch.sqrt(t + 1.0) * 2  # s = 4 * qw\n            qw = 0.25 * s\n            qx = (r[..., 2, 1] - r[..., 1, 2]) / s\n            qy = (r[..., 0, 2] - r[..., 2, 0]) / s\n            qz = (r[..., 1, 0] - r[..., 0, 1]) / s\n        elif (r[..., 0, 0] > r[..., 1, 1]) and (r[..., 0, 0] > r[..., 2, 2]):\n            s = torch.sqrt(1.0 + r[..., 0, 0] - r[..., 1, 1] - r[..., 2, 2]) * 2  # s = 4 * qx\n            qw = (r[..., 2, 1] - r[..., 1, 2]) / s\n            qx = 0.25 * s\n            qy = (r[..., 0, 1] + r[..., 1, 0]) / s\n            qz = (r[..., 0, 2] + r[..., 2, 0]) / s\n        elif r[..., 1, 1] > r[..., 2, 2]:\n            s = torch.sqrt(1.0 + r[..., 1, 1] - r[..., 0, 0] - r[..., 2, 2]) * 2  # s = 4 * qy\n            qw = (r[..., 0, 2] - r[..., 2, 0]) / s\n            qx = (r[..., 0, 1] + r[..., 1, 0]) / s\n            qy = 0.25 * s\n            qz = (r[..., 1, 2] + r[..., 2, 1]) / s\n        else:\n            s = torch.sqrt(1.0 + r[..., 2, 2] - r[..., 0, 0] - r[..., 1, 1]) * 2  # s = 4 * qz\n            qw = (r[..., 1, 0] - r[..., 0, 1]) / s\n            qx = (r[..., 0, 2] + r[..., 2, 0]) / s\n            qy = (r[..., 1, 2] + r[..., 2, 1]) / s\n            qz = 0.25 * s\n        return torch.stack((qw, qx, qy, qz), dim=-1)\n\n    # 5. Apply the quaternion computation across the batch\n    q = compute_quaternion(rotation_matrix, trace)\n\n    # 6. Normalize the quaternion to ensure it is a unit quaternion\n    q = q / (torch.norm(q, dim=-1, keepdim=True) + eps)\n\n    return q\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Define a sample rotation matrix\n    rot_matrix = torch.tensor([\n        [0.0, -1.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ]).unsqueeze(0)  # Add batch dimension\n\n    # Convert to quaternion\n    quaternion = rotation_matrix_to_quaternion(rot_matrix)\n    print(\"Quaternion:\", quaternion)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function checks if the input tensor has the correct shape of (..., 3, 3). If not, it raises a `ValueError`.\n\n2. **Trace Calculation**: The trace of the rotation matrix is calculated to determine which formula to use for computing the quaternion components.\n\n3. **Quaternion Calculation**: Depending on the trace value, different formulas are used to compute the quaternion components to ensure numerical stability.\n\n4. **Normalization**: The resulting quaternion is normalized to ensure it is a unit quaternion.\n\n5. **Example Usage**: An example is provided to demonstrate how to use the function with a sample rotation matrix.",
    "prompt": "Generate a Python function called rotation_matrix_to_quaternion that converts a 3x3 rotation matrix to a 4d quaternion vector. The input parameters are a rotation matrix tensor and a small value eps to avoid zero division. The output is a quaternion tensor with components in (w, x, y, z) format. The function returns the quaternion tensor with shape (*, 4). The function includes examples of usage and error handling for input types and sizes.",
    "function_name": "rotation_matrix_to_quaternion",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestRotationMatrixToQuaternion",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}