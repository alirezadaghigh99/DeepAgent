{
    "result": "To create the `quaternion_exp_to_log` function, we will follow a step-by-step approach similar to the examples provided. This function will apply the logarithmic map to a quaternion, which is a common operation in 3D rotations and computer graphics. Here's how you can implement it:\n\n```python\nimport torch\n\ndef quaternion_exp_to_log(quaternion: torch.Tensor, eps: float) -> torch.Tensor:\n    \"\"\"\n    Applies the logarithmic map to a quaternion.\n\n    Args:\n        quaternion (Tensor): A tensor of shape (*, 4) representing quaternions in (w, x, y, z) format.\n        eps (float): A small value for clamping to avoid division by zero.\n\n    Returns:\n        Tensor: A tensor of shape (*, 3) representing the quaternion log map.\n    \"\"\"\n    # 1. Check if the input is a tensor and has the correct shape\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor.\")\n    if quaternion.shape[-1] != 4:\n        raise ValueError(\"Input tensor must have shape (*, 4).\")\n\n    # 2. Unpack the quaternion into scalar (w) and vector (x, y, z) parts\n    w, x, y, z = quaternion.unbind(dim=-1)\n    vector_part = quaternion[..., 1:]\n\n    # 3. Compute the norm of the vector part\n    vector_norm = torch.norm(vector_part, dim=-1, keepdim=True)\n\n    # 4. Compute the quaternion norm\n    quaternion_norm = torch.norm(quaternion, dim=-1, keepdim=True)\n\n    # 5. Apply the log map\n    #    Use eps to clamp the vector_norm to avoid division by zero\n    vector_norm_clamped = torch.clamp(vector_norm, min=eps)\n    theta = torch.acos(torch.clamp(w / quaternion_norm, min=-1.0, max=1.0))\n    log_map = (theta / vector_norm_clamped) * vector_part\n\n    # 6. Handle the case where the vector part is zero\n    #    If vector_norm is zero, the log map should be zero\n    log_map = torch.where(vector_norm < eps, torch.zeros_like(log_map), log_map)\n\n    # 7. Return the resulting tensor\n    return log_map\n\n# Example usage\nquaternion = torch.tensor((1., 0., 0., 0.))\nresult = quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\nprint(result)  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input is a tensor and has the correct shape of `(*, 4)`.\n\n2. **Unpacking**: The quaternion is unpacked into its scalar (`w`) and vector (`x, y, z`) components.\n\n3. **Norm Calculation**: The norm of the vector part and the quaternion norm are calculated.\n\n4. **Log Map Calculation**: The logarithmic map is computed using the formula for quaternion logarithms. Clamping is used to avoid division by zero.\n\n5. **Zero Vector Handling**: If the vector part is zero, the log map is set to zero to handle this special case.\n\n6. **Return**: The function returns the computed log map as a tensor of shape `(*, 3)`.\n\nThis implementation should work for any batch of quaternions and handle edge cases like zero vectors gracefully.",
    "prompt": "Generate a Python function called quaternion_exp_to_log that applies the log map to a quaternion. The input is a tensor called quaternion in (w, x, y, z) format and a float called eps for clamping. The output is a tensor of shape (*, 3) representing the quaternion log map. The function checks if the input is a Tensor and has a shape of (*, 4). It then unpacks the quaternion into a vector and scalar, computes the quaternion norm, and applies the log map to calculate the quaternion log. An example usage is provided with a sample quaternion input. >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_exp_to_log(quaternion, eps=torch.finfo(quaternion.dtype).eps)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_exp_to_log",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/epipolar/test_essential.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}