{
    "result": "To implement the `forward` method for the `Rotate` class, we need to rotate the input tensor anti-clockwise around its center. We'll use PyTorch's `torch.nn.functional` module, specifically the `grid_sample` function, which allows for flexible spatial transformations, including rotation. Here's how you can implement the `forward` method:\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Rotate(nn.Module):\n    def __init__(self, angle, center=None, interpolation='bilinear', padding_mode='zeros', align_corners=False):\n        super(Rotate, self).__init__()\n        self.angle = angle\n        self.center = center\n        self.interpolation = interpolation\n        self.padding_mode = padding_mode\n        self.align_corners = align_corners\n\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Get the dimensions of the input tensor\n        _, _, height, width = input.size()\n\n        # Calculate the center of rotation if not provided\n        if self.center is None:\n            center = (width / 2, height / 2)\n        else:\n            center = self.center\n\n        # Convert angle from degrees to radians\n        angle_rad = -self.angle * (torch.pi / 180.0)  # Negative for anti-clockwise rotation\n\n        # Create the rotation matrix\n        cos_a = torch.cos(angle_rad)\n        sin_a = torch.sin(angle_rad)\n        rotation_matrix = torch.tensor([\n            [cos_a, -sin_a, (1 - cos_a) * center[0] + sin_a * center[1]],\n            [sin_a, cos_a, (1 - cos_a) * center[1] - sin_a * center[0]]\n        ], dtype=input.dtype, device=input.device)\n\n        # Create the affine grid\n        grid = F.affine_grid(rotation_matrix.unsqueeze(0), input.size(), align_corners=self.align_corners)\n\n        # Sample the input tensor using the grid\n        output = F.grid_sample(input, grid, mode=self.interpolation, padding_mode=self.padding_mode, align_corners=self.align_corners)\n\n        return output\n```\n\n### Explanation:\n\n1. **Initialization**: The `Rotate` class is initialized with parameters such as `angle`, `center`, `interpolation`, `padding_mode`, and `align_corners`.\n\n2. **Center Calculation**: If the center of rotation is not provided, it defaults to the center of the image.\n\n3. **Angle Conversion**: The angle is converted from degrees to radians, and it's negated to achieve anti-clockwise rotation.\n\n4. **Rotation Matrix**: A 2x3 rotation matrix is constructed using trigonometric functions. This matrix is used to transform the coordinates of the input tensor.\n\n5. **Affine Grid**: The `affine_grid` function generates a grid of coordinates that will be used to sample the input tensor.\n\n6. **Grid Sampling**: The `grid_sample` function applies the transformation defined by the grid to the input tensor, using the specified interpolation and padding modes.\n\n7. **Return**: The transformed tensor is returned, maintaining the same shape as the input tensor.",
    "prompt": "**Task:** Write the `forward` method for the `Rotate` class. This method should rotate the input tensor anti-clockwise around its center. The method should return a tensor of the same shape as the input.\n\n\n**Class Context:**\n```python\nclass Rotate(nn.Module):\n    def forward(self, input: torch.Tensor) -> torch.Tensor:\n        # Implement this function\n```\n\n**Requirements:**\n- The method should take the input tensor and rotate it by the specified angle.\n- The rotation should be performed around the provided center, or the center should be calculated if not provided.\n- Use the specified interpolation mode (`'bilinear'` or `'nearest'`), padding mode (`'zeros'`, `'border'`, or `'reflection'`), and alignment flag (`align_corners`).",
    "function_name": "forward",
    "ground_truth": "kornia/geometry/transform/affwarp.py",
    "test": "tests/geometry/transform/test_affine.py::TestRotate",
    "class": "Rotate",
    "stage": "Image",
    "task": "",
    "data": "Inference"
}