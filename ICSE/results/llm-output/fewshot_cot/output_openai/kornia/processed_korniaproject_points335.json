{
    "result": "To create the `project_points` function, we need to perform a matrix multiplication between the 3D points and the camera matrix to project the points onto the 2D camera plane. Here's a step-by-step implementation of the function:\n\n```python\nimport torch\n\ndef project_points(points_3d: torch.Tensor, camera_matrix: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Projects 3D points onto a 2D camera plane using a camera matrix.\n\n    Args:\n        points_3d (torch.Tensor): A tensor of shape (*, 3) representing 3D points.\n        camera_matrix (torch.Tensor): A tensor of shape (*, 3, 3) representing the camera matrix.\n\n    Returns:\n        torch.Tensor: A tensor of shape (*, 2) representing the (u, v) camera coordinates.\n    \"\"\"\n    # 1. Ensure the input tensors have the correct shapes\n    if points_3d.shape[-1] != 3:\n        raise ValueError(\"The last dimension of points_3d must be 3.\")\n    if camera_matrix.shape[-2:] != (3, 3):\n        raise ValueError(\"The last two dimensions of camera_matrix must be (3, 3).\")\n\n    # 2. Add a homogeneous coordinate (1) to the 3D points\n    ones = torch.ones(*points_3d.shape[:-1], 1, dtype=points_3d.dtype, device=points_3d.device)\n    points_3d_homogeneous = torch.cat((points_3d, ones), dim=-1)\n\n    # 3. Perform matrix multiplication to project the points\n    projected_points_homogeneous = torch.matmul(points_3d_homogeneous, camera_matrix.transpose(-1, -2))\n\n    # 4. Convert from homogeneous coordinates to 2D coordinates\n    u = projected_points_homogeneous[..., 0] / projected_points_homogeneous[..., 2]\n    v = projected_points_homogeneous[..., 1] / projected_points_homogeneous[..., 2]\n\n    # 5. Stack the u and v coordinates to form the final output\n    projected_points_2d = torch.stack((u, v), dim=-1)\n\n    return projected_points_2d\n\n# Example usage\npoints_3d = torch.rand(5, 3)  # Random 3D points\ncamera_matrix = torch.eye(3)  # Identity matrix as the camera matrix\nprojected_points = project_points(points_3d, camera_matrix)\nprint(projected_points)\n```\n\n### Explanation:\n\n1. **Input Validation**: We first check that the input tensors have the correct shapes. The `points_3d` tensor should have a last dimension of size 3, and the `camera_matrix` should have a shape of (*, 3, 3).\n\n2. **Homogeneous Coordinates**: We add a homogeneous coordinate (1) to each 3D point to facilitate the matrix multiplication with the camera matrix.\n\n3. **Matrix Multiplication**: We perform the matrix multiplication between the homogeneous 3D points and the transposed camera matrix to project the points onto the 2D plane.\n\n4. **Convert to 2D Coordinates**: We convert the resulting homogeneous coordinates to 2D coordinates by dividing by the third coordinate (z).\n\n5. **Output**: We stack the `u` and `v` coordinates to form the final output tensor of shape (*, 2).\n\nThis function can be used to project any 3D points onto a 2D camera plane using a given camera matrix.",
    "prompt": "Generate a Python function called project_points that takes in a 3D point tensor and a camera matrix tensor as input. The function projects the 3D point onto the 2D camera plane using the camera matrix. The input tensor for the 3D point should have shape (*, 3) and the camera matrix tensor should have shape (*, 3, 3). The function returns a tensor of (u, v) camera coordinates with shape (*, 2). An example usage of the function is provided where a random 3D point and an identity matrix as the camera matrix are used to project the point onto the camera plane, resulting in a tensor of camera coordinates.",
    "function_name": "project_points",
    "ground_truth": "kornia/geometry/camera/perspective.py",
    "test": "tests/geometry/camera/test_projections.py::TestProjectionZ1",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}