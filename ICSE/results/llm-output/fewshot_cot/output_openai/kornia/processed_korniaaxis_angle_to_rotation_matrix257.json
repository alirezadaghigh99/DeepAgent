{
    "result": "To implement the `axis_angle_to_rotation_matrix` function, we need to convert a 3D vector representing an axis-angle rotation into a 3x3 rotation matrix. This involves using the Rodrigues' rotation formula. Here's a step-by-step breakdown of how you can implement this function:\n\n```python\nimport torch\n\ndef axis_angle_to_rotation_matrix(axis_angle: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Convert 3D vector of axis-angle rotation to 3x3 rotation matrix.\n\n    Args:\n        axis_angle: tensor of 3D vector of axis-angle rotations in radians with shape (N, 3).\n\n    Returns:\n        tensor of rotation matrices of shape (N, 3, 3).\n    \"\"\"\n    # 1. Compute the angle (theta) as the norm of the axis-angle vector\n    theta = torch.norm(axis_angle, dim=1, keepdim=True)\n\n    # 2. Avoid division by zero by setting zero angles to one (will be handled later)\n    theta = torch.where(theta == 0, torch.ones_like(theta), theta)\n\n    # 3. Normalize the axis to get the unit vector\n    axis = axis_angle / theta\n\n    # 4. Compute the sine and cosine of the angle\n    cos_theta = torch.cos(theta)\n    sin_theta = torch.sin(theta)\n\n    # 5. Compute the components of the Rodrigues' rotation formula\n    #    K is the skew-symmetric cross-product matrix of the axis\n    kx, ky, kz = axis[:, 0], axis[:, 1], axis[:, 2]\n    K = torch.stack([\n        torch.zeros_like(kx), -kz, ky,\n        kz, torch.zeros_like(ky), -kx,\n        -ky, kx, torch.zeros_like(kz)\n    ], dim=1).reshape(-1, 3, 3)\n\n    # 6. Compute the rotation matrix using the Rodrigues' formula\n    I = torch.eye(3, device=axis_angle.device).unsqueeze(0)  # Identity matrix\n    R = I + sin_theta.unsqueeze(-1) * K + (1 - cos_theta.unsqueeze(-1)) * torch.bmm(K, K)\n\n    # 7. Handle the case where theta is zero (no rotation)\n    #    In this case, the rotation matrix should be the identity matrix\n    R = torch.where(theta.unsqueeze(-1) == 0, I, R)\n\n    return R\n\n# Example usage\ninput = torch.tensor([[0., 0., 0.]])\nprint(axis_angle_to_rotation_matrix(input))\n\ninput = torch.tensor([[1.5708, 0., 0.]])\nprint(axis_angle_to_rotation_matrix(input))\n```\n\n### Explanation:\n1. **Angle Calculation**: The angle of rotation is the magnitude (norm) of the axis-angle vector.\n2. **Normalization**: The axis is normalized to ensure it is a unit vector.\n3. **Rodrigues' Formula**: This formula is used to compute the rotation matrix from the axis and angle.\n4. **Special Case Handling**: When the angle is zero, the rotation matrix should be the identity matrix, as there is no rotation.\n\nThis function should correctly convert axis-angle representations to rotation matrices for a batch of inputs.",
    "prompt": "Write a python function axis_angle_to_rotation_matrix thatConvert 3d vector of axis-angle rotation to 3x3 rotation matrix.\n\n    Args:\n        axis_angle: tensor of 3d vector of axis-angle rotations in radians with shape :math:`(N, 3)`.\n\n    Returns:\n        tensor of rotation matrices of shape :math:`(N, 3, 3)`.\n\n    Example:\n        >>> input = tensor([[0., 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[1., 0., 0.],\n                 [0., 1., 0.],\n                 [0., 0., 1.]]])\n\n        >>> input = tensor([[1.5708, 0., 0.]])\n        >>> axis_angle_to_rotation_matrix(input)\n        tensor([[[ 1.0000e+00,  0.0000e+00,  0.0000e+00],\n                 [ 0.0000e+00, -3.6200e-06, -1.0000e+00],\n                 [ 0.0000e+00,  1.0000e+00, -3.6200e-06]]]]",
    "function_name": "axis_angle_to_rotation_matrix",
    "ground_truth": "kornia/geometry/conversions.py#L267",
    "test": "tests/geometry/test_conversions.py::TestAngleAxisToRotationMatrix",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}