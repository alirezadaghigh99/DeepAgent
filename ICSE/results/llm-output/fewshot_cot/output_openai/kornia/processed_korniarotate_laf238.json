{
    "result": "To create the `rotate_laf` function, we need to apply a rotation transformation to each Local Affine Frame (LAF) in the input tensor. The LAF is represented by a tensor of shape `(B, N, 2, 3)`, where `B` is the batch size, `N` is the number of LAFs, and each LAF is a 2x3 matrix. The rotation angles are provided in degrees in a tensor of shape `(B, N, 1)`. Here's a step-by-step implementation:\n\n```python\nimport torch\n\ndef rotate_laf(LAF: torch.Tensor, angles_degrees: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Rotate a Local Affine Frame (LAF) by specified angles.\n\n    Args:\n        LAF (torch.Tensor): Tensor of shape (B, N, 2, 3) representing the LAFs.\n        angles_degrees (torch.Tensor): Tensor of shape (B, N, 1) representing rotation angles in degrees.\n\n    Returns:\n        torch.Tensor: Rotated LAF with the same shape as input.\n\n    Raises:\n        ValueError: If the input LAF is not of shape (B, N, 2, 3).\n    \"\"\"\n    # 1. Validate the input LAF shape\n    if LAF.ndim != 4 or LAF.shape[2:] != (2, 3):\n        raise ValueError(\"Input LAF must have shape (B, N, 2, 3)\")\n\n    # 2. Convert angles from degrees to radians\n    angles_radians = torch.deg2rad(angles_degrees.squeeze(-1))\n\n    # 3. Compute the rotation matrices for each angle\n    cos_angles = torch.cos(angles_radians)\n    sin_angles = torch.sin(angles_radians)\n    rotation_matrices = torch.stack([\n        torch.stack([cos_angles, -sin_angles], dim=-1),\n        torch.stack([sin_angles, cos_angles], dim=-1)\n    ], dim=-2)\n\n    # 4. Apply the rotation to the LAF\n    #    The rotation is applied to the first two columns of the LAF (2x2 part)\n    rotated_LAF = LAF.clone()\n    rotated_LAF[..., :2] = torch.matmul(rotation_matrices, LAF[..., :2])\n\n    # 5. Return the rotated LAF\n    return rotated_LAF\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input `LAF` tensor has the correct shape `(B, N, 2, 3)`. If not, it raises a `ValueError`.\n\n2. **Angle Conversion**: The rotation angles are converted from degrees to radians using `torch.deg2rad`.\n\n3. **Rotation Matrices**: For each angle, a 2x2 rotation matrix is constructed using the cosine and sine of the angle.\n\n4. **Apply Rotation**: The rotation matrix is applied to the first two columns of each LAF (the 2x2 part), which represents the affine transformation. The `torch.matmul` function is used to perform the matrix multiplication.\n\n5. **Return Result**: The function returns the rotated LAF tensor, maintaining the original shape `(B, N, 2, 3)`.",
    "prompt": "Create a function `rotate_laf` that applies an additional rotation to a Local Affine Frame (LAF). The function takes in a tensor `LAF` of shape `(B, N, 2, 3)` and a tensor `angles_degrees` of shape `(B, N, 1)` representing rotation angles in degrees. It returns the rotated LAF with the same shape. The function raises an error if the input LAF is not properly structured.",
    "function_name": "rotate_laf",
    "ground_truth": "kornia/feature/laf.py#L70",
    "test": "tests/feature/test_laf.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}