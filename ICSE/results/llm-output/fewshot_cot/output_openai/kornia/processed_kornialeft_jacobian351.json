{
    "result": "To create a Python function called `left_jacobian` that computes the left Jacobian of SO(3) for a batch of vectors, we can follow a step-by-step approach similar to the examples you provided. The left Jacobian of SO(3) is a matrix that relates small changes in the rotation vector to small changes in the rotation matrix. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef left_jacobian(vec: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Compute the left Jacobian of SO(3) for a batch of vectors.\n\n    Args:\n        vec (Tensor): A tensor of shape (B, 3) where B is the batch size.\n\n    Returns:\n        Tensor: A tensor of shape (B, 3, 3) representing the left Jacobian matrix for each vector.\n    \"\"\"\n    # 1. Ensure the input tensor has the correct shape\n    assert vec.shape[-1] == 3, \"Input tensor must have shape (B, 3)\"\n\n    # 2. Compute the norm of each vector in the batch\n    theta = torch.norm(vec, dim=-1, keepdim=True)\n\n    # 3. Create a mask for small angles to avoid division by zero\n    small_angle_mask = theta < 1e-6\n\n    # 4. Compute the skew-symmetric matrix for each vector\n    def skew_symmetric(v):\n        zero = torch.zeros_like(v[..., 0])\n        return torch.stack([\n            zero, -v[..., 2], v[..., 1],\n            v[..., 2], zero, -v[..., 0],\n            -v[..., 1], v[..., 0], zero\n        ], dim=-1).reshape(-1, 3, 3)\n\n    skew_vec = skew_symmetric(vec)\n\n    # 5. Compute the left Jacobian using the series expansion for small angles\n    #    and the exact formula for larger angles\n    theta_sq = theta ** 2\n    sin_theta = torch.sin(theta)\n    cos_theta = torch.cos(theta)\n\n    # 6. Use Taylor series expansion for small angles\n    J_small = torch.eye(3, device=vec.device).unsqueeze(0) + 0.5 * skew_vec\n\n    # 7. Use the exact formula for larger angles\n    J_large = (\n        torch.eye(3, device=vec.device).unsqueeze(0)\n        + (1 - cos_theta) / theta_sq * skew_vec\n        + (theta - sin_theta) / (theta_sq * theta) * torch.bmm(skew_vec, skew_vec)\n    )\n\n    # 8. Combine the results using the mask\n    J = torch.where(small_angle_mask, J_small, J_large)\n\n    # 9. Return the left Jacobian matrix\n    return J\n\n```\n\n### Explanation:\n\n1. **Input Validation**: We ensure the input tensor `vec` has the correct shape `(B, 3)`.\n\n2. **Norm Calculation**: We compute the norm of each vector, which represents the angle of rotation.\n\n3. **Small Angle Handling**: We create a mask to handle small angles separately to avoid numerical instability.\n\n4. **Skew-Symmetric Matrix**: We define a helper function to compute the skew-symmetric matrix for each vector.\n\n5. **Left Jacobian Calculation**: We use a Taylor series expansion for small angles and the exact formula for larger angles to compute the left Jacobian.\n\n6. **Combining Results**: We use the mask to select the appropriate Jacobian calculation for each vector in the batch.\n\nThis function efficiently computes the left Jacobian for a batch of vectors, handling both small and large angles appropriately.",
    "prompt": "Generate a Python function called left_jacobian that computes the left Jacobian of So3. The input is a tensor called vec of shape (B, 3) where B is the batch size. The output is a tensor of shape (B, 3, 3) representing the left Jacobian matrix. The function uses the input tensor to calculate the left Jacobian matrix using specific mathematical operations",
    "function_name": "left_jacobian",
    "ground_truth": "kornia/geometry/liegroup/so3.py",
    "test": "tests/geometry/liegroup/test_so3.py::TestSo3::test_left_jacobian",
    "class": "So3",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Image"
}