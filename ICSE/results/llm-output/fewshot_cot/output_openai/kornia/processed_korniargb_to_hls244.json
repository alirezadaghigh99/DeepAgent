{
    "result": "To create a function `rgb_to_hls` that converts an RGB image to HLS format, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef rgb_to_hls(image: torch.Tensor, eps: float = 1e-10) -> torch.Tensor:\n    \"\"\"\n    Convert an RGB image to HLS format.\n\n    Args:\n        image (torch.Tensor): Input image tensor with shape (*, 3, H, W) and values in range (0, 1).\n        eps (float): Small epsilon value to avoid division by zero.\n\n    Returns:\n        torch.Tensor: HLS image tensor with the same shape as the input.\n\n    Raises:\n        TypeError: If the input is not a PyTorch tensor.\n        ValueError: If the input does not have a shape of (*, 3, H, W).\n    \"\"\"\n    # 1. Check if the input is a PyTorch tensor\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Input must be a PyTorch tensor.\")\n\n    # 2. Check if the input has the correct shape\n    if image.ndim < 3 or image.shape[-3] != 3:\n        raise ValueError(\"Input must have shape (*, 3, H, W).\")\n\n    # 3. Separate the RGB channels\n    r, g, b = image.unbind(dim=-3)\n\n    # 4. Calculate the max and min values across the RGB channels\n    max_rgb, _ = torch.max(image, dim=-3)\n    min_rgb, _ = torch.min(image, dim=-3)\n\n    # 5. Calculate luminance\n    l = (max_rgb + min_rgb) / 2\n\n    # 6. Calculate saturation\n    delta = max_rgb - min_rgb\n    s = torch.where(l < 0.5, delta / (max_rgb + min_rgb + eps), delta / (2 - max_rgb - min_rgb + eps))\n\n    # 7. Calculate hue\n    zero_tensor = torch.zeros_like(delta)\n    hue = torch.where(delta == 0, zero_tensor, zero_tensor)  # Initialize hue with zeros\n\n    # 8. Calculate hue for non-zero delta\n    mask = delta != 0\n    r_eq_max = (r == max_rgb) & mask\n    g_eq_max = (g == max_rgb) & mask\n    b_eq_max = (b == max_rgb) & mask\n\n    hue[r_eq_max] = (g[r_eq_max] - b[r_eq_max]) / (delta[r_eq_max] + eps)\n    hue[g_eq_max] = 2.0 + (b[g_eq_max] - r[g_eq_max]) / (delta[g_eq_max] + eps)\n    hue[b_eq_max] = 4.0 + (r[b_eq_max] - g[b_eq_max]) / (delta[b_eq_max] + eps)\n\n    # 9. Normalize hue to be in the range [0, 1]\n    hue = (hue / 6.0) % 1.0\n\n    # 10. Stack the HLS components back together\n    hls = torch.stack((hue, l, s), dim=-3)\n\n    # 11. Return the HLS image\n    return hls\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create a random RGB image tensor with shape (2, 3, 4, 4)\n    random_rgb_image = torch.rand((2, 3, 4, 4))\n\n    # Convert the RGB image to HLS format\n    hls_image = rgb_to_hls(random_rgb_image)\n\n    print(\"HLS Image Shape:\", hls_image.shape)\n    print(\"HLS Image:\", hls_image)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input is a PyTorch tensor and if it has the correct shape. If not, it raises appropriate errors.\n\n2. **Channel Separation**: The RGB channels are separated using `unbind`.\n\n3. **Luminance Calculation**: Luminance is calculated as the average of the maximum and minimum RGB values.\n\n4. **Saturation Calculation**: Saturation is calculated based on the luminance and the difference between the max and min RGB values.\n\n5. **Hue Calculation**: Hue is calculated based on which channel has the maximum value. The hue is normalized to be in the range [0, 1].\n\n6. **Output**: The HLS components are stacked back together and returned as a tensor with the same shape as the input.\n\nThis function provides a robust way to convert RGB images to HLS format while handling potential issues like division by zero.",
    "prompt": "Generate a Python function called rgb_to_hls that converts an RGB image to HLS format. The function takes in a PyTorch tensor called image representing the RGB image with shape (*, 3, H, W) and an epsilon value eps to avoid division by zero. The image data is assumed to be in the range of (0, 1).\n\nThe function returns the HLS version of the input image with the same shape (*, 3, H, W). If the input image is not a PyTorch tensor, a TypeError is raised. If the input size does not have a shape of (*, 3, H, W), a ValueError is raised.\n\nThe conversion process involves calculating the HLS components (hue, luminance, saturation) based on the RGB values of the input image. The resulting HLS image is returned as a PyTorch tensor.\n\nAn example usage of the rgb_to_hls function is provided in the code snippet, where a random input RGB image tensor is converted to HLS format. Raise the value error if there input not instance of image or there was a problem with shape",
    "function_name": "rgb_to_hls",
    "ground_truth": "kornia/color/hls.py",
    "test": "tests/color/test_hls.py::TestRgbToHls",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}