{
    "result": "To create a function that converts a quaternion to an axis-angle representation, we need to follow a series of steps. Here's a step-by-step guide to implementing the `quaternion_to_axis_angle` function:\n\n```python\nimport torch\n\ndef quaternion_to_axis_angle(quaternion: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Convert a quaternion to an axis-angle representation.\n\n    Args:\n        quaternion (torch.Tensor): A tensor of shape (N, 4) or (4,) representing quaternions in (w, x, y, z) format.\n\n    Returns:\n        torch.Tensor: A tensor of shape (N, 3) or (3,) representing the axis-angle of rotation in radians.\n    \"\"\"\n    # 1. Check if the input is a tensor\n    if not isinstance(quaternion, torch.Tensor):\n        raise TypeError(\"Input must be a torch.Tensor\")\n\n    # 2. Check the shape of the input tensor\n    if quaternion.dim() == 1:\n        if quaternion.size(0) != 4:\n            raise ValueError(\"Input tensor must have shape (4,) for a single quaternion\")\n        quaternions = quaternion.unsqueeze(0)  # Convert to (1, 4) for consistent processing\n    elif quaternion.dim() == 2:\n        if quaternion.size(1) != 4:\n            raise ValueError(\"Input tensor must have shape (N, 4) for multiple quaternions\")\n        quaternions = quaternion\n    else:\n        raise ValueError(\"Input tensor must have shape (N, 4) or (4,)\")\n\n    # 3. Unpack the quaternion components\n    w, x, y, z = quaternions.unbind(dim=-1)\n\n    # 4. Compute the angle of rotation\n    angle = 2 * torch.acos(w)\n\n    # 5. Compute the axis of rotation\n    sin_half_angle = torch.sqrt(1 - w**2)\n    axis = torch.stack((x, y, z), dim=-1) / sin_half_angle.unsqueeze(-1)\n\n    # 6. Handle the case where the angle is close to zero\n    #    In this case, the axis can be arbitrary, so we set it to (1, 0, 0)\n    near_zero = sin_half_angle < 1e-6\n    axis[near_zero] = torch.tensor([1.0, 0.0, 0.0], device=quaternion.device)\n\n    # 7. Combine the axis and angle into the final output\n    axis_angle = axis * angle.unsqueeze(-1)\n\n    # 8. Return the axis-angle representation\n    return axis_angle.squeeze(0) if quaternion.dim() == 1 else axis_angle\n\n# Example usage:\nquaternion = torch.tensor((1., 0., 0., 0.))\nprint(quaternion_to_axis_angle(quaternion))  # Output: tensor([0., 0., 0.])\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input is a tensor and whether it has the correct shape, either `(N, 4)` for multiple quaternions or `(4,)` for a single quaternion.\n\n2. **Unpacking**: The quaternion components `(w, x, y, z)` are extracted for further calculations.\n\n3. **Angle Calculation**: The angle of rotation is calculated using the formula `angle = 2 * acos(w)`.\n\n4. **Axis Calculation**: The axis of rotation is computed by normalizing the vector `(x, y, z)`. Special care is taken when the angle is close to zero to avoid division by zero.\n\n5. **Output**: The function returns the axis-angle representation, which is a tensor of the same batch size as the input, with each quaternion converted to a 3D vector representing the axis-angle.",
    "prompt": "Generate a Python function called quaternion_to_axis_angle that converts a quaternion vector to an axis angle of rotation in radians. The input is a tensor called quaternion with quaternions in (w, x, y, z) format. The output is a tensor with the axis angle of rotation. The function checks if the input is a tensor and has a shape of Nx4 or 4. It then unpacks the input and computes the conversion using mathematical operations. The final output is a tensor with the axis angle values.Example:\n        >>> quaternion = tensor((1., 0., 0., 0.))\n        >>> quaternion_to_axis_angle(quaternion)\n        tensor([0., 0., 0.])",
    "function_name": "quaternion_to_axis_angle",
    "ground_truth": "kornia/geometry/conversions.py",
    "test": "tests/geometry/test_conversions.py::TestQuaternionToAngleAxis",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}