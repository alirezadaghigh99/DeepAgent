{
    "result": "To create the `normalized_mse` function, we will follow a step-by-step approach similar to the examples provided. Here's how you can implement it:\n\n```python\nimport numpy as np\n\ndef normalized_mse(ref_outputs, approx_outputs):\n    \"\"\"\n    Compute the normalized mean square error (NMSE) between two lists of NumPy arrays.\n\n    The NMSE is defined as the mean square error (MSE) between the reference and approximate outputs,\n    normalized by the MSE between the reference output and zero.\n\n    Args:\n        ref_outputs (List[np.ndarray]): List of reference output arrays.\n        approx_outputs (List[np.ndarray]): List of approximate output arrays.\n\n    Returns:\n        float: The average NMSE across all pairs of reference and approximate outputs.\n    \"\"\"\n    # 1. Initialize a list to store NMSE values for each pair of arrays\n    nmse_values = []\n\n    # 2. Iterate over pairs of reference and approximate outputs\n    for ref, approx in zip(ref_outputs, approx_outputs):\n        # 3. Compute the mean square error (MSE) between ref and approx\n        mse = np.mean((ref - approx) ** 2)\n\n        # 4. Compute the MSE between ref and zero\n        mse_ref_zero = np.mean(ref ** 2)\n\n        # 5. Compute the normalized MSE for the current pair\n        nmse = mse / mse_ref_zero\n\n        # 6. Append the computed NMSE to the list\n        nmse_values.append(nmse)\n\n    # 7. Compute the average NMSE across all pairs\n    average_nmse = np.mean(nmse_values)\n\n    # 8. Return the average NMSE\n    return average_nmse\n```\n\n### Explanation:\n\n1. **Initialize a List**: We start by initializing an empty list `nmse_values` to store the NMSE for each pair of reference and approximate outputs.\n\n2. **Iterate Over Pairs**: We iterate over the pairs of arrays from `ref_outputs` and `approx_outputs` using `zip`.\n\n3. **Compute MSE**: For each pair, we compute the mean square error (MSE) between the reference and approximate outputs.\n\n4. **Compute MSE with Zero**: We also compute the MSE between the reference output and zero, which serves as the normalization factor.\n\n5. **Compute NMSE**: The normalized MSE is calculated by dividing the MSE by the normalization factor.\n\n6. **Store NMSE**: We append the computed NMSE to the `nmse_values` list.\n\n7. **Average NMSE**: After iterating through all pairs, we compute the average NMSE across all pairs.\n\n8. **Return Result**: Finally, we return the average NMSE as a single float value.",
    "prompt": "Create a Python function `normalized_mse` that computes the normalized mean square error (NMSE) between two lists of NumPy arrays, `ref_outputs` and `approx_outputs`. The NMSE is defined as the mean square error (MSE) between the reference and approximate outputs, normalized by the MSE between the reference output and zero. The function iterates over corresponding elements in `ref_outputs` and `approx_outputs`, computes the NMSE for each pair, and then returns the average NMSE across all pairs as a single float value.",
    "function_name": "normalized_mse",
    "ground_truth": "nncf/quantization/algorithms/accuracy_control/rank_functions.py",
    "test": "tests/common/accuracy_control/test_ranking.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Regression",
    "data": ""
}