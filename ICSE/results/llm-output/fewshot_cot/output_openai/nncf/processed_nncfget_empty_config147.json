{
    "result": "To create the `get_empty_config` function as described, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement it:\n\n```python\nfrom typing import Optional, List, Tuple, Dict, Union\n\nclass NNCFConfig:\n    def __init__(self):\n        self.config = {}\n\n    def update(self, new_config: Dict):\n        self.config.update(new_config)\n\n    def __repr__(self):\n        return f\"NNCFConfig({self.config})\"\n\ndef get_empty_config(\n    model_size: int = 4,\n    input_sample_sizes: Optional[Union[List[int], Tuple[int, ...]]] = None,\n    input_info: Optional[Dict] = None\n) -> NNCFConfig:\n    \"\"\"\n    Generate an empty NNCFConfig with specified parameters.\n\n    Args:\n        model_size (int): The size of the model. Defaults to 4.\n        input_sample_sizes (List[int] or Tuple[int]): Sample sizes for input. Defaults to None.\n        input_info (Dict, optional): Additional input information. Defaults to None.\n\n    Returns:\n        NNCFConfig: Configured NNCFConfig instance.\n    \"\"\"\n\n    # 1. Set default input_sample_sizes if None is provided\n    if input_sample_sizes is None:\n        input_sample_sizes = [1, 1, 4, 4]\n\n    # 2. Define a nested function to create input info based on sample sizes\n    def _create_input_info() -> List[Dict[str, Union[List[int], Tuple[int, ...]]]]:\n        return [{\"sample_size\": input_sample_sizes}]\n\n    # 3. Create an instance of NNCFConfig\n    config = NNCFConfig()\n\n    # 4. Update the config with model and input information\n    config.update({\n        \"model\": \"empty_config\",\n        \"model_size\": model_size,\n        \"input_info\": input_info if input_info is not None else _create_input_info()\n    })\n\n    # 5. Return the configured NNCFConfig instance\n    return config\n\n# Example usage\nconfig = get_empty_config()\nprint(config)\n```\n\n### Explanation:\n\n1. **Default Parameters**: The function `get_empty_config` takes three optional parameters: `model_size`, `input_sample_sizes`, and `input_info`. Default values are provided for each.\n\n2. **Default Input Sample Sizes**: If `input_sample_sizes` is `None`, it is set to `[1, 1, 4, 4]`.\n\n3. **Nested Function**: A nested function `_create_input_info` is defined to create a list of dictionaries with the key `\"sample_size\"` based on `input_sample_sizes`.\n\n4. **NNCFConfig Class**: A simple `NNCFConfig` class is defined to mimic the behavior of updating and storing configuration data.\n\n5. **Update Configuration**: The `NNCFConfig` instance is updated with the specified keys and values.\n\n6. **Return Config**: The configured `NNCFConfig` instance is returned.\n\nThis implementation follows the step-by-step approach to ensure clarity and maintainability.",
    "prompt": "Generate a Python function called get_empty_config that takes in three optional parameters: model_size (default value of 4), input_sample_sizes (a list or tuple of integers, default value of None), and input_info (a dictionary, default value of None). The function returns an instance of NNCFConfig.\n\nIf input_sample_sizes is None, it is set to [1, 1, 4, 4]. The function also contains a nested function _create_input_info that creates a list of dictionaries with the key \"sample_size\" based on the input_sample_sizes parameter.\n\nThe NNCFConfig instance is created and updated with the keys \"model\" set to \"empty_config\", \"model_size\" set to the model_size parameter, and \"input_info\" set to input_info if it is provided, otherwise it is set to the result of calling _create_input_info(). The final output is the configured NNCFConfig instance.",
    "function_name": "get_empty_config",
    "ground_truth": "tests/torch/helpers.py",
    "test": "tests/torch/quantization/test_algo_quantization.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}