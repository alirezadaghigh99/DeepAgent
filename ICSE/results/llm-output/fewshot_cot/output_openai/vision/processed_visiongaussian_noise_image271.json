{
    "result": "To create a function `gaussian_noise_image` that adds Gaussian noise to an input image tensor, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport torch\n\ndef gaussian_noise_image(image: torch.Tensor, mean: float = 0.0, sigma: float = 0.1, clip: bool = True) -> torch.Tensor:\n    \"\"\"\n    Adds Gaussian noise to an input image tensor.\n\n    Args:\n        image (torch.Tensor): Input image tensor with floating-point dtype.\n        mean (float): Mean of the Gaussian noise. Defaults to 0.0.\n        sigma (float): Standard deviation of the Gaussian noise. Defaults to 0.1.\n        clip (bool): Whether to clip the output values to the [0, 1] range. Defaults to True.\n\n    Returns:\n        torch.Tensor: Noisy image tensor.\n\n    Raises:\n        ValueError: If the input tensor is not of a floating-point dtype or if sigma is negative.\n    \"\"\"\n    # 1. Check if the input image tensor is of a floating-point dtype\n    if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n\n    # 2. Check if sigma is non-negative\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")\n\n    # 3. Generate Gaussian noise with the specified mean and sigma\n    noise = torch.randn_like(image) * sigma + mean\n\n    # 4. Add the generated noise to the input image\n    noisy_image = image + noise\n\n    # 5. Clip the noisy image to the [0, 1] range if clip is True\n    if clip:\n        noisy_image = torch.clamp(noisy_image, 0.0, 1.0)\n\n    # 6. Return the noisy image tensor\n    return noisy_image\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input image tensor is of a floating-point dtype and if `sigma` is non-negative. If not, it raises a `ValueError`.\n\n2. **Noise Generation**: Gaussian noise is generated using `torch.randn_like(image)`, which creates a tensor of the same shape as the input image with values drawn from a standard normal distribution. This noise is then scaled by `sigma` and shifted by `mean`.\n\n3. **Adding Noise**: The generated noise is added to the input image to create the noisy image.\n\n4. **Clipping**: If the `clip` parameter is `True`, the noisy image is clipped to ensure all values are within the [0, 1] range, which is typical for image data in floating-point format.\n\n5. **Return**: The function returns the noisy image tensor.",
    "prompt": "Write a Python function `gaussian_noise_image` that adds Gaussian noise to an input image tensor. The function should accept the following parameters: `image` (a float tensor), `mean` (mean of the Gaussian noise, defaulting to 0.0), `sigma` (standard deviation of the Gaussian noise, defaulting to 0.1), and `clip` (a boolean indicating whether to clip the output values to the [0, 1] range, defaulting to `True`). The function should return the noisy image tensor. Ensure that the input tensor is of a floating-point dtype and that `sigma` is non-negative, raising a `ValueError` if these conditions are not met.  if not image.is_floating_point():\n        raise ValueError(f\"Input tensor is expected to be in float dtype, got dtype={image.dtype}\")\n    if sigma < 0:\n        raise ValueError(f\"sigma shouldn't be negative. Got {sigma}\")",
    "function_name": "gaussian_noise_image",
    "ground_truth": "torchvision/transforms/v2/functional/_misc.py",
    "test": "test/test_transforms_v2.py::TestGaussianNoise",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}