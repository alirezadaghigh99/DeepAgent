{
    "result": "To create a Python function called `affine` that applies an affine transformation to an image while keeping the image center invariant, you can follow these steps. This function will handle both PIL Images and Tensors, and it will allow for various transformation parameters such as rotation, translation, scaling, and shearing. Here's how you can implement it:\n\n```python\nimport torch\nfrom PIL import Image\nimport torchvision.transforms.functional as F\nfrom typing import Optional, Tuple, Union\n\ndef affine(\n    img: Union[Image.Image, torch.Tensor],\n    angle: float,\n    translate: Tuple[int, int],\n    scale: float,\n    shear: Tuple[float, float],\n    interpolation: Optional[str] = 'bilinear',\n    fill: Optional[Union[int, Tuple[int, int, int]]] = 0,\n    center: Optional[Tuple[int, int]] = None\n) -> Union[Image.Image, torch.Tensor]:\n    \"\"\"\n    Apply an affine transformation to an image while keeping the image center invariant.\n\n    Args:\n        img (PIL Image or Tensor): Image to be transformed.\n        angle (float): Rotation angle in degrees.\n        translate (tuple of int): Horizontal and vertical translations.\n        scale (float): Overall scale factor.\n        shear (tuple of float): Shear angle values (shear_x, shear_y).\n        interpolation (str, optional): Interpolation mode. Defaults to 'bilinear'.\n        fill (int or tuple, optional): Pixel fill value for areas outside the transformed image.\n        center (tuple of int, optional): Center of rotation. Defaults to the center of the image.\n\n    Returns:\n        Transformed image as a PIL Image or Tensor.\n    \"\"\"\n    # Convert Tensor to PIL Image if necessary\n    if isinstance(img, torch.Tensor):\n        img = F.to_pil_image(img)\n\n    # Determine the center of the image if not provided\n    if center is None:\n        width, height = img.size\n        center = (width // 2, height // 2)\n\n    # Apply the affine transformation\n    transformed_img = F.affine(\n        img,\n        angle=angle,\n        translate=translate,\n        scale=scale,\n        shear=shear,\n        interpolation=interpolation,\n        fill=fill,\n        center=center\n    )\n\n    # Convert back to Tensor if the input was a Tensor\n    if isinstance(img, torch.Tensor):\n        transformed_img = F.to_tensor(transformed_img)\n\n    return transformed_img\n```\n\n### Explanation:\n\n1. **Input Handling**: The function accepts either a PIL Image or a PyTorch Tensor. If the input is a Tensor, it is converted to a PIL Image for processing.\n\n2. **Center Calculation**: If the center of rotation is not provided, it defaults to the center of the image.\n\n3. **Affine Transformation**: The `torchvision.transforms.functional.affine` function is used to apply the affine transformation. It takes into account the rotation, translation, scaling, and shearing parameters.\n\n4. **Output Handling**: If the input was a Tensor, the output is converted back to a Tensor. Otherwise, it remains a PIL Image.\n\n5. **Interpolation and Fill**: The function allows specifying the interpolation mode and fill value for areas outside the transformed image.\n\nThis function provides a flexible way to apply complex affine transformations to images while maintaining the option to specify a custom center of rotation.",
    "prompt": "Create a Python function called affine that applies an affine transformation on an image while keeping the image center invariant. The function takes in parameters such as img (PIL Image or Tensor), angle (rotation angle in degrees), translate (horizontal and vertical translations), scale (overall scale), shear (shear angle values), interpolation (desired interpolation mode), fill (pixel fill value for areas outside the transformed image), and center (optional center of rotation). The function returns the transformed image as a PIL Image or Tensor.",
    "function_name": "affine",
    "ground_truth": "torchvision/transforms/_functional_pil.py",
    "test": "test/test_transforms_tensor.py::test_random_affine_shear",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}