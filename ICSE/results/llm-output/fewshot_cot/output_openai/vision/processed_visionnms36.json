{
    "result": "To create a Python function that performs non-maximum suppression (NMS) on a set of bounding boxes using PyTorch, you can follow these steps. The function will take in bounding boxes, scores, and an IoU threshold, and it will return the indices of the boxes that are kept after applying NMS. Here's how you can implement it:\n\n```python\nimport torch\nfrom torchvision.ops import nms\n\ndef nms(boxes: torch.Tensor, scores: torch.Tensor, iou_threshold: float) -> torch.Tensor:\n    \"\"\"\n    Perform non-maximum suppression (NMS) on bounding boxes based on their IoU values.\n\n    Args:\n        boxes (Tensor[N, 4]): Bounding box coordinates in (x1, y1, x2, y2) format.\n        scores (Tensor[N]): Scores for each bounding box.\n        iou_threshold (float): IoU threshold for suppression.\n\n    Returns:\n        Tensor: Indices of the boxes that are kept after NMS, sorted in decreasing order of scores.\n    \"\"\"\n    # 1. Validate input dimensions\n    if boxes.ndimension() != 2 or boxes.size(1) != 4:\n        raise ValueError(\"boxes should have shape [N, 4]\")\n    if scores.ndimension() != 1 or scores.size(0) != boxes.size(0):\n        raise ValueError(\"scores should have shape [N] and match the number of boxes\")\n\n    # 2. Ensure the IoU threshold is a valid float\n    if not isinstance(iou_threshold, float) or not (0 <= iou_threshold <= 1):\n        raise ValueError(\"iou_threshold should be a float between 0 and 1\")\n\n    # 3. Perform NMS using torchvision's built-in function\n    keep_indices = nms(boxes, scores, iou_threshold)\n\n    # 4. Return the indices of the boxes that are kept\n    return keep_indices\n\n# Example usage:\n# boxes = torch.tensor([[10, 20, 30, 40], [15, 25, 35, 45], [50, 60, 70, 80]], dtype=torch.float32)\n# scores = torch.tensor([0.9, 0.85, 0.75], dtype=torch.float32)\n# iou_threshold = 0.5\n# kept_indices = nms(boxes, scores, iou_threshold)\n# print(kept_indices)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks that the input tensors have the correct dimensions. `boxes` should be a 2D tensor with shape `[N, 4]`, and `scores` should be a 1D tensor with length `N`.\n\n2. **IoU Threshold Validation**: The function ensures that the `iou_threshold` is a float between 0 and 1.\n\n3. **NMS Operation**: The function uses the `nms` function from `torchvision.ops` to perform non-maximum suppression. This function returns the indices of the boxes that are kept after suppression.\n\n4. **Return**: The function returns the indices of the boxes that are kept, sorted in decreasing order of their scores.\n\nThis implementation leverages PyTorch's efficient NMS operation, ensuring that the function is both concise and performant.",
    "prompt": "Generate a Python function called nms that performs non-maximum suppression (NMS) on a set of bounding boxes based on their intersection-over-union (IoU) values. The function takes three inputs: boxes (a Tensor of shape [N, 4] representing bounding box coordinates in (x1, y1, x2, y2) format), scores (a Tensor of shape [N] containing scores for each box), and iou_threshold (a float value specifying the IoU threshold for suppression).\n\nThe function iteratively removes lower scoring boxes that have an IoU greater than the specified threshold with another higher scoring box. The output is an int64 Tensor containing the indices of the boxes that have been kept after NMS, sorted in decreasing order of scores. Additionally, the function logs API usage and ensures that necessary operations are available before performing NMS using PyTorch's torchvision library.",
    "function_name": "nms",
    "ground_truth": "torchvision/ops/boxes.py",
    "test": "test/test_ops.py::TestNMS",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "Image"
}