{
    "result": "To create the `draw_keypoints` function, we will follow a structured approach similar to the examples provided. This function will overlay keypoints on a given RGB image tensor, with optional connectivity lines between keypoints. Here's how you can implement it step by step:\n\n```python\nimport torch\nfrom typing import Optional, List, Tuple, Union\nfrom PIL import Image, ImageDraw\nimport torchvision.transforms.functional as F\n\ndef draw_keypoints(\n    image: torch.Tensor,\n    keypoints: torch.Tensor,\n    connectivity: Optional[List[Tuple[int, int]]] = None,\n    colors: Optional[Union[str, Tuple[int, int, int]]] = \"red\",\n    radius: int = 3,\n    width: int = 2,\n    visibility: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n    \"\"\"\n    Draws keypoints and optional connectivity lines on an RGB image.\n\n    Args:\n        image (Tensor): Tensor of shape (3, H, W) and dtype uint8 or float.\n        keypoints (Tensor): Tensor of shape (num_instances, K, 2) with (x, y) coordinates.\n        connectivity (List[Tuple[int, int]], optional): Pairs of keypoints to connect.\n        colors (Union[str, Tuple[int, int, int]], optional): Color for keypoints and lines.\n        radius (int): Radius of each keypoint.\n        width (int): Width of the lines connecting keypoints.\n        visibility (Tensor, optional): Tensor of shape (num_instances, K) indicating visibility.\n\n    Returns:\n        Tensor: Image tensor with keypoints and connections drawn.\n    \"\"\"\n    # 1. Validate the input image\n    if not isinstance(image, torch.Tensor):\n        raise TypeError(\"Image must be a tensor.\")\n    if image.dtype not in [torch.uint8, torch.float32, torch.float64]:\n        raise ValueError(\"Image dtype must be uint8 or float.\")\n    if image.shape[0] != 3:\n        raise ValueError(\"Image must have 3 channels (C, H, W).\")\n\n    # 2. Validate the keypoints tensor\n    if keypoints.ndim != 3 or keypoints.shape[2] != 2:\n        raise ValueError(\"Keypoints must have shape (num_instances, K, 2).\")\n\n    # 3. Validate the visibility tensor\n    if visibility is not None and visibility.shape != keypoints.shape[:2]:\n        raise ValueError(\"Visibility tensor must match the shape of keypoints.\")\n\n    # 4. Convert image to uint8 if it\u2019s floating-point\n    original_dtype = image.dtype\n    if original_dtype.is_floating_point:\n        image = F.to_dtype(image, dtype=torch.uint8, scale=True)\n\n    # 5. Convert the PyTorch tensor to a PIL Image\n    img_to_draw = F.to_pil_image(image)\n\n    # 6. Create a draw object\n    draw = ImageDraw.Draw(img_to_draw)\n\n    # 7. Loop over each instance and draw keypoints and connections\n    num_instances, num_keypoints, _ = keypoints.shape\n    for i in range(num_instances):\n        for j in range(num_keypoints):\n            if visibility is None or visibility[i, j]:\n                x, y = keypoints[i, j].tolist()\n                # Draw keypoint\n                draw.ellipse(\n                    [(x - radius, y - radius), (x + radius, y + radius)],\n                    outline=colors,\n                    fill=colors\n                )\n\n        # Draw connectivity lines if provided\n        if connectivity:\n            for start, end in connectivity:\n                if (visibility is None or (visibility[i, start] and visibility[i, end])):\n                    x0, y0 = keypoints[i, start].tolist()\n                    x1, y1 = keypoints[i, end].tolist()\n                    draw.line([(x0, y0), (x1, y1)], fill=colors, width=width)\n\n    # 8. Convert the PIL image back to a tensor\n    out = F.pil_to_tensor(img_to_draw)\n    if original_dtype.is_floating_point:\n        out = F.to_dtype(out, dtype=original_dtype, scale=True)\n\n    # 9. Return the resulting tensor with keypoints and connections drawn\n    return out\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if the input image is a tensor and if it has the correct dtype and shape. It also validates the shape of the keypoints and visibility tensors.\n\n2. **Image Conversion**: If the image is in a floating-point format, it is converted to `uint8` for drawing operations. The image is then converted to a PIL image for drawing.\n\n3. **Drawing Keypoints and Connections**: The function iterates over each instance and keypoint, drawing them on the image. If connectivity is provided, it draws lines between specified keypoints, considering their visibility.\n\n4. **Output Conversion**: After drawing, the PIL image is converted back to a PyTorch tensor, restoring the original dtype if necessary.\n\nThis function provides a flexible way to overlay keypoints and connections on an image, with error handling for common input issues.",
    "prompt": "Create a Python function draw_keypoints that overlays keypoints on a given RGB image tensor. The function should accept the following parameters:\n\nimage: A tensor of shape (3, H, W) and dtype uint8 or float, representing the image.\nkeypoints: A tensor of shape (num_instances, K, 2), where K denotes the number of keypoints per instance, and each keypoint is represented by its (x, y) coordinates.\nconnectivity: An optional list of tuples, where each tuple contains two integers representing keypoints that should be connected with a line.\ncolors: An optional string or tuple specifying the color for the keypoints and lines. The color can be a string (e.g., \"red\") or an RGB tuple.\nradius: An integer specifying the radius of each keypoint.\nwidth: An integer specifying the width of the lines connecting the keypoints.\nvisibility: An optional tensor of shape (num_instances, K) that indicates whether each keypoint is visible (True) or not (False).\nThe function should validate the input tensors and ensure the image is in the correct format. It should draw each visible keypoint on the image, and if connectivity is provided, draw lines connecting the keypoints based on their visibility. The resulting image tensor should be returned with the keypoints and connections drawn.\n\nError Handling:\nRaise a TypeError if the input image is not a tensor.\nRaise a ValueError if the image dtype is not uint8 or float, if the image shape is incorrect, or if the keypoints tensor has an incorrect shape.\nRaise a ValueError if the visibility tensor does not match the shape of the keypoints tensor.",
    "function_name": "draw_keypoints",
    "ground_truth": "torchvision/utils.py",
    "test": "test/test_utils.py::test_draw_keypoints_visibility",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Segmentation",
    "data": "Image"
}