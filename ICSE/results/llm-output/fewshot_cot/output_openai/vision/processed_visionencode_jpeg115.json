{
    "result": "To create the `encode_jpeg` function, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport torch\nfrom torchvision.transforms.functional import to_pil_image\nfrom io import BytesIO\nfrom typing import Union, List\n\ndef encode_jpeg(\n    images: Union[torch.Tensor, List[torch.Tensor]],\n    quality: int\n) -> Union[torch.Tensor, List[torch.Tensor]]:\n    \"\"\"\n    Encodes an input tensor or list of tensors representing images into JPEG format.\n\n    Args:\n        images (Union[torch.Tensor, List[torch.Tensor]]): Image(s) in CHW layout.\n        quality (int): JPEG quality parameter between 1 and 100.\n\n    Returns:\n        Union[torch.Tensor, List[torch.Tensor]]: Tensor or list of tensors containing the raw bytes of the JPEG file(s).\n\n    Raises:\n        ValueError: If quality is not between 1 and 100 or if an empty list is passed as input.\n    \"\"\"\n    # 1. Validate the quality parameter\n    if not (1 <= quality <= 100):\n        raise ValueError(\"Quality must be between 1 and 100.\")\n\n    # 2. Ensure images is a list for consistent processing\n    if isinstance(images, torch.Tensor):\n        images = [images]\n    elif not images:\n        raise ValueError(\"Input list of images is empty.\")\n\n    # 3. Initialize a list to store the encoded JPEG bytes\n    encoded_images = []\n\n    # 4. Iterate over each image tensor\n    for image in images:\n        # 5. Convert the image tensor to a PIL Image\n        pil_image = to_pil_image(image)\n\n        # 6. Encode the PIL Image to JPEG format using a BytesIO buffer\n        buffer = BytesIO()\n        pil_image.save(buffer, format='JPEG', quality=quality)\n\n        # 7. Convert the buffer contents to a tensor of bytes\n        jpeg_bytes = torch.tensor(list(buffer.getvalue()), dtype=torch.uint8)\n\n        # 8. Append the encoded bytes tensor to the list\n        encoded_images.append(jpeg_bytes)\n\n    # 9. Return a single tensor if the input was a single tensor, otherwise return the list\n    return encoded_images[0] if len(encoded_images) == 1 else encoded_images\n```\n\n### Explanation:\n\n1. **Quality Validation**: The function first checks if the `quality` parameter is within the valid range (1 to 100). If not, it raises a `ValueError`.\n\n2. **Input Handling**: The function ensures that the input is treated as a list, even if a single tensor is provided. It also checks for an empty list and raises a `ValueError` if found.\n\n3. **Image Conversion**: Each image tensor is converted to a PIL Image using `to_pil_image`.\n\n4. **JPEG Encoding**: The PIL Image is saved to a `BytesIO` buffer in JPEG format with the specified quality. The buffer's contents are then converted to a tensor of bytes.\n\n5. **Output**: The function returns a single tensor if the input was a single tensor, or a list of tensors if the input was a list.",
    "prompt": "Create a Python function `encode_jpeg` that encodes an input tensor or list of tensors representing images into JPEG format. The function accepts images in CHW layout and a quality parameter between 1 and 100 to control the output JPEG quality. The output is a tensor or list of tensors containing the raw bytes of the JPEG file(s). The function raises a `ValueError` if the quality is not between 1 and 100 or if an empty list is passed as input.",
    "function_name": "encode_jpeg",
    "ground_truth": "torchvision/io/image.py",
    "test": "test/test_image.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": "Image"
}