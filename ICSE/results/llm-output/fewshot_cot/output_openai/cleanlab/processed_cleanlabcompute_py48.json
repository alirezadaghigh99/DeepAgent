{
    "result": "To create the `compute_py` function as described, we need to handle various input parameters and implement different methods for computing the prior probabilities. Here's a step-by-step implementation:\n\n```python\nimport numpy as np\n\ndef compute_py(ps, noise_matrix, inverse_noise_matrix, py_method, true_labels_class_counts=None):\n    \"\"\"\n    Compute the prior probability of true class labels based on observed noisy labels,\n    noise matrices, and inverse noise matrices.\n\n    Parameters:\n        ps (np.ndarray): Array of shape (K,) representing the observed class probabilities.\n        noise_matrix (np.ndarray): Noise matrix of shape (K, K).\n        inverse_noise_matrix (np.ndarray): Inverse noise matrix of shape (K, K).\n        py_method (str): Method to compute prior probabilities ('cnt', 'eqn', 'marginal', 'marginal_ps').\n        true_labels_class_counts (np.ndarray, optional): Array of shape (K,) with counts of true class labels.\n\n    Returns:\n        np.ndarray: Array of shape (K,) containing the prior probability of each true class label.\n    \"\"\"\n    # 1. Validate input shapes and parameters\n    K = ps.shape[0]\n    if noise_matrix.shape != (K, K) or inverse_noise_matrix.shape != (K, K):\n        raise ValueError(\"Noise matrices must be of shape (K, K).\")\n    if py_method not in ['cnt', 'eqn', 'marginal', 'marginal_ps']:\n        raise ValueError(\"Invalid py_method. Choose from 'cnt', 'eqn', 'marginal', 'marginal_ps'.\")\n    if py_method == 'cnt' and true_labels_class_counts is None:\n        raise ValueError(\"true_labels_class_counts must be provided for 'cnt' method.\")\n\n    # 2. Initialize py array\n    py = np.zeros(K)\n\n    # 3. Compute prior probabilities based on the specified method\n    if py_method == 'cnt':\n        # Use true class counts to compute prior probabilities\n        py = true_labels_class_counts / np.sum(true_labels_class_counts)\n    elif py_method == 'eqn':\n        # Use the inverse noise matrix to compute prior probabilities\n        py = np.dot(inverse_noise_matrix, ps)\n    elif py_method == 'marginal':\n        # Use the noise matrix to compute prior probabilities\n        py = np.dot(noise_matrix.T, ps)\n    elif py_method == 'marginal_ps':\n        # Use the observed probabilities directly\n        py = ps\n\n    # 4. Clip py to ensure values are between 0 and 1\n    py = np.clip(py, 0, 1)\n\n    # 5. Return the resulting py array\n    return py\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks that the input matrices have the correct shape and that the `py_method` is valid. It also ensures that `true_labels_class_counts` is provided when using the 'cnt' method.\n\n2. **Initialization**: An array `py` is initialized to store the prior probabilities.\n\n3. **Computation Methods**:\n   - **'cnt'**: Uses the true class counts to compute the prior probabilities.\n   - **'eqn'**: Uses the inverse noise matrix to compute the prior probabilities.\n   - **'marginal'**: Uses the noise matrix to compute the prior probabilities.\n   - **'marginal_ps'**: Directly uses the observed probabilities.\n\n4. **Clipping**: The resulting `py` array is clipped to ensure all values are between 0 and 1.\n\n5. **Return**: The function returns the computed `py` array.",
    "prompt": "Generate a Python function called compute_py that computes the prior probability of true class labels based on observed noisy labels, noise matrices, and inverse noise matrices. The function takes in parameters ps, noise_matrix, inverse_noise_matrix, py_method, and true_labels_class_counts. The function returns an array py of shape (K,) or (1, K) containing the prior probability of each true class label. The function includes error handling for invalid input shapes and missing parameters, and uses different methods (cnt, eqn, marginal, marginal_ps) to compute the prior probabilities based on the specified py_method. The output array py is clipped to ensure values are between 0 and 1.",
    "function_name": "compute_py",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}