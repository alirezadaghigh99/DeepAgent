{
    "result": "To create the `find_overlapping_classes` function, we need to follow a structured approach similar to the examples provided. This function will identify pairs of classes that are often mislabeled as one another and return a Pandas DataFrame with relevant statistics. Here's a step-by-step implementation:\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom typing import Optional, Iterable, Union\n\ndef find_overlapping_classes(\n    labels: Optional[Union[np.ndarray, list]] = None,\n    pred_probs: Optional[np.ndarray] = None,\n    asymmetric: bool = False,\n    class_names: Optional[Iterable[str]] = None,\n    num_examples: Optional[int] = None,\n    joint: Optional[np.ndarray] = None,\n    confident_joint: Optional[np.ndarray] = None\n) -> pd.DataFrame:\n    \"\"\"\n    Returns pairs of classes that are often mislabeled as one another.\n\n    Parameters\n    ----------\n    labels : np.ndarray or list, optional\n        An array_like of noisy labels for the classification dataset.\n    pred_probs : np.ndarray, optional\n        An array of shape (N, K) of model-predicted probabilities.\n    asymmetric : bool, optional\n        If True, returns separate estimates for both pairs (class1, class2) and (class2, class1).\n    class_names : Iterable[str], optional\n        A list or other iterable of the string class names.\n    num_examples : int or None, optional\n        The number of examples in the dataset.\n    joint : np.ndarray, optional\n        An array of shape (K, K) representing the estimated joint distribution.\n    confident_joint : np.ndarray, optional\n        An array of shape (K, K) representing the confident joint.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\".\n    \"\"\"\n    # 1. Validate input and determine the number of classes (K)\n    if joint is not None:\n        K = joint.shape[0]\n        if num_examples is None:\n            raise ValueError(\"num_examples must be provided if joint is used.\")\n    elif confident_joint is not None:\n        K = confident_joint.shape[0]\n        num_examples = num_examples or int(np.sum(confident_joint))\n    elif labels is not None and pred_probs is not None:\n        K = pred_probs.shape[1]\n        num_examples = num_examples or len(labels)\n    else:\n        raise ValueError(\"Provide either (labels and pred_probs), (joint and num_examples), or (confident_joint).\")\n\n    # 2. Compute the confident joint if not provided\n    if confident_joint is None:\n        confident_joint = compute_confident_joint(labels, pred_probs, K)\n\n    # 3. Calculate the number of overlapping examples and joint probabilities\n    overlapping_examples = confident_joint if asymmetric else confident_joint + confident_joint.T\n    joint_probabilities = overlapping_examples / num_examples\n\n    # 4. Prepare the DataFrame to store results\n    data = []\n    for i in range(K):\n        for j in range(i + 1, K):\n            if asymmetric:\n                data.append((i, j, overlapping_examples[i, j], joint_probabilities[i, j]))\n                data.append((j, i, overlapping_examples[j, i], joint_probabilities[j, i]))\n            else:\n                data.append((i, j, overlapping_examples[i, j], joint_probabilities[i, j]))\n\n    # 5. Create a DataFrame and sort by joint probability\n    df = pd.DataFrame(data, columns=[\"Class Index A\", \"Class Index B\", \"Num Overlapping Examples\", \"Joint Probability\"])\n    df.sort_values(by=\"Joint Probability\", ascending=False, inplace=True)\n\n    # 6. Optionally add class names to the DataFrame\n    if class_names:\n        df[\"Class Name A\"] = df[\"Class Index A\"].apply(lambda x: class_names[x])\n        df[\"Class Name B\"] = df[\"Class Index B\"].apply(lambda x: class_names[x])\n\n    return df\n\ndef compute_confident_joint(labels, pred_probs, K):\n    # Placeholder function to compute the confident joint\n    # This should be replaced with the actual implementation\n    # For now, it returns a dummy matrix\n    return np.zeros((K, K))\n```\n\n### Explanation:\n1. **Input Validation**: The function checks which inputs are provided and determines the number of classes \\( K \\). It ensures that necessary parameters are available for computation.\n2. **Confident Joint Calculation**: If the `confident_joint` is not provided, it is computed using a placeholder function `compute_confident_joint`. This function should be replaced with the actual implementation.\n3. **Overlapping Examples and Joint Probabilities**: The function calculates the number of overlapping examples and their joint probabilities. If `asymmetric` is `True`, it considers both directions of class pairs.\n4. **DataFrame Construction**: The results are stored in a Pandas DataFrame, which is sorted by joint probability in descending order. Optionally, class names are added to the DataFrame for better readability.\n\nThis implementation provides a structured approach to identifying and analyzing overlapping classes in a dataset.",
    "prompt": "Generate a Python function called find_overlapping_classes that rReturns the pairs of classes that are often mislabeled as one another.\n    Consider merging the top pairs of classes returned by this method each into a single class.\n    If the dataset is labeled by human annotators, consider clearly defining the\n    difference between the classes prior to having annotators label the data.\n    This method provides two scores in the Pandas DataFrame that is returned:\n    * **Num Overlapping Examples**: The number of examples where the two classes overlap\n    * **Joint Probability**: `(num overlapping examples / total number of examples in the dataset`).\n    This method works by providing any one (and only one) of the following inputs:\n    1. ``labels`` and ``pred_probs``, or\n    2. ``joint`` and ``num_examples``, or\n    3. ``confident_joint``\n      Parameters\n    ----------\n    labels : np.ndarray or list, optional\n      An array_like (of length N) of noisy labels for the classification dataset, i.e. some labels may be erroneous.\n      Elements must be integers in the set 0, 1, ..., K-1, where K is the number of classes.\n      All the classes (0, 1, ..., and K-1) should be present in ``labels``, such that\n      ``len(set(labels)) == pred_probs.shape[1]`` for standard multi-class classification with single-labeled data (e.g. ``labels =  [1,0,2,1,1,0...]``).\n      For multi-label classification where each example can belong to multiple classes (e.g. ``labels = [[1,2],[1],[0],[],...]``),\n      your labels should instead satisfy: ``len(set(k for l in labels for k in l)) == pred_probs.shape[1])``.\n\n    pred_probs : np.ndarray, optional\n      An array of shape ``(N, K)`` of model-predicted probabilities,\n      ``P(label=k|x)``. Each row of this matrix corresponds\n      to an example `x` and contains the model-predicted probabilities that\n      `x` belongs to each possible class, for each of the K classes. The\n      columns must be ordered such that these probabilities correspond to\n      class 0, 1, ..., K-1. `pred_probs` should have been computed using 3 (or\n      higher) fold cross-validation.\n\n    asymmetric : bool, optional\n      If ``asymmetric=True``, returns separate estimates for both pairs (class1, class2) and (class2, class1). Use this\n      for finding \"is a\" relationships where for example \"class1 is a class2\".\n      In this case, num overlapping examples counts the number of examples that have been labeled as class1 which should actually have been labeled as class2.\n      If ``asymmetric=False``, the pair (class1, class2) will only be returned once with an arbitrary order.\n      In this case, their estimated score is the sum: ``score(class1, class2) + score(class2, class1))``.\n\n    class_names : Iterable[str]\n        A list or other iterable of the string class names. The list should be in the order that\n        matches the class indices. So if class 0 is 'dog' and class 1 is 'cat', then\n        ``class_names = ['dog', 'cat']``.\n\n    num_examples : int or None, optional\n        The number of examples in the dataset, i.e. ``len(labels)``. You only need to provide this if\n        you use this function with the joint, e.g. ``find_overlapping_classes(joint=joint)``, otherwise\n        this is automatically computed via ``sum(confident_joint)`` or ``len(labels)``.\n\n    joint : np.ndarray, optional\n        An array of shape ``(K, K)``, where K is the number of classes,\n        representing the estimated joint distribution of the noisy labels and\n        true labels. The sum of all entries in this matrix must be 1 (valid\n        probability distribution). Each entry in the matrix captures the co-occurence joint\n        probability of a true label and a noisy label, i.e. ``p(noisy_label=i, true_label=j)``.\n        **Important**. If you input the joint, you must also input `num_examples`.\n\n    confident_joint : np.ndarray, optional\n      An array of shape ``(K, K)`` representing the confident joint, the matrix used for identifying label issues, which\n      estimates a confident subset of the joint distribution of the noisy and true labels, ``P_{noisy label, true label}``.\n      Entry ``(j, k)`` in the matrix is the number of examples confidently counted into the pair of ``(noisy label=j, true label=k)`` classes.\n      The `confident_joint` can be computed using :py:func:`count.compute_confident_joint <cleanlab.count.compute_confident_joint>`.\n      If not provided, it is computed from the given (noisy) `labels` and `pred_probs`.\n\n    Returns\n    -------\n    overlapping_classes : pd.DataFrame\n        Pandas DataFrame with columns \"Class Index A\", \"Class Index B\",\n        \"Num Overlapping Examples\", \"Joint Probability\" and a description of each below.\n        Each row corresponds to a pair of classes.\n\n        * *Class Index A*: the index of a class in 0, 1, ..., K-1.\n        * *Class Index B*: the index of a different class (from Class A) in 0, 1, ..., K-1.\n        * *Num Overlapping Examples*: estimated number of labels overlapping between the two classes.\n        * *Joint Probability*: the *Num Overlapping Examples* divided by the number of examples in the dataset.\n\n        By default, the DataFrame is ordered by \"Joint Probability\" descending.",
    "function_name": "find_overlapping_classes",
    "ground_truth": "cleanlab/dataset.py",
    "test": "tests/test_dataset.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}