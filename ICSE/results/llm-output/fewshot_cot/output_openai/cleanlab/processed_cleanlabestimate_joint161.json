{
    "result": "To create the `estimate_joint` function, we need to follow a structured approach similar to the examples provided. This function will estimate the joint distribution of label noise based on the given inputs. Here's a step-by-step breakdown of how you might implement this function:\n\n```python\nimport numpy as np\n\ndef estimate_joint(labels, pred_probs, confident_joint=None, multi_label=False):\n    \"\"\"\n    Estimate the joint distribution of label noise P(label=i, true_label=j).\n\n    Args:\n        labels (array-like): Class labels for each example in the dataset.\n        pred_probs (array-like): Model-predicted class probabilities for each example.\n        confident_joint (array-like, optional): Estimated class label error statistics.\n        multi_label (bool): Indicates if the dataset is multi-label classification.\n\n    Returns:\n        confident_joint_distribution (np.ndarray): Estimated joint distribution of noisy and true labels.\n    \"\"\"\n    # 1. Determine the number of classes (K) from the predicted probabilities\n    K = pred_probs.shape[1]\n\n    # 2. If confident_joint is not provided, compute it\n    if confident_joint is None:\n        confident_joint = _compute_confident_joint(labels, pred_probs, K, multi_label)\n\n    # 3. Normalize the confident_joint to ensure it sums to 1\n    confident_joint_distribution = confident_joint / np.sum(confident_joint)\n\n    # 4. If multi_label is True, handle multi-label classification\n    if multi_label:\n        confident_joint_distribution = _estimate_joint_multilabel(confident_joint_distribution, K)\n\n    # 5. Return the estimated joint distribution\n    return confident_joint_distribution\n\ndef _compute_confident_joint(labels, pred_probs, K, multi_label):\n    \"\"\"\n    Compute the confident joint if not provided.\n    \"\"\"\n    # Initialize the confident joint matrix\n    if multi_label:\n        confident_joint = np.zeros((K, 2, 2))\n    else:\n        confident_joint = np.zeros((K, K))\n\n    # Populate the confident joint matrix based on labels and predicted probabilities\n    for i, label in enumerate(labels):\n        predicted_label = np.argmax(pred_probs[i])\n        if multi_label:\n            # Update the multi-label confident joint\n            confident_joint[label, predicted_label, 1] += 1\n            confident_joint[label, 1 - predicted_label, 0] += 1\n        else:\n            # Update the regular confident joint\n            confident_joint[label, predicted_label] += 1\n\n    return confident_joint\n\ndef _estimate_joint_multilabel(confident_joint_distribution, K):\n    \"\"\"\n    Handle multi-label classification to estimate the joint distribution.\n    \"\"\"\n    # Normalize each (2, 2) matrix in the multi-label joint distribution\n    for i in range(K):\n        confident_joint_distribution[i] /= np.sum(confident_joint_distribution[i])\n\n    return confident_joint_distribution\n```\n\n### Explanation:\n\n1. **Determine the Number of Classes (K):** We extract the number of classes from the shape of `pred_probs`.\n\n2. **Compute Confident Joint:** If `confident_joint` is not provided, we compute it using a helper function `_compute_confident_joint`. This function initializes a matrix and populates it based on the labels and predicted probabilities.\n\n3. **Normalize the Joint Distribution:** We ensure that the sum of the joint distribution is 1 by normalizing `confident_joint`.\n\n4. **Handle Multi-Label Classification:** If `multi_label` is `True`, we call `_estimate_joint_multilabel` to handle the multi-label case, normalizing each (2, 2) matrix within the joint distribution.\n\n5. **Return the Joint Distribution:** Finally, we return the estimated joint distribution.\n\nThis implementation provides a basic structure and can be further refined based on specific requirements or additional constraints.",
    "prompt": "Generate a Python function called estimate_joint that estimates the joint distribution of label noise P(label=i, true_label=j) based on the given inputs. The function takes in the following parameters:\n\n- labels: an array or list of class labels for each example in the dataset\n- pred_probs: an array of model-predicted class probabilities for each example in the dataset\n- confident_joint: an optional array of estimated class label error statistics\n- multi_label: a boolean indicating whether the dataset is for regular (multi-class) classification or multi-label classification\n\nThe function returns confident_joint_distribution, an array representing an estimate of the true joint distribution of noisy and true labels. The shape of the array depends on the value of multi_label - it will be (K, K) if multi_label is False, and (K, 2, 2) if multi_label is True. The function ensures that the sum of the joint distribution is 1 and satisfies certain conditions.\n\nThe function internally computes the confident_joint if it is not provided, and calibrates it based on the input labels and pred_probs. If multi_label is True, the function calls _estimate_joint_multilabel to handle multi-label classification.",
    "function_name": "estimate_joint",
    "ground_truth": "cleanlab/count.py",
    "test": "tests/test_filter_count.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "",
    "data": "Table"
}