{
    "result": "To implement a confusion matrix function without relying on `sklearn`, you can follow these steps. The function will take two 1D numpy arrays, `true` and `pred`, which represent the true labels and predicted labels, respectively. Both arrays must have the same length and contain the same set of distinct class labels. Here's how you can implement it:\n\n```python\nimport numpy as np\n\ndef confusion_matrix(true, pred):\n    \"\"\"\n    Compute the confusion matrix to evaluate the accuracy of a classification.\n\n    Parameters\n    ----------\n    true : np.ndarray 1d\n        Contains true labels.\n        Assumes true and pred contain the same set of distinct labels.\n\n    pred : np.ndarray 1d\n        A discrete vector of predicted labels, i.e., some labels may be erroneous.\n        *Format requirements*: for dataset with K classes, labels must be in {0,1,...,K-1}.\n\n    Returns\n    -------\n    confusion_matrix : np.ndarray (2D)\n        Matrix of confusion counts with true labels on rows and predicted labels on columns.\n    \"\"\"\n    # 1. Ensure true and pred are numpy arrays\n    true = np.asarray(true)\n    pred = np.asarray(pred)\n\n    # 2. Check that true and pred have the same length\n    if true.shape[0] != pred.shape[0]:\n        raise ValueError(\"The length of true and pred must be the same.\")\n\n    # 3. Determine the number of classes (K) from the unique labels\n    unique_labels = np.unique(np.concatenate((true, pred)))\n    K = unique_labels.size\n\n    # 4. Initialize the confusion matrix with zeros\n    conf_matrix = np.zeros((K, K), dtype=int)\n\n    # 5. Populate the confusion matrix\n    for t, p in zip(true, pred):\n        conf_matrix[t, p] += 1\n\n    # 6. Return the confusion matrix\n    return conf_matrix\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first ensures that `true` and `pred` are numpy arrays and checks that they have the same length.\n\n2. **Determine Unique Labels**: It finds the unique labels present in both `true` and `pred` to determine the number of classes, `K`.\n\n3. **Initialize Confusion Matrix**: A `K x K` matrix is initialized with zeros. This matrix will store the counts of true vs. predicted labels.\n\n4. **Populate Confusion Matrix**: The function iterates over pairs of true and predicted labels, incrementing the appropriate cell in the confusion matrix for each pair.\n\n5. **Return the Matrix**: Finally, the populated confusion matrix is returned.\n\nThis implementation assumes that the labels are integers starting from 0 up to `K-1`, which is a common format for classification tasks.",
    "prompt": "Generate a Python function called confusion_matrix that iImplements a confusion matrix for true labels\n    and predicted labels. true and pred MUST BE the same length\n    and have the same distinct set of class labels represented.\n\n    Results are identical (and similar computation time) to:\n        \"sklearn.metrics.confusion_matrix\"\n\n    However, this function avoids the dependency on sklearn.\n\n    Parameters\n    ----------\n    true : np.ndarray 1d\n      Contains labels.\n      Assumes true and pred contains the same set of distinct labels.\n\n    pred : np.ndarray 1d\n      A discrete vector of noisy labels, i.e. some labels may be erroneous.\n      *Format requirements*: for dataset with K classes, labels must be in {0,1,...,K-1}.\n\n    Returns\n    -------\n    confusion_matrix : np.ndarray (2D)\n      matrix of confusion counts with true on rows and pred on columns",
    "function_name": "confusion_matrix",
    "ground_truth": "cleanlab/internal/util.py",
    "test": "tests/test_util.py",
    "class": "",
    "stage": "Evaluating&Metrics",
    "task": "Classification",
    "data": "Table"
}