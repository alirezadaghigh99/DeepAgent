{
    "result": "To create a function called `create_knn_graph_and_index` that calculates the K-Nearest Neighbors (KNN) graph from input features, we can use libraries like `scikit-learn` for the KNN search and `scipy` for creating a sparse adjacency matrix. Below is a step-by-step implementation of the function, along with examples demonstrating its usage with numpy arrays.\n\n```python\nimport numpy as np\nfrom sklearn.neighbors import NearestNeighbors\nfrom scipy.sparse import csr_matrix\n\ndef create_knn_graph_and_index(features, n_neighbors=5, metric='euclidean', correct_duplicates=False, **kwargs):\n    \"\"\"\n    Create a KNN graph and search index from input features.\n\n    Args:\n        features (np.ndarray): Feature array of shape (n_samples, n_features).\n        n_neighbors (int): Number of nearest neighbors to consider. Defaults to 5.\n        metric (str): Distance metric to use. Defaults to 'euclidean'.\n        correct_duplicates (bool): Whether to correct for exact duplicates. Defaults to False.\n        **kwargs: Additional keyword arguments for the NearestNeighbors constructor.\n\n    Returns:\n        Tuple[csr_matrix, NearestNeighbors]: A tuple containing:\n            - A sparse, weighted adjacency matrix representing the KNN graph.\n            - A k-nearest neighbors search object fitted to the input feature array.\n    \"\"\"\n    # 1. Initialize the NearestNeighbors object with the given parameters\n    knn = NearestNeighbors(n_neighbors=n_neighbors, metric=metric, **kwargs)\n    \n    # 2. Fit the NearestNeighbors object to the feature array\n    knn.fit(features)\n    \n    # 3. Find the k-nearest neighbors for each sample in the feature array\n    distances, indices = knn.kneighbors(features)\n    \n    # 4. If correct_duplicates is True, handle exact duplicates\n    if correct_duplicates:\n        # Ensure that each point is its own neighbor\n        for i in range(features.shape[0]):\n            if i not in indices[i]:\n                indices[i][-1] = i\n                distances[i][-1] = 0.0\n    \n    # 5. Create a sparse adjacency matrix from the distances and indices\n    n_samples = features.shape[0]\n    row_indices = np.repeat(np.arange(n_samples), n_neighbors)\n    col_indices = indices.flatten()\n    data = distances.flatten()\n    \n    adjacency_matrix = csr_matrix((data, (row_indices, col_indices)), shape=(n_samples, n_samples))\n    \n    # 6. Return the adjacency matrix and the fitted NearestNeighbors object\n    return adjacency_matrix, knn\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Generate random feature data\n    np.random.seed(0)\n    features = np.random.rand(10, 3)  # 10 samples, 3 features each\n\n    # Create KNN graph and index\n    adjacency_matrix, knn_index = create_knn_graph_and_index(features, n_neighbors=3)\n\n    # Print the adjacency matrix\n    print(\"Adjacency Matrix (dense format):\")\n    print(adjacency_matrix.toarray())\n\n    # Print the indices of the nearest neighbors for the first sample\n    print(\"\\nIndices of nearest neighbors for the first sample:\")\n    print(knn_index.kneighbors(features[:1], return_distance=False))\n```\n\n### Explanation:\n\n1. **Initialization**: We initialize a `NearestNeighbors` object with the specified number of neighbors, distance metric, and any additional keyword arguments.\n\n2. **Fitting**: The `fit` method is used to fit the KNN model to the input feature array.\n\n3. **Finding Neighbors**: The `kneighbors` method is used to find the nearest neighbors for each sample, returning both distances and indices.\n\n4. **Handling Duplicates**: If `correct_duplicates` is set to `True`, we ensure that each point is its own neighbor by checking and correcting the indices.\n\n5. **Creating Adjacency Matrix**: We construct a sparse adjacency matrix using the distances and indices obtained from the KNN search.\n\n6. **Return**: The function returns the adjacency matrix and the fitted KNN object.\n\nThis function provides a flexible way to compute a KNN graph and can be easily adapted for different datasets and requirements.",
    "prompt": "Generate a Python function called create_knn_graph_and_index that calculates the KNN graph from input features. The function takes in a feature array, optional parameters for the number of nearest neighbors and distance metric, a boolean flag for correcting exact duplicates, and additional keyword arguments for the search index constructor. \n\nThe function returns a tuple containing a sparse, weighted adjacency matrix representing the KNN graph of the feature array and a k-nearest neighbors search object fitted to the input feature array. The function also includes examples demonstrating its usage with numpy arrays.",
    "function_name": "create_knn_graph_and_index",
    "ground_truth": "cleanlab/internal/neighbor/knn_graph.py",
    "test": "tests/internal/neighbor/test_neighbor.py",
    "class": "",
    "stage": "Model Construction",
    "task": "",
    "data": ""
}