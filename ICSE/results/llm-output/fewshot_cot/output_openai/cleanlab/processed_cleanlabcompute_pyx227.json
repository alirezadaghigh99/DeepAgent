{
    "result": "To implement the `compute_pyx` function, we need to calculate the posterior probabilities \\( P(\\text{true\\_label}=k|x) \\) using the given predicted probabilities \\( P(\\text{label}=k|x) \\), the noise matrix, and the inverse noise matrix. The function will follow these steps:\n\n1. **Validate Input Shapes**: Ensure that `pred_probs` is a 2D array and both `noise_matrix` and `inverse_noise_matrix` are square matrices with the same number of classes.\n\n2. **Compute Posterior Probabilities**: Use the inverse noise matrix to adjust the predicted probabilities, effectively correcting for the noise in the labels.\n\n3. **Normalize the Probabilities**: Ensure that the resulting probabilities for each example sum to 1.\n\nHere's a step-by-step implementation of the function:\n\n```python\nimport numpy as np\n\ndef compute_pyx(pred_probs, noise_matrix, inverse_noise_matrix):\n    \"\"\"\n    Compute pyx := P(true_label=k|x) from pred_probs := P(label=k|x), noise_matrix, and inverse_noise_matrix.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        (N x K) matrix with model-predicted probabilities P(label=k|x).\n    noise_matrix : np.ndarray\n        (K x K) matrix P(label=k_s|true_label=k_y).\n    inverse_noise_matrix : np.ndarray\n        (K x K) matrix P(true_label=k_y|label=k_s).\n\n    Returns\n    -------\n    pyx : np.ndarray\n        (N x K) matrix of model-predicted probabilities P(true_label=k|x).\n    \"\"\"\n    # Validate input shapes\n    if len(pred_probs.shape) != 2:\n        raise ValueError(f\"pred_probs should be a 2D array, but got shape {pred_probs.shape}\")\n    \n    N, K = pred_probs.shape\n    if noise_matrix.shape != (K, K):\n        raise ValueError(f\"noise_matrix should be of shape ({K}, {K}), but got shape {noise_matrix.shape}\")\n    \n    if inverse_noise_matrix.shape != (K, K):\n        raise ValueError(f\"inverse_noise_matrix should be of shape ({K}, {K}), but got shape {inverse_noise_matrix.shape}\")\n\n    # Compute pyx using the inverse noise matrix\n    pyx = np.dot(pred_probs, inverse_noise_matrix)\n\n    # Normalize the probabilities to ensure they sum to 1 for each example\n    pyx /= pyx.sum(axis=1, keepdims=True)\n\n    return pyx\n```\n\n### Explanation:\n\n- **Input Validation**: The function first checks that `pred_probs` is a 2D array and that both `noise_matrix` and `inverse_noise_matrix` are square matrices with dimensions matching the number of classes \\( K \\).\n\n- **Matrix Multiplication**: The core computation involves multiplying the predicted probabilities by the inverse noise matrix. This operation adjusts the predicted probabilities to account for label noise.\n\n- **Normalization**: After computing the adjusted probabilities, the function normalizes them so that each row sums to 1, ensuring they represent valid probability distributions.\n\nThis function assumes that the inverse noise matrix is correctly estimated and that the input matrices are well-formed. If the inverse noise matrix is not provided, additional logic would be needed to compute it from the data.",
    "prompt": "\"Write a python function compute_pyx Compute ``pyx := P(true_label=k|x)`` from ``pred_probs := P(label=k|x)``, `noise_matrix` and\n    `inverse_noise_matrix`.\n\n    This method is ROBUST - meaning it works well even when the\n    noise matrices are estimated poorly by only using the diagonals of the\n    matrices which tend to be easy to estimate correctly.\n\n    Parameters\n    ----------\n    pred_probs : np.ndarray\n        ``P(label=k|x)`` is a ``(N x K)`` matrix with K model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of `noise_matrix` sum to 1.\n\n    inverse_noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``)  of the form ``P(true_label=k_y|label=k_s)`` representing\n        the estimated fraction observed examples in each class `k_s`, that are\n        mislabeled examples from every other class `k_y`. If None, the\n        inverse_noise_matrix will be computed from `pred_probs` and `labels`.\n        Assumes columns of `inverse_noise_matrix` sum to 1.\n\n    Returns\n    -------\n    pyx : np.ndarray\n        ``P(true_label=k|x)`` is a  ``(N, K)`` matrix of model-predicted probabilities.\n        Each row of this matrix corresponds to an example `x` and contains the model-predicted\n        probabilities that `x` belongs to each possible class.\n        The columns must be ordered such that these probabilities correspond to class 0,1,2,...\n        `pred_probs` should have been computed using 3 (or higher) fold cross-validation.\n\n    if len(np.shape(pred_probs)) != 2:\n        raise ValueError(\n            \"Input parameter np.ndarray 'pred_probs' has shape \"\n            + str(np.shape(pred_probs))\n            + \", but shape should be (N, K)\"\n        )",
    "function_name": "compute_pyx",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}