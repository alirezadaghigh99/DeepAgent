{
    "result": "To create the `generate_noise_matrix_from_trace` function, we need to follow a structured approach similar to the examples provided. Here's a step-by-step breakdown of how you might implement this function:\n\n```python\nimport numpy as np\n\ndef generate_noise_matrix_from_trace(K, trace, max_trace_prob, min_trace_prob, max_noise_rate, min_noise_rate, \n                                     valid_noise_matrix=True, py=None, frac_zero_noise_rates=0.0, seed=None, max_iter=10000):\n    \"\"\"\n    Generates a K x K noise matrix P(label=k_s|true_label=k_y) with np.sum(np.diagonal(noise_matrix)) equal to the given trace.\n\n    Parameters\n    ----------\n    K : int\n        Number of classes, creating a noise matrix of shape (K, K).\n    trace : float\n        Desired sum of diagonal entries of the noise matrix.\n    max_trace_prob : float\n        Maximum probability for any diagonal entry.\n    min_trace_prob : float\n        Minimum probability for any diagonal entry.\n    max_noise_rate : float\n        Maximum noise rate for any off-diagonal entry.\n    min_noise_rate : float\n        Minimum noise rate for any off-diagonal entry.\n    valid_noise_matrix : bool, default=True\n        If True, ensures the matrix satisfies conditions for learning with noisy labels.\n    py : np.ndarray\n        Array of shape (K,) representing the prior probability of each true class label.\n    frac_zero_noise_rates : float\n        Fraction of off-diagonal noise rates set to 0.\n    seed : int\n        Seed for the random number generator.\n    max_iter : int, default=10000\n        Maximum number of iterations to attempt generating a valid matrix.\n\n    Returns\n    -------\n    noise_matrix : np.ndarray or None\n        A K x K noise matrix with the specified trace, or None if max_iter is exceeded.\n    \"\"\"\n    # 1. Initialize the random number generator\n    rng = np.random.default_rng(seed)\n\n    # 2. Validate input parameters\n    if valid_noise_matrix and (py is None or len(py) != K):\n        raise ValueError(\"py must be provided and have length K when valid_noise_matrix is True.\")\n    if trace < 1:\n        raise ValueError(\"Trace must be greater than 1 for a valid noise matrix.\")\n\n    # 3. Initialize the noise matrix\n    noise_matrix = np.zeros((K, K))\n\n    # 4. Attempt to generate a valid noise matrix\n    for _ in range(max_iter):\n        # 5. Generate diagonal entries\n        diagonal_probs = rng.uniform(min_trace_prob, max_trace_prob, size=K)\n        diagonal_probs *= trace / np.sum(diagonal_probs)  # Scale to match the desired trace\n\n        # 6. Generate off-diagonal entries\n        for i in range(K):\n            remaining_prob = 1 - diagonal_probs[i]\n            off_diagonal_probs = rng.uniform(min_noise_rate, max_noise_rate, size=K-1)\n            off_diagonal_probs *= remaining_prob / np.sum(off_diagonal_probs)\n            noise_matrix[i, :] = np.insert(off_diagonal_probs, i, diagonal_probs[i])\n\n        # 7. Apply zero noise rates if specified\n        if frac_zero_noise_rates > 0:\n            num_zero_rates = int(frac_zero_noise_rates * K * (K - 1))\n            zero_indices = rng.choice(K * (K - 1), size=num_zero_rates, replace=False)\n            for idx in zero_indices:\n                i, j = divmod(idx, K)\n                if i != j:\n                    noise_matrix[i, j] = 0\n\n        # 8. Check if the matrix is valid\n        if valid_noise_matrix:\n            if np.all(noise_matrix @ py < np.diag(noise_matrix) * py):\n                return noise_matrix\n        else:\n            return noise_matrix\n\n    # 9. Return None if a valid matrix could not be generated\n    return None\n```\n\n### Explanation:\n\n1. **Random Number Generator**: We initialize a random number generator with the given seed for reproducibility.\n\n2. **Input Validation**: We check if the inputs are valid, especially when `valid_noise_matrix` is `True`.\n\n3. **Matrix Initialization**: We start with a zero matrix of shape `(K, K)`.\n\n4. **Matrix Generation Loop**: We attempt to generate a valid matrix up to `max_iter` times.\n\n5. **Diagonal Entries**: We generate diagonal probabilities and scale them to match the desired trace.\n\n6. **Off-Diagonal Entries**: We fill the off-diagonal entries with random probabilities, ensuring they sum to the remaining probability after the diagonal entry.\n\n7. **Zero Noise Rates**: We optionally set a fraction of off-diagonal entries to zero.\n\n8. **Validity Check**: If `valid_noise_matrix` is `True`, we check the condition for learning with noisy labels.\n\n9. **Return**: We return the generated matrix or `None` if a valid matrix could not be generated within the iteration limit.",
    "prompt": "Create a Python function called generate_noise_matrix_from_trace that Generates a ``K x K`` noise matrix ``P(label=k_s|true_label=k_y)`` with\n    ``np.sum(np.diagonal(noise_matrix))`` equal to the given `trace`.\n\n    Parameters\n    ----------\n    K : int\n      Creates a noise matrix of shape ``(K, K)``. Implies there are\n      K classes for learning with noisy labels.\n\n    trace : float\n      Sum of diagonal entries of array of random probabilities returned.\n\n    max_trace_prob : float\n      Maximum probability of any entry in the trace of the return matrix.\n\n    min_trace_prob : float\n      Minimum probability of any entry in the trace of the return matrix.\n\n    max_noise_rate : float\n      Maximum noise_rate (non-diagonal entry) in the returned np.ndarray.\n\n    min_noise_rate : float\n      Minimum noise_rate (non-diagonal entry) in the returned np.ndarray.\n\n    valid_noise_matrix : bool, default=True\n      If ``True``, returns a matrix having all necessary conditions for\n      learning with noisy labels. In particular, ``p(true_label=k)p(label=k) < p(true_label=k,label=k)``\n      is satisfied. This requires that ``trace > 1``.\n\n    py : np.ndarray\n      An array of shape ``(K,)`` representing the fraction (prior probability) of each true class label, ``P(true_label = k)``.\n      This argument is **required** when ``valid_noise_matrix=True``.\n\n    frac_zero_noise_rates : float\n      The fraction of the ``n*(n-1)`` noise rates\n      that will be set to 0. Note that if you set a high trace, it may be\n      impossible to also have a low fraction of zero noise rates without\n      forcing all non-1 diagonal values. Instead, when this happens we only\n      guarantee to produce a noise matrix with `frac_zero_noise_rates` *or\n      higher*. The opposite occurs with a small trace.\n\n    seed : int\n      Seeds the random number generator for numpy.\n\n    max_iter : int, default=10000\n      The max number of tries to produce a valid matrix before returning ``None``.\n\n    Returns\n    -------\n    noise_matrix : np.ndarray or None\n      An array of shape ``(K, K)`` representing the noise matrix ``P(label=k_s|true_label=k_y)`` with `trace`\n      equal to ``np.sum(np.diagonal(noise_matrix))``. This a conditional probability matrix and a\n      left stochastic matrix. Returns ``None`` if `max_iter` is exceeded.",
    "function_name": "generate_noise_matrix_from_trace",
    "ground_truth": "cleanlab/benchmarking/noise_generation.py",
    "test": "tests/test_noise_generation.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Classification",
    "data": "Table"
}