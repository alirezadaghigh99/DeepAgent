{
    "result": "To create the `compute_ps_py_inv_noise_matrix` function, we need to follow a structured approach similar to the examples provided. This function will compute the probabilities `ps` and `py`, and the inverse of the noise matrix. Here's a step-by-step implementation:\n\n```python\nimport numpy as np\n\ndef compute_ps_py_inv_noise_matrix(labels, noise_matrix):\n    \"\"\"\n    Compute ps := P(labels=k), py := P(true_labels=k), and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n        A discrete vector of noisy labels, i.e., some labels may be erroneous.\n        *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.\n\n    Returns\n    -------\n    ps : np.ndarray\n        The probability distribution of the noisy labels.\n\n    py : np.ndarray\n        The probability distribution of the true labels.\n\n    inv_noise_matrix : np.ndarray\n        The inverse of the noise matrix.\n    \"\"\"\n    # 1. Determine the number of classes K from the noise matrix\n    K = noise_matrix.shape[0]\n\n    # 2. Compute the probability distribution of the noisy labels (ps)\n    #    Count occurrences of each label and normalize by the total number of labels\n    ps = np.bincount(labels, minlength=K) / len(labels)\n\n    # 3. Compute the probability distribution of the true labels (py)\n    #    This is done by solving the linear system: noise_matrix @ py = ps\n    py = np.linalg.solve(noise_matrix, ps)\n\n    # 4. Compute the inverse of the noise matrix\n    inv_noise_matrix = np.linalg.inv(noise_matrix)\n\n    # 5. Return the computed ps, py, and inv_noise_matrix\n    return ps, py, inv_noise_matrix\n```\n\n### Explanation:\n\n1. **Determine the Number of Classes (`K`)**: We extract the number of classes from the shape of the noise matrix, assuming it's a square matrix of shape `(K, K)`.\n\n2. **Compute `ps`**: This is the probability distribution of the noisy labels. We use `np.bincount` to count the occurrences of each label and normalize by the total number of labels to get the probabilities.\n\n3. **Compute `py`**: This is the probability distribution of the true labels. We solve the linear system `noise_matrix @ py = ps` to find `py`. This uses the assumption that the noise matrix columns sum to 1.\n\n4. **Compute the Inverse Noise Matrix**: We use `np.linalg.inv` to compute the inverse of the noise matrix, which is useful for correcting the noisy labels.\n\n5. **Return Values**: Finally, we return the computed `ps`, `py`, and `inv_noise_matrix`.",
    "prompt": "Generate a Python function called compute_ps_py_inv_noise_matrix that Compute ``ps := P(labels=k), py := P(true_labels=k)``, and the inverse noise matrix.\n\n    Parameters\n    ----------\n    labels : np.ndarray\n          A discrete vector of noisy labels, i.e. some labels may be erroneous.\n          *Format requirements*: for dataset with `K` classes, labels must be in ``{0,1,...,K-1}``.\n\n    noise_matrix : np.ndarray\n        A conditional probability matrix (of shape ``(K, K)``) of the form ``P(label=k_s|true_label=k_y)`` containing\n        the fraction of examples in every class, labeled as every other class.\n        Assumes columns of noise_matrix sum to 1.",
    "function_name": "compute_ps_py_inv_noise_matrix",
    "ground_truth": "cleanlab/internal/latent_algebra.py",
    "test": "tests/test_latent_algebra.py",
    "class": "",
    "stage": "Training",
    "task": "Classification",
    "data": "Table"
}