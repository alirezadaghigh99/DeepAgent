{
    "result": "To create the `so3_exp_map` function, we will follow a step-by-step approach similar to the examples provided. The function will convert a batch of logarithmic representations of rotation matrices into a batch of 3x3 rotation matrices using the Rodrigues' rotation formula. Here's how you can implement it:\n\n```python\nimport torch\n\ndef so3_exp_map(log_rot: torch.Tensor, eps: float = 0.0001) -> torch.Tensor:\n    \"\"\"\n    Converts a batch of logarithmic representations of rotation matrices to a batch of 3x3 rotation matrices\n    using the Rodrigues' rotation formula.\n\n    Args:\n        log_rot (torch.Tensor): A batch of vectors of shape (minibatch, 3) representing logarithmic rotations.\n        eps (float, optional): A small value to handle the singularity around log(R) = 0. Defaults to 0.0001.\n\n    Returns:\n        torch.Tensor: A batch of rotation matrices of shape (minibatch, 3, 3).\n\n    Raises:\n        ValueError: If the input log_rot is not of shape (minibatch, 3).\n    \"\"\"\n    # 1. Check the shape of the input tensor\n    if log_rot.ndim != 2 or log_rot.shape[1] != 3:\n        raise ValueError(\"Input log_rot must have shape (minibatch, 3)\")\n\n    # 2. Compute the angle (theta) as the norm of the log_rot vectors\n    theta = torch.norm(log_rot, dim=1, keepdim=True)\n\n    # 3. Normalize the log_rot vectors to get the rotation axis\n    #    Handle the singularity by clamping theta with eps\n    axis = log_rot / torch.clamp(theta, min=eps)\n\n    # 4. Compute the sine and cosine of theta\n    sin_theta = torch.sin(theta)\n    cos_theta = torch.cos(theta)\n\n    # 5. Compute the outer product of the axis with itself\n    axis_outer = axis.unsqueeze(2) * axis.unsqueeze(1)\n\n    # 6. Compute the skew-symmetric cross-product matrix of the axis\n    zero = torch.zeros_like(axis[:, 0])\n    K = torch.stack([\n        zero, -axis[:, 2], axis[:, 1],\n        axis[:, 2], zero, -axis[:, 0],\n        -axis[:, 1], axis[:, 0], zero\n    ], dim=1).reshape(-1, 3, 3)\n\n    # 7. Compute the rotation matrix using Rodrigues' formula\n    I = torch.eye(3, device=log_rot.device).unsqueeze(0)  # Identity matrix\n    R = cos_theta.unsqueeze(2) * I + (1 - cos_theta).unsqueeze(2) * axis_outer + sin_theta.unsqueeze(2) * K\n\n    # 8. Return the batch of rotation matrices\n    return R\n```\n\n### Explanation:\n\n1. **Input Validation**: We first check if the input `log_rot` has the correct shape `(minibatch, 3)`. If not, a `ValueError` is raised.\n\n2. **Angle Calculation**: The angle `theta` is computed as the norm of each vector in the batch.\n\n3. **Axis Normalization**: The rotation axis is obtained by normalizing `log_rot`. We use `torch.clamp` to handle the singularity when `theta` is close to zero.\n\n4. **Trigonometric Functions**: We compute the sine and cosine of `theta`.\n\n5. **Outer Product**: The outer product of the axis with itself is calculated to be used in Rodrigues' formula.\n\n6. **Skew-Symmetric Matrix**: The skew-symmetric matrix `K` is constructed for the cross-product operation.\n\n7. **Rodrigues' Formula**: The rotation matrix `R` is computed using the formula:  \n   \\[\n   R = I + \\sin(\\theta)K + (1 - \\cos(\\theta)) \\text{axis\\_outer}\n   \\]\n\n8. **Return**: Finally, the function returns the batch of 3x3 rotation matrices.",
    "prompt": "Create a Python function called so3_exp_map that takes in a torch.Tensor log_rot representing a batch of logarithmic representations of rotation matrices and an optional float eps set to 0.0001. The function converts the logarithmic representations to a batch of 3x3 rotation matrices using the Rodrigues formula. The input log_rot should be a batch of vectors of shape (minibatch, 3) and the output should be a batch of rotation matrices of shape (minibatch, 3, 3). The function handles a singularity around log(R) = 0 by clamping it with the eps argument. If the input log_rot is of incorrect shape, a ValueError is raised. The function returns the batch of rotation matrices after conversion. Reference to Rodrigues' rotation formula is provided for further information.",
    "function_name": "so3_exp_map",
    "ground_truth": "pytorch3d/transforms/so3.py",
    "test": "tests/test_so3.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "Detection",
    "data": "image"
}