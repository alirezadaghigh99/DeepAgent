{
    "result": "To create a Python function named `look_at_view_transform1` that computes a rotation and translation matrix for a 'Look At' transformation, we need to follow a structured approach. This function will allow customization of the camera's position and orientation with respect to an object in 3D space. Here's a step-by-step implementation:\n\n```python\nimport torch\nimport math\n\ndef look_at_view_transform1(\n    dist=1.0,\n    elev=0.0,\n    azim=0.0,\n    degrees=True,\n    eye=None,\n    at=(0, 0, 0),\n    up=(0, 1, 0),\n    device=\"cpu\"\n):\n    \"\"\"\n    Computes a rotation and translation matrix for a 'Look At' transformation.\n\n    Args:\n        dist (float or tensor, default 1.0): Distance of the camera from the object.\n        elev (float or tensor, default 0.0): Elevation angle.\n        azim (float or tensor, default 0.0): Azimuth angle.\n        degrees (bool, default True): Whether angles are in degrees.\n        eye (optional, sequence or tensor, default None): Camera's position in world coordinates.\n        at (tuple, default (0, 0, 0)): Object's position in world coordinates.\n        up (tuple, default (0, 1, 0)): Up axis direction in world coordinates.\n        device (str, default \"cpu\"): Device for computation.\n\n    Returns:\n        R (tensor): Rotation matrix.\n        T (tensor): Translation matrix.\n    \"\"\"\n    # 1. Convert angles from degrees to radians if necessary\n    if degrees:\n        elev = math.radians(elev)\n        azim = math.radians(azim)\n\n    # 2. Calculate the camera position if 'eye' is not provided\n    if eye is None:\n        eye_x = dist * math.cos(elev) * math.sin(azim)\n        eye_y = dist * math.sin(elev)\n        eye_z = dist * math.cos(elev) * math.cos(azim)\n        eye = torch.tensor([eye_x, eye_y, eye_z], device=device)\n    else:\n        eye = torch.tensor(eye, device=device)\n\n    # 3. Convert 'at' and 'up' to tensors\n    at = torch.tensor(at, device=device)\n    up = torch.tensor(up, device=device)\n\n    # 4. Compute the forward vector from 'eye' to 'at'\n    forward = at - eye\n    forward = forward / torch.norm(forward)\n\n    # 5. Compute the right vector as the cross product of 'up' and 'forward'\n    right = torch.cross(up, forward)\n    right = right / torch.norm(right)\n\n    # 6. Recompute the up vector as the cross product of 'forward' and 'right'\n    up = torch.cross(forward, right)\n\n    # 7. Create the rotation matrix R\n    R = torch.stack([right, up, forward], dim=0)\n\n    # 8. Create the translation matrix T\n    T = -R @ eye\n\n    # 9. Return the rotation and translation matrices\n    return R, T\n\n# Example usage:\nR, T = look_at_view_transform1(dist=2.0, elev=45.0, azim=30.0, degrees=True)\nprint(\"Rotation Matrix:\\n\", R)\nprint(\"Translation Matrix:\\n\", T)\n```\n\n### Explanation:\n\n1. **Angle Conversion**: If the angles are provided in degrees, they are converted to radians for trigonometric calculations.\n\n2. **Camera Position Calculation**: If the `eye` parameter is not provided, the camera position is calculated using spherical coordinates based on `dist`, `elev`, and `azim`.\n\n3. **Vector Calculations**:\n   - **Forward Vector**: Points from the camera to the object.\n   - **Right Vector**: Perpendicular to both the `up` vector and the `forward` vector.\n   - **Up Vector**: Recomputed to ensure orthogonality.\n\n4. **Rotation Matrix**: Constructed using the `right`, `up`, and `forward` vectors.\n\n5. **Translation Matrix**: Aligns the camera's position with the world origin.\n\nThis function provides a flexible way to compute the necessary transformations for a 'Look At' operation in 3D space, accommodating various input configurations.",
    "prompt": "Create a Python function named look_at_view_transform1 that computes a rotation and translation matrix for applying a 'Look At' transformation from world coordinates to view coordinates. This function should allow for customization of the camera's position and orientation with respect to an object in 3D space.\n\nFunction Overview:\n\nInputs:\n\ndist (float or tensor, default 1.0): The distance of the camera from the object.\nelev (float or tensor, default 0.0): The elevation angle, representing the angle between the camera-object vector and the horizontal plane (in degrees or radians).\nazim (float or tensor, default 0.0): The azimuth angle, representing the angle between the projected camera-object vector on the horizontal plane and a reference vector.\ndegrees (bool, default True): A flag indicating whether the elevation and azimuth angles are provided in degrees or radians.\neye (optional, sequence or tensor, default None): The camera's position in world coordinates, overriding dist, elev, and azim if provided.\nat (tuple, default ((0, 0, 0),)): The object's position in world coordinates.\nup (tuple, default ((0, 1, 0),)): The direction of the up axis in the world coordinate system.\ndevice (str, default \"cpu\"): The device on which to perform the computation (e.g., 'cpu' or 'cuda').\nOutputs:\n\nA tuple containing:\nR (tensor): The rotation matrix aligning the points with the camera.\nT (tensor): The translation matrix aligning the points with the camera.\nError Handling:\n\nEnsure that the inputs are tensors and have compatible shapes by broadcasting them.\nHandle cases where the eye parameter is provided, overriding the calculated camera position based on dist, elev, and azim.",
    "function_name": "look_at_view_transform",
    "ground_truth": "pytorch3d/renderer/cameras.py",
    "test": "tests/test_camera_utils.py",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Image"
}