{
    "result": "To create a Python function `maximum_weight_matching` that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching, we can use the `scipy.optimize.linear_sum_assignment` function, which implements the Hungarian algorithm for solving the assignment problem. This function will not compute gradients, as it is intended for use in scenarios where you need to find the optimal assignment without backpropagation.\n\nHere's a step-by-step implementation:\n\n```python\nimport torch\nfrom scipy.optimize import linear_sum_assignment\n\ndef maximum_weight_matching(logits: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Perform maximum-weight matching on the input logits tensor and return the optimal assignments.\n\n    Args:\n        logits (torch.Tensor): A 2D tensor of shape (N, M) representing the weights or scores\n                               for each possible assignment between N and M elements.\n\n    Returns:\n        torch.Tensor: A 1D tensor of shape (N,) where each element is the index of the optimal\n                      assignment for the corresponding row in the input logits.\n    \"\"\"\n    # 1. Convert the logits tensor to a NumPy array for compatibility with scipy functions\n    logits_np = logits.detach().cpu().numpy()\n\n    # 2. Use the linear_sum_assignment function to find the optimal assignment\n    #    The function returns two arrays: row indices and column indices of the optimal assignment\n    row_indices, col_indices = linear_sum_assignment(-logits_np)\n\n    # 3. Create a tensor to store the optimal assignments\n    #    Initialize with -1 to indicate unassigned rows (if any)\n    assignments = torch.full((logits.size(0),), -1, dtype=torch.int64)\n\n    # 4. Fill the assignments tensor with the column indices of the optimal assignment\n    assignments[row_indices] = torch.tensor(col_indices, dtype=torch.int64)\n\n    # 5. Return the assignments tensor\n    return assignments\n\n# Example usage:\n# logits = torch.tensor([[1.0, 2.0, 3.0], [4.0, 6.0, 5.0], [7.0, 8.0, 9.0]])\n# optimal_assignments = maximum_weight_matching(logits)\n# print(optimal_assignments)  # Output: tensor([2, 1, 0])\n```\n\n### Explanation:\n\n1. **Convert to NumPy**: The `logits` tensor is converted to a NumPy array because `scipy.optimize.linear_sum_assignment` works with NumPy arrays.\n\n2. **Negate Logits**: The `linear_sum_assignment` function finds the minimum cost assignment, so we negate the logits to transform the problem into a maximum-weight matching.\n\n3. **Optimal Assignment**: The function returns two arrays: `row_indices` and `col_indices`, which represent the optimal assignment.\n\n4. **Create Assignments Tensor**: We initialize a tensor `assignments` with `-1` to indicate unassigned rows, then fill it with the optimal column indices for each row.\n\n5. **Return Result**: The function returns the `assignments` tensor, which contains the index of the optimal assignment for each row in the input logits.\n\nThis function is designed to work with 2D tensors where each row represents a set of elements to be matched with columns, and it finds the optimal assignment based on the maximum weight.",
    "prompt": "Generate a Python function maximum_weight_matching that takes logits as a tensor and returns a tensor of optimal assignments based on a maximum-weight matching. The function performs a matching process and returns the best assignment for each element in the input without computing gradients.",
    "function_name": "maximum_weight_matching",
    "ground_truth": "pyro/distributions/one_two_matching.py",
    "test": "tests/distributions/test_one_two_matching.py::test_mode_phylo",
    "class": "",
    "stage": "Inference",
    "task": "prediction",
    "data": "Table"
}