{
    "result": "To create the `sample_n_k` function as described, we can follow a step-by-step approach similar to the examples provided. Here's how you can implement this function:\n\n```python\nimport numpy as np\n\ndef sample_n_k(n, k):\n    \"\"\"\n    Sample k distinct elements uniformly from the range 0 to n.\n\n    Args:\n        n (int): The upper limit of the range (exclusive).\n        k (int): The number of distinct elements to sample.\n\n    Returns:\n        np.ndarray: An array of k distinct elements sampled from the range 0 to n.\n\n    Raises:\n        ValueError: If k is larger than n or if k is negative.\n    \"\"\"\n    # 1. Check if k is larger than n or if k is negative\n    if k > n or k < 0:\n        raise ValueError(\"k must be non-negative and less than or equal to n.\")\n\n    # 2. If k is 0, return an empty NumPy array\n    if k == 0:\n        return np.array([], dtype=int)\n\n    # 3. If 3 * k is greater than or equal to n, use np.random.choice\n    if 3 * k >= n:\n        return np.random.choice(n, size=k, replace=False)\n\n    # 4. Otherwise, sample 2k elements and ensure they are distinct\n    #    before returning the first k elements\n    while True:\n        # Sample 2k elements\n        samples = np.random.choice(n, size=2*k, replace=True)\n        # Use np.unique to ensure distinct elements\n        unique_samples = np.unique(samples)\n        # Check if we have at least k distinct elements\n        if len(unique_samples) >= k:\n            return unique_samples[:k]\n\n# Example usage:\n# result = sample_n_k(10, 3)\n# print(result)\n```\n\n### Explanation:\n\n1. **Input Validation**: The function first checks if `k` is larger than `n` or if `k` is negative, raising a `ValueError` if either condition is true.\n\n2. **Return Empty Array**: If `k` is 0, the function returns an empty NumPy array.\n\n3. **Efficient Sampling**: If `3 * k` is greater than or equal to `n`, the function uses `np.random.choice` to sample `k` elements without replacement, which is efficient for this case.\n\n4. **Sampling with Replacement**: If `3 * k` is less than `n`, the function samples `2k` elements with replacement and uses `np.unique` to ensure they are distinct. It then checks if there are at least `k` distinct elements and returns the first `k` elements.\n\nThis approach ensures that the function efficiently samples `k` distinct elements from the range `0` to `n` while handling edge cases appropriately.",
    "prompt": "Generate a Python function called sample_n_k that samples k distinct elements uniformly from the range 0 to n. The inputs are two integers, n and k. The function will raise a ValueError if k is larger than n or is negative. If k is 0, the function will return an empty NumPy array. If 3 times k is greater than or equal to n, the function will use NumPy's random.choice function to sample k elements without replacement. Otherwise, the function will sample 2k elements and ensure that they are distinct before returning the first k elements. The output of the function is a NumPy array containing k distinct elements sampled from the range 0 to n.",
    "function_name": "sample_n_k",
    "ground_truth": "pfrl/utils/random.py",
    "test": "tests/utils_tests/test_random.py::TestSampleNK::test_fast",
    "class": "",
    "stage": "Pre-Post processing",
    "task": "",
    "data": "Table"
}